<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>Would I Lie to You?</title><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous"/></head><body><div class="container"><div class="row justify-content-center"><div class="col-md-8"><h1 class="text-center">Would I Lie to You?</h1><div id="app"></div><h3>How to play</h3><p>In a round of <a href="https://www.youtube.com/watch?v=B94q7gUu75k" target="_blank">Would I Lie To You</a>, the person whose turn it is reads a statement to the other players. The other players then take some time to ask the person questions about the statement until they feel they can guess whether the statement is a truth or a lie about the person. Everyone makes their guess, then the person whose turn it is reveals whether it was a truth or a lie. Everyone who guessed correctly gets a point, and the person whose turn it is gets a point for each person who guessed incorrectly. Players take turns until everyone has gone. </p><p>This app helps with picking a statement to present when it's your turn. Before playing, partner up with another player. Come up with at least one truth about yourself and at least one lie about your partner. When playing, don't participate when it's your partner's turn, since you'll already know whether you partner is telling a truth or lie. Type the lie(s) for your partner into the &quot;Lies to send&quot; box and click &quot;Encode&quot;, then send the generated lie code to your partner. Type the truth(s) about yourself into the &quot;Truth(s) about yourself&quot; box. When you receive a lie code from your partner, paste it into the &quot;Lie code you received&quot; box. When it's your turn, click the &quot;Would I Lie to You?&quot; button and the app will randomly pick a truth or lie for you to present to the other players. The app removes this truth/lie from the corresponding input, so if you play another turn, there isn't a chance of getting a truth/lie you've already gotten. </p></div></div></div><script>
//<![CDATA[
//# 1 "app.bc.runtime.js"
// Generated by js_of_ocaml 3.8.0
(function(joo_global_object)
   {"use strict";
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))
       this.content[name] = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       this.content[name] = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         this.content[name] = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           this.content[name] = new MlFakeFile(bytes)}
         else
          caml_raise_sys_error
           (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try
       {return this.fs.existsSync(this.nm(name))?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.readdir
    =
    function(name)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       content=
        typeof content == "string"?caml_string_of_jsbytes(content):content,
       root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = root.path + root.rest + "/";
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarray";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function win_cleanup(){}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_bytes(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_jsbytes(h,v.c);break;
        case 2:h = caml_hash_mix_bytes_arr(h,v.c)
        }
      return h}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)}
      else
       return false}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_sys_const_word_size(){return 32}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_string_of_bytes(s){return s}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_ba_kind_of_typed_array(ta)
     {var g=joo_global_object,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=joo_global_object;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_js_pure_expr(f){return f()}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes("Unix"),32,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === null)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (joo_global_object.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var
     caml_ephe_blit_key=caml_weak_blit,
     caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var g=joo_global_object,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_memprof_stop(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape){case 0:case 1:case 2:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    joo_global_object.jsoo_runtime
    =
    {caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     unix_isatty:unix_isatty,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     re_replacement_text:re_replacement_text,
     re_partial_match:re_partial_match,
     re_string_match:re_string_match,
     re_search_backward:re_search_backward,
     re_search_forward:re_search_forward,
     re_match:re_match,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_sys_isatty:caml_sys_isatty,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_time:caml_sys_time,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_sys_exit:caml_sys_exit,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_is_printable:caml_is_printable,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     caml_get_public_method:caml_get_public_method,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_js_to_string:caml_js_to_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_from_string:caml_js_from_string,
     caml_new_string:caml_new_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_is_ml_string:caml_is_ml_string,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_equal:caml_string_equal,
     caml_string_compare:caml_string_compare,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_string_of_array:caml_string_of_array,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_str_repeat:caml_str_repeat,
     caml_md5_bytes:caml_md5_bytes,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlStringReader:MlStringReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_is_js:caml_is_js,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_channel_descriptor:caml_channel_descriptor,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_format_int:caml_format_int,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     MlInt64:MlInt64,
     caml_int64_offset:caml_int64_offset,
     caml_float_of_string:caml_float_of_string,
     caml_format_float:caml_format_float,
     caml_round_float:caml_round_float,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state:caml_gr_state,
     caml_memprof_stop:caml_memprof_stop,
     caml_memprof_start:caml_memprof_start,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_failwith:caml_failwith,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_custom_name:caml_ba_custom_name,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),0],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-1],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-2],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-3],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-5],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));


//# 1 "../../.js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_get=runtime.caml_array_get,
     caml_array_set=runtime.caml_array_set,
     caml_array_sub=runtime.caml_array_sub,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bswap16=runtime.caml_bswap16,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_get16=runtime.caml_bytes_get16,
     caml_bytes_get32=runtime.caml_bytes_get32,
     caml_bytes_get64=runtime.caml_bytes_get64,
     caml_bytes_of_string=runtime.caml_bytes_of_string,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_set16=runtime.caml_bytes_set16,
     caml_bytes_set32=runtime.caml_bytes_set32,
     caml_bytes_set64=runtime.caml_bytes_set64,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_ephe_set_key=runtime.caml_ephe_set_key,
     caml_ephe_unset_key=runtime.caml_ephe_unset_key,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_floatarray_create=runtime.caml_floatarray_create,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtra=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_nextafter_float=runtime.caml_nextafter_float,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_make_forward=runtime.caml_obj_make_forward,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_restore_raw_backtrace=runtime.caml_restore_raw_backtrace,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_signbit_float=runtime.caml_signbit_float,
     caml_spacetime_enabled=runtime.caml_spacetime_enabled,
     caml_spacetime_only_works_for_=
      runtime.caml_spacetime_only_works_for_native_code,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_bytes=runtime.caml_string_of_bytes,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_argv=runtime.caml_sys_argv,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_string_of_jsbytes("%,"),
     cst_really_input=caml_string_of_jsbytes("really_input"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_output_substring=caml_string_of_jsbytes("output_substring"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_12g=caml_string_of_jsbytes("%.12g"),
     cst=caml_string_of_jsbytes("."),
     cst_false$1=caml_string_of_jsbytes("false"),
     cst_true$1=caml_string_of_jsbytes("true"),
     cst_false$0=caml_string_of_jsbytes("false"),
     cst_true$0=caml_string_of_jsbytes("true"),
     cst_bool_of_string=caml_string_of_jsbytes("bool_of_string"),
     cst_true=caml_string_of_jsbytes("true"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_char_of_int=caml_string_of_jsbytes("char_of_int"),
     cst_Stdlib_Exit=caml_string_of_jsbytes("Stdlib.Exit"),
     cst_Stdlib_Pervasives_Exit=
      caml_string_of_jsbytes("Stdlib.Pervasives.Exit"),
     cst_option_is_None=caml_string_of_jsbytes("option is None"),
     cst_result_is_Ok=caml_string_of_jsbytes("result is Ok _"),
     cst_result_is_Error=caml_string_of_jsbytes("result is Error _"),
     cst_true$2=caml_string_of_jsbytes("true"),
     cst_false$2=caml_string_of_jsbytes("false"),
     cst$1=caml_string_of_jsbytes("\\\\"),
     cst$2=caml_string_of_jsbytes("\\'"),
     cst_b=caml_string_of_jsbytes("\\b"),
     cst_t=caml_string_of_jsbytes("\\t"),
     cst_n=caml_string_of_jsbytes("\\n"),
     cst_r=caml_string_of_jsbytes("\\r"),
     cst_Char_chr=caml_string_of_jsbytes("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_string_of_jsbytes(" is not a latin1 character"),
     cst_04X=caml_string_of_jsbytes("%04X"),
     cst_U=caml_string_of_jsbytes("U+"),
     cst_is_not_an_Unicode_scalar_v=
      caml_string_of_jsbytes(" is not an Unicode scalar value"),
     cst_X=caml_string_of_jsbytes("%X"),
     err_no_pred=caml_string_of_jsbytes("U+0000 has no predecessor"),
     err_no_succ=caml_string_of_jsbytes("U+10FFFF has no successor"),
     cst_Stdlib_Sys_Break=caml_string_of_jsbytes("Stdlib.Sys.Break"),
     ocaml_version=caml_string_of_jsbytes("4.09.0"),
     cst_List_map2=caml_string_of_jsbytes("List.map2"),
     cst_List_iter2=caml_string_of_jsbytes("List.iter2"),
     cst_List_fold_left2=caml_string_of_jsbytes("List.fold_left2"),
     cst_List_fold_right2=caml_string_of_jsbytes("List.fold_right2"),
     cst_List_for_all2=caml_string_of_jsbytes("List.for_all2"),
     cst_List_exists2=caml_string_of_jsbytes("List.exists2"),
     cst_List_combine=caml_string_of_jsbytes("List.combine"),
     cst_List_rev_map2=caml_string_of_jsbytes("List.rev_map2"),
     cst_List_init=caml_string_of_jsbytes("List.init"),
     cst_List_nth$0=caml_string_of_jsbytes("List.nth"),
     cst_nth=caml_string_of_jsbytes("nth"),
     cst_List_nth=caml_string_of_jsbytes("List.nth"),
     cst_tl=caml_string_of_jsbytes("tl"),
     cst_hd=caml_string_of_jsbytes("hd"),
     cst_Bytes_of_seq_cannot_grow_b=
      caml_string_of_jsbytes("Bytes.of_seq: cannot grow bytes"),
     cst_String_rcontains_from_Byte=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_string_of_jsbytes("Bytes.concat"),
     cst_String_blit_Bytes_blit_str=
      caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_string_of_jsbytes("Bytes.blit"),
     cst_String_fill_Bytes_fill=
      caml_string_of_jsbytes("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_string_of_jsbytes("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_string_of_jsbytes("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Byte$0=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes$0=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt$0=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r$0=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte$0=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in$0=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_String_concat=caml_string_of_jsbytes("String.concat"),
     cst$5=caml_string_of_jsbytes("()"),
     cst_Marshal_from_bytes=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_string_of_jsbytes("Marshal.data_size"),
     cst_Marshal_to_buffer_substrin=
      caml_string_of_jsbytes("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_Ephemeron_blit_key=
      caml_string_of_jsbytes("Obj.Ephemeron.blit_key"),
     cst_Obj_Ephemeron_check_key=
      caml_string_of_jsbytes("Obj.Ephemeron.check_key"),
     cst_Obj_Ephemeron_unset_key=
      caml_string_of_jsbytes("Obj.Ephemeron.unset_key"),
     cst_Obj_Ephemeron_set_key=caml_string_of_jsbytes("Obj.Ephemeron.set_key"),
     cst_Obj_Ephemeron_get_key_copy=
      caml_string_of_jsbytes("Obj.Ephemeron.get_key_copy"),
     cst_Obj_Ephemeron_get_key=caml_string_of_jsbytes("Obj.Ephemeron.get_key"),
     cst_Obj_Ephemeron_create=caml_string_of_jsbytes("Obj.Ephemeron.create"),
     cst_Obj_extension_constructor$0=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Array_map2_arrays_must_hav=
      caml_string_of_jsbytes("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_ha=
      caml_string_of_jsbytes("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_string_of_jsbytes("Array.blit"),
     cst_Array_fill=caml_string_of_jsbytes("Array.fill"),
     cst_Array_sub=caml_string_of_jsbytes("Array.sub"),
     cst_Array_init=caml_string_of_jsbytes("Array.init"),
     cst_Stdlib_Array_Bottom=caml_string_of_jsbytes("Stdlib.Array.Bottom"),
     cst_Float_Array_map2_arrays_mu=
      caml_string_of_jsbytes
       ("Float.Array.map2: arrays must have the same length"),
     cst_Float_Array_iter2_arrays_m=
      caml_string_of_jsbytes
       ("Float.Array.iter2: arrays must have the same length"),
     cst_Float_array_blit=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_array_blit$0=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_Array_fill=caml_string_of_jsbytes("Float.Array.fill"),
     cst_Float_Array_sub=caml_string_of_jsbytes("Float.Array.sub"),
     cst_Float_Array_concat=caml_string_of_jsbytes("Float.Array.concat"),
     cst_Float_Array_init=caml_string_of_jsbytes("Float.Array.init"),
     cst_Stdlib_Float_Array_Bottom=
      caml_string_of_jsbytes("Stdlib.Float.Array.Bottom"),
     cst_d=caml_string_of_jsbytes("%d"),
     cst_d$0=caml_string_of_jsbytes("%d"),
     zero$2=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     one$2=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     minus_one$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     min_int$2=runtime.caml_int64_create_lo_mi_hi(0,0,32768),
     max_int$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     cst_d$1=caml_string_of_jsbytes("%d"),
     cst_Lexing_lex_refill_cannot_g=
      caml_string_of_jsbytes("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_string_of_jsbytes(""),0,0,-1],
     zero_pos=[0,caml_string_of_jsbytes(""),1,0,0],
     cst_syntax_error=caml_string_of_jsbytes("syntax error"),
     cst_Stdlib_Parsing_YYexit=caml_string_of_jsbytes("Stdlib.Parsing.YYexit"),
     cst_Stdlib_Parsing_Parse_error=
      caml_string_of_jsbytes("Stdlib.Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_string_of_jsbytes("Set.remove_min_elt"),
     cst_Set_bal=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$0=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$1=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$2=caml_string_of_jsbytes("Set.bal"),
     cst_Map_remove_min_elt=caml_string_of_jsbytes("Map.remove_min_elt"),
     cst_Map_bal=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$0=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$1=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$2=caml_string_of_jsbytes("Map.bal"),
     cst_Stdlib_Stack_Empty=caml_string_of_jsbytes("Stdlib.Stack.Empty"),
     cst_Stdlib_Queue_Empty=caml_string_of_jsbytes("Stdlib.Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
     cst_count=caml_string_of_jsbytes("{count = "),
     cst_data=caml_string_of_jsbytes("; data = "),
     cst$6=caml_string_of_jsbytes("}"),
     cst_Sempty=caml_string_of_jsbytes("Sempty"),
     cst_Scons=caml_string_of_jsbytes("Scons ("),
     cst$7=caml_string_of_jsbytes(", "),
     cst$8=caml_string_of_jsbytes(")"),
     cst_Sapp=caml_string_of_jsbytes("Sapp ("),
     cst$9=caml_string_of_jsbytes(", "),
     cst$10=caml_string_of_jsbytes(")"),
     cst_Slazy=caml_string_of_jsbytes("Slazy"),
     cst_Sgen=caml_string_of_jsbytes("Sgen"),
     cst_Sbuffio=caml_string_of_jsbytes("Sbuffio"),
     cst_Stdlib_Stream_Failure=caml_string_of_jsbytes("Stdlib.Stream.Failure"),
     cst_Stdlib_Stream_Error=caml_string_of_jsbytes("Stdlib.Stream.Error"),
     cst_Buffer_truncate=caml_string_of_jsbytes("Buffer.truncate"),
     cst_Buffer_add_channel=caml_string_of_jsbytes("Buffer.add_channel"),
     cst_Buffer_add_substring_add_s=
      caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buf=
      caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_string_of_jsbytes("Buffer.nth"),
     cst_Buffer_blit=caml_string_of_jsbytes("Buffer.blit"),
     cst_Buffer_sub=caml_string_of_jsbytes("Buffer.sub"),
     cst_c=caml_string_of_jsbytes("%c"),
     cst_s=caml_string_of_jsbytes("%s"),
     cst_i=caml_string_of_jsbytes("%i"),
     cst_li=caml_string_of_jsbytes("%li"),
     cst_ni=caml_string_of_jsbytes("%ni"),
     cst_Li=caml_string_of_jsbytes("%Li"),
     cst_f=caml_string_of_jsbytes("%f"),
     cst_B=caml_string_of_jsbytes("%B"),
     cst$21=caml_string_of_jsbytes("%{"),
     cst$22=caml_string_of_jsbytes("%}"),
     cst$23=caml_string_of_jsbytes("%("),
     cst$24=caml_string_of_jsbytes("%)"),
     cst_a=caml_string_of_jsbytes("%a"),
     cst_t$0=caml_string_of_jsbytes("%t"),
     cst$25=caml_string_of_jsbytes("%?"),
     cst_r$0=caml_string_of_jsbytes("%r"),
     cst_r$1=caml_string_of_jsbytes("%_r"),
     cst_u$0=caml_string_of_jsbytes("%u"),
     cst_Printf_bad_conversion=
      caml_string_of_jsbytes("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=
      caml_string_of_jsbytes("Printf: bad conversion %_"),
     cst$29=caml_string_of_jsbytes("@{"),
     cst$30=caml_string_of_jsbytes("@["),
     cst$31=caml_string_of_jsbytes("@{"),
     cst$32=caml_string_of_jsbytes("@["),
     cst$33=caml_string_of_jsbytes("@{"),
     cst$34=caml_string_of_jsbytes("@["),
     cst_0=caml_string_of_jsbytes("0"),
     cst_padding=caml_string_of_jsbytes("padding"),
     cst_precision=caml_string_of_jsbytes("precision"),
     cst$39=caml_string_of_jsbytes("'*'"),
     cst$37=caml_string_of_jsbytes("'-'"),
     cst_0$2=caml_string_of_jsbytes("'0'"),
     cst$38=caml_string_of_jsbytes("'*'"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_0$1=caml_string_of_jsbytes("0"),
     cst_precision$0=caml_string_of_jsbytes("precision"),
     cst_precision$1=caml_string_of_jsbytes("precision"),
     cst$40=caml_string_of_jsbytes("'+'"),
     cst$41=caml_string_of_jsbytes("'#'"),
     cst$42=caml_string_of_jsbytes("' '"),
     cst_padding$0=caml_string_of_jsbytes("`padding'"),
     cst_precision$2=caml_string_of_jsbytes("`precision'"),
     cst$43=caml_string_of_jsbytes("'+'"),
     cst$44=caml_string_of_jsbytes("'_'"),
     sub_format=[0,0,caml_string_of_jsbytes("")],
     formatting_lit=[0,caml_string_of_jsbytes("@;"),1,0],
     cst_digit=caml_string_of_jsbytes("digit"),
     cst_character=caml_string_of_jsbytes("character ')'"),
     cst_character$0=caml_string_of_jsbytes("character '}'"),
     cst$48=caml_string_of_jsbytes("'#'"),
     cst$47=caml_string_of_jsbytes("'+'"),
     cst$46=caml_string_of_jsbytes("'+'"),
     cst$45=caml_string_of_jsbytes("' '"),
     cst$49=caml_string_of_jsbytes("'+'"),
     cst_non_zero_widths_are_unsupp=
      caml_string_of_jsbytes
       ("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=
      caml_string_of_jsbytes("unexpected end of format"),
     cst$35=caml_string_of_jsbytes(""),
     cst$36=caml_string_of_jsbytes(""),
     cst_b$0=caml_string_of_jsbytes("b"),
     cst_h=caml_string_of_jsbytes("h"),
     cst_hov=caml_string_of_jsbytes("hov"),
     cst_hv=caml_string_of_jsbytes("hv"),
     cst_v=caml_string_of_jsbytes("v"),
     cst_nan=caml_string_of_jsbytes("nan"),
     cst$28=caml_string_of_jsbytes("."),
     cst_neg_infinity=caml_string_of_jsbytes("neg_infinity"),
     cst_infinity=caml_string_of_jsbytes("infinity"),
     cst_nd$0=caml_string_of_jsbytes("%+nd"),
     cst_nd$1=caml_string_of_jsbytes("% nd"),
     cst_ni$1=caml_string_of_jsbytes("%+ni"),
     cst_ni$2=caml_string_of_jsbytes("% ni"),
     cst_nx=caml_string_of_jsbytes("%nx"),
     cst_nx$0=caml_string_of_jsbytes("%#nx"),
     cst_nX=caml_string_of_jsbytes("%nX"),
     cst_nX$0=caml_string_of_jsbytes("%#nX"),
     cst_no=caml_string_of_jsbytes("%no"),
     cst_no$0=caml_string_of_jsbytes("%#no"),
     cst_nd=caml_string_of_jsbytes("%nd"),
     cst_ni$0=caml_string_of_jsbytes("%ni"),
     cst_nu=caml_string_of_jsbytes("%nu"),
     cst_ld$0=caml_string_of_jsbytes("%+ld"),
     cst_ld$1=caml_string_of_jsbytes("% ld"),
     cst_li$1=caml_string_of_jsbytes("%+li"),
     cst_li$2=caml_string_of_jsbytes("% li"),
     cst_lx=caml_string_of_jsbytes("%lx"),
     cst_lx$0=caml_string_of_jsbytes("%#lx"),
     cst_lX=caml_string_of_jsbytes("%lX"),
     cst_lX$0=caml_string_of_jsbytes("%#lX"),
     cst_lo=caml_string_of_jsbytes("%lo"),
     cst_lo$0=caml_string_of_jsbytes("%#lo"),
     cst_ld=caml_string_of_jsbytes("%ld"),
     cst_li$0=caml_string_of_jsbytes("%li"),
     cst_lu=caml_string_of_jsbytes("%lu"),
     cst_Ld$0=caml_string_of_jsbytes("%+Ld"),
     cst_Ld$1=caml_string_of_jsbytes("% Ld"),
     cst_Li$1=caml_string_of_jsbytes("%+Li"),
     cst_Li$2=caml_string_of_jsbytes("% Li"),
     cst_Lx=caml_string_of_jsbytes("%Lx"),
     cst_Lx$0=caml_string_of_jsbytes("%#Lx"),
     cst_LX=caml_string_of_jsbytes("%LX"),
     cst_LX$0=caml_string_of_jsbytes("%#LX"),
     cst_Lo=caml_string_of_jsbytes("%Lo"),
     cst_Lo$0=caml_string_of_jsbytes("%#Lo"),
     cst_Ld=caml_string_of_jsbytes("%Ld"),
     cst_Li$0=caml_string_of_jsbytes("%Li"),
     cst_Lu=caml_string_of_jsbytes("%Lu"),
     cst_d$3=caml_string_of_jsbytes("%+d"),
     cst_d$4=caml_string_of_jsbytes("% d"),
     cst_i$1=caml_string_of_jsbytes("%+i"),
     cst_i$2=caml_string_of_jsbytes("% i"),
     cst_x=caml_string_of_jsbytes("%x"),
     cst_x$0=caml_string_of_jsbytes("%#x"),
     cst_X$0=caml_string_of_jsbytes("%X"),
     cst_X$1=caml_string_of_jsbytes("%#X"),
     cst_o=caml_string_of_jsbytes("%o"),
     cst_o$0=caml_string_of_jsbytes("%#o"),
     cst_d$2=caml_string_of_jsbytes("%d"),
     cst_i$0=caml_string_of_jsbytes("%i"),
     cst_u=caml_string_of_jsbytes("%u"),
     cst$26=caml_string_of_jsbytes("%!"),
     cst$27=caml_string_of_jsbytes("@{"),
     cst_0c=caml_string_of_jsbytes("0c"),
     cst$20=caml_string_of_jsbytes("%%"),
     cst$12=caml_string_of_jsbytes("@]"),
     cst$13=caml_string_of_jsbytes("@}"),
     cst$14=caml_string_of_jsbytes("@?"),
     cst$15=caml_string_of_jsbytes("@\n"),
     cst$16=caml_string_of_jsbytes("@."),
     cst$17=caml_string_of_jsbytes("@@"),
     cst$18=caml_string_of_jsbytes("@%"),
     cst$19=caml_string_of_jsbytes("@"),
     cst$11=caml_string_of_jsbytes(".*"),
     cst_CamlinternalFormat_Type_mi=
      caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
     cst$57=caml_string_of_jsbytes(""),
     cst$58=caml_string_of_jsbytes("\n"),
     cst_a_boolean=caml_string_of_jsbytes("a boolean"),
     cst_an_integer=caml_string_of_jsbytes("an integer"),
     cst_an_integer$0=caml_string_of_jsbytes("an integer"),
     cst_a_float=caml_string_of_jsbytes("a float"),
     cst_a_float$0=caml_string_of_jsbytes("a float"),
     cst$54=caml_string_of_jsbytes(""),
     cst$55=caml_string_of_jsbytes(" "),
     cst$56=caml_string_of_jsbytes(""),
     cst_one_of=caml_string_of_jsbytes("one of: "),
     cst_Arg_Expand_is_is_only_allo=
      caml_string_of_jsbytes
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_string_of_jsbytes("no argument"),
     cst$53=caml_string_of_jsbytes("(?)"),
     cst_help$3=caml_string_of_jsbytes("--help"),
     cst_help$4=caml_string_of_jsbytes("-help"),
     cst_help$2=caml_string_of_jsbytes("-help"),
     cst_Display_this_list_of_optio=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help=caml_string_of_jsbytes("-help"),
     cst_help$1=caml_string_of_jsbytes("--help"),
     cst_Display_this_list_of_optio$0=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help$0=caml_string_of_jsbytes("--help"),
     cst$50=caml_string_of_jsbytes("}"),
     cst$51=caml_string_of_jsbytes("|"),
     cst$52=caml_string_of_jsbytes("{"),
     cst_none=caml_string_of_jsbytes("<none>"),
     cst_Stdlib_Arg_Bad=caml_string_of_jsbytes("Stdlib.Arg.Bad"),
     cst_Stdlib_Arg_Help=caml_string_of_jsbytes("Stdlib.Arg.Help"),
     cst_Stdlib_Arg_Stop=caml_string_of_jsbytes("Stdlib.Arg.Stop"),
     cst$60=caml_string_of_jsbytes(""),
     cst_Program_not_linked_with_g_=
      caml_string_of_jsbytes
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_string_of_jsbytes("Raised at"),
     cst_Re_raised_at=caml_string_of_jsbytes("Re-raised at"),
     cst_Raised_by_primitive_operat=
      caml_string_of_jsbytes("Raised by primitive operation at"),
     cst_Called_from=caml_string_of_jsbytes("Called from"),
     cst_inlined=caml_string_of_jsbytes(" (inlined)"),
     cst$63=caml_string_of_jsbytes(""),
     partial=[4,0,0,0,0],
     cst_Out_of_memory=caml_string_of_jsbytes("Out of memory"),
     cst_Stack_overflow=caml_string_of_jsbytes("Stack overflow"),
     cst_Pattern_matching_failed=
      caml_string_of_jsbytes("Pattern matching failed"),
     cst_Assertion_failed=caml_string_of_jsbytes("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_string_of_jsbytes("Undefined recursive module"),
     cst$61=caml_string_of_jsbytes(""),
     cst$62=caml_string_of_jsbytes(""),
     cst$59=caml_string_of_jsbytes("_"),
     locfmt=
      [0,
       [11,
        caml_string_of_jsbytes('File "'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", characters "),
            [4,
             0,
             0,
             0,
             [12,45,[4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]]]]]]],
       caml_string_of_jsbytes('File "%s", line %d, characters %d-%d: %s')],
     cst_Stdlib_Fun_Finally_raised=
      caml_string_of_jsbytes("Stdlib.Fun.Finally_raised"),
     cst_Digest_from_hex$0=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_from_hex=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_to_hex=caml_string_of_jsbytes("Digest.to_hex"),
     cst_Digest_substring=caml_string_of_jsbytes("Digest.substring"),
     cst_Random_int64=caml_string_of_jsbytes("Random.int64"),
     cst_Random_int32=caml_string_of_jsbytes("Random.int32"),
     cst_Random_int=caml_string_of_jsbytes("Random.int"),
     cst_x$1=caml_string_of_jsbytes("x"),
     cst_OCAMLRUNPARAM=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_string_of_jsbytes("CAMLRUNPARAM"),
     cst$64=caml_string_of_jsbytes(""),
     cst_Weak_Make_hash_bucket_cann=
      caml_string_of_jsbytes("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_string_of_jsbytes("Weak.fill"),
     cst_Weak_blit=caml_string_of_jsbytes("Weak.blit"),
     cst_Weak_check=caml_string_of_jsbytes("Weak.check"),
     cst_Weak_get_copy=caml_string_of_jsbytes("Weak.get_copy"),
     cst_Weak_get=caml_string_of_jsbytes("Weak.get"),
     cst_Weak_set=caml_string_of_jsbytes("Weak.set"),
     cst_Weak_create=caml_string_of_jsbytes("Weak.create"),
     cst$82=caml_string_of_jsbytes(""),
     cst$83=caml_string_of_jsbytes(""),
     cst$81=caml_string_of_jsbytes("."),
     cst$78=caml_string_of_jsbytes(">"),
     cst$79=caml_string_of_jsbytes("<\/"),
     cst$80=caml_string_of_jsbytes(""),
     cst$75=caml_string_of_jsbytes(">"),
     cst$76=caml_string_of_jsbytes("<"),
     cst$77=caml_string_of_jsbytes(""),
     cst$74=caml_string_of_jsbytes("\n"),
     cst_Format_pp_set_geometry_max=
      caml_string_of_jsbytes("Format.pp_set_geometry: max_indent < 2"),
     cst_Format_pp_set_geometry_mar=
      caml_string_of_jsbytes("Format.pp_set_geometry: margin <= max_indent"),
     cst$70=caml_string_of_jsbytes(""),
     cst$71=caml_string_of_jsbytes(""),
     cst$72=caml_string_of_jsbytes(""),
     cst$73=caml_string_of_jsbytes(""),
     cst$66=caml_string_of_jsbytes(""),
     cst$67=caml_string_of_jsbytes(""),
     cst$68=caml_string_of_jsbytes(""),
     cst$69=caml_string_of_jsbytes(""),
     cst$65=caml_string_of_jsbytes(""),
     cst_Stdlib_Format_String_tag=
      caml_string_of_jsbytes("Stdlib.Format.String_tag"),
     cst_end_of_input_not_found=
      caml_string_of_jsbytes("end of input not found"),
     cst_scanf_bad_conversion_a=
      caml_string_of_jsbytes('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=
      caml_string_of_jsbytes('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_string_of_jsbytes("scanf: missing reader"),
     cst_scanf_bad_conversion_custo=
      caml_string_of_jsbytes('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=
      caml_string_of_jsbytes('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst$89=caml_string_of_jsbytes('"'),
     cst$90=caml_string_of_jsbytes('"'),
     cst$87=caml_string_of_jsbytes('"'),
     cst$88=caml_string_of_jsbytes('"'),
     cst$86=caml_string_of_jsbytes('"'),
     cst_in_format=caml_string_of_jsbytes(' in format "'),
     cst_an=caml_string_of_jsbytes("an"),
     cst_x$2=caml_string_of_jsbytes("x"),
     cst_nfinity=caml_string_of_jsbytes("nfinity"),
     cst_digits=caml_string_of_jsbytes("digits"),
     cst_decimal_digits=caml_string_of_jsbytes("decimal digits"),
     cst_0b=caml_string_of_jsbytes("0b"),
     cst_0o=caml_string_of_jsbytes("0o"),
     cst_0u=caml_string_of_jsbytes("0u"),
     cst_0x=caml_string_of_jsbytes("0x"),
     cst_false$3=caml_string_of_jsbytes("false"),
     cst_true$3=caml_string_of_jsbytes("true"),
     cst_not_a_valid_float_in_hexad=
      caml_string_of_jsbytes("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_fo=
      caml_string_of_jsbytes("no dot or exponent part found in float token"),
     cst$85=caml_string_of_jsbytes("-"),
     cst_unnamed_function=caml_string_of_jsbytes("unnamed function"),
     cst_unnamed_character_string=
      caml_string_of_jsbytes("unnamed character string"),
     cst_unnamed_Stdlib_input_chann=
      caml_string_of_jsbytes("unnamed Stdlib input channel"),
     cst$84=caml_string_of_jsbytes("-"),
     cst_Stdlib_Scanf_Scan_failure=
      caml_string_of_jsbytes("Stdlib.Scanf.Scan_failure"),
     cst_binary=caml_string_of_jsbytes("binary"),
     cst_octal=caml_string_of_jsbytes("octal"),
     cst_hexadecimal=caml_string_of_jsbytes("hexadecimal"),
     cst_a_Char=caml_string_of_jsbytes("a Char"),
     cst_a_String=caml_string_of_jsbytes("a String"),
     cst$91=caml_string_of_jsbytes(""),
     cst$92=caml_string_of_jsbytes(""),
     cst$93=caml_string_of_jsbytes(""),
     cst$94=caml_string_of_jsbytes(""),
     cst$95=caml_string_of_jsbytes(""),
     cst$97=caml_string_of_jsbytes(""),
     cst$96=caml_string_of_jsbytes(""),
     cst_Illegal_character=caml_string_of_jsbytes("Illegal character "),
     cst_Filename_chop_extension=
      caml_string_of_jsbytes("Filename.chop_extension"),
     cst$108=caml_string_of_jsbytes(""),
     cst_Filename_chop_suffix=caml_string_of_jsbytes("Filename.chop_suffix"),
     cst$107=caml_string_of_jsbytes(""),
     cst$105=caml_string_of_jsbytes("./"),
     cst$104=caml_string_of_jsbytes(".\\"),
     cst$103=caml_string_of_jsbytes("../"),
     cst$102=caml_string_of_jsbytes("..\\"),
     cst$101=caml_string_of_jsbytes("./"),
     cst$100=caml_string_of_jsbytes("../"),
     cst$99=caml_string_of_jsbytes(""),
     cst$98=caml_string_of_jsbytes(""),
     current_dir_name=caml_string_of_jsbytes("."),
     parent_dir_name=caml_string_of_jsbytes(".."),
     dir_sep=caml_string_of_jsbytes("/"),
     cst_TMPDIR=caml_string_of_jsbytes("TMPDIR"),
     cst_tmp=caml_string_of_jsbytes("/tmp"),
     quotequote=caml_string_of_jsbytes("'\\''"),
     current_dir_name$0=caml_string_of_jsbytes("."),
     parent_dir_name$0=caml_string_of_jsbytes(".."),
     dir_sep$0=caml_string_of_jsbytes("\\"),
     cst_TEMP=caml_string_of_jsbytes("TEMP"),
     cst$106=caml_string_of_jsbytes("."),
     current_dir_name$1=caml_string_of_jsbytes("."),
     parent_dir_name$1=caml_string_of_jsbytes(".."),
     dir_sep$1=caml_string_of_jsbytes("/"),
     cst_Cygwin=caml_string_of_jsbytes("Cygwin"),
     cst_Win32=caml_string_of_jsbytes("Win32"),
     zero$4=[254,0.,0.],
     one$4=[254,1.,0.],
     i=[254,0.,1.],
     cst_Series_is_closed$0=caml_string_of_jsbytes("Series is closed"),
     cst_Series_is_closed=caml_string_of_jsbytes("Series is closed"),
     cst_Bigarray_array3_of_genarra=
      caml_string_of_jsbytes("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarra=
      caml_string_of_jsbytes("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarra=
      caml_string_of_jsbytes("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarra=
      caml_string_of_jsbytes("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_n$0=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array2.of_array: non-rectangular data"),
     Invalid_argument=global_data.Invalid_argument,
     Failure=global_data.Failure,
     Match_failure=global_data.Match_failure,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Sys_error=global_data.Sys_error,
     End_of_file=global_data.End_of_file,
     Division_by_zero=global_data.Division_by_zero,
     Sys_blocked_io=global_data.Sys_blocked_io,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _l_=[0,0,[0,6,0]],
     _k_=[0,0,[0,7,0]],
     _j_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _i_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _g_=[0,1],
     _h_=[0,0],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,0,32752),
     _b_=runtime.caml_int64_create_lo_mi_hi(0,0,65520),
     _c_=runtime.caml_int64_create_lo_mi_hi(1,0,32752),
     _d_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32751),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,16),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,15536),
     _o_=[0,0,0],
     _p_=[0,caml_string_of_jsbytes("list.ml"),282,11],
     _t_=[0,caml_string_of_jsbytes("array.ml"),236,4],
     _v_=[0,caml_string_of_jsbytes("float.ml"),381,6],
     _u_=[0,caml_string_of_jsbytes("float.ml"),208,14],
     _G_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _F_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _E_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _D_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _H_=[0,0,0,0],
     _I_=[0,0,0],
     _J_=[0,caml_string_of_jsbytes("set.ml"),547,18],
     _K_=[0,0,0,0],
     _L_=[0,caml_string_of_jsbytes("map.ml"),398,10],
     _M_=[0,0,0],
     _N_=[0,caml_string_of_jsbytes("stream.ml"),53,12],
     _O_=[0,0],
     _P_=[0,caml_string_of_jsbytes("stream.ml"),82,12],
     _Z_=[0,caml_string_of_jsbytes("buffer.ml"),282,9],
     _Y_=[0,caml_string_of_jsbytes("buffer.ml"),263,2],
     _X_=[0,caml_string_of_jsbytes("buffer.ml"),195,19],
     _W_=[0,caml_string_of_jsbytes("buffer.ml"),213,8],
     _V_=[0,caml_string_of_jsbytes("buffer.ml"),174,19],
     _U_=[0,caml_string_of_jsbytes("buffer.ml"),192,8],
     _T_=[0,caml_string_of_jsbytes("buffer.ml"),138,19],
     _S_=[0,caml_string_of_jsbytes("buffer.ml"),171,8],
     _R_=[0,caml_string_of_jsbytes("buffer.ml"),93,2],
     _Q_=[0,caml_string_of_jsbytes("buffer.ml"),94,2],
     _$_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),847,23],
     _ak_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),811,21],
     _ac_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),812,21],
     _al_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),815,21],
     _ad_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),816,21],
     _am_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),819,19],
     _ae_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),820,19],
     _an_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),823,22],
     _af_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),824,22],
     _ao_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),828,30],
     _ag_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),829,30],
     _ai_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),833,26],
     _aa_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),834,26],
     _aj_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),843,28],
     _ab_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),844,28],
     _ah_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),848,23],
     _aq_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1555,4],
     _ar_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1623,39],
     _as_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1646,31],
     _at_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1647,31],
     _au_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1827,8],
     _aY_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aX_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", duplicate flag "),[1,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aB_=[0,1,0],
     _aC_=[0,0],
     _aE_=[1,0],
     _aD_=[1,1],
     _aG_=[1,1],
     _aF_=[1,1],
     _aK_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", flag "),
            [1,
             [11,
              caml_string_of_jsbytes(" is only allowed after the '"),
              [12,
               37,
               [11,
                caml_string_of_jsbytes("', before padding and precision"),
                0]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aH_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aI_=[0,0],
     _aJ_=[0,0],
     _aL_=[0,[12,64,0]],
     _aM_=[0,caml_string_of_jsbytes("@ "),1,0],
     _aN_=[0,caml_string_of_jsbytes("@,"),0,0],
     _aO_=[2,60],
     _aP_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": '"),
          [12,
           37,
           [11,
            caml_string_of_jsbytes
             ("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_string_of_jsbytes(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aQ_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": integer "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" is greater than the limit "),
            [4,0,0,0,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aR_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2842,11],
     _aS_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,
            [11,caml_string_of_jsbytes('" at character number '),[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aT_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2904,34],
     _aU_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2940,28],
     _aV_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2961,11],
     _aW_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(" is incompatible with '"),
              [0,[11,caml_string_of_jsbytes("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _az_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(" expected, read "),[1,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _ay_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", '"),
            [0,[11,caml_string_of_jsbytes("' without "),[2,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, '%c' without %s")],
     _ax_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]]]],
       caml_string_of_jsbytes("invalid format %S: at character number %d, %s")],
     _aw_=
      [0,
       [11,caml_string_of_jsbytes("invalid box description "),[3,0,0]],
       caml_string_of_jsbytes("invalid box description %S")],
     _av_=[0,0,4],
     _ap_=[0,103],
     ___=[0,0,0],
     _bi_=[0,[2,0,[0,0]],caml_string_of_jsbytes("%s%c")],
     _bc_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bd_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _ba_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bb_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a__=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a$_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a4_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": unknown option '"),
         [2,0,[11,caml_string_of_jsbytes("'.\n"),0]]]],
       caml_string_of_jsbytes("%s: unknown option '%s'.\n")],
     _a7_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": wrong argument '"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("'; option '"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("' expects "),
             [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]]]]]],
       caml_string_of_jsbytes
        ("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a8_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": option '"),
         [2,0,[11,caml_string_of_jsbytes("' needs an argument.\n"),0]]]],
       caml_string_of_jsbytes("%s: option '%s' needs an argument.\n")],
     _a9_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]],
       caml_string_of_jsbytes("%s: %s.\n")],
     _a5_=[0,caml_string_of_jsbytes("-help")],
     _a6_=[0,caml_string_of_jsbytes("--help")],
     _a3_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a2_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _a1_=[0,caml_string_of_jsbytes("-help")],
     _aZ_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_string_of_jsbytes("  %s %s\n")],
     _a0_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_string_of_jsbytes("  %s %s%s\n")],
     _bn_=
      [0,
       [11,caml_string_of_jsbytes(", "),[2,0,[2,0,0]]],
       caml_string_of_jsbytes(", %s%s")],
     _bw_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bu_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bv_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_string_of_jsbytes
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bs_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(' file "'),
         [2,
          0,
          [12,
           34,
           [2,
            0,
            [11,
             caml_string_of_jsbytes(", line "),
             [4,
              0,
              0,
              0,
              [11,
               caml_string_of_jsbytes(", characters "),
               [4,0,0,0,[12,45,partial]]]]]]]]]],
       caml_string_of_jsbytes('%s file "%s"%s, line %d, characters %d-%d')],
     _bt_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" unknown location"),0]],
       caml_string_of_jsbytes("%s unknown location")],
     _br_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _bq_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _bo_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_string_of_jsbytes("(%s%s)")],
     _bp_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _bm_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bl_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _bF_=
      [0,
       [11,caml_string_of_jsbytes("minor_collections: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("minor_collections: %d\n")],
     _bG_=
      [0,
       [11,caml_string_of_jsbytes("major_collections: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("major_collections: %d\n")],
     _bH_=
      [0,
       [11,caml_string_of_jsbytes("compactions:       "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("compactions:       %d\n")],
     _bI_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bJ_=[0,[8,[0,0,0],0,[0,0],0],caml_string_of_jsbytes("%.0f")],
     _bK_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("minor_words:    %*.0f\n")],
     _bL_=
      [0,
       [11,
        caml_string_of_jsbytes("promoted_words: "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("promoted_words: %*.0f\n")],
     _bM_=
      [0,
       [11,
        caml_string_of_jsbytes("major_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("major_words:    %*.0f\n")],
     _bN_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bO_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bP_=
      [0,
       [11,caml_string_of_jsbytes("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("top_heap_words: %*d\n")],
     _bQ_=
      [0,
       [11,caml_string_of_jsbytes("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("heap_words:     %*d\n")],
     _bR_=
      [0,
       [11,caml_string_of_jsbytes("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("live_words:     %*d\n")],
     _bS_=
      [0,
       [11,caml_string_of_jsbytes("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("free_words:     %*d\n")],
     _bT_=
      [0,
       [11,caml_string_of_jsbytes("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("largest_free:   %*d\n")],
     _bU_=
      [0,
       [11,caml_string_of_jsbytes("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("fragments:      %*d\n")],
     _bV_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bW_=
      [0,
       [11,caml_string_of_jsbytes("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("live_blocks: %d\n")],
     _bX_=
      [0,
       [11,caml_string_of_jsbytes("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("free_blocks: %d\n")],
     _bY_=
      [0,
       [11,caml_string_of_jsbytes("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("heap_chunks: %d\n")],
     _b1_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _b2_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _b3_=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _b7_=[0,0],
     _b6_=[0,caml_string_of_jsbytes("hashtbl.ml"),108,23],
     _b__=[3,0,3],
     _b9_=[0,caml_string_of_jsbytes("")],
     _b8_=[0,caml_string_of_jsbytes(""),0,caml_string_of_jsbytes("")],
     _co_=[0,91],
     _cn_=[0,123],
     _cp_=[0,caml_string_of_jsbytes("scanf.ml"),1453,13],
     _cq_=[0,[3,0,[10,0]],caml_string_of_jsbytes("%S%!")],
     _cm_=[0,37,caml_string_of_jsbytes("")],
     _cl_=
      [0,
       [11,
        caml_string_of_jsbytes("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]],
       caml_string_of_jsbytes("scanf: bad input at char number %i: %s")],
     _ck_=
      [0,
       [11,
        caml_string_of_jsbytes("the character "),
        [1,[11,caml_string_of_jsbytes(" cannot start a boolean"),0]]],
       caml_string_of_jsbytes("the character %C cannot start a boolean")],
     _cj_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character hexadecimal encoding \\"),
        [0,[0,0]]],
       caml_string_of_jsbytes("bad character hexadecimal encoding \\%c%c")],
     _ci_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character decimal encoding \\"),
        [0,[0,[0,0]]]],
       caml_string_of_jsbytes("bad character decimal encoding \\%c%c%c")],
     _ch_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,
         [11,
          caml_string_of_jsbytes(" is not a valid "),
          [2,0,[11,caml_string_of_jsbytes(" digit"),0]]]]],
       caml_string_of_jsbytes("character %C is not a valid %s digit")],
     _cg_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,[11,caml_string_of_jsbytes(" is not a decimal digit"),0]]],
       caml_string_of_jsbytes("character %C is not a decimal digit")],
     _cf_=[0,caml_string_of_jsbytes("scanf.ml"),555,9],
     _ce_=
      [0,
       [11,caml_string_of_jsbytes("invalid boolean '"),[2,0,[12,39,0]]],
       caml_string_of_jsbytes("invalid boolean '%s'")],
     _cd_=
      [0,
       [11,
        caml_string_of_jsbytes("looking for "),
        [1,[11,caml_string_of_jsbytes(", found "),[1,0]]]],
       caml_string_of_jsbytes("looking for %C, found %C")],
     _cc_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _cb_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: the specified length was too short for token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: the specified length was too short for token")],
     _ca_=
      [0,
       [11,caml_string_of_jsbytes("illegal escape character "),[1,0]],
       caml_string_of_jsbytes("illegal escape character %C")],
     _cx_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),438,17],
     _cw_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),420,13],
     _cv_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),417,13],
     _cu_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),414,13],
     _ct_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),411,13],
     _cs_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),408,13],
     _cr_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),281,50],
     _cA_=[0,0],
     _cz_=[0,0],
     _cy_=[0,0],
     _cE_=[0,7,0],
     _cD_=[0,1,[0,3,[0,5,0]]],
     _cC_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_string_of_jsbytes("%s%06x%s")],
     _cF_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (708,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Stdlib_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function symbol(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_g_
              :_h_}
    function string_of_int(n){return caml_string_of_jsbytes("" + n)}
    function int_of_string_opt(s)
     {try
       {var _AB_=[0,caml_int_of_string(s)];return _AB_}
      catch(_AC_)
       {_AC_ = caml_wrap_exception(_AC_);
        if(_AC_[1] === Failure)return 0;
        throw _AC_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return symbol(s,cst);
        var match=caml_string_get(s,i),switch$0=0;
        if(48 <= match)
         {if(! (58 <= match))switch$0 = 1}
        else
         if(45 === match)switch$0 = 1;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function to_string(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function of_string_opt(s)
     {try
       {var _Az_=[0,caml_float_of_string(s)];return _Az_}
      catch(_AA_)
       {_AA_ = caml_wrap_exception(_AA_);
        if(_AA_[1] === Failure)return 0;
        throw _AA_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_i_,438,name)}
    function open_out_bin(name){return open_out_gen(_j_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_Ay_)
             {_Ay_ = caml_wrap_exception(_Ay_);
              if(_Ay_[1] !== Sys_error)throw _Ay_;
              var _Ax_=_Ay_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(s) - len | 0) < ofs))
       return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_Aw_){}
      try
       {var _Au_=caml_ml_close_channel(oc);return _Au_}
      catch(_Av_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_k_,0,name)}
    function open_in_bin(name){return open_in_gen(_l_,0,name)}
    function input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);
      really_input(ic,s,0,len);
      return caml_string_of_bytes(s)}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _At_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _At_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _At_=res}
        return caml_string_of_bytes(_At_)}}
    function close_in_noerr(ic)
     {try
       {var _Ar_=caml_ml_close_channel(ic);return _Ar_}
      catch(_As_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_string_of_jsbytes("" + i))}
    function print_float(f){return output_string(stdout,to_string(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_string_of_jsbytes("" + i))}
    function prerr_float(f){return output_string(stderr,to_string(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    function symbol$0(param,_Ap_)
     {var
       str2=_Ap_[2],
       fmt2=_Ap_[1],
       str1=param[2],
       fmt1=param[1],
       _Aq_=symbol(str1,symbol(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_Aq_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {var g=exit_function[1],f_already_ran=[0,0];
      exit_function[1]
      =
      function(param)
       {if(1 - f_already_ran[1]){f_already_ran[1] = 1;caml_call1(f,0)}
        return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    var
     set_binary_mode_in=caml_ml_set_binary_mode,
     close_in=caml_ml_close_channel,
     in_channel_length=caml_ml_channel_size,
     pos_in=runtime.caml_ml_pos_in,
     seek_in=runtime.caml_ml_seek_in,
     input_value=caml_input_value,
     input_binary_int=runtime.caml_ml_input_int,
     input_byte=caml_ml_input_char,
     input_char=caml_ml_input_char,
     set_binary_mode_out=caml_ml_set_binary_mode,
     out_channel_length=caml_ml_channel_size,
     pos_out=runtime.caml_ml_pos_out,
     seek_out=runtime.caml_ml_seek_out,
     output_binary_int=runtime.caml_ml_output_int,
     output_byte=caml_ml_output_char,
     output_char=caml_ml_output_char,
     flush=caml_ml_flush,
     Stdlib=
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(721,Stdlib,"Stdlib");
    var
     Exit$0=[248,cst_Stdlib_Pervasives_Exit,caml_fresh_oo_id(0)],
     Stdlib_pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       do_at_exit];
    caml_register_global(722,Stdlib_pervasives,"Stdlib__pervasives");
    function empty(param){return 0}
    function return$0(x,param){return [0,x,empty]}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _An_=function(_Ao_){return map(f,next,_Ao_)};
        return [0,caml_call1(f,x),_An_]}
      return 0}
    function filter_map(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1],match$0=caml_call1(f,x);
          if(match$0)
           {var y=match$0[1];
            return [0,y,function(_Am_){return filter_map(f,next,_Am_)}]}
          var seq$0=next;
          continue}
        return 0}}
    function filter(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          if(caml_call1(f,x))
           return [0,x,function(_Al_){return filter(f,next,_Al_)}];
          var seq$0=next;
          continue}
        return 0}}
    function flat_map$0(counter,f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1],_Ak_=caml_call1(f,x),_Aj_=0;
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return flat_map_app$0(counter$0,f,_Ak_,next,_Aj_)}
        return caml_trampoline_return(flat_map_app$0,[0,f,_Ak_,next,_Aj_])}
      return 0}
    function flat_map_app$0(counter,f,seq,tail,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_Ai_){return flat_map_app(f,next,tail,_Ai_)}]}
      var _Ah_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return flat_map$0(counter$0,f,tail,_Ah_)}
      return caml_trampoline_return(flat_map$0,[0,f,tail,_Ah_])}
    function flat_map(f,seq,param)
     {return caml_trampoline(flat_map$0(0,f,seq,param))}
    function flat_map_app(f,seq,tail,param)
     {return caml_trampoline(flat_map_app$0(0,f,seq,tail,param))}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    var
     Stdlib_seq=
      [0,empty,return$0,map,filter,filter_map,flat_map,fold_left,iter];
    caml_register_global(723,Stdlib_seq,"Stdlib__seq");
    var none=0;
    function some(v){return [0,v]}
    function value(o,default$0){if(o){var v=o[1];return v}return default$0}
    function get(param)
     {if(param){var v=param[1];return v}
      return invalid_arg(cst_option_is_None)}
    function bind(o,f){if(o){var v=o[1];return caml_call1(f,v)}return 0}
    function join(param)
     {if(param){var _Ag_=param[1];if(_Ag_)return _Ag_}return 0}
    function map$0(f,o){if(o){var v=o[1];return [0,caml_call1(f,v)]}return 0}
    function fold(none,some,param)
     {if(param){var v=param[1];return caml_call1(some,v)}return none}
    function iter$0(f,param)
     {if(param){var v=param[1];return caml_call1(f,v)}return 0}
    function is_none(param){return param?0:1}
    function is_some(param){return param?1:0}
    function equal(eq,o0,o1)
     {if(o0)
       {if(o1){var v1=o1[1],v0=o0[1];return caml_call2(eq,v0,v1)}}
      else
       if(! o1)return 1;
      return 0}
    function compare(cmp,o0,o1)
     {if(o0)
       {var _Af_=o0[1];
        if(o1){var v1=o1[1];return caml_call2(cmp,_Af_,v1)}
        return 1}
      return o1?-1:0}
    function to_result(none,param)
     {if(param){var v=param[1];return [0,v]}return [1,none]}
    function to_list(param){if(param){var v=param[1];return [0,v,0]}return 0}
    function to_seq(param)
     {if(param){var v=param[1];return function(_Ae_){return return$0(v,_Ae_)}}
      return empty}
    var
     Stdlib_option=
      [0,
       none,
       some,
       value,
       get,
       bind,
       join,
       map$0,
       fold,
       iter$0,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
    caml_register_global(724,Stdlib_option,"Stdlib__option");
    function ok(v){return [0,v]}
    function error(e){return [1,e]}
    function value$0(r,default$0)
     {if(0 === r[0]){var v=r[1];return v}return default$0}
    function get_ok(param)
     {if(0 === param[0]){var v=param[1];return v}
      return invalid_arg(cst_result_is_Error)}
    function get_error(param)
     {if(0 === param[0])return invalid_arg(cst_result_is_Ok);
      var e=param[1];
      return e}
    function bind$0(r,f)
     {if(0 === r[0]){var v=r[1];return caml_call1(f,v)}return r}
    function join$0(e){if(0 === e[0]){var r=e[1];return r}return e}
    function map$1(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_error(f,v)
     {if(0 === v[0])return v;var e=v[1];return [1,caml_call1(f,e)]}
    function fold$0(ok,error,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(ok,v)}
      var e=param[1];
      return caml_call1(error,e)}
    function iter$1(f,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(f,v)}return 0}
    function iter_error(f,param)
     {if(0 === param[0])return 0;var e=param[1];return caml_call1(f,e)}
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function equal$0(ok,error,r0,match)
     {if(0 === r0[0])
       {var _Ac_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_Ac_,v1)}}
      else
       {var _Ad_=r0[1];
        if(0 !== match[0]){var e1=match[1];return caml_call2(error,_Ad_,e1)}}
      return 0}
    function compare$0(ok,error,r0,match)
     {if(0 === r0[0])
       {var _Aa_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_Aa_,v1)}
        return -1}
      var _Ab_=r0[1];
      if(0 === match[0])return 1;
      var e1=match[1];
      return caml_call2(error,_Ab_,e1)}
    function to_option(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function to_list$0(param)
     {if(0 === param[0]){var v=param[1];return [0,v,0]}return 0}
    function to_seq$0(param)
     {if(0 === param[0])
       {var v=param[1];return function(_z$_){return return$0(v,_z$_)}}
      return empty}
    var
     Stdlib_result=
      [0,
       ok,
       error,
       value$0,
       get_ok,
       get_error,
       bind$0,
       join$0,
       map$1,
       map_error,
       fold$0,
       iter$1,
       iter_error,
       is_ok,
       is_error,
       equal$0,
       compare$0,
       to_option,
       to_list$0,
       to_seq$0];
    caml_register_global(725,Stdlib_result,"Stdlib__result");
    function equal$1(_z__,_z9_){return _z__ === _z9_?1:0}
    var compare$1=caml_int_compare;
    function to_int(param){return 0 === param?0:1}
    function to_float(param){return 0 === param?0.:1.}
    function to_string$0(param){return 0 === param?cst_false$2:cst_true$2}
    var
     Stdlib_bool=
      [0,
       function(_z8_){return 1 - _z8_},
       equal$1,
       compare$1,
       to_int,
       to_float,
       to_string$0];
    caml_register_global(726,Stdlib_bool,"Stdlib__bool");
    function chr(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {var switch$0=0;
      if(40 <= c)
       {if(92 === c)return cst$1;if(! (127 <= c))switch$0 = 1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;switch$0 = 1}
       else
        if(! (14 <= c))
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r
           }
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var switch$0=0;
      if(! (65 <= c) || 90 < c)switch$0 = 1;
      if(switch$0)
       {var switch$1=0;
        if(! (192 <= c) || 214 < c)switch$1 = 1;
        if(switch$1)
         {var switch$2=0;
          if(! (216 <= c) || 222 < c)switch$2 = 1;
          if(switch$2)return c}}
      return c + 32 | 0}
    function uppercase(c)
     {var switch$0=0;
      if(! (97 <= c) || 122 < c)switch$0 = 1;
      if(switch$0)
       {var switch$1=0;
        if(! (224 <= c) || 246 < c)switch$1 = 1;
        if(switch$1)
         {var switch$2=0;
          if(! (248 <= c) || 254 < c)switch$2 = 1;
          if(switch$2)return c}}
      return c - 32 | 0}
    function lowercase_ascii(c)
     {if(65 <= c && ! (90 < c))return c + 32 | 0;return c}
    function uppercase_ascii(c)
     {if(97 <= c && ! (122 < c))return c - 32 | 0;return c}
    function compare$2(c1,c2){return c1 - c2 | 0}
    function equal$2(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Stdlib_char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare$2,
       equal$2];
    caml_register_global(727,Stdlib_char,"Stdlib__char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _z4_=0 <= i?1:0,_z5_=_z4_?i <= 55295?1:0:_z4_;
      if(_z5_)
       var _z6_=_z5_;
      else
       var _z7_=57344 <= i?1:0,_z6_=_z7_?i <= 1114111?1:0:_z7_;
      return _z6_}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (symbol
                  (caml_format_int(cst_X,i),cst_is_not_an_Unicode_scalar_v))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (symbol
                  (cst_U,
                   symbol
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_z3_){return _z3_}
    function equal$3(_z2_,_z1_){return _z2_ === _z1_?1:0}
    var compare$3=caml_int_compare;
    function hash(_z0_){return _z0_}
    function _m_(_zZ_){return _zZ_}
    var
     Stdlib_uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_zY_){return _zY_},
       _m_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$3,
       compare$3,
       hash];
    caml_register_global(728,Stdlib_uchar,"Stdlib__uchar");
    var
     executable_name=runtime.caml_sys_executable_name(0),
     match=runtime.caml_sys_get_config(0),
     os_type=match[1],
     match$0=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_floatarray_length=max_array_length / 2 | 0,
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     big_endian=0,
     match$1=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _zW_=[0,caml_sys_getenv(s)];return _zW_}
      catch(_zX_)
       {_zX_ = caml_wrap_exception(_zX_);
        if(_zX_ === Not_found)return 0;
        throw _zX_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Stdlib_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    var
     Stdlib_sys=
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       match$0,
       unix,
       win32,
       cygwin,
       match$1,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled];
    caml_register_global(729,Stdlib_sys,"Stdlib__sys");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    var rev_init_threshold=typeof match$0 === "number"?10000:50;
    function init(len,f)
     {if(0 <= len)
       {if(rev_init_threshold < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$2(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$2(f,l)]}
      return 0}
    function _n_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_n_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _n_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter$2(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left$0(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zV_=caml_call1(p,a);
          if(_zV_){var param$0=l;continue}
          return _zV_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zU_=caml_call1(p,a);
          if(_zU_)return _zU_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _zT_=caml_call2(p,a1,a2);
            if(_zT_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _zT_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _zS_=caml_call2(p,a1,a2);
            if(_zS_)return _zS_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zR_=0 === caml_compare(a,x)?1:0;
          if(_zR_)return _zR_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zQ_=a === x?1:0;
          if(_zQ_)return _zQ_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _zP_=0 === caml_compare(a,x)?1:0;
          if(_zP_)return _zP_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_zO_=a === x?1:0;
          if(_zO_)return _zO_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function filter_map$0(f)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1],match=caml_call1(f,x);
            if(match)
             {var v=match[1],accu$1=[0,v,accu$0],accu$0=accu$1,param=l;
              continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _zN_=rev(no);
        return [0,rev(yes),_zN_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _o_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function chop(k,l)
     {var k$0=k,l$0=l;
      for(;;)
       {if(0 === k$0)return l$0;
        if(l$0){var l$1=l$0[2],k$1=k$0 - 1 | 0,k$0=k$1,l$0=l$1;continue}
        throw [0,Assert_failure,_p_]}}
    function fast_sort(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zK_=l[2];
            if(_zK_)
             {var x2=_zK_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n && l)
          {var _zL_=l[2];
           if(_zL_)
            {var _zM_=_zL_[2];
             if(_zM_)
              {var x3=_zM_[1],x2$0=_zL_[1],x1$0=l[1];
               return 0 < caml_call2(cmp,x1$0,x2$0)
                       ?0 < caml_call2(cmp,x2$0,x3)
                         ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                         :0 < caml_call2(cmp,x1$0,x3)
                           ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                           :[0,x3,[0,x1$0,[0,x2$0,0]]]
                       :0 < caml_call2(cmp,x1$0,x3)
                         ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                         :0 < caml_call2(cmp,x2$0,x3)
                           ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                           :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zH_=l[2];
            if(_zH_)
             {var x2=_zH_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n && l)
          {var _zI_=l[2];
           if(_zI_)
            {var _zJ_=_zI_[2];
             if(_zJ_)
              {var x3=_zJ_[1],x2$0=_zI_[1],x1$0=l[1];
               return 0 < caml_call2(cmp,x1$0,x2$0)
                       ?0 < caml_call2(cmp,x1$0,x3)
                         ?0 < caml_call2(cmp,x2$0,x3)
                           ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                           :[0,x2$0,[0,x3,[0,x1$0,0]]]
                         :[0,x2$0,[0,x1$0,[0,x3,0]]]
                       :0 < caml_call2(cmp,x2$0,x3)
                         ?0 < caml_call2(cmp,x1$0,x3)
                           ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                           :[0,x1$0,[0,x3,[0,x2$0,0]]]
                         :[0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function sort_uniq(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zE_=l[2];
            if(_zE_)
             {var x2=_zE_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n && l)
          {var _zF_=l[2];
           if(_zF_)
            {var _zG_=_zF_[2];
             if(_zG_)
              {var
                x3=_zG_[1],
                x2$0=_zF_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                {var c$2=caml_call2(cmp,x2$0,x3);
                 return 0 === c$2
                         ?[0,x2$0,0]
                         :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]]}
               if(0 < c$1)
                {var c$3=caml_call2(cmp,x2$0,x3);
                 if(0 === c$3)return [0,x1$0,[0,x2$0,0]];
                 if(0 < c$3)return [0,x1$0,[0,x2$0,[0,x3,0]]];
                 var c$4=caml_call2(cmp,x1$0,x3);
                 return 0 === c$4
                         ?[0,x1$0,[0,x2$0,0]]
                         :0 < c$4
                           ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                           :[0,x3,[0,x1$0,[0,x2$0,0]]]}
               var c$5=caml_call2(cmp,x1$0,x3);
               if(0 === c$5)return [0,x2$0,[0,x1$0,0]];
               if(0 < c$5)return [0,x2$0,[0,x1$0,[0,x3,0]]];
               var c$6=caml_call2(cmp,x2$0,x3);
               return 0 === c$6
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 < c$6
                         ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                         :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zB_=l[2];
            if(_zB_)
             {var x2=_zB_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n && l)
          {var _zC_=l[2];
           if(_zC_)
            {var _zD_=_zC_[2];
             if(_zD_)
              {var
                x3=_zD_[1],
                x2$0=_zC_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                {var c$2=caml_call2(cmp,x2$0,x3);
                 return 0 === c$2
                         ?[0,x2$0,0]
                         :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]]}
               if(0 <= c$1)
                {var c$3=caml_call2(cmp,x1$0,x3);
                 if(0 === c$3)return [0,x2$0,[0,x1$0,0]];
                 if(0 <= c$3)
                  {var c$4=caml_call2(cmp,x2$0,x3);
                   return 0 === c$4
                           ?[0,x2$0,[0,x1$0,0]]
                           :0 <= c$4
                             ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                             :[0,x2$0,[0,x3,[0,x1$0,0]]]}
                 return [0,x2$0,[0,x1$0,[0,x3,0]]]}
               var c$5=caml_call2(cmp,x2$0,x3);
               if(0 === c$5)return [0,x1$0,[0,x2$0,0]];
               if(0 <= c$5)
                {var c$6=caml_call2(cmp,x1$0,x3);
                 return 0 === c$6
                         ?[0,x1$0,[0,x2$0,0]]
                         :0 <= c$6
                           ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                           :[0,x1$0,[0,x3,[0,x2$0,0]]]}
               return [0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    function to_seq$1(l)
     {function aux(l,param)
       {if(l)
         {var tail=l[2],x=l[1];
          return [0,x,function(_zA_){return aux(tail,_zA_)}]}
        return 0}
      return function(_zz_){return aux(l,_zz_)}}
    function of_seq(seq)
     {function direct(depth,seq)
       {if(0 === depth)
         {var _zy_=0;
          return rev(fold_left(function(acc,x){return [0,x,acc]},_zy_,seq))}
        var match=caml_call1(seq,0);
        if(match)
         {var next=match[2],x=match[1];
          return [0,x,direct(depth - 1 | 0,next)]}
        return 0}
      return direct(500,seq)}
    var
     include=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$2,
       iteri,
       map$2,
       mapi,
       rev_map,
       filter_map$0,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(730,include,"Stdlib__list");
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_zw_=n - 1 | 0,_zv_=0;
      if(! (_zw_ < 0))
       {var i=_zv_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _zx_=i + 1 | 0;
          if(_zw_ !== i){var i=_zx_;continue}
          break}}
      return s}
    var empty$0=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string$1(b){return caml_string_of_bytes(copy(b))}
    function of_string(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       {var r=caml_create_bytes(len);caml_blit_bytes(s,ofs,r,0,len);return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function symbol$1(a,b)
     {var c=a + b | 0,_zu_=b < 0?1:0,match=c < 0?1:0,switch$0=0;
      if(0 === (a < 0?1:0))
       {if(0 === _zu_ && 0 !== match)switch$0 = 1}
      else
       if(0 !== _zu_ && 0 === match)switch$0 = 1;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=symbol$1(symbol$1(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var srcoff=0,dstoff=left;
      else
       var srcoff=- left | 0,dstoff=0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_bytes_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_string_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_str)}
    function iter$3(f,a)
     {var _zs_=caml_ml_bytes_length(a) - 1 | 0,_zr_=0;
      if(! (_zs_ < 0))
       {var i=_zr_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _zt_=i + 1 | 0;
          if(_zs_ !== i){var i=_zt_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _zp_=caml_ml_bytes_length(a) - 1 | 0,_zo_=0;
      if(! (_zp_ < 0))
       {var i=_zo_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _zq_=i + 1 | 0;
          if(_zp_ !== i){var i=_zq_;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _zj_=param[2],_zk_=param[1];
            if(_zj_)
             {var
               x=(caml_ml_bytes_length(_zk_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=_zj_;
              continue}
            var _zn_=caml_ml_bytes_length(_zk_) + acc | 0}
          else
           var _zn_=acc;
          var dst=caml_create_bytes(_zn_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _zl_=param$0[2],_zm_=param$0[1];
              if(_zl_)
               {caml_blit_bytes(_zm_,0,dst,pos,caml_ml_bytes_length(_zm_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_zm_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_zm_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_zl_;
                continue}
              caml_blit_bytes(_zm_,0,dst,pos,caml_ml_bytes_length(_zm_));
              return dst}
            return dst}}}
      return empty$0}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var _zi_=param - 9 | 0,switch$0=0;
      if(4 < _zi_ >>> 0)
       {if(23 === _zi_)switch$0 = 1}
      else
       if(2 !== _zi_)switch$0 = 1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len && is_space(caml_bytes_unsafe_get(s,i[1])))
         {i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s,j[1])))
           {j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty$0}}}
    function escaped$0(s)
     {var n=[0,0],_zb_=caml_ml_bytes_length(s) - 1 | 0,_za_=0;
      if(! (_zb_ < 0))
       {var i$0=_za_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0),switch$0=0;
          if(32 <= match)
           {var _zf_=match - 34 | 0,switch$1=0;
            if(58 < _zf_ >>> 0)
             {if(93 <= _zf_)switch$1 = 1}
            else
             if(56 < (_zf_ - 1 | 0) >>> 0){switch$0 = 1;switch$1 = 1}
            if(! switch$1){var _zg_=1;switch$0 = 2}}
          else
           if(11 <= match)
            {if(13 === match)switch$0 = 1}
           else
            if(8 <= match)switch$0 = 1;
          switch(switch$0){case 0:var _zg_=4;break;case 1:var _zg_=2;break}
          n[1] = n[1] + _zg_ | 0;
          var _zh_=i$0 + 1 | 0;
          if(_zb_ !== i$0){var i$0=_zh_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _zd_=caml_ml_bytes_length(s) - 1 | 0,_zc_=0;
      if(! (_zd_ < 0))
       {var i=_zc_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i),switch$2=0;
          if(35 <= c)
           if(92 === c)
            switch$2 = 2;
           else
            if(127 <= c)switch$2 = 1;else switch$2 = 3;
          else
           if(32 <= c)
            if(34 <= c)switch$2 = 2;else switch$2 = 3;
           else
            if(14 <= c)
             switch$2 = 1;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                break;
               default:switch$2 = 1}
          switch(switch$2)
           {case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 2:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 3:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _ze_=i + 1 | 0;
          if(_zd_ !== i){var i=_ze_;continue}
          break}}
      return s$0}
    function map$3(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_y__=l - 1 | 0,_y9_=0;
      if(! (_y__ < 0))
       {var i=_y9_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _y$_=i + 1 | 0;
          if(_y__ !== i){var i=_y$_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_y7_=l - 1 | 0,_y6_=0;
      if(! (_y7_ < 0))
       {var i=_y6_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _y8_=i + 1 | 0;
          if(_y7_ !== i){var i=_y8_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$3(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$3(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))
       return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec(s,l,i,c);var _y4_=1;return _y4_}
       catch(_y5_)
        {_y5_ = caml_wrap_exception(_y5_);
         if(_y5_ === Not_found)return 0;
         throw _y5_}
      return invalid_arg(cst_String_contains_from_Bytes)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i && ! (caml_ml_bytes_length(s) <= i))
       try
        {rindex_rec(s,i,c);var _y2_=1;return _y2_}
       catch(_y3_)
        {_y3_ = caml_wrap_exception(_y3_);
         if(_y3_ === Not_found)return 0;
         throw _y3_}
      return invalid_arg(cst_String_rcontains_from_Byte)}
    var compare$4=runtime.caml_bytes_compare;
    function uppercase$0(s){return map$3(uppercase,s)}
    function lowercase$0(s){return map$3(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function to_seq$2(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_y0_=i + 1 | 0;
        return [0,x,function(_y1_){return aux(_y0_,_y1_)}]}
      var _yY_=0;
      return function(_yZ_){return aux(_yY_,_yZ_)}}
    function to_seqi(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_yW_=i + 1 | 0;
        return [0,[0,i,x],function(_yX_){return aux(_yW_,_yX_)}]}
      var _yU_=0;
      return function(_yV_){return aux(_yU_,_yV_)}}
    function of_seq$0(i)
     {var n=[0,0],buf=[0,make(256,0)];
      iter
       (function(c)
         {if(n[1] === caml_ml_bytes_length(buf[1]))
           {var
             new_len=
              min(2 * caml_ml_bytes_length(buf[1]) | 0,max_string_length);
            if(caml_ml_bytes_length(buf[1]) === new_len)
             failwith(cst_Bytes_of_seq_cannot_grow_b);
            var new_buf=make(new_len,0);
            blit(buf[1],0,new_buf,0,n[1]);
            buf[1] = new_buf}
          caml_bytes_set(buf[1],n[1],c);
          n[1]++;
          return 0},
        i);
      return sub(buf[1],0,n[1])}
    function get_int8(b,i){return caml_bytes_get(b,i) << 24 >> 24}
    function get_uint16_le(b,i){return caml_bytes_get16(b,i)}
    function get_uint16_be(b,i){return caml_bswap16(caml_bytes_get16(b,i))}
    function get_int16_ne(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_le(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_be(b,i){return get_uint16_be(b,i) << 16 >> 16}
    function get_int32_le(b,i){return caml_bytes_get32(b,i)}
    function get_int32_be(b,i){return caml_int32_bswap(caml_bytes_get32(b,i))}
    function get_int64_le(b,i){return caml_bytes_get64(b,i)}
    function get_int64_be(b,i){return caml_int64_bswap(caml_bytes_get64(b,i))}
    function set_int16_le(b,i,x){return caml_bytes_set16(b,i,x)}
    function set_int16_be(b,i,x){return caml_bytes_set16(b,i,caml_bswap16(x))}
    function set_int32_le(b,i,x){return caml_bytes_set32(b,i,x)}
    function set_int32_be(b,i,x)
     {return caml_bytes_set32(b,i,caml_int32_bswap(x))}
    function set_int64_le(b,i,x){return caml_bytes_set64(b,i,x)}
    function set_int64_be(b,i,x)
     {return caml_bytes_set64(b,i,caml_int64_bswap(x))}
    var
     set_uint8=caml_bytes_set,
     set_uint16_ne=caml_bytes_set16,
     set_int64_ne=caml_bytes_set64,
     set_int32_ne=caml_bytes_set32,
     set_int16_ne=caml_bytes_set16,
     set_int8=caml_bytes_set,
     get_int64_ne=caml_bytes_get64,
     get_int32_ne=caml_bytes_get32,
     get_uint16_ne=caml_bytes_get16,
     get_uint8=caml_bytes_get,
     unsafe_of_string=caml_bytes_of_string,
     unsafe_to_string=caml_string_of_bytes,
     equal$4=runtime.caml_bytes_equal,
     include$0=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$3,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$4,
       equal$4,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(731,include$0,"Stdlib__bytes");
    function make$0(n,c){return caml_string_of_bytes(make(n,c))}
    function init$1(n,f){return caml_string_of_bytes(init$0(n,f))}
    function copy$0(s)
     {return caml_string_of_bytes(copy(caml_bytes_of_string(s)))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _yP_=param[2],_yQ_=param[1];
            if(_yP_)
             {var
               x=(caml_ml_string_length(_yQ_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=_yP_;
              continue}
            var _yT_=caml_ml_string_length(_yQ_) + acc | 0}
          else
           var _yT_=acc;
          var dst=caml_create_bytes(_yT_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _yR_=param$0[2],_yS_=param$0[1];
              if(_yR_)
               {caml_blit_string(_yS_,0,dst,pos,caml_ml_string_length(_yS_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_yS_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_yS_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_yR_;
                continue}
              caml_blit_string(_yS_,0,dst,pos,caml_ml_string_length(_yS_))}
            return caml_string_of_bytes(dst)}}}
      return cst$3}
    function iter$4(f,s)
     {var _yN_=caml_ml_string_length(s) - 1 | 0,_yM_=0;
      if(! (_yN_ < 0))
       {var i=_yM_;
        for(;;)
         {caml_call1(f,caml_string_unsafe_get(s,i));
          var _yO_=i + 1 | 0;
          if(_yN_ !== i){var i=_yO_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _yK_=caml_ml_string_length(s) - 1 | 0,_yJ_=0;
      if(! (_yK_ < 0))
       {var i=_yJ_;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(s,i));
          var _yL_=i + 1 | 0;
          if(_yK_ !== i){var i=_yL_;continue}
          break}}
      return 0}
    function map$4(f,s)
     {return caml_string_of_bytes(map$3(f,caml_bytes_of_string(s)))}
    function mapi$1(f,s)
     {return caml_string_of_bytes(mapi$0(f,caml_bytes_of_string(s)))}
    function is_space$0(param)
     {var _yI_=param - 9 | 0,switch$0=0;
      if(4 < _yI_ >>> 0)
       {if(23 === _yI_)switch$0 = 1}
      else
       if(2 !== _yI_)switch$0 = 1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if
       (!
        is_space$0(caml_string_unsafe_get(s,0))
        &&
        !
        is_space$0(caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
       return s;
      return caml_string_of_bytes(trim(caml_bytes_of_string(s)))}
    function escaped$1(s)
     {var n=caml_ml_string_length(s),i=0;
      for(;;)
       {if(n <= i)return s;
        var match=caml_string_unsafe_get(s,i),_yH_=match - 32 | 0,switch$0=0;
        if(59 < _yH_ >>> 0)
         {if(33 < (_yH_ - 61 | 0) >>> 0)switch$0 = 1}
        else
         if(2 === _yH_)switch$0 = 1;
        if(switch$0)
         return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec$0(s,l,i,c);var _yF_=1;return _yF_}
       catch(_yG_)
        {_yG_ = caml_wrap_exception(_yG_);
         if(_yG_ === Not_found)return 0;
         throw _yG_}
      return invalid_arg(cst_String_contains_from_Bytes$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i && ! (caml_ml_string_length(s) <= i))
       try
        {rindex_rec$0(s,i,c);var _yD_=1;return _yD_}
       catch(_yE_)
        {_yE_ = caml_wrap_exception(_yE_);
         if(_yE_ === Not_found)return 0;
         throw _yE_}
      return invalid_arg(cst_String_rcontains_from_Byte$0)}
    function uppercase_ascii$1(s)
     {return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s)))}
    function lowercase_ascii$1(s)
     {return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s)))}
    function capitalize_ascii$0(s)
     {return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s)))}
    function uncapitalize_ascii$0(s)
     {return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s)))}
    var compare$5=caml_string_compare;
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _yz_=caml_ml_string_length(s) - 1 | 0;
      if(! (_yz_ < 0))
       {var i=_yz_;
        for(;;)
         {if(caml_string_unsafe_get(s,i) === sep)
           {var _yB_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_yB_];
            j[1] = i}
          var _yC_=i - 1 | 0;
          if(0 !== i){var i=_yC_;continue}
          break}}
      var _yA_=r[1];
      return [0,sub$0(s,0,j[1]),_yA_]}
    function uppercase$1(s)
     {return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s)))}
    function lowercase$1(s)
     {return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s)))}
    function capitalize$0(s)
     {return caml_string_of_bytes(capitalize(caml_bytes_of_string(s)))}
    function uncapitalize$0(s)
     {return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s)))}
    function to_seq$3(s){return to_seq$2(caml_bytes_of_string(s))}
    function to_seqi$0(s){return to_seqi(caml_bytes_of_string(s))}
    function of_seq$1(g){return caml_string_of_bytes(of_seq$0(g))}
    var
     equal$5=caml_string_equal,
     include$1=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$4,
       iteri$1,
       map$4,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$5,
       equal$5,
       split_on_char,
       to_seq$3,
       to_seqi$0,
       of_seq$1];
    caml_register_global(732,include$1,"Stdlib__string");
    function equal$6(param,_yy_){return 1}
    function compare$6(param,_yx_){return 0}
    function to_string$2(param){return cst$5}
    var Stdlib_unit=[0,equal$6,compare$6,to_string$2];
    caml_register_global(733,Stdlib_unit,"Stdlib__unit");
    function to_buffer(buff,ofs,len,v,flags)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_bytes_length(buff) - len | 0) < ofs))
       return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substrin)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       {var len=caml_marshal_data_size(buff,ofs);
        return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                ?invalid_arg(cst_Marshal_from_bytes$0)
                :runtime.caml_input_value_from_bytes(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs)
     {return from_bytes(caml_bytes_of_string(buff),ofs)}
    var
     Stdlib_marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(734,Stdlib_marshal,"Stdlib__marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    var double_field=caml_array_get,set_double_field=caml_array_set;
    function marshal(obj){return runtime.caml_output_value_to_bytes(obj,0)}
    function unmarshal(str,pos)
     {var _yw_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_yw_]}
    var
     first_non_constant_constructor=0,
     last_non_constant_constructor_=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function of_val(x)
     {var switch$0=0;
      if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1)
       {var slot=x[1];switch$0 = 1}
      if(! switch$0)var slot=x;
      var switch$1=0;
      if(is_block(slot) && caml_obj_tag(slot) === 248)
       {var name=slot[1];switch$1 = 1}
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function name(slot){return slot[1]}
    function id(slot){return slot[2]}
    var
     Extension_constructor=[0,of_val,name,id],
     extension_constructor=Extension_constructor[1],
     extension_name=Extension_constructor[2],
     extension_id=Extension_constructor[3],
     max_ephe_length=max_array_length - 2 | 0;
    function create(l)
     {var _yu_=0 <= l?1:0,_yv_=_yu_?l <= max_ephe_length?1:0:_yu_;
      if(1 - _yv_)invalid_arg(cst_Obj_Ephemeron_create);
      return runtime.caml_ephe_create(l)}
    function length$0(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset(e,o,msg)
     {var _yr_=0 <= o?1:0,_ys_=_yr_?o < length$0(e)?1:0:_yr_,_yt_=1 - _ys_;
      return _yt_?invalid_arg(msg):_yt_}
    function get_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key);
      return runtime.caml_ephe_get_key(e,o)}
    function get_key_copy(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key_copy);
      return runtime.caml_ephe_get_key_copy(e,o)}
    function set_key(e,o,x)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_set_key);
      return caml_ephe_set_key(e,o,x)}
    function unset_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_unset_key);
      return caml_ephe_unset_key(e,o)}
    function check_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_check_key);
      return runtime.caml_ephe_check_key(e,o)}
    function blit_key(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$0(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$0(e2) - l | 0) < o2))
       {var
         _yp_=0 !== l?1:0,
         _yq_=_yp_?runtime.caml_ephe_blit_key(e1,o1,e2,o2,l):_yp_;
        return _yq_}
      return invalid_arg(cst_Obj_Ephemeron_blit_key)}
    var
     _q_=runtime.caml_ephe_blit_data,
     _r_=runtime.caml_ephe_check_data,
     _s_=
      [0,
       create,
       length$0,
       get_key,
       get_key_copy,
       set_key,
       unset_key,
       check_key,
       blit_key,
       runtime.caml_ephe_get_data,
       runtime.caml_ephe_get_data_copy,
       runtime.caml_ephe_set_data,
       function(_yo_){return runtime.caml_ephe_unset_data(_yo_)},
       _r_,
       _q_,
       max_ephe_length],
     Stdlib_obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor,
       last_non_constant_constructor_,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _s_];
    caml_register_global(735,Stdlib_obj,"Stdlib__obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_ym_=l - 1 | 0,_yl_=1;
        if(! (_ym_ < 1))
         {var i=_yl_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _yn_=i + 1 | 0;
            if(_ym_ !== i){var i=_yn_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_yj_=sx - 1 | 0,_yi_=0;
      if(! (_yj_ < 0))
       {var x=_yi_;
        for(;;)
         {res[1 + x] = caml_make_vect(sy,init);
          var _yk_=x + 1 | 0;
          if(_yj_ !== x){var x=_yk_;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$0(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       {var _yg_=(ofs + len | 0) - 1 | 0;
        if(! (_yg_ < ofs))
         {var i=ofs;
          for(;;)
           {a[1 + i] = v;
            var _yh_=i + 1 | 0;
            if(_yg_ !== i){var i=_yh_;continue}
            break}}
        return 0}
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((a1.length - 1 - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((a2.length - 1 - len | 0) < ofs2))
       return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$5(f,a)
     {var _ye_=a.length - 1 - 1 | 0,_yd_=0;
      if(! (_ye_ < 0))
       {var i=_yd_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _yf_=i + 1 | 0;
          if(_ye_ !== i){var i=_yf_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_ha);
      var _yb_=a.length - 1 - 1 | 0,_ya_=0;
      if(! (_yb_ < 0))
       {var i=_ya_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _yc_=i + 1 | 0;
          if(_yb_ !== i){var i=_yc_;continue}
          break}}
      return 0}
    function map$5(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_x__=l - 1 | 0,_x9_=1;
      if(! (_x__ < 1))
       {var i=_x9_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _x$_=i + 1 | 0;
          if(_x__ !== i){var i=_x$_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Array_map2_arrays_must_hav);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_x7_=la - 1 | 0,_x6_=1;
      if(! (_x7_ < 1))
       {var i=_x6_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _x8_=i + 1 | 0;
          if(_x7_ !== i){var i=_x8_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _x4_=a.length - 1 - 1 | 0,_x3_=0;
      if(! (_x4_ < 0))
       {var i=_x3_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _x5_=i + 1 | 0;
          if(_x4_ !== i){var i=_x5_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_x1_=l - 1 | 0,_x0_=1;
      if(! (_x1_ < 1))
       {var i=_x0_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _x2_=i + 1 | 0;
          if(_x1_ !== i){var i=_x2_;continue}
          break}}
      return r}
    function to_list$1(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[1 + i],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         a=caml_make_vect(list_length(0,l),hd),
         i=1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i + 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    function fold_left$1(f,x,a)
     {var r=[0,x],_xY_=a.length - 1 - 1 | 0,_xX_=0;
      if(! (_xY_ < 0))
       {var i=_xX_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _xZ_=i + 1 | 0;
          if(_xY_ !== i){var i=_xZ_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_xV_=a.length - 1 - 1 | 0;
      if(! (_xV_ < 0))
       {var i=_xV_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _xW_=i - 1 | 0;
          if(0 !== i){var i=_xW_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Stdlib_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _xO_=i31 + 1 | 0,_xP_=caml_check_bound(a,_xO_)[1 + _xO_];
          if(caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_xP_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _xQ_=i31 + 2 | 0,
           _xR_=caml_check_bound(a,_xQ_)[1 + _xQ_],
           _xS_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_xS_)[1 + _xS_],_xR_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _xT_=i31 + 1 | 0,_xU_=caml_check_bound(a,_xT_)[1 + _xT_];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_xU_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[1 + j],e))
           {var _xN_=caml_check_bound(a,j)[1 + j];
            caml_check_bound(a,i$0)[1 + i$0] = _xN_;
            var i$0=j;
            continue}
          caml_check_bound(a,i$0)[1 + i$0] = e;
          return 0}}
      function trickle(l,i,e)
       {try
         {var _xM_=trickledown(l,i,e);return _xM_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_xL_=caml_check_bound(a,i$1)[1 + i$1];
          caml_check_bound(a,i$0)[1 + i$0] = _xL_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _xK_=bubbledown(l,i);return _xK_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_xC_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_xC_ < 0))
       {var i$2=_xC_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[1 + i$2]);
          var _xJ_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_xJ_;continue}
          break}}
      var _xD_=l - 1 | 0;
      if(! (_xD_ < 2))
       {var i$0=_xD_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[1 + i$0],
           _xH_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[1 + i$0] = _xH_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_t_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[1 + father],e$0))
             caml_check_bound(a,i)[1 + i] = e$0;
            else
             {var _xB_=caml_check_bound(a,father)[1 + father];
              caml_check_bound(a,i)[1 + i] = _xB_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _xI_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_xI_;continue a}
            break}
          break}}
      var _xE_=1 < l?1:0;
      if(_xE_)
       {var e=caml_check_bound(a,1)[2],_xF_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _xF_;
        caml_check_bound(a,0)[1] = e;
        var _xG_=0}
      else
       var _xG_=_xE_;
      return _xG_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[1 + src2ofs],
         s1$1=caml_check_bound(a,src1ofs)[1 + src1ofs],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[1 + d] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[1 + i2$0],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[1 + d] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[1 + i1$0],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _xt_=len - 1 | 0,_xs_=0;
        if(! (_xt_ < 0))
         {var i=_xs_;
          a:
          for(;;)
           {var
             _xu_=srcofs + i | 0,
             e=caml_check_bound(a,_xu_)[1 + _xu_],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _xv_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_xv_)[1 + _xv_],e))
                 {var
                   _xw_=j[1],
                   _xx_=caml_check_bound(dst,_xw_)[1 + _xw_],
                   _xy_=j[1] + 1 | 0;
                  caml_check_bound(dst,_xy_)[1 + _xy_] = _xx_;
                  j[1] += -1;
                  continue}}
              var _xz_=j[1] + 1 | 0;
              caml_check_bound(dst,_xz_)[1 + _xz_] = e;
              var _xA_=i + 1 | 0;
              if(_xt_ !== i){var i=_xA_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$4(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xq_=i + 1 | 0;
          return [0,x,function(_xr_){return aux(_xq_,_xr_)}]}
        return 0}
      var _xo_=0;
      return function(_xp_){return aux(_xo_,_xp_)}}
    function to_seqi$1(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xm_=i + 1 | 0;
          return [0,[0,i,x],function(_xn_){return aux(_xm_,_xn_)}]}
        return 0}
      var _xk_=0;
      return function(_xl_){return aux(_xk_,_xl_)}}
    function of_seq$2(i$2)
     {var _xj_=0,l=fold_left(function(acc,x){return [0,x,acc]},_xj_,i$2);
      if(l)
       {var
         tl=l[2],
         hd=l[1],
         len=list_length(0,l),
         a=caml_make_vect(len,hd),
         i$1=len - 2 | 0,
         i=i$1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i - 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    var
     concat$1=caml_array_concat,
     include$2=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$5,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(736,include$2,"Stdlib__array");
    var zero=0.,one=1.,minus_one=-1.;
    function is_finite(x){return x - x == 0.?1:0}
    function is_infinite(x){return 1. / x == 0.?1:0}
    function is_nan(x){return x != x?1:0}
    var pi=3.14159265358979312;
    function is_integer(x)
     {var _xi_=x == runtime.caml_trunc_float(x)?1:0;
      return _xi_?is_finite(x):_xi_}
    function succ$0(x){return caml_nextafter_float(x,infinity)}
    function pred$0(x){return caml_nextafter_float(x,neg_infinity)}
    function equal$7(x,y){return 0 === caml_float_compare(x,y)?1:0}
    function min$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?x:y}
      return y != y?y:x}
    function max$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?y:x}
      return x != x?x:y}
    function min_max(x,y)
     {if(x == x && y == y)
       {if(! (x < y))
         {var switch$0=0;
          if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
          if(switch$0)return [0,y,x]}
        return [0,x,y]}
      return [0,nan,nan]}
    function min_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?x:y}
      return x != x?y:x}
    function max_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?y:x}
      return y != y?x:y}
    function min_max_num(x,y)
     {if(x != x)return [0,y,y];
      if(y != y)return [0,x,x];
      if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return [0,y,x]}
      return [0,x,y]}
    function hash$0(x){return caml_hash(10,100,0,x)}
    function unsafe_fill(a,ofs,len,v)
     {var _xg_=(ofs + len | 0) - 1 | 0;
      if(! (_xg_ < ofs))
       {var i=ofs;
        for(;;)
         {a[1 + i] = v;
          var _xh_=i + 1 | 0;
          if(_xg_ !== i){var i=_xh_;continue}
          break}}
      return 0}
    function unsafe_blit(src,sofs,dst,dofs,len)
     {var _xe_=len - 1 | 0,_xd_=0;
      if(! (_xe_ < 0))
       {var i=_xd_;
        for(;;)
         {dst[1 + (dofs + i | 0)] = src[1 + (sofs + i | 0)];
          var _xf_=i + 1 | 0;
          if(_xe_ !== i){var i=_xf_;continue}
          break}}
      return 0}
    function check(a,ofs,len,msg)
     {var _w$_=ofs < 0?1:0;
      if(_w$_)
       var _xa_=_w$_;
      else
       {var _xb_=len < 0?1:0;
        if(_xb_)
         var _xa_=_xb_;
        else
         var
          _xc_=(ofs + len | 0) < 0?1:0,
          _xa_=_xc_ || (a.length - 1 < (ofs + len | 0)?1:0)}
      return _xa_?invalid_arg(msg):_xa_}
    function make$1(n,v)
     {var result=caml_floatarray_create(n);
      unsafe_fill(result,0,n,v);
      return result}
    function init$3(l,f)
     {if(0 <= l)
       {var res=caml_floatarray_create(l),_w9_=l - 1 | 0,_w8_=0;
        if(! (_w9_ < 0))
         {var i=_w8_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _w__=i + 1 | 0;
            if(_w9_ !== i){var i=_w__;continue}
            break}}
        return res}
      return invalid_arg(cst_Float_Array_init)}
    function append$1(a1,a2)
     {var
       l1=a1.length - 1,
       l2=a2.length - 1,
       result=caml_floatarray_create(l1 + l2 | 0);
      unsafe_blit(a1,0,result,0,l1);
      unsafe_blit(a2,0,result,l1,l2);
      return result}
    function concat$2(l)
     {var acc=0,param=l;
      for(;;)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           x=hd.length - 1 + acc | 0,
           acc$0=acc <= x?x:invalid_arg(cst_Float_Array_concat),
           acc=acc$0,
           param=tl;
          continue}
        var result=caml_floatarray_create(acc),l$0=l,i=0;
        for(;;)
         {if(l$0)
           {var tl$0=l$0[2],hd$0=l$0[1],hlen=hd$0.length - 1;
            unsafe_blit(hd$0,0,result,i,hlen);
            var i$0=i + hlen | 0,l$0=tl$0,i=i$0;
            continue}
          if(i === acc)return result;
          throw [0,Assert_failure,_u_]}}}
    function sub$2(a,ofs,len)
     {check(a,ofs,len,cst_Float_Array_sub);
      var result=caml_floatarray_create(len);
      unsafe_blit(a,ofs,result,0,len);
      return result}
    function copy$2(a)
     {var l=a.length - 1,result=caml_floatarray_create(l);
      unsafe_blit(a,0,result,0,l);
      return result}
    function fill$1(a,ofs,len,v)
     {check(a,ofs,len,cst_Float_Array_fill);return unsafe_fill(a,ofs,len,v)}
    function blit$2(src,sofs,dst,dofs,len)
     {check(src,sofs,len,cst_Float_array_blit);
      check(dst,dofs,len,cst_Float_array_blit$0);
      return unsafe_blit(src,sofs,dst,dofs,len)}
    function to_list$2(a)
     {return init(a.length - 1,function(_w7_){return a[1 + _w7_]})}
    function of_list$0(l)
     {var result=caml_floatarray_create(length(l)),i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],h=l$0[1];
          result[1 + i] = h;
          var i$0=i + 1 | 0,i=i$0,l$0=t;
          continue}
        return result}}
    function iter$6(f,a)
     {var _w5_=a.length - 1 - 1 | 0,_w4_=0;
      if(! (_w5_ < 0))
       {var i=_w4_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _w6_=i + 1 | 0;
          if(_w5_ !== i){var i=_w6_;continue}
          break}}
      return 0}
    function iter2$1(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Float_Array_iter2_arrays_m);
      var _w2_=a.length - 1 - 1 | 0,_w1_=0;
      if(! (_w2_ < 0))
       {var i=_w1_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _w3_=i + 1 | 0;
          if(_w2_ !== i){var i=_w3_;continue}
          break}}
      return 0}
    function map$6(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_wZ_=l - 1 | 0,_wY_=0;
      if(! (_wZ_ < 0))
       {var i=_wY_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _w0_=i + 1 | 0;
          if(_wZ_ !== i){var i=_w0_;continue}
          break}}
      return r}
    function map2$1(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Float_Array_map2_arrays_mu);
      var r=caml_floatarray_create(la),_wW_=la - 1 | 0,_wV_=0;
      if(! (_wW_ < 0))
       {var i=_wV_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _wX_=i + 1 | 0;
          if(_wW_ !== i){var i=_wX_;continue}
          break}}
      return r}
    function iteri$3(f,a)
     {var _wT_=a.length - 1 - 1 | 0,_wS_=0;
      if(! (_wT_ < 0))
       {var i=_wS_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _wU_=i + 1 | 0;
          if(_wT_ !== i){var i=_wU_;continue}
          break}}
      return 0}
    function mapi$3(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_wQ_=l - 1 | 0,_wP_=0;
      if(! (_wQ_ < 0))
       {var i=_wP_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _wR_=i + 1 | 0;
          if(_wQ_ !== i){var i=_wR_;continue}
          break}}
      return r}
    function fold_left$2(f,x,a)
     {var r=[0,x],_wN_=a.length - 1 - 1 | 0,_wM_=0;
      if(! (_wN_ < 0))
       {var i=_wM_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _wO_=i + 1 | 0;
          if(_wN_ !== i){var i=_wO_;continue}
          break}}
      return r[1]}
    function fold_right$1(f,a,x)
     {var r=[0,x],_wK_=a.length - 1 - 1 | 0;
      if(! (_wK_ < 0))
       {var i=_wK_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _wL_=i - 1 | 0;
          if(0 !== i){var i=_wL_;continue}
          break}}
      return r[1]}
    function exists$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$1(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_float_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem_ieee(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x == a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom$0=[248,cst_Stdlib_Float_Array_Bottom,caml_fresh_oo_id(0)];
    function sort$0(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {if
           (caml_call2
             (cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))
            <
            0)
           x[1] = i31 + 1 | 0;
          if
           (caml_call2
             (cmp,caml_array_get(a,x[1]),caml_array_get(a,i31 + 2 | 0))
            <
            0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if
         ((i31 + 1 | 0)
          <
          l
          &&
          !
          (0
           <=
           caml_call2(cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))))
         return i31 + 1 | 0;
        if(i31 < l)return i31;
        throw [0,Bottom$0,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_array_get(a,j),e))
           {caml_array_set(a,i$0,caml_array_get(a,j));var i$0=j;continue}
          return caml_array_set(a,i$0,e)}}
      function trickle(l,i,e)
       {try
         {var _wJ_=trickledown(l,i,e);return _wJ_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0)
           {var i$0=exn[2];return caml_array_set(a,i$0,e)}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0);
          caml_array_set(a,i$0,caml_array_get(a,i$1));
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _wI_=bubbledown(l,i);return _wI_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_wC_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_wC_ < 0))
       {var i$2=_wC_;
        for(;;)
         {trickle(l,i$2,caml_array_get(a,i$2));
          var _wH_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_wH_;continue}
          break}}
      var _wD_=l - 1 | 0;
      if(! (_wD_ < 2))
       {var i$0=_wD_;
        a:
        for(;;)
         {var e$0=caml_array_get(a,i$0);
          caml_array_set(a,i$0,caml_array_get(a,0));
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_v_];
            if(0 <= caml_call2(cmp,caml_array_get(a,father),e$0))
             caml_array_set(a,i,e$0);
            else
             {caml_array_set(a,i,caml_array_get(a,father));
              if(0 < father){var i=father;continue}
              caml_array_set(a,0,e$0)}
            var _wG_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_wG_;continue a}
            break}
          break}}
      var _wE_=1 < l?1:0;
      if(_wE_)
       {var e=caml_array_get(a,1);
        caml_array_set(a,1,caml_array_get(a,0));
        var _wF_=caml_array_set(a,0,e)}
      else
       var _wF_=_wE_;
      return _wF_}
    function stable_sort(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_array_get(src2,src2ofs),
         s1$1=caml_array_get(a,src1ofs),
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_array_set(dst,d,s2);
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_array_get(src2,i2$0),
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$2(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_array_set(dst,d,s1);
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_array_get(a,i1$0),
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$2(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _wA_=len - 1 | 0,_wz_=0;
        if(! (_wA_ < 0))
         {var i=_wz_;
          a:
          for(;;)
           {var
             e=caml_array_get(a,srcofs + i | 0),
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if
               (dstofs
                <=
                j[1]
                &&
                0
                <
                caml_call2(cmp,caml_array_get(dst,j[1]),e))
               {caml_array_set(dst,j[1] + 1 | 0,caml_array_get(dst,j[1]));
                j[1] += -1;
                continue}
              caml_array_set(dst,j[1] + 1 | 0,e);
              var _wB_=i + 1 | 0;
              if(_wA_ !== i){var i=_wB_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var l1=l / 2 | 0,l2=l - l1 | 0,t=caml_floatarray_create(l2);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$5(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_wx_=i + 1 | 0;
          return [0,x,function(_wy_){return aux(_wx_,_wy_)}]}
        return 0}
      var _wv_=0;
      return function(_ww_){return aux(_wv_,_ww_)}}
    function to_seqi$2(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_wt_=i + 1 | 0;
          return [0,[0,i,x],function(_wu_){return aux(_wt_,_wu_)}]}
        return 0}
      var _wr_=0;
      return function(_ws_){return aux(_wr_,_ws_)}}
    function of_seq$3(i$2)
     {var
       _wq_=0,
       param$0=fold_left(function(acc,x){return [0,x,acc]},_wq_,i$2),
       len=length(param$0),
       a=caml_floatarray_create(len),
       i$1=len - 1 | 0,
       i=i$1,
       param=param$0;
      for(;;)
       {if(param)
         {var tl=param[2],hd=param[1];
          a[1 + i] = hd;
          var i$0=i - 1 | 0,i=i$0,param=tl;
          continue}
        return a}}
    function map_to_array(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_wo_=l - 1 | 0,_wn_=1;
      if(! (_wo_ < 1))
       {var i=_wn_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _wp_=i + 1 | 0;
          if(_wo_ !== i){var i=_wp_;continue}
          break}}
      return r}
    function map_from_array(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_wl_=l - 1 | 0,_wk_=0;
      if(! (_wl_ < 0))
       {var i=_wk_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _wm_=i + 1 | 0;
          if(_wl_ !== i){var i=_wm_;continue}
          break}}
      return r}
    var
     _w_=caml_floatarray_create,
     _x_=caml_array_set,
     _y_=caml_array_get,
     _z_=
      [0,
       function(_wj_){return _wj_.length - 1},
       _y_,
       _x_,
       make$1,
       _w_,
       init$3,
       append$1,
       concat$2,
       sub$2,
       copy$2,
       fill$1,
       blit$2,
       to_list$2,
       of_list$0,
       iter$6,
       iteri$3,
       map$6,
       mapi$3,
       fold_left$2,
       fold_right$1,
       iter2$1,
       map2$1,
       for_all$1,
       exists$1,
       mem$1,
       mem_ieee,
       sort$0,
       stable_sort,
       stable_sort,
       to_seq$5,
       to_seqi$2,
       of_seq$3,
       map_to_array,
       map_from_array],
     _A_=caml_floatarray_create,
     _B_=caml_array_set,
     _C_=caml_array_get,
     Stdlib_float=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       infinity,
       neg_infinity,
       nan,
       pi,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal$7,
       min$1,
       max$1,
       min_max,
       min_num,
       max_num,
       min_max_num,
       hash$0,
       [0,
        function(_wi_){return _wi_.length - 1},
        _C_,
        _B_,
        make$1,
        _A_,
        init$3,
        append$1,
        concat$2,
        sub$2,
        copy$2,
        fill$1,
        blit$2,
        to_list$2,
        of_list$0,
        iter$6,
        iteri$3,
        map$6,
        mapi$3,
        fold_left$2,
        fold_right$1,
        iter2$1,
        map2$1,
        for_all$1,
        exists$1,
        mem$1,
        mem_ieee,
        sort$0,
        stable_sort,
        stable_sort,
        to_seq$5,
        to_seqi$2,
        of_seq$3,
        map_to_array,
        map_from_array],
       _z_];
    caml_register_global(737,Stdlib_float,"Stdlib__float");
    var zero$0=0,one$0=1,minus_one$0=-1;
    function abs$0(x){return 0 <= x?x:- x | 0}
    var max_int$0=2147483647,min_int$0=-2147483648;
    function lognot(x){return x ^ -1}
    function equal$8(_wh_,_wg_){return _wh_ === _wg_?1:0}
    var compare$7=caml_int_compare;
    function to_string$3(x){return caml_string_of_jsbytes("" + x)}
    var
     Stdlib_int=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       equal$8,
       compare$7,
       to_string$3];
    caml_register_global(738,Stdlib_int,"Stdlib__int");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$1(n){return n + 1 | 0}
    function pred$1(n){return n - 1 | 0}
    function abs$1(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$1=-2147483648,max_int$1=2147483647;
    function lognot$0(n){return n ^ -1}
    function unsigned_to_int(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$4(n){return caml_format_int(cst_d,n)}
    function of_string_opt$0(s)
     {try
       {var _we_=[0,caml_int_of_string(s)];return _we_}
      catch(_wf_)
       {_wf_ = caml_wrap_exception(_wf_);
        if(_wf_[1] === Failure)return 0;
        throw _wf_}}
    var compare$8=caml_int_compare;
    function equal$9(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare(n,d)?one$1:zero$1;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare(r,d)?q + 1 | 0:q}
    function unsigned_rem(n,d){return n - caml_mul(unsigned_div(n,d),d) | 0}
    var
     Stdlib_int32=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       unsigned_div,
       unsigned_rem,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       unsigned_to_int,
       of_string_opt$0,
       to_string$4,
       compare$8,
       unsigned_compare,
       equal$9];
    caml_register_global(739,Stdlib_int32,"Stdlib__int32");
    function succ$2(n){return caml_int64_add(n,_D_)}
    function pred$2(n){return caml_int64_sub(n,_E_)}
    function abs$2(n)
     {return caml_greaterequal(n,_F_)?n:runtime.caml_int64_neg(n)}
    function lognot$1(n){return runtime.caml_int64_xor(n,_G_)}
    var max_int$3=caml_int64_of_int32(2147483647);
    function unsigned_to_int$0(n)
     {if
       (!
        (0 < caml_int64_compare(zero$2,n))
        &&
        !
        (0 < caml_int64_compare(n,max_int$3)))
       return [0,runtime.caml_int64_to_int32(n)];
      return 0}
    function to_string$5(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$1(s)
     {try
       {var _wc_=[0,caml_int64_of_string(s)];return _wc_}
      catch(_wd_)
       {_wd_ = caml_wrap_exception(_wd_);
        if(_wd_[1] === Failure)return 0;
        throw _wd_}}
    function compare$9(x,y){return caml_int64_compare(x,y)}
    function equal$10(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    function unsigned_compare$0(n,m)
     {return caml_int64_compare
              (caml_int64_sub(n,min_int$2),caml_int64_sub(m,min_int$2))}
    function unsigned_div$0(n,d)
     {if(caml_lessthan(d,zero$2))
       return 0 <= unsigned_compare$0(n,d)?one$2:zero$2;
      var
       q=
        caml_int64_shift_left
         (runtime.caml_int64_div
           (runtime.caml_int64_shift_right_unsigned(n,1),d),
          1),
       r=caml_int64_sub(n,caml_int64_mul(q,d));
      return 0 <= unsigned_compare$0(r,d)?succ$2(q):q}
    function unsigned_rem$0(n,d)
     {return caml_int64_sub(n,caml_int64_mul(unsigned_div$0(n,d),d))}
    var
     Stdlib_int64=
      [0,
       zero$2,
       one$2,
       minus_one$2,
       unsigned_div$0,
       unsigned_rem$0,
       succ$2,
       pred$2,
       abs$2,
       max_int$2,
       min_int$2,
       lognot$1,
       unsigned_to_int$0,
       of_string_opt$1,
       to_string$5,
       compare$9,
       unsigned_compare$0,
       equal$10];
    caml_register_global(740,Stdlib_int64,"Stdlib__int64");
    var zero$3=0,one$3=1,minus_one$3=-1;
    function succ$3(n){return n + 1 | 0}
    function pred$3(n){return n - 1 | 0}
    function abs$3(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$3=-2147483648,max_int$4=2147483647;
    function lognot$2(n){return n ^ -1}
    function unsigned_to_int$1(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$6(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$2(s)
     {try
       {var _wa_=[0,caml_int_of_string(s)];return _wa_}
      catch(_wb_)
       {_wb_ = caml_wrap_exception(_wb_);
        if(_wb_[1] === Failure)return 0;
        throw _wb_}}
    var compare$10=caml_int_compare;
    function equal$11(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare$1(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div$1(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare$1(n,d)?one$3:zero$3;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare$1(r,d)?q + 1 | 0:q}
    function unsigned_rem$1(n,d)
     {return n - caml_mul(unsigned_div$1(n,d),d) | 0}
    var
     Stdlib_nativeint=
      [0,
       zero$3,
       one$3,
       minus_one$3,
       unsigned_div$1,
       unsigned_rem$1,
       succ$3,
       pred$3,
       abs$3,
       match$1,
       max_int$4,
       min_int$3,
       lognot$2,
       unsigned_to_int$1,
       of_string_opt$2,
       to_string$6,
       compare$10,
       unsigned_compare$1,
       equal$11];
    caml_register_global(741,Stdlib_nativeint,"Stdlib__nativeint");
    function engine(tbl,state,buf)
     {var
       result=runtime.caml_lex_engine(tbl,state,buf),
       _v9_=0 <= result?1:0,
       _v__=_v9_?buf[12] !== dummy_pos?1:0:_v9_;
      if(_v__)
       {buf[11] = buf[12];
        var _v$_=buf[12];
        buf[12] = [0,_v$_[1],_v$_[2],_v$_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var
       result=runtime.caml_new_lex_engine(tbl,state,buf),
       _v6_=0 <= result?1:0,
       _v7_=_v6_?buf[12] !== dummy_pos?1:0:_v6_;
      if(_v7_)
       {buf[11] = buf[12];
        var _v8_=buf[12];
        buf[12] = [0,_v8_[1],_v8_[2],_v8_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(opt,f)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _vS_=with_positions?zero_pos:dummy_pos,
       _vT_=with_positions?zero_pos:dummy_pos,
       aux_buffer=caml_create_bytes(512),
       _vU_=[0],
       _vV_=0,
       _vW_=0,
       _vX_=0,
       _vY_=0,
       _vZ_=0,
       _v0_=0,
       _v1_=0,
       _v2_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_g);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_v4_=t.length - 1 - 1 | 0,_v3_=0;
                  if(! (_v4_ < 0))
                   {var i=_v3_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[1 + i];
                      if(0 <= v)caml_check_bound(t,i)[1 + i] = v - s | 0;
                      var _v5_=i + 1 | 0;
                      if(_v4_ !== i){var i=_v5_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _v2_,
              _v1_,
              _v0_,
              _vZ_,
              _vY_,
              _vX_,
              _vW_,
              _vV_,
              _vU_,
              _vT_,
              _vS_]}
    function from_channel(with_positions,ic)
     {return from_function
              (with_positions,function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(opt,s)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _vH_=with_positions?zero_pos:dummy_pos,
       _vI_=with_positions?zero_pos:dummy_pos,
       _vJ_=[0],
       _vK_=1,
       _vL_=0,
       _vM_=0,
       _vN_=0,
       _vO_=0,
       _vP_=0,
       _vQ_=caml_ml_string_length(s),
       _vR_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _vR_,
              _vQ_,
              _vP_,
              _vO_,
              _vN_,
              _vM_,
              _vL_,
              _vK_,
              _vJ_,
              _vI_,
              _vH_]}
    function with_positions(lexbuf){return lexbuf[12] !== dummy_pos?1:0}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var
       lcp=lexbuf[12],
       _vF_=lcp !== dummy_pos?1:0,
       _vG_=_vF_?(lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]],0):_vF_;
      return _vG_}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var lcp=lb[12];
      if(lcp !== dummy_pos)
       lb[12] = [0,lcp[1],zero_pos[2],zero_pos[3],zero_pos[4]];
      lb[3] = 0;
      return 0}
    var
     Stdlib_lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(742,Stdlib_lexing,"Stdlib__lexing");
    var
     YYexit=[248,cst_Stdlib_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Stdlib_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _vz_=env[13],
                _vA_=
                 caml_call1(caml_check_bound(tables[1],_vz_)[1 + _vz_],env),
                _vB_=4,
                cmd$0=_vB_,
                arg$1=_vA_}
             catch(_vE_)
              {_vE_ = caml_wrap_exception(_vE_);
               if(_vE_ !== Parse_error)throw _vE_;
               var cmd$0=5,arg$1=0,_vC_=_vE_}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _vD_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_vD_)[1 + _vD_] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[1 + tok] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _vy_=env[11] - n | 0;return caml_check_bound(env[2],_vy_)[1 + _vy_]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _vv_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_vv_)[1 + _vv_],
           _vw_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_vw_)[1 + _vw_];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _vx_=env[11];
        return caml_check_bound(env[4],_vx_)[1 + _vx_]}}
    function symbol_end_pos(param)
     {var _vu_=env[11];return caml_check_bound(env[4],_vu_)[1 + _vu_]}
    function rhs_start_pos(n)
     {var _vt_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_vt_)[1 + _vt_]}
    function rhs_end_pos(n)
     {var _vs_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_vs_)[1 + _vs_]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Stdlib_parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_vr_){return runtime.caml_set_parser_trace(_vr_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(743,Stdlib_parsing,"Stdlib__parsing");
    var
     Stdlib_set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _vq_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_vq_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_vl_=height(lr);
               if(_vl_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_vm_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_vm_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_vn_=height(rl);
               if(_vn_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_vo_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_vo_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _vp_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_vp_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vk_=param$0[1];
               if(_vk_){var param$0=_vk_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vj_=param$0[1];
               if(_vj_){var param$0=_vj_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vh_=param$0[3],_vi_=param$0[2];
               if(_vh_){var param$0=_vh_;continue}
               return _vi_}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vf_=param$0[3],_vg_=param$0[2];
               if(_vf_){var param$0=_vf_;continue}
               return [0,_vg_]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _ve_=param[1];
             if(_ve_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_ve_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _vd_=remove_min_elt(match);
               return join(t,min_elt(match),_vd_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _H_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _vc_=0 === c?1:0;
               if(_vc_)return _vc_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _vb_=remove_min_elt(r);return bal(l,min_elt(r),_vb_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _u$_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_u$_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _va_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_va_)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _u7_=split(v1,match),
                _u8_=_u7_[1];
               if(0 === _u7_[2])
                {var r2=_u7_[3],_u9_=inter(r1,r2);
                 return concat(inter(l1,_u8_),_u9_)}
               var r2$0=_u7_[3],_u__=inter(r1,r2$0);
               return join(inter(l1,_u8_),v1,_u__)}
             return 0}
           return 0}
         function split_bis(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return 0;
             if(0 <= c)
              {var match=split_bis(x,r);
               if(match)
                {var rr=match[2],lr=match[1];return [0,join(l,v,lr),rr]}
               return 0}
             var match$0=split_bis(x,l);
             if(match$0)
              {var rl=match$0[2],ll=match$0[1];
               return [0,
                       ll,
                       function(param){return join(caml_call1(rl,0),v,r)}]}
             return 0}
           return [0,0,function(param){return 0}]}
         function disjoint(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0 && s2$0)
              {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
               if(s1$0 === s2$0)return 0;
               var match=split_bis(v1,s2$0);
               if(match)
                {var r2=match[2],l2=match[1],_u6_=disjoint(l1,l2);
                 if(_u6_)
                  {var s2$1=caml_call1(r2,0),s1$0=r1,s2$0=s2$1;continue}
                 return _u6_}
               return 0}
             return 1}}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _u2_=split(v1,match),
                _u3_=_u2_[1];
               if(0 === _u2_[2])
                {var r2=_u2_[3],_u4_=diff(r1,r2);
                 return join(diff(l1,_u3_),v1,_u4_)}
               var r2$0=_u2_[3],_u5_=diff(r1,r2$0);
               return concat(diff(l1,_u3_),_u5_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _uZ_=subset(l1,l2);
                   if(_uZ_){var s1$0=r1,s2$0=r2;continue}
                   return _uZ_}
                 if(0 <= c)
                  {var _u0_=subset([0,0,v1,r1,0],r2);
                   if(_u0_){var s1$0=l1;continue}
                   return _u0_}
                 var _u1_=subset([0,l1,v1,0,0],l2);
                 if(_u1_){var s1$0=r1;continue}
                 return _u1_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uW_=caml_call1(p,v);
               if(_uW_)
                {var _uX_=for_all(p,l);
                 if(_uX_){var param$0=r;continue}
                 var _uY_=_uX_}
               else
                var _uY_=_uW_;
               return _uY_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uT_=caml_call1(p,v);
               if(_uT_)
                var _uU_=_uT_;
               else
                {var _uV_=exists(p,l);
                 if(! _uV_){var param$0=r;continue}
                 var _uU_=_uV_}
               return _uU_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0 && r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _uR_=concat(lf,rf);return [0,join(lt,v,rt),_uR_]}
             var _uS_=join(lf,v,rf);
             return [0,concat(lt,rt),_uS_]}
           return _I_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_uQ_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _uQ_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0 && v === v$0 && r === r$0)return t;
             var switch$0=0;
             if(0 !== l$0)
              {var _uP_=max_elt(l$0);
               if(0 <= caml_call2(Ord[1],_uP_,v$0))switch$0 = 1}
             if(! switch$0)
              {var switch$1=0;
               if(0 !== r$0)
                {var _uO_=min_elt(r$0);
                 if(0 <= caml_call2(Ord[1],v$0,_uO_))switch$1 = 1}
               if(! switch$1)return join(l$0,v$0,r$0)}
             return union(l$0,add(v$0,r$0))}
           return 0}
         function of_list(l)
          {if(l)
            {var _uD_=l[2],_uE_=l[1];
             if(_uD_)
              {var _uF_=_uD_[2],_uG_=_uD_[1];
               if(_uF_)
                {var _uH_=_uF_[2],_uI_=_uF_[1];
                 if(_uH_)
                  {var _uJ_=_uH_[2],_uK_=_uH_[1];
                   if(_uJ_)
                    {if(_uJ_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _uL_=l[2];
                                 if(_uL_)
                                  {var l$4=_uL_[2],x1=_uL_[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _uM_=l[2];
                                 if(_uM_)
                                  {var _uN_=_uM_[2];
                                   if(_uN_)
                                    {var l$5=_uN_[2],x2=_uN_[1],x1$0=_uM_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_J_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_uJ_[1];
                     return add(x4,add(_uK_,add(_uI_,add(_uG_,singleton(_uE_)))))}
                   return add(_uK_,add(_uI_,add(_uG_,singleton(_uE_))))}
                 return add(_uI_,add(_uG_,singleton(_uE_)))}
               return add(_uG_,singleton(_uE_))}
             return singleton(_uE_)}
           return empty}
         function add_seq(i,m)
          {return fold_left(function(s,x){return add(x,s)},m,i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_uB_=cons_enum(t,rest);
             return [0,x,function(_uC_){return seq_of_enum(_uB_,_uC_)}]}
           return 0}
         function to_seq(c)
          {var _uz_=cons_enum(c,0);
           return function(_uA_){return seq_of_enum(_uz_,_uA_)}}
         function to_seq_from(low,s)
          {var s$0=s,c=0;
           for(;;)
            {if(s$0)
              {var r=s$0[3],v=s$0[2],l=s$0[1],n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,r,c],s$0=l,c=c$0;continue}
                 var s$0=r;
                 continue}
               var _ux_=[0,v,r,c]}
             else
              var _ux_=c;
             return function(_uy_){return seq_of_enum(_ux_,_uy_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 disjoint,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list,
                 to_seq_from,
                 to_seq,
                 add_seq,
                 of_seq]}];
    caml_register_global(744,Stdlib_set,"Stdlib__set");
    var
     Stdlib_map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_uw_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_uw_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_ur_=height(lr);
               if(_ur_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _us_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_us_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_ut_=height(rl);
               if(_ut_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _uu_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_uu_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _uv_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_uv_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _uq_=0 === c?1:0;
               if(_uq_)return _uq_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _up_=param$0[1];
               if(_up_){var param$0=_up_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _uo_=param$0[1];
               if(_uo_){var param$0=_uo_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _ul_=param$0[4],_um_=param$0[3],_un_=param$0[2];
               if(_ul_){var param$0=_ul_;continue}
               return [0,_un_,_um_]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _ui_=param$0[4],_uj_=param$0[3],_uk_=param$0[2];
               if(_ui_){var param$0=_ui_;continue}
               return [0,[0,_uk_,_uj_]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _uh_=param[1];
             if(_uh_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_uh_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _tW_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _tW_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _tW_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _ue_=caml_call2(p,v,d);
               if(_ue_)
                {var _uf_=for_all(p,l);
                 if(_uf_){var param$0=r;continue}
                 var _ug_=_uf_}
               else
                var _ug_=_ue_;
               return _ug_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _ub_=caml_call2(p,v,d);
               if(_ub_)
                var _uc_=_ub_;
               else
                {var _ud_=exists(p,l);
                 if(! _ud_){var param$0=r;continue}
                 var _uc_=_ud_}
               return _uc_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _K_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _t9_=merge(f,r1,r2),
                _t__=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_t__,_t9_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _t$_=merge(f,r1$0,r2$0),
              _ua_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_ua_,_t$_)}
           throw [0,Assert_failure,_L_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0 && r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _t7_=concat(lf,rf);return [0,join(lt,v,d,rt),_t7_]}
             var _t8_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_t8_]}
           return _M_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _t4_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_t4_)
                  {var _t5_=caml_call2(cmp,d1,d2);
                   if(_t5_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _t6_=_t5_}
                 else
                  var _t6_=_t4_;
                 return _t6_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_t3_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _t3_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         function add_seq(i,m)
          {return fold_left
                   (function(m,param)
                     {var v=param[2],k=param[1];return add(k,v,m)},
                    m,
                    i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_t1_=cons_enum(t,rest);
             return [0,[0,k,v],function(_t2_){return seq_of_enum(_t1_,_t2_)}]}
           return 0}
         function to_seq(m)
          {var _tZ_=cons_enum(m,0);
           return function(_t0_){return seq_of_enum(_tZ_,_t0_)}}
         function to_seq_from(low,m)
          {var m$0=m,c=0;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
                 var m$0=r;
                 continue}
               var _tX_=[0,v,d,r,c]}
             else
              var _tX_=c;
             return function(_tY_){return seq_of_enum(_tX_,_tY_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 to_seq,
                 to_seq_from,
                 add_seq,
                 of_seq]}];
    caml_register_global(745,Stdlib_map,"Stdlib__map");
    var Empty=[248,cst_Stdlib_Stack_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$3(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _tV_=s[1];
      if(_tV_)
       {var tl=_tV_[2],hd=_tV_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function pop_opt(s)
     {var _tU_=s[1];
      if(_tU_)
       {var tl=_tU_[2],hd=_tU_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return [0,hd]}
      return 0}
    function top(s)
     {var _tT_=s[1];if(_tT_){var hd=_tT_[1];return hd}throw Empty}
    function top_opt(s)
     {var _tS_=s[1];if(_tS_){var hd=_tS_[1];return [0,hd]}return 0}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$7(f,s){return iter$2(f,s[1])}
    function fold$1(f,acc,s){return fold_left$0(f,acc,s[1])}
    function to_seq$6(s){return to_seq$1(s[1])}
    function add_seq(q,i){return iter(function(x){return push(x,q)},i)}
    function of_seq$4(g){var s=create$0(0);add_seq(s,g);return s}
    var
     Stdlib_stack=
      [0,
       Empty,
       create$0,
       push,
       pop,
       pop_opt,
       top,
       top_opt,
       clear,
       copy$3,
       is_empty,
       length$1,
       iter$7,
       fold$1,
       to_seq$6,
       add_seq,
       of_seq$4];
    caml_register_global(746,Stdlib_stack,"Stdlib__stack");
    var Empty$0=[248,cst_Stdlib_Queue_Empty,caml_fresh_oo_id(0)];
    function create$1(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_tR_=q[3];
      return _tR_
              ?(q[1] = q[1] + 1 | 0,_tR_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _tQ_=q[2];if(_tQ_){var content=_tQ_[1];return content}throw Empty$0}
    function peek_opt(q)
     {var _tP_=q[2];if(_tP_){var content=_tP_[1];return [0,content]}return 0}
    function take(q)
     {var _tM_=q[2];
      if(_tM_)
       {var _tN_=_tM_[1],_tO_=_tM_[2];
        return _tO_?(q[1] = q[1] - 1 | 0,q[2] = _tO_,_tN_):(clear$0(q),_tN_)}
      throw Empty$0}
    function take_opt(q)
     {var _tJ_=q[2];
      if(_tJ_)
       {var _tK_=_tJ_[1],_tL_=_tJ_[2];
        return _tL_
                ?(q[1] = q[1] - 1 | 0,q[2] = _tL_,[0,_tK_])
                :(clear$0(q),[0,_tK_])}
      return 0}
    function copy$4(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$8(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$2(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _tH_=0 < q1[1]?1:0;
      if(_tH_)
       {var _tI_=q2[3];
        return _tI_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _tI_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _tH_}
    function to_seq$7(q)
     {function aux(c,param)
       {if(c)
         {var x=c[1],next=c[2];
          return [0,x,function(_tG_){return aux(next,_tG_)}]}
        return 0}
      var _tE_=q[2];
      return function(_tF_){return aux(_tE_,_tF_)}}
    function add_seq$0(q,i){return iter(function(x){return add(x,q)},i)}
    function of_seq$5(g){var q=create$1(0);add_seq$0(q,g);return q}
    var
     Stdlib_queue=
      [0,
       Empty$0,
       create$1,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear$0,
       copy$4,
       is_empty$0,
       length$2,
       iter$8,
       fold$2,
       transfer,
       to_seq$7,
       add_seq$0,
       of_seq$5];
    caml_register_global(747,Stdlib_queue,"Stdlib__queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        caml_obj_make_forward(blk,result);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      caml_obj_make_forward(blk,result);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(748,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250 && t !== 246 && t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Stdlib_lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(749,Stdlib_lazy,"Stdlib__lazy");
    var
     Failure$0=[248,cst_Stdlib_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stdlib_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_N_]}
           case 2:
            var
             f=d$0[1],
             _tA_=caml_obj_tag(f),
             d$1=250 === _tA_?f[1]:246 === _tA_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _tB_=d$0[1],_tC_=_tB_[1];
            if(_tC_)
             {var _tD_=_tC_[1];
              if(_tD_){var a$0=_tD_[1];_tB_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_tB_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _tB_[1] = _O_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _tv_=s[2];
        if(typeof _tv_ === "number")
         return 0;
        else
         switch(_tv_[0])
          {case 0:var a=_tv_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_P_]}
           case 2:
            var
             f=_tv_[1],
             _tw_=caml_obj_tag(f),
             _tx_=250 === _tw_?f[1]:246 === _tw_?force_lazy_block(f):f;
            s[2] = _tx_;
            continue;
           case 3:
            var _ty_=_tv_[1],_tz_=_ty_[1];
            if(_tz_){var a$1=_tz_[1];return a$1}
            var x=caml_call1(_ty_[2],s[1]);
            _ty_[1] = [0,x];
            return x;
           default:
            var b=_tv_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _tt_=s[2];
        if(typeof _tt_ !== "number")
         switch(_tt_[0])
          {case 0:var d=_tt_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _tu_=_tt_[1];
            if(_tu_[1]){s[1] = s[1] + 1 | 0;_tu_[1] = 0;return 0}
            break;
           case 4:
            var b=_tt_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :(s[1] = s[1] + 1 | 0,b[4] = b[4] + 1 | 0,0)
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$1(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$9(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$1(l)
     {var _ts_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_ts_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _tr_=data(s);return [0,[0,0,[1,data(i),_tr_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_tp_)
                  {var _tq_=data(s);return [1,data(caml_call1(f,0)),_tq_]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_tn_)
                  {var _to_=data(s);return [0,caml_call1(f,0),_to_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_tm_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_tl_){return data(caml_call1(f,0))}]]]]}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$7);
          dump_data(f,d);
          return print_string(cst$8);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$9);
          dump_data(f,d2);
          return print_string(cst$10);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$6);
      return print_newline(0)}
    var
     Stdlib_stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$1,
       of_string$0,
       of_bytes,
       of_channel,
       iter$9,
       next,
       empty$1,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(750,Stdlib_stream,"Stdlib__stream");
    function create$2(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$3(b,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((b[2] - len | 0) < ofs))
       return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$3(src,srcoff,dst,dstoff,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        srcoff
        &&
        !
        ((src[2] - len | 0) < srcoff)
        &&
        0
        <=
        dstoff
        &&
        !
        ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
       return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs && ! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var old_pos=b[2],old_len=b[3],new_len=[0,old_len];
      for(;;)
       {if(new_len[1] < (old_pos + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((old_pos + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buf);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        if((b[2] + more | 0) <= b[3])
         {if((old_pos + more | 0) <= b[3])return 0;
          throw [0,Assert_failure,_Q_]}
        throw [0,Assert_failure,_R_]}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_S_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_T_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_U_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_V_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_W_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_X_]}
    function add_substring(b,s,offset,len)
     {var _ti_=offset < 0?1:0;
      if(_ti_)
       var _tj_=_ti_;
      else
       var
        _tk_=len < 0?1:0,
        _tj_=_tk_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_tj_)invalid_arg(cst_Buffer_add_substring_add_s);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,caml_string_of_bytes(s),offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,caml_string_of_bytes(s))}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len)
     {var _tg_=len < 0?1:0,_th_=_tg_ || (max_string_length < len?1:0);
      if(_th_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len | 0))resize(b,len);
      var already_read=0,ofs=b[2],to_read=len,_tf_=b[1];
      for(;;)
       {if(0 !== to_read)
         {var r=input(ic,_tf_,ofs,to_read);
          if(0 !== r)
           {var
             already_read$0=already_read + r | 0,
             ofs$0=ofs + r | 0,
             to_read$0=to_read - r | 0,
             already_read=already_read$0,
             ofs=ofs$0,
             to_read=to_read$0;
            continue}}
        if((b[2] + already_read | 0) <= b[3])
         {b[2] = b[2] + already_read | 0;
          if(already_read < len)throw End_of_file;
          return 0}
        throw [0,Assert_failure,_Y_]}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start),switch$0=0;
            if(40 !== opening && 123 !== opening)
             {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
              for(;;)
               {if(lim$0 <= i$3)
                 var stop=lim$0;
                else
                 {var match=caml_string_get(s,i$3),switch$1=0;
                  if(91 <= match)
                   {if(97 <= match)
                     {if(! (123 <= match))switch$1 = 1}
                    else
                     if(95 === match)switch$1 = 1}
                  else
                   if(58 <= match)
                    {if(65 <= match)switch$1 = 1}
                   else
                    if(48 <= match)switch$1 = 1;
                  if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                  var stop=i$3}
                var match$0=[0,sub$0(s,start,stop - start | 0),stop];
                switch$0 = 1;
                break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _td_=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,_Z_];var _td_=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _td_)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _te_=92 === previous?1:0;
        return _te_?add_char(b,previous):_te_}}
    function truncate(b,len)
     {if(0 <= len && ! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    function to_seq$8(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_tb_=i + 1 | 0;
        return [0,x,function(_tc_){return aux(_tb_,_tc_)}]}
      var _s$_=0;
      return function(_ta_){return aux(_s$_,_ta_)}}
    function to_seqi$3(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_s9_=i + 1 | 0;
        return [0,[0,i,x],function(_s__){return aux(_s9_,_s__)}]}
      var _s7_=0;
      return function(_s8_){return aux(_s7_,_s8_)}}
    function add_seq$1(b,seq)
     {return iter(function(_s6_){return add_char(b,_s6_)},seq)}
    function of_seq$6(i){var b=create$2(32);add_seq$1(b,i);return b}
    function add_int8(b,x)
     {var new_position=b[2] + 1 | 0;
      if(b[3] < new_position)resize(b,1);
      caml_bytes_unsafe_set(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_ne(b,x)
     {var new_position=b[2] + 2 | 0;
      if(b[3] < new_position)resize(b,2);
      caml_bytes_set16(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int32_ne(b,x)
     {var new_position=b[2] + 4 | 0;
      if(b[3] < new_position)resize(b,4);
      caml_bytes_set32(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int64_ne(b,x)
     {var new_position=b[2] + 8 | 0;
      if(b[3] < new_position)resize(b,8);
      caml_bytes_set64(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_le(b,x){return add_int16_ne(b,x)}
    function add_int16_be(b,x)
     {var x$0=caml_bswap16(x);return add_int16_ne(b,x$0)}
    function add_int32_le(b,x){return add_int32_ne(b,x)}
    function add_int32_be(b,x)
     {var x$0=caml_int32_bswap(x);return add_int32_ne(b,x$0)}
    function add_int64_le(b,x){return add_int64_ne(b,x)}
    function add_int64_be(b,x)
     {var x$0=caml_int64_bswap(x);return add_int64_ne(b,x$0)}
    var
     Stdlib_buffer=
      [0,
       create$2,
       contents,
       to_bytes,
       sub$3,
       blit$3,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate,
       to_seq$8,
       to_seqi$3,
       add_seq$1,
       of_seq$6,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
    caml_register_global(751,Stdlib_buffer,"Stdlib__buffer");
    function create_char_set(param){return make(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string$1(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _s5_=i + 1 | 0;
        if(31 !== i){var i=_s5_;continue}
        return caml_string_of_bytes(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_s4_=[0,ndec];else var _s4_=0;
          return [0,[8,___,pad_of_pad_opt(pad_opt$5),_s4_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    function default_float_precision(fconv){return 5 === fconv[2]?12:-6}
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _s2_=len < min_len?1:0;
      if(_s2_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _s3_=0}
      else
       var _s3_=_s2_;
      return _s3_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 12:
        case 15:return 117;
        case 0:
        case 1:
        case 2:
        case 13:return 100;
        default:return 105}}
    function char_of_fconv(opt,fconv)
     {if(opt)var sth=opt[1],cF=sth;else var cF=70;
      switch(fconv[2])
       {case 0:return 102;
        case 1:return 101;
        case 2:return 69;
        case 3:return 103;
        case 4:return 71;
        case 5:return cF;
        case 6:return 104;
        default:return 72}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_string_of_jsbytes("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")
       return 0 === prec?0:buffer_add_string(buf,cst$11);
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:
        case 13:
        case 14:
        case 15:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv[1])
       {case 0:return 0;
        case 1:return buffer_add_char(buf,43);
        default:return buffer_add_char(buf,32)}}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$12;
         case 1:return cst$13;
         case 2:return cst$14;
         case 3:return cst$15;
         case 4:return cst$16;
         case 5:return cst$17;
         default:return cst$18}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return symbol(cst$19,make$0(1,c))}}
    function string_of_formatting_gen(formatting_gen)
     {if(0 === formatting_gen[0])
       {var match=formatting_gen[1],str=match[2];return str}
      var match$0=formatting_gen[1],str$0=match$0[2];
      return str$0}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$20):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _s0_=caml_ml_string_length(str) - 1 | 0,_sZ_=0;
      if(! (_s0_ < 0))
       {var i=_sZ_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _s1_=i + 1 | 0;
          if(_s0_ !== i){var i=_s1_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$21);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$22);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$23);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$25);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(0,fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$26);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           bprint_string_literal(buf,cst$27);
           bprint_string_literal(buf,string_of_formatting_gen(fmting_gen));
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _sP_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_sU_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _sV_=is_in_char_set(_sU_,c);
                 if(_sV_)
                  var
                   _sW_=is_in_char_set(_sU_,before),
                   _sX_=_sW_?is_in_char_set(_sU_,after):_sW_,
                   _sY_=1 - _sX_;
                 else
                  var _sY_=_sV_;
                 return _sY_}
               return is_alone},
            is_alone=is_alone$0(_sP_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_sP_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0,switch$0=0;
               if(48 < switcher >>> 0)
                if(210 <= switcher)print_char(buf,255);else switch$0 = 1;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 switch$0 = 1}
               if(switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_sP_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var
                  match$0=char_of_int(i$1),
                  switcher$1=match$0 - 45 | 0,
                  switch$1=0;
                 if(48 < switcher$1 >>> 0)
                  if(210 <= switcher$1)
                   {print_char(buf,254);print_char(buf,255)}
                  else
                   switch$1 = 1;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_sP_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     switch$1 = 1}
                   else
                    switch$1 = 1}
                 if(switch$1)
                  {if(! is_in_char_set(_sP_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0 && is_in_char_set(_sP_,char_of_int(j$0)))
                      {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _sQ_=108;break;
             case 1:var _sQ_=110;break;
             default:var _sQ_=78}
           buffer_add_char(buf,_sQ_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$1=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$1[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _sS_=int_of_custom_arity(arity),
            _sR_=1;
           if(! (_sS_ < 1))
            {var i$8=_sR_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _sT_=i$8 + 1 | 0;
               if(_sS_ !== i$8){var i$8=_sT_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function trans(ty1,match)
     {var switch$0=0;
      if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:break;
          case 11:switch$0 = 1;break;
          case 12:switch$0 = 2;break;
          case 13:switch$0 = 3;break;
          case 14:switch$0 = 4;break;
          case 8:switch$0 = 5;break;
          case 9:switch$0 = 6;break;
          default:throw [0,Assert_failure,_$_]}
      else
       switch(ty1[0])
        {case 0:
          var switch$1=0,_sw_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_sw_,rest2)];
             case 8:switch$0 = 5;switch$1 = 1;break;
             case 9:switch$0 = 6;switch$1 = 1;break;
             case 10:switch$1 = 1;break;
             case 11:switch$0 = 1;switch$1 = 1;break;
             case 12:switch$0 = 2;switch$1 = 1;break;
             case 13:switch$0 = 3;switch$1 = 1;break;
             case 14:switch$0 = 4;switch$1 = 1;break
             }
          if(! switch$1)switch$0 = 7;
          break;
         case 1:
          var switch$2=0,_sx_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_sx_,rest2$0)];
             case 8:switch$0 = 5;switch$2 = 1;break;
             case 9:switch$0 = 6;switch$2 = 1;break;
             case 10:switch$2 = 1;break;
             case 11:switch$0 = 1;switch$2 = 1;break;
             case 12:switch$0 = 2;switch$2 = 1;break;
             case 13:switch$0 = 3;switch$2 = 1;break;
             case 14:switch$0 = 4;switch$2 = 1;break
             }
          if(! switch$2)switch$0 = 7;
          break;
         case 2:
          var switch$3=0,_sy_=ty1[1];
          if(typeof match === "number")
           switch$3 = 1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_sy_,rest2$1)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$3 = 1}
          if(switch$3)switch$0 = 7;
          break;
         case 3:
          var switch$4=0,_sz_=ty1[1];
          if(typeof match === "number")
           switch$4 = 1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_sz_,rest2$2)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$4 = 1}
          if(switch$4)switch$0 = 7;
          break;
         case 4:
          var switch$5=0,_sA_=ty1[1];
          if(typeof match === "number")
           switch$5 = 1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_sA_,rest2$3)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$5 = 1}
          if(switch$5)switch$0 = 7;
          break;
         case 5:
          var switch$6=0,_sB_=ty1[1];
          if(typeof match === "number")
           switch$6 = 1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_sB_,rest2$4)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$6 = 1}
          if(switch$6)switch$0 = 7;
          break;
         case 6:
          var switch$7=0,_sC_=ty1[1];
          if(typeof match === "number")
           switch$7 = 1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_sC_,rest2$5)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$7 = 1}
          if(switch$7)switch$0 = 7;
          break;
         case 7:
          var switch$8=0,_sD_=ty1[1];
          if(typeof match === "number")
           switch$8 = 1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_sD_,rest2$6)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$8 = 1}
          if(switch$8)switch$0 = 7;
          break;
         case 8:
          var switch$9=0,_sE_=ty1[2],_sF_=ty1[1];
          if(typeof match === "number")
           switch$9 = 1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_sG_=trans(_sE_,rest2$7);
              return [8,trans(_sF_,ty2),_sG_];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$9 = 1}
          if(switch$9)throw [0,Assert_failure,_ai_];
          break;
         case 9:
          var switch$10=0,_sH_=ty1[3],_sI_=ty1[2],_sJ_=ty1[1];
          if(typeof match === "number")
           switch$10 = 1;
          else
           switch(match[0])
            {case 8:switch$0 = 5;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_sI_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_sJ_,ty22,trans(_sH_,rest2$8)];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$10 = 1}
          if(switch$10)throw [0,Assert_failure,_aj_];
          break;
         case 10:
          var _sK_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_sK_,rest2$9)]}
          throw [0,Assert_failure,_ak_];
         case 11:
          var switch$11=0,_sL_=ty1[1];
          if(typeof match === "number")
           switch$11 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:var rest2$10=match[1];return [11,trans(_sL_,rest2$10)];
             default:switch$11 = 1}
          if(switch$11)throw [0,Assert_failure,_al_];
          break;
         case 12:
          var switch$12=0,_sM_=ty1[1];
          if(typeof match === "number")
           switch$12 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:var rest2$11=match[1];return [12,trans(_sM_,rest2$11)];
             default:switch$12 = 1}
          if(switch$12)throw [0,Assert_failure,_am_];
          break;
         case 13:
          var switch$13=0,_sN_=ty1[1];
          if(typeof match === "number")
           switch$13 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:var rest2$12=match[1];return [13,trans(_sN_,rest2$12)];
             default:switch$13 = 1}
          if(switch$13)throw [0,Assert_failure,_an_];
          break;
         default:
          var switch$14=0,_sO_=ty1[1];
          if(typeof match === "number")
           switch$14 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:var rest2$13=match[1];return [14,trans(_sO_,rest2$13)];
             default:switch$14 = 1}
          if(switch$14)throw [0,Assert_failure,_ao_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ac_];
        case 1:throw [0,Assert_failure,_ad_];
        case 2:throw [0,Assert_failure,_ae_];
        case 3:throw [0,Assert_failure,_af_];
        case 4:throw [0,Assert_failure,_ag_];
        case 5:throw [0,Assert_failure,_aa_];
        case 6:throw [0,Assert_failure,_ab_];
        default:throw [0,Assert_failure,_ah_]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _r__=function(param){return 0},
         _r$_=function(param){return 0},
         _sa_=function(param){return 0};
        return [0,function(param){return 0},_sa_,_r$_,_r__]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _sb_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_sb_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _sc_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _sc_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _sd_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _sd_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _se_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _se_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _sf_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _sf_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _sg_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _sg_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _sh_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _sh_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _si_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _si_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _sj_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _sj_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _sk_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _sl_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _sm_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _sm_,
                  _sl_,
                  _sk_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _sn_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _sn_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _so_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _so_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _sp_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _sp_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _sq_=function(param){caml_call1(de$12,0);return 0},
           _sr_=function(param){caml_call1(ed$12,0);return 0},
           _ss_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _ss_,
                  _sr_,
                  _sq_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _st_=function(param){caml_call1(de$13,0);return 0},
           _su_=function(param){caml_call1(ed$13,0);return 0},
           _sv_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _sv_,
                  _su_,
                  _st_]}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?0 === prec?fmtty:[2,fmtty]:fmtty}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _r8_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_r9_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _r9_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_r9_,_r8_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mi,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(0 === prec)
         {var rest=match[2],pad$0=match[1];return [0,pad$0,0,rest]}
        var _r7_=match[2];
        if(typeof _r7_ !== "number" && 2 === _r7_[0])
         {var rest$0=_r7_[1],pad$1=match[1];return [0,pad$1,1,rest$0]}
        throw Type_mismatch}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_ignored_format_substituti(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substituti(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substituti
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substituti
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substituti
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substituti
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substituti
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substituti
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substituti
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substituti
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _r5_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_r5_))
             throw Type_mismatch;
            var _r6_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_r6_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substituti
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substituti
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substituti
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substituti
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substituti
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           _rA_=type_padding(pad,fmtty),
           _rB_=_rA_[2],
           _rC_=_rA_[1];
          if(typeof _rB_ !== "number" && 1 === _rB_[0])
           {var
             fmtty_rest$1=_rB_[1],
             match$1=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$1[2],
             fmt$2=match$1[1];
            return [0,[2,_rC_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           _rD_=type_padding(pad$0,fmtty),
           _rE_=_rD_[2],
           _rF_=_rD_[1];
          if(typeof _rE_ !== "number" && 1 === _rE_[0])
           {var
             fmtty_rest$2=_rE_[1],
             match$2=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$2[2],
             fmt$3=match$2[1];
            return [0,[3,_rF_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           _rG_=type_padprec(pad$1,prec,fmtty),
           _rH_=_rG_[3],
           _rI_=_rG_[2],
           _rJ_=_rG_[1];
          if(typeof _rH_ !== "number" && 2 === _rH_[0])
           {var
             fmtty_rest$3=_rH_[1],
             match$3=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$3[2],
             fmt$4=match$3[1];
            return [0,[4,iconv,_rJ_,_rI_,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$0=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           _rK_=type_padprec(pad$2,prec$0,fmtty),
           _rL_=_rK_[3],
           _rM_=_rK_[2],
           _rN_=_rK_[1];
          if(typeof _rL_ !== "number" && 3 === _rL_[0])
           {var
             fmtty_rest$4=_rL_[1],
             match$4=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$4[2],
             fmt$5=match$4[1];
            return [0,[5,iconv$0,_rN_,_rM_,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$1=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           _rO_=type_padprec(pad$3,prec$1,fmtty),
           _rP_=_rO_[3],
           _rQ_=_rO_[2],
           _rR_=_rO_[1];
          if(typeof _rP_ !== "number" && 4 === _rP_[0])
           {var
             fmtty_rest$5=_rP_[1],
             match$5=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$5[2],
             fmt$6=match$5[1];
            return [0,[6,iconv$1,_rR_,_rQ_,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$2=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           _rS_=type_padprec(pad$4,prec$2,fmtty),
           _rT_=_rS_[3],
           _rU_=_rS_[2],
           _rV_=_rS_[1];
          if(typeof _rT_ !== "number" && 5 === _rT_[0])
           {var
             fmtty_rest$6=_rT_[1],
             match$6=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$6[2],
             fmt$7=match$6[1];
            return [0,[7,iconv$2,_rV_,_rU_,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$3=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           _rW_=type_padprec(pad$5,prec$3,fmtty),
           _rX_=_rW_[3],
           _rY_=_rW_[2],
           _rZ_=_rW_[1];
          if(typeof _rX_ !== "number" && 6 === _rX_[0])
           {var
             fmtty_rest$7=_rX_[1],
             match$7=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$7[2],
             fmt$8=match$7[1];
            return [0,[8,fconv,_rZ_,_rY_,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           _r0_=type_padding(pad$6,fmtty),
           _r1_=_r0_[2],
           _r2_=_r0_[1];
          if(typeof _r1_ !== "number" && 7 === _r1_[0])
           {var
             fmtty_rest$8=_r1_[1],
             match$8=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$8[2],
             fmt$9=match$8[1];
            return [0,[9,_r2_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$9=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$9[2],
           fmt$10=match$9[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$10=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$10[2],
           fmt$11=match$10[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$11=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$11[2],
           fmt$12=match$11[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$12=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$12[2],
             fmt$13=match$12[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _r3_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_r3_))
             throw Type_mismatch;
            var
             match$13=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$13[2],
             fmt$14=match$13[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$14=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$14[2],
             fmt$15=match$14[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$15=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$15[2],
             fmt$16=match$15[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$16=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$16[2],
           fmt$17=match$16[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$20=formatting_gen[1],
             str$0=match$20[2],
             fmt1=match$20[1],
             match$21=type_format_gen(fmt1,fmtty),
             fmtty2=match$21[2],
             fmt2=match$21[1],
             match$22=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$22[2],
             fmt3=match$22[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$23=formatting_gen[1],
           str$1=match$23[2],
           fmt1$0=match$23[1],
           match$24=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$24[2],
           fmt2$0=match$24[1],
           match$25=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$25[2],
           fmt3$0=match$25[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$17=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$17[2],
             fmt$18=match$17[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$18=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$18[2],
             fmt$19=match$18[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$19=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$19[2],
             fmt$20=match$19[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$26=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$26[2],
                 fmt$21=match$26[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _r4_=type_ignored_format_substituti(sub_fmtty$3,rest,fmtty),
               match$27=_r4_[2],
               fmtty$22=match$27[2],
               fmt$22=match$27[1],
               sub_fmtty$4=_r4_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format(fmt,fmtty)
     {var _rz_=type_format_gen(fmt,fmtty);
      if(typeof _rz_[2] === "number"){var fmt$0=_rz_[1];return fmt$0}
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _ry_=2 === padty$0?48:32,res=make(width$0,_ry_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         var switch$0=0;
         if(0 < len)
          {var switch$1=0;
           if
            (43
             !==
             caml_string_get(str,0)
             &&
             45
             !==
             caml_string_get(str,0)
             &&
             32
             !==
             caml_string_get(str,0))
            {switch$0 = 1;switch$1 = 1}
           if(! switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0)}}
         else
          switch$0 = 1;
         if(switch$0)
          {var switch$2=0;
           if(1 < len && 48 === caml_string_get(str,0))
            {var switch$3=0;
             if
              (120
               !==
               caml_string_get(str,1)
               &&
               88
               !==
               caml_string_get(str,1))
              {switch$2 = 1;switch$3 = 1}
             if(! switch$3)
              {caml_bytes_set(res,1,caml_string_get(str,1));
               blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0)}}
           else
            switch$2 = 1;
           if(switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0),
       switch$0=0;
      if(58 <= c)
       {if(71 <= c)
         {if(! (5 < (c - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= c)switch$0 = 1}
      else
       {var switch$1=0;
        if(32 !== c)
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0) && 1 < len)
               {var switch$2=0;
                if
                 (120
                  ===
                  caml_string_get(str,1)
                  ||
                  88
                  ===
                  caml_string_get(str,1))
                 switch$2 = 1;
                if(switch$2)
                 {var res$1=make(prec$0 + 2 | 0,48);
                  caml_bytes_set(res$1,1,caml_string_get(str,1));
                  blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                  return caml_string_of_bytes(res$1)}}
              switch$0 = 1;
              switch$1 = 1;
              break;
             case 0:
             case 2:break;
             case 1:
             case 3:
             case 4:switch$1 = 1;break;
             default:switch$0 = 1;switch$1 = 1}}
         else
          switch$1 = 1;
        if(! switch$1 && len < (prec$0 + 1 | 0))
         {var res$0=make(prec$0 + 1 | 0,48);
          caml_bytes_set(res$0,0,c);
          blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
          return caml_string_of_bytes(res$0)}}
      if(switch$0 && len < prec$0)
       {var res=make(prec$0,48);
        blit$0(str,0,res,prec$0 - len | 0,len);
        return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function transform_int_alt(iconv,s)
     {if(13 <= iconv)
       {var n=[0,0],_rt_=caml_ml_string_length(s) - 1 | 0,_rs_=0;
        if(! (_rt_ < 0))
         {var i$0=_rs_;
          for(;;)
           {var match=caml_string_unsafe_get(s,i$0),switcher$0=match - 48 | 0;
            if(! (9 < switcher$0 >>> 0))n[1]++;
            var _rx_=i$0 + 1 | 0;
            if(_rt_ !== i$0){var i$0=_rx_;continue}
            break}}
        var
         digits=n[1],
         buf=
          caml_create_bytes
           (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
         pos=[0,0],
         put=function(c){caml_bytes_set(buf,pos[1],c);pos[1]++;return 0},
         left=[0,((digits - 1 | 0) % 3 | 0) + 1 | 0],
         _rv_=caml_ml_string_length(s) - 1 | 0,
         _ru_=0;
        if(! (_rv_ < 0))
         {var i=_ru_;
          for(;;)
           {var c=caml_string_unsafe_get(s,i),switcher=c - 48 | 0;
            if(9 < switcher >>> 0)
             put(c);
            else
             {if(0 === left[1]){put(95);left[1] = 3}left[1] += -1;put(c)}
            var _rw_=i + 1 | 0;
            if(_rv_ !== i){var i=_rw_;continue}
            break}}
        return caml_string_of_bytes(buf)}
      return s}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 1:var _rr_=cst_d$3;break;
        case 2:var _rr_=cst_d$4;break;
        case 4:var _rr_=cst_i$1;break;
        case 5:var _rr_=cst_i$2;break;
        case 6:var _rr_=cst_x;break;
        case 7:var _rr_=cst_x$0;break;
        case 8:var _rr_=cst_X$0;break;
        case 9:var _rr_=cst_X$1;break;
        case 10:var _rr_=cst_o;break;
        case 11:var _rr_=cst_o$0;break;
        case 0:
        case 13:var _rr_=cst_d$2;break;
        case 3:
        case 14:var _rr_=cst_i$0;break;
        default:var _rr_=cst_u}
      return transform_int_alt(iconv,caml_format_int(_rr_,n))}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 1:var _rq_=cst_ld$0;break;
        case 2:var _rq_=cst_ld$1;break;
        case 4:var _rq_=cst_li$1;break;
        case 5:var _rq_=cst_li$2;break;
        case 6:var _rq_=cst_lx;break;
        case 7:var _rq_=cst_lx$0;break;
        case 8:var _rq_=cst_lX;break;
        case 9:var _rq_=cst_lX$0;break;
        case 10:var _rq_=cst_lo;break;
        case 11:var _rq_=cst_lo$0;break;
        case 0:
        case 13:var _rq_=cst_ld;break;
        case 3:
        case 14:var _rq_=cst_li$0;break;
        default:var _rq_=cst_lu}
      return transform_int_alt(iconv,caml_format_int(_rq_,n))}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 1:var _rp_=cst_nd$0;break;
        case 2:var _rp_=cst_nd$1;break;
        case 4:var _rp_=cst_ni$1;break;
        case 5:var _rp_=cst_ni$2;break;
        case 6:var _rp_=cst_nx;break;
        case 7:var _rp_=cst_nx$0;break;
        case 8:var _rp_=cst_nX;break;
        case 9:var _rp_=cst_nX$0;break;
        case 10:var _rp_=cst_no;break;
        case 11:var _rp_=cst_no$0;break;
        case 0:
        case 13:var _rp_=cst_nd;break;
        case 3:
        case 14:var _rp_=cst_ni$0;break;
        default:var _rp_=cst_nu}
      return transform_int_alt(iconv,caml_format_int(_rp_,n))}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 1:var _ro_=cst_Ld$0;break;
        case 2:var _ro_=cst_Ld$1;break;
        case 4:var _ro_=cst_Li$1;break;
        case 5:var _ro_=cst_Li$2;break;
        case 6:var _ro_=cst_Lx;break;
        case 7:var _ro_=cst_Lx$0;break;
        case 8:var _ro_=cst_LX;break;
        case 9:var _ro_=cst_LX$0;break;
        case 10:var _ro_=cst_Lo;break;
        case 11:var _ro_=cst_Lo$0;break;
        case 0:
        case 13:var _ro_=cst_Ld;break;
        case 3:
        case 14:var _ro_=cst_Li$0;break;
        default:var _ro_=cst_Lu}
      return transform_int_alt(iconv,caml_int64_format(_ro_,n))}
    function convert_float(fconv,prec$0,x)
     {if(6 <= fconv[2])
       {switch(fconv[1])
         {case 0:var sign=45;break;
          case 1:var sign=43;break;
          default:var sign=32}
        var str=runtime.caml_hexstring_of_float(x,prec$0,sign);
        return 7 <= fconv[2]?uppercase_ascii$1(str):str}
      var
       prec=abs(prec$0),
       symb=char_of_fconv(_ap_,fconv),
       buf=buffer_create(16);
      buffer_add_char(buf,37);
      bprint_fconv_flag(buf,fconv);
      buffer_add_char(buf,46);
      buffer_add_string(buf,caml_string_of_jsbytes("" + prec));
      buffer_add_char(buf,symb);
      var str$0=caml_format_float(buffer_contents(buf),x);
      if(5 === fconv[2])
       {var
         len=caml_ml_string_length(str$0),
         match$0=runtime.caml_classify_float(x);
        if(3 === match$0)return x < 0.?cst_neg_infinity:cst_infinity;
        if(4 <= match$0)return cst_nan;
        var i=0;
        for(;;)
         {if(i === len)
           var _rn_=0;
          else
           {var match=caml_string_get(str$0,i),_rm_=match - 46 | 0,switch$0=0;
            if(23 < _rm_ >>> 0)
             {if(55 === _rm_)switch$0 = 1}
            else
             if(21 < (_rm_ - 1 | 0) >>> 0)switch$0 = 1;
            if(! switch$0){var i$0=i + 1 | 0,i=i$0;continue}
            var _rn_=1}
          return _rn_?str$0:symbol(str$0,cst$28)}}
      return str$0}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_printf$0(counter,k,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding(k$0,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(x)
                        {var
                          str=
                           convert_float(fconv,default_float_precision(fconv),x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _rj_=pad$5[2],_rk_=pad$5[1];
               if(typeof prec$3 === "number")
                return 0 === prec$3
                        ?function(x)
                          {var
                            str=convert_float(fconv,default_float_precision(fconv),x),
                            str$0=fix_padding(_rk_,_rj_,str);
                           return make_printf(k$0,[4,acc$0,str$0],rest$7)}
                        :function(p,x)
                          {var str=fix_padding(_rk_,_rj_,convert_float(fconv,p,x));
                           return make_printf(k$0,[4,acc$0,str],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_rk_,_rj_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,[4,acc$0,str],rest$7)}}
             var _rl_=pad$5[1];
             if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision(fconv),x),
                          str$0=fix_padding(_rl_,w,str);
                         return make_printf(k$0,[4,acc$0,str$0],rest$7)}
                      :function(w,p,x)
                        {var str=fix_padding(_rl_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_rl_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str){return make_printf(k$0,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _rh_=fmt$0[1];
           if(0 === _rh_[0])
            {var
              rest$13=fmt$0[2],
              match=_rh_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(kacc)
                  {return make_printf(k,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_rh_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(kacc){return make_printf(k,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_aq_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _ri_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,acc$0,rest$19,arity,_ri_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,acc$0,rest$19,arity,_ri_])}}
    function make_ignored_param$0(counter,k,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:throw [0,Assert_failure,_ar_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,acc,fmtty,fmt)}
          return caml_trampoline_return(make_from_fmtty$0,[0,k,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}}
    function make_from_fmtty$0(counter,k,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_rg_)
           {return make_from_fmtty(k,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_as_];
         default:throw [0,Assert_failure,_at_]}}
    function make_invalid_arg(counter,k,acc,fmt)
     {var _rf_=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_rf_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,_rf_,fmt])}
    function make_custom$0(counter,k,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,acc,rest,arity$0,caml_call1(f,x))}}
      var _re_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_re_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,_re_,rest])}
    function make_printf(k,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,acc,fmt))}
    function make_ignored_param(k,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,acc,ign,fmt))}
    function make_from_fmtty(k,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,acc,fmtty,fmt))}
    function make_custom(k,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,acc,rest,arity,f))}
    function make_padding(k,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,new_acc,fmt)}}}
    function make_int_padding_precision(k,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return 0 === match
                 ?function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _rb_=pad[2],_rc_=pad[1];
          if(typeof match === "number")
           return 0 === match
                   ?function(x)
                     {var str=fix_padding(_rc_,_rb_,caml_call2(trans,iconv,x));
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(p,x)
                     {var
                       str=
                        fix_padding
                         (_rc_,_rb_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_rc_,_rb_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,[4,acc,str],fmt)}}
        var _rd_=pad[1];
        if(typeof match === "number")
         return 0 === match
                 ?function(w,x)
                   {var str=fix_padding(_rd_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_rd_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_rd_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,[4,acc,str],fmt)}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_qs_=make_iprintf(k$0,o,rest);
           return function(_ra_){return _qs_};
          case 1:
           var rest$0=fmt$0[1],_qt_=make_iprintf(k$0,o,rest$0);
           return function(_q$_){return _qt_};
          case 2:
           var _qu_=fmt$0[1];
           if(typeof _qu_ === "number")
            {var rest$1=fmt$0[2],_qv_=make_iprintf(k$0,o,rest$1);
             return function(_q7_){return _qv_}}
           else
            {if(0 === _qu_[0])
              {var rest$2=fmt$0[2],_qw_=make_iprintf(k$0,o,rest$2);
               return function(_q__){return _qw_}}
             var
              rest$3=fmt$0[2],
              _qx_=make_iprintf(k$0,o,rest$3),
              _qy_=function(_q9_){return _qx_};
             return function(_q8_){return _qy_}}
          case 3:
           var _qz_=fmt$0[1];
           if(typeof _qz_ === "number")
            {var rest$4=fmt$0[2],_qA_=make_iprintf(k$0,o,rest$4);
             return function(_q3_){return _qA_}}
           else
            {if(0 === _qz_[0])
              {var rest$5=fmt$0[2],_qB_=make_iprintf(k$0,o,rest$5);
               return function(_q6_){return _qB_}}
             var
              rest$6=fmt$0[2],
              _qC_=make_iprintf(k$0,o,rest$6),
              _qD_=function(_q5_){return _qC_};
             return function(_q4_){return _qD_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _qE_=fmt$0[1];
           if(typeof _qE_ === "number")
            {var rest$12=fmt$0[2],_qF_=make_iprintf(k$0,o,rest$12);
             return function(_qZ_){return _qF_}}
           else
            {if(0 === _qE_[0])
              {var rest$13=fmt$0[2],_qG_=make_iprintf(k$0,o,rest$13);
               return function(_q2_){return _qG_}}
             var
              rest$14=fmt$0[2],
              _qH_=make_iprintf(k$0,o,rest$14),
              _qI_=function(_q1_){return _qH_};
             return function(_q0_){return _qI_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_qJ_=make_iprintf(k$0,o,rest$15);
           return function(_qY_){return _qJ_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _qK_=make_iprintf(k$0,o,rest$17),
            _qL_=function(_qX_){return _qK_};
           return function(_qW_){return _qL_};
          case 16:
           var rest$18=fmt$0[1],_qM_=make_iprintf(k$0,o,rest$18);
           return function(_qV_){return _qM_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _qN_=fmt$0[1];
           if(0 === _qN_[0])
            {var
              rest$19=fmt$0[2],
              match=_qN_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_qN_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_au_];
          case 20:
           var rest$21=fmt$0[3],_qO_=make_iprintf(k$0,o,rest$21);
           return function(_qU_){return _qO_};
          case 21:
           var rest$22=fmt$0[2],_qP_=make_iprintf(k$0,o,rest$22);
           return function(_qT_){return _qP_};
          case 22:
           var rest$23=fmt$0[1],_qQ_=make_iprintf(k$0,o,rest$23);
           return function(_qS_){return _qQ_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_qR_=0;
           return make_ignored_param
                   (function(param){return caml_call1(k$0,o)},_qR_,ign,rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_qq_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_qr_){return _qq_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {var _pY_=make_iprintf(k,o,fmt);return function(_qe_){return _pY_}}
          var _pZ_=make_iprintf(k,o,fmt),_p0_=function(_qd_){return _pZ_};
          return function(_qc_){return _p0_}}
        var _p1_=make_iprintf(k,o,fmt);
        return function(_qb_){return _p1_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(0 === prec)
             {var _p2_=make_iprintf(k,o,fmt);
              return function(_qp_){return _p2_}}
            var _p3_=make_iprintf(k,o,fmt),_p4_=function(_qo_){return _p3_};
            return function(_qn_){return _p4_}}
          var _p5_=make_iprintf(k,o,fmt);
          return function(_qm_){return _p5_}}
        if(typeof prec === "number")
         {if(0 === prec)
           {var _p6_=make_iprintf(k,o,fmt),_p7_=function(_ql_){return _p6_};
            return function(_qk_){return _p7_}}
          var
           _p8_=make_iprintf(k,o,fmt),
           _p9_=function(_qj_){return _p8_},
           _p__=function(_qi_){return _p9_};
          return function(_qh_){return _p__}}
        var _p$_=make_iprintf(k,o,fmt),_qa_=function(_qg_){return _p$_};
        return function(_qf_){return _qa_}}}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _pW_=acc$0[2],_pX_=acc$0[1];
           if(0 === _pW_[0])
            {var acc$1=_pW_[1];
             output_acc(o,_pX_);
             output_string(o,cst$29);
             var acc$0=acc$1;
             continue}
           var acc$2=_pW_[1];
           output_acc(o,_pX_);
           output_string(o,cst$30);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _pU_=acc$0[2],_pV_=acc$0[1];
           if(0 === _pU_[0])
            {var acc$1=_pU_[1];
             bufput_acc(b,_pV_);
             add_string(b,cst$31);
             var acc$0=acc$1;
             continue}
           var acc$2=_pU_[1];
           bufput_acc(b,_pV_);
           add_string(b,cst$32);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _pS_=acc$0[2],_pT_=acc$0[1];
           if(0 === _pS_[0])
            {var acc$1=_pS_[1];
             strput_acc(b,_pT_);
             add_string(b,cst$33);
             var acc$0=acc$1;
             continue}
           var acc$2=_pS_[1];
           strput_acc(b,_pT_);
           add_string(b,cst$34);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$2(256);
      function k(acc){strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$35))return _av_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_aw_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match && 32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _pQ_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_pQ_}
       catch(_pR_)
        {_pR_ = caml_wrap_exception(_pR_);
         if(_pR_[1] !== Failure)throw _pR_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      var switch$0=0;
      if
       (caml_string_notequal(box_name,cst$36)
        &&
        caml_string_notequal(box_name,cst_b$0))
       var
        box_type=
         caml_string_notequal(box_name,cst_h)
          ?caml_string_notequal(box_name,cst_hov)
            ?caml_string_notequal(box_name,cst_hv)
              ?caml_string_notequal(box_name,cst_v)?invalid_box(0):1
              :2
            :3
          :0;
      else
       switch$0 = 1;
      if(switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=0 === prec?[0,0,fmt]:[0,1,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_ax_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_ay_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_az_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aQ_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aR_]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aW_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {var switch$0=0;
          if(0 === plus$0)
           if(0 === hash$0)
            if(0 === space$0)
             {var switcher=symb - 88 | 0;
              if(! (32 < switcher >>> 0))
               switch(switcher)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6
                 }}
            else
             {if(100 === symb)return 2;if(105 === symb)return 5}
           else
            if(0 === space$0)
             {var switcher$0=symb - 88 | 0;
              if(32 < switcher$0 >>> 0)
               switch$0 = 1;
              else
               switch(switcher$0)
                {case 0:return 9;
                 case 12:return 13;
                 case 17:return 14;
                 case 23:return 11;
                 case 29:return 15;
                 case 32:return 7;
                 default:switch$0 = 1}}
            else
             switch$0 = 1;
          else
           if(0 === hash$0)
            {if(0 === space$0)
              {if(100 === symb)return 1;if(105 === symb)return 4}}
           else
            switch$0 = 1;
          if(switch$0)
           {var switcher$1=symb - 88 | 0;
            if(! (32 < switcher$1 >>> 0))
             switch(switcher$1)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$48)
               }}
          if(0 === plus$0)
           {if(0 === space$0)throw [0,Assert_failure,_aU_];
            if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$45)}
          if(0 === space$0)
           {if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$46)}
          if(legacy_behavior$0){var space$0=0;continue}
          return incompatible_flag(pct_ind,str_ind,32,cst$47)}}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aS_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$2)
           {if(! (58 <= match$2))switch$0 = 1}
          else
           if(45 === match$2)switch$0 = 1;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _pO_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _pO_=0;
          var _pN_=_pO_}
        catch(_pP_)
         {_pP_ = caml_wrap_exception(_pP_);
          if(_pP_ !== Not_found && _pP_[1] !== Failure)throw _pP_;
          var _pN_=0}
        if(_pN_)
         {var
           match=_pN_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aO_,fmt_rest$0]]}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _pG_=str_ind === end_ind?1:0,
           _pH_=_pG_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_pH_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$0)
           {if(! (58 <= match$0))switch$0 = 1}
          else
           if(45 === match$0)switch$0 = 1;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0,
           switch$1=0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _pI_=[0,s,width,0],
             _pJ_=str_ind_3 + 1 | 0,
             next_ind=_pJ_,
             formatting_lit$0=_pI_;
           else
            switch$1 = 1;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _pK_=[0,s$0,width,offset],
               _pL_=str_ind_5 + 1 | 0,
               next_ind=_pL_,
               formatting_lit$0=_pK_}
            else
             switch$1 = 1}
          if(switch$1)throw Not_found}
        catch(_pM_)
         {_pM_ = caml_wrap_exception(_pM_);
          if(_pM_ !== Not_found && _pM_[1] !== Failure)throw _pM_;
          var next_ind=str_ind,formatting_lit$0=formatting_lit}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str];
            if(is_open_tag)
             var formatting$0=[0,sub_format$0];
            else
             {var switch$0=0;
              if
               (typeof sub_fmt
                !==
                "number"
                &&
                11
                ===
                sub_fmt[0]
                &&
                typeof sub_fmt[2]
                ===
                "number")
               {var str$0=sub_fmt[1];
                try
                 {var switch$1=0;open_box_of_string(str$0)}
                catch(_pF_)
                 {_pF_ = caml_wrap_exception(_pF_);
                  if(_pF_[1] !== Failure)throw _pF_;
                  switch$0 = 1;
                  switch$1 = 1}
                if(! switch$1)switch$0 = 1}
              var formatting$0=[1,sub_format$0]}
            var _pD_=[0,[18,formatting$0,fmt_rest$0]];
            return _pD_}
          throw Not_found}
        catch(_pE_)
         {_pE_ = caml_wrap_exception(_pE_);
          if(_pE_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _pE_}}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _pA_=flag[1],_pB_=_pA_?1 - legacy_behavior$0:_pA_;
          if(_pB_)
           {var _pC_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_aA_),str,str_ind,_pC_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _pv_=space[1],
           _pw_=hash[1],
           _px_=plus[1],
           _py_=minus[1],
           _pz_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            0 === _pz_
             ?0 === _py_?1:0
             :0 === _py_
               ?2
               :legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0),
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _py_,
                       _px_,
                       _pw_,
                       _pv_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _py_,
                     _px_,
                     _pw_,
                     _pv_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_py_,_px_,_pw_,_pv_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_py_,_px_,_pw_,_pv_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_py_,_px_,_pw_,_pv_,ign,_aB_)}}}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _pu_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_pu_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aC_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number" && 0 === match)return parse_conv(0);
          if(0 === minus)
           {if(typeof match === "number")return parse_conv(_aD_);
            var n=match[1];
            return parse_conv([0,1,n])}
          if(typeof match === "number")return parse_conv(_aE_);
          var n$0=match[1];
          return parse_conv([0,0,n$0])}
        return parse_conv(pad)}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number" && 0 === match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aF_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aG_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$37);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$38)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        var switch$0=0;
        if(124 <= symb)
         switch$0 = 1;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]];
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _o3_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _o3_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_o3_;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind);break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _o5_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_o5_;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_o$_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _o$_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_o$_;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _pa_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _pa_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_pa_;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _pt_=i + 1 | 0;
                    if(c !== i){var i=_pt_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aP_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _ps_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_ps_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_ps_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0),switch$0=0;
                  if(46 <= c$1)
                   {if(64 === c$1)
                     switch$0 = 1;
                    else
                     if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}}
                  else
                   if(37 === c$1)
                    switch$0 = 1;
                   else
                    if(45 <= c$1)
                     {var str_ind$2=str_ind$0 + 1 | 0;
                      if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                      var c$2=caml_string_get(str,str_ind$2);
                      if(37 === c$2)
                       {if((str_ind$2 + 1 | 0) === end_ind)
                         unexpected_end_of_format(end_ind);
                        var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                        if(37 !== c$3 && 64 !== c$3)
                         return fail_single_percent(str_ind$2);
                        add_range(c$0,c$3);
                        var _pq_=str_ind$2 + 2 | 0;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return parse_char_set_content(counter$2,_pq_,end_ind)}
                        return caml_trampoline_return
                                (parse_char_set_content,[0,_pq_,end_ind])}
                      if(93 === c$2)
                       {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                      add_range(c$0,c$2);
                      var _pr_=str_ind$2 + 1 | 0;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return parse_char_set_content(counter$1,_pr_,end_ind)}
                      return caml_trampoline_return
                              (parse_char_set_content,[0,_pr_,end_ind])}
                  if(switch$0 && 37 === c$0)
                   {add_char(c$1);
                    var _pp_=str_ind$0 + 1 | 0;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return parse_char_set_content(counter$0,_pp_,end_ind)}
                    return caml_trampoline_return
                            (parse_char_set_content,[0,_pp_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,str_ind$1=str_ind$0,reverse=1;
            else
             var str_ind$1=str_ind,reverse=0;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _pf_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _pf_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_pf_;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]];
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _pg_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _ph_=_pg_;
              else
               var
                _ph_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,cst_non_zero_widths_are_unsupp);
              var _pi_=_ph_}
            else
             var _pi_=char_format(fmt_rest$21);
            var fmt_result=_pi_;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _pj_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_pj_;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _pk_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _pk_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_pk_;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]];
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _pl_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _pl_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_pl_;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _o4_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _o4_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_o4_;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]];
            break;
           case 76:
           case 108:
           case 110:
            var switch$1=0;
            if(str_ind !== end_ind)
             {var
               symb$0=caml_string_get(str,str_ind),
               _pm_=symb$0 - 88 | 0,
               switch$2=0;
              if(! (32 < _pm_ >>> 0))
               switch(_pm_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _o__=1;switch$2 = 1;break
                 }
              if(! switch$2)var _o__=0;
              if(_o__){switch$0 = 1;switch$1 = 1}}
            if(! switch$1)
             {var
               match$15=parse(str_ind,end_ind),
               fmt_rest$13=match$15[1],
               switch$3=0;
              if(108 <= symb)
               {if(! (111 <= symb))
                 {var switcher$0=symb - 108 | 0;
                  switch(switcher$0)
                   {case 0:var counter=0;switch$3 = 1;break;
                    case 1:break;
                    default:var counter=1;switch$3 = 1}}}
              else
               if(76 === symb){var counter=2;switch$3 = 1}
              if(! switch$3)throw [0,Assert_failure,_aT_];
              if(get_ign(0))
               var ignored$5=[11,counter],_o9_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _o9_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_o9_}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=
              caml_call3(failwith_message(_aK_),str,pct_ind,symb);
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _pb_=get_space(0),
             _pc_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_pc_,_pb_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _pd_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _pe_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_pe_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _pd_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_pd_;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             plus$2=get_plus(0),
             flag=
              0 === plus$2
               ?0 === space$1?0:2
               :0 === space$1
                 ?1
                 :legacy_behavior$0
                   ?1
                   :incompatible_flag(pct_ind,str_ind,32,cst$49),
             switch$4=0;
            if(73 <= symb)
             {var switcher$1=symb - 101 | 0;
              if(! (3 < switcher$1 >>> 0))
               {switch(switcher$1)
                 {case 0:var _pn_=1;break;
                  case 1:var _pn_=0;break;
                  case 2:var _pn_=3;break;
                  default:var _pn_=6}
                var kind=_pn_;
                switch$4 = 1}}
            else
             if(69 <= symb)
              {var switcher$2=symb - 69 | 0;
               switch(switcher$2)
                {case 0:var _po_=2;break;
                 case 1:var _po_=5;break;
                 case 2:var _po_=4;break;
                 default:var _po_=7}
               var kind=_po_;
               switch$4 = 1}
            if(! switch$4)throw [0,Assert_failure,_aV_];
            var
             fconv=[0,flag,kind],
             match$13=parse(str_ind,end_ind),
             fmt_rest$11=match$13[1];
            if(get_ign(0))
             {var match=get_prec(0);
              if(typeof match === "number")
               var
                _o6_=
                 0 === match?0:incompatible_flag(pct_ind,str_ind,95,cst$39);
              else
               var ndec=match[1],_o6_=[0,ndec];
              var
               ignored$4=[6,get_pad_opt(95),_o6_],
               _o7_=[0,[23,ignored$4,fmt_rest$11]]}
            else
             var
              _o8_=get_prec(0),
              match$14=make_padprec_fmt_ebb(get_pad(0),_o8_,fmt_rest$11),
              fmt_rest$12=match$14[3],
              prec$3=match$14[2],
              pad$5=match$14[1],
              _o7_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
            var fmt_result=_o7_;
            break;
           default:switch$0 = 1}
        if(switch$0)
         {var switch$5=0;
          if(108 <= symb)
           if(111 <= symb)
            switch$5 = 1;
           else
            {var switcher=symb - 108 | 0,switch$6=0;
             switch(switcher)
              {case 0:
                var
                 _oN_=caml_string_get(str,str_ind),
                 _oO_=get_space(0),
                 _oP_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_oP_,_oO_,_oN_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _oQ_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _oS_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_oS_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _oQ_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _oR_=_oQ_;
                break;
               case 1:switch$5 = 1;switch$6 = 1;break;
               default:
                var
                 _oT_=caml_string_get(str,str_ind),
                 _oU_=get_space(0),
                 _oV_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_oV_,_oU_,_oT_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _oW_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _oX_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_oX_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _oW_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _oR_=_oW_}
             if(! switch$6)var fmt_result=_oR_}
          else
           if(76 === symb)
            {var
              _oY_=caml_string_get(str,str_ind),
              _oZ_=get_space(0),
              _o0_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_o0_,_oZ_,_oY_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _o1_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _o2_=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_o2_,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _o1_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_o1_}
           else
            switch$5 = 1;
          if(switch$5)
           var
            fmt_result=
             caml_call3(failwith_message(_aH_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _oE_=1 - plus_used[1],plus$0=_oE_?plus:_oE_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$40);
          var _oF_=1 - hash_used[1],hash$0=_oF_?hash:_oF_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _oG_=1 - space_used[1],space$0=_oG_?space:_oG_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$42);
          var _oH_=1 - pad_used[1],_oI_=_oH_?caml_notequal([0,pad],_aI_):_oH_;
          if(_oI_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _oJ_=1 - prec_used[1],
           _oK_=_oJ_?caml_notequal([0,prec],_aJ_):_oJ_;
          if(_oK_)
           {var _oL_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_oL_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$43)}
        var _oM_=1 - ign_used[1],ign$0=_oM_?ign:_oM_;
        if(ign$0)
         {var switch$7=0;
          if(38 <= symb)
           {if(44 !== symb && 64 !== symb)switch$7 = 1}
          else
           if(33 !== symb && ! (37 <= symb))switch$7 = 1;
          var switch$8=0;
          if(switch$7 || ! legacy_behavior$0)switch$8 = 1;
          if(switch$8)incompatible_flag(pct_ind,str_ind,symb,cst$44)}
        return fmt_result}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _oD_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_oD_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aL_;
            else
             {var c=caml_string_get(str,str_ind$0),switch$0=0;
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  switch$0 = 1;
                 else
                  switch(switcher)
                   {case 0:
                     var match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]]}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]]}}
                else
                 switch$0 = 1;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]];
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aM_,fmt_rest$5]];
                     break;
                    case 5:
                     var switch$1=0;
                     if
                      ((str_ind$0 + 1 | 0)
                       <
                       end_ind
                       &&
                       37
                       ===
                       caml_string_get(str,str_ind$0 + 1 | 0))
                      {var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]];
                       switch$1 = 1}
                     if(! switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]];
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aN_,fmt_rest$8]];
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]];
                     break;
                    case 27:
                     var match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 28:
                     var match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]];
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]];
                     break;
                    default:switch$0 = 1}}
                else
                 switch$0 = 1;
              if(switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _oB_=[0,type_format(fmt,fmtty),str];return _oB_}
      catch(_oC_)
       {_oC_ = caml_wrap_exception(_oC_);
        if(_oC_ === Type_mismatch)
         {var _oA_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aX_),str,_oA_)}
        throw _oC_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _oy_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _oy_}
      catch(_oz_)
       {_oz_ = caml_wrap_exception(_oz_);
        if(_oz_ === Type_mismatch)
         return caml_call2(failwith_message(_aY_),str,str$0);
        throw _oz_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_formatting_gen,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(752,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_ox_=0;
      return make_printf
              (function(acc){output_acc(o,acc);return caml_call1(k,o)},
               _ox_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_ow_=0;
      return make_printf
              (function(acc){bufput_acc(b,acc);return caml_call1(k,b)},
               _ow_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_ov_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_ou_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_ot_){return 0},oc,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(acc)
       {var buf=create$2(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Stdlib_printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ksprintf];
    caml_register_global(753,Stdlib_printf,"Stdlib__printf");
    var
     Bad=[248,cst_Stdlib_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Stdlib_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Stdlib_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$0=t;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _os_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_os_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_or_=symbol(prefix,h);
        return symbol
                (fold_left$0
                  (function(x,y){return symbol(x,symbol(sep,y))},_or_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a1_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _oo_=0,_om_=_oo_}
      catch(_oq_)
       {_oq_ = caml_wrap_exception(_oq_);
        if(_oq_ !== Not_found)throw _oq_;
        var
         _om_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_optio],0]}
      try
       {assoc3(cst_help$1,speclist);var _on_=0,add2=_on_}
      catch(_op_)
       {_op_ = caml_wrap_exception(_op_);
        if(_op_ !== Not_found)throw _op_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_optio$0],
           0]}
      return append(speclist,append(_om_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a2_),errmsg);
      var _oj_=add_help(speclist);
      return iter$2
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _ok_=0 < caml_ml_string_length(doc)?1:0;
                 if(_ok_)
                  {if(11 === spec[0])
                    {var l=spec[1],_ol_=make_symlist(cst$52,cst$51,cst$50,l);
                     return caml_call3(bprintf(buf,_a0_),key,_ol_,doc)}
                   return caml_call2(bprintf(buf,_aZ_),key,doc)}
                 return _ok_},
               _oj_)}
    function usage_string(speclist,errmsg)
     {var b=create$2(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _oi_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a3_),_oi_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _og_=[0,bool_of_string(x)];return _og_}
      catch(_oh_)
       {_oh_ = caml_wrap_exception(_oh_);
        if(_oh_[1] === Invalid_argument)return 0;
        throw _oh_}}
    function int_of_string_opt$0(x)
     {try
       {var _oe_=[0,caml_int_of_string(x)];return _oe_}
      catch(_of_)
       {_of_ = caml_wrap_exception(_of_);
        if(_of_[1] === Failure)return 0;
        throw _of_}}
    function float_of_string_opt(x)
     {try
       {var _oc_=[0,caml_float_of_string(x)];return _oc_}
      catch(_od_)
       {_od_ = caml_wrap_exception(_od_);
        if(_od_[1] === Failure)return 0;
        throw _od_}}
    function parse_and_expand_argv_dynamic_
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$2(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[1 + initpos]
           :cst$53;
        switch(error[0])
         {case 0:
           var _ob_=error[1];
           if
            (caml_string_notequal(_ob_,cst_help$3)
             &&
             caml_string_notequal(_ob_,cst_help$4))
            caml_call2(bprintf(b,_a4_),progname,_ob_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a7_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a8_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a9_),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a5_) && ! caml_equal(error,_a6_))
         return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var
             _n4_=current[1],
             s=caml_check_bound(argv[1],_n4_)[1 + _n4_],
             switch$0=0;
            if(1 <= caml_ml_string_length(s) && 45 === caml_string_get(s,0))
             {try
               {var
                 follow$1=0,
                 _n6_=assoc3(s,speclist[1]),
                 action=_n6_,
                 follow$0=follow$1}
              catch(_n$_)
               {_n$_ = caml_wrap_exception(_n$_);
                if(_n$_ !== Not_found)throw _n$_;
                try
                 {var
                   match=split$0(s),
                   arg=match[2],
                   keyword=match[1],
                   follow=[0,arg],
                   _n5_=assoc3(keyword,speclist[1])}
                catch(_oa_)
                 {_oa_ = caml_wrap_exception(_oa_);
                  if(_oa_ === Not_found)throw [0,Stop,[0,s]];
                  throw _oa_;
                  var _n7_=_oa_}
                var action=_n5_,follow$0=follow,_n8_=_n$_}
              var
               no_arg$0=
                function(s,follow)
                 {function no_arg(param)
                   {if(follow)
                     {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                    return 0}
                  return no_arg},
               no_arg=no_arg$0(s,follow$0),
               get_arg$0=
                function(s,follow)
                 {function get_arg(param)
                   {if(follow){var arg=follow[1];return arg}
                    if((current[1] + 1 | 0) < argv[1].length - 1)
                     {var _n__=current[1] + 1 | 0;
                      return caml_check_bound(argv[1],_n__)[1 + _n__]}
                    throw [0,Stop,[2,s]]}
                  return get_arg},
               get_arg=get_arg$0(s,follow$0),
               consume_arg$0=
                function(follow)
                 {function consume_arg(param)
                   {return follow?0:(current[1]++,0)}
                  return consume_arg},
               consume_arg=consume_arg$0(follow$0),
               treat_action$0=
                function(s,no_arg,get_arg,consume_arg)
                 {function treat_action(param)
                   {switch(param[0])
                     {case 0:var f=param[1];no_arg(0);return caml_call1(f,0);
                      case 1:
                       var
                        f$0=param[1],
                        arg=get_arg(0),
                        match=bool_of_string_opt$0(arg);
                       if(match)
                        {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg,cst_a_boolean]];
                      case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                      case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                      case 4:
                       var f$1=param[1],arg$0=get_arg(0);
                       caml_call1(f$1,arg$0);
                       return consume_arg(0);
                      case 5:
                       var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                      case 6:
                       var
                        f$2=param[1],
                        arg$1=get_arg(0),
                        match$0=int_of_string_opt$0(arg$1);
                       if(match$0)
                        {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                      case 7:
                       var
                        r$2=param[1],
                        arg$2=get_arg(0),
                        match$1=int_of_string_opt$0(arg$2);
                       if(match$1)
                        {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                      case 8:
                       var
                        f$3=param[1],
                        arg$3=get_arg(0),
                        match$2=float_of_string_opt(arg$3);
                       if(match$2)
                        {var x$1=match$2[1];
                         caml_call1(f$3,x$1);
                         return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$3,cst_a_float]];
                      case 9:
                       var
                        r$3=param[1],
                        arg$4=get_arg(0),
                        match$3=float_of_string_opt(arg$4);
                       if(match$3)
                        {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                      case 10:
                       var specs=param[1];
                       no_arg(0);
                       return iter$2(treat_action,specs);
                      case 11:
                       var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                       if(mem(arg$5,symb))
                        {caml_call1(f$4,arg$5);return consume_arg(0)}
                       throw [0,
                              Stop,
                              [1,
                               s,
                               arg$5,
                               symbol(cst_one_of,make_symlist(cst$56,cst$55,cst$54,symb))]];
                      case 12:
                       var f$5=param[1];
                       no_arg(0);
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _n9_=current[1] + 1 | 0;
                           caml_call1(f$5,caml_check_bound(argv[1],_n9_)[1 + _n9_]);
                           consume_arg(0);
                           continue}
                         return 0}
                      default:
                       var f$6=param[1];
                       if(1 - allow_expand)
                        throw [0,Invalid_argument,cst_Arg_Expand_is_is_only_allo];
                       var arg$6=get_arg(0),newarg=caml_call1(f$6,arg$6);
                       consume_arg(0);
                       var
                        before=sub$1(argv[1],0,current[1] + 1 | 0),
                        after=
                         sub$1
                          (argv[1],
                           current[1] + 1 | 0,
                           (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                       argv[1]
                       =
                       caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                       return 0}}
                  return treat_action},
               treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
              treat_action(action);
              switch$0 = 1}
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            if(exn$0[1] === Bad){var m=exn$0[2];throw convert_error([3,m])}
            if(exn$0[1] === Stop){var e=exn$0[2];throw convert_error(e)}
            throw exn$0;
            var exn=exn$0}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _n3_=parse_argv(0,caml_sys_argv(0),l,f,msg);return _n3_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a__),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_a$_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _n2_=parse_argv_dynamic(0,caml_sys_argv(0),l,f,msg);return _n2_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_ba_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bb_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,caml_sys_argv(0)],
         spec=[0,l],
         current$0=[0,current[1]],
         _n1_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _n1_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bc_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bd_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_nZ_)
       {_nZ_ = caml_wrap_exception(_nZ_);
        if(_nZ_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_n0_)
           {_n0_ = caml_wrap_exception(_n0_);
            if(_n0_ === Not_found)return len;
            throw _n0_}
          return loop(n + 1 | 0)}
        throw _nZ_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$4
              (function(c)
                {if(9 === c && ! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left$0(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map$2
              (function(ksd)
                {var _nX_=ksd[2],_nY_=ksd[1];
                 if(caml_string_notequal(ksd[3],cst$57))
                  {if(11 === _nX_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$0(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _nY_,
                             _nX_,
                             symbol(cst$58,symbol(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_nY_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$0(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_nY_,_nX_,symbol(prefix,symbol(spaces,suffix))]}
                   return [0,_nY_,_nX_,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$2(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s),switch$0=0;
          if(0 < len && 13 === caml_string_get(s,len - 1 | 0))
           {var _nW_=sub$0(s,0,len - 1 | 0);switch$0 = 1}
          if(! switch$0)var _nW_=s;
          var word=_nW_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      try
       {for(;;)
         {var c=caml_ml_input_char(ic);
          if(c === sep)stash(0);else add_char(buf,c);
          continue}}
      catch(_nV_)
       {_nV_ = caml_wrap_exception(_nV_);
        if(_nV_ === End_of_file)
         {if(0 < buf[2])stash(0);
          caml_ml_close_channel(ic);
          return of_list(rev(words[1]))}
        throw _nV_}}
    var _be_=10,_bf_=1;
    function read_arg(_nU_){return read_aux(_bf_,_be_,_nU_)}
    var _bg_=0,_bh_=0;
    function read_arg0(_nT_){return read_aux(_bh_,_bg_,_nT_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$5(function(s){return caml_call2(fprintf(oc,_bi_),s,sep)},args);
      return close_out(oc)}
    var _bj_=10;
    function write_arg(_nR_,_nS_){return write_aux(_bj_,_nR_,_nS_)}
    var _bk_=0;
    function write_arg0(_nP_,_nQ_){return write_aux(_bk_,_nP_,_nQ_)}
    var
     Stdlib_arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(754,Stdlib_arg,"Stdlib__arg");
    var printers=[0,0];
    function field(x,i)
     {var f=x[1 + i];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bl_),f)
                :caml_obj_tag(f) === 253?to_string(f):cst$59
              :caml_call1(sprintf(_bm_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$60;
      var _nN_=other_fields(x,i + 1 | 0),_nO_=field(x,i);
      return caml_call2(sprintf(_bn_),_nO_,_nN_)}
    function use_printers(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try
             {var switch$0=0,val=caml_call1(hd,x);switch$0 = 1}
            catch(_nM_){}
            if(switch$0 && val){var s=val[1];return [0,s]}
            var param$0=tl;
            continue}
          return 0}}
      return conv(printers[1])}
    function to_string_default(x)
     {if(x === Out_of_memory)return cst_Out_of_memory;
      if(x === Stack_overflow)return cst_Stack_overflow;
      if(x[1] === Match_failure)
       {var match$0=x[2],char$0=match$0[3],line=match$0[2],file=match$0[1];
        return caml_call5
                (sprintf(locfmt),
                 file,
                 line,
                 char$0,
                 char$0 + 5 | 0,
                 cst_Pattern_matching_failed)}
      if(x[1] === Assert_failure)
       {var
         match$1=x[2],
         char$1=match$1[3],
         line$0=match$1[2],
         file$0=match$1[1];
        return caml_call5
                (sprintf(locfmt),
                 file$0,
                 line$0,
                 char$1,
                 char$1 + 6 | 0,
                 cst_Assertion_failed)}
      if(x[1] === Undefined_recursive_module)
       {var
         match$2=x[2],
         char$2=match$2[3],
         line$1=match$2[2],
         file$1=match$2[1];
        return caml_call5
                (sprintf(locfmt),
                 file$1,
                 line$1,
                 char$2,
                 char$2 + 6 | 0,
                 cst_Undefined_recursive_module)}
      if(0 === caml_obj_tag(x))
       {var constructor=x[1][1],match=x.length - 1;
        if(2 < match >>> 0)
         var
          _nI_=other_fields(x,2),
          _nJ_=field(x,1),
          _nL_=caml_call2(sprintf(_bo_),_nJ_,_nI_);
        else
         switch(match)
          {case 0:var _nL_=cst$61;break;
           case 1:var _nL_=cst$62;break;
           default:var _nK_=field(x,1),_nL_=caml_call1(sprintf(_bp_),_nK_)}
        return symbol(constructor,_nL_)}
      return x[1]}
    function to_string$7(e)
     {var match=use_printers(e);
      if(match){var s=match[1];return s}
      return to_string_default(e)}
    function print(fct,arg)
     {try
       {var _nH_=caml_call1(fct,arg);return _nH_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _nG_=to_string$7(x);
        caml_call1(eprintf(_bq_),_nG_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _nF_=caml_call1(fct,arg);return _nF_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _nE_=to_string$7(x);
        caml_call1(eprintf(_br_),_nE_);
        return exit(2)}}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos?cst_Raised_by_primitive_operat:cst_Called_from}
      if(0 === slot[0])
       {var
         _nx_=slot[5],
         _ny_=slot[4],
         _nz_=slot[3],
         _nA_=slot[6]?cst_inlined:cst$63,
         _nB_=slot[2],
         _nC_=info(slot[1]);
        return [0,caml_call6(sprintf(_bs_),_nC_,_nB_,_nA_,_nz_,_ny_,_nx_)]}
      if(slot[1])return 0;
      var _nD_=info(0);
      return [0,caml_call1(sprintf(_bt_),_nD_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_nv_=a.length - 1 - 1 | 0,_nu_=0;
        if(! (_nv_ < 0))
         {var i=_nu_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bu_),str)}
            var _nw_=i + 1 | 0;
            if(_nv_ !== i){var i=_nw_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bv_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtra(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$2(1024),_ns_=a.length - 1 - 1 | 0,_nr_=0;
        if(! (_ns_ < 0))
         {var i=_nr_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bw_),str)}
            var _nt_=i + 1 | 0;
            if(_ns_ !== i){var i=_nt_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _nq_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[1 + i],
             _np_=0 === param[0]?1:0;
            if(! _np_){var i$0=i - 1 | 0,i=i$0;continue}
            var _nq_=_np_}
          return _nq_?[0,backtrace]:0}}
      return 0}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtra(0))}
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var uncaught_exception_handler=[0,0];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = [0,fn];return 0}
    function _bx_(_no_){return runtime.caml_raw_backtrace_next_slot(_no_)}
    function _by_(_nn_){return runtime.caml_convert_raw_backtrace_slot(_nn_)}
    function _bz_(_nm_,_nl_)
     {return runtime.caml_raw_backtrace_slot(_nm_,_nl_)}
    function _bA_(_nk_){return runtime.caml_raw_backtrace_length(_nk_)}
    var
     _bB_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       format_backtrace_slot];
    function _bC_(_nj_){return runtime.caml_get_current_callstack(_nj_)}
    function _bD_(_ni_){return caml_get_exception_raw_backtra(_ni_)}
    function _bE_(_nh_){return runtime.caml_backtrace_status(_nh_)}
    var
     Stdlib_printexc=
      [0,
       to_string$7,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_ng_){return runtime.caml_record_backtrace(_ng_)},
       _bE_,
       register_printer,
       use_printers,
       _bD_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       _bC_,
       set_uncaught_exception_handler,
       backtrace_slots,
       _bB_,
       _bA_,
       _bz_,
       _by_,
       _bx_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(755,Stdlib_printexc,"Stdlib__printexc");
    function const$0(c,param){return c}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function negate(p,v){return 1 - caml_call1(p,v)}
    var
     Finally_raised=
      [248,cst_Stdlib_Fun_Finally_raised,caml_fresh_oo_id(0)];
    function protect(finally$0,work)
     {function finally_no_exn(param)
       {try
         {var _nf_=caml_call1(finally$0,0);return _nf_}
        catch(e)
         {e = caml_wrap_exception(e);
          var bt=caml_get_exception_raw_backtra(0),exn=[0,Finally_raised,e];
          caml_restore_raw_backtrace(exn,bt);
          throw exn}}
      try
       {var result=caml_call1(work,0)}
      catch(work_exn)
       {work_exn = caml_wrap_exception(work_exn);
        var work_bt=caml_get_exception_raw_backtra(0);
        finally_no_exn(0);
        caml_restore_raw_backtrace(work_exn,work_bt);
        throw work_exn}
      finally_no_exn(0);
      return result}
    var Stdlib_fun=[0,const$0,flip,negate,protect,Finally_raised];
    caml_register_global(756,Stdlib_fun,"Stdlib__fun");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_m0_=st[4];
      caml_call1(fprintf(c,_bF_),_m0_);
      var _m1_=st[5];
      caml_call1(fprintf(c,_bG_),_m1_);
      var _m2_=st[14];
      caml_call1(fprintf(c,_bH_),_m2_);
      fprintf(c,_bI_);
      var
       _m3_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bJ_),_m3_)),
       _m4_=st[1];
      caml_call2(fprintf(c,_bK_),l1,_m4_);
      var _m5_=st[2];
      caml_call2(fprintf(c,_bL_),l1,_m5_);
      var _m6_=st[3];
      caml_call2(fprintf(c,_bM_),l1,_m6_);
      fprintf(c,_bN_);
      var
       _m7_=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bO_),_m7_)),
       _m8_=st[15];
      caml_call2(fprintf(c,_bP_),l2,_m8_);
      var _m9_=st[6];
      caml_call2(fprintf(c,_bQ_),l2,_m9_);
      var _m__=st[8];
      caml_call2(fprintf(c,_bR_),l2,_m__);
      var _m$_=st[10];
      caml_call2(fprintf(c,_bS_),l2,_m$_);
      var _na_=st[12];
      caml_call2(fprintf(c,_bT_),l2,_na_);
      var _nb_=st[13];
      caml_call2(fprintf(c,_bU_),l2,_nb_);
      fprintf(c,_bV_);
      var _nc_=st[9];
      caml_call1(fprintf(c,_bW_),_nc_);
      var _nd_=st[11];
      caml_call1(fprintf(c,_bX_),_nd_);
      var _ne_=st[7];
      return caml_call1(fprintf(c,_bY_),_ne_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _bZ_(_mZ_){return runtime.caml_final_release(_mZ_)}
    function _b0_(_mY_,_mX_)
     {return runtime.caml_final_register_called_without_value(_mY_,_mX_)}
    var
     Stdlib_gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_mW_,_mV_){return runtime.caml_final_register(_mW_,_mV_)},
       _b0_,
       _bZ_,
       create_alarm,
       delete_alarm];
    caml_register_global(757,Stdlib_gc,"Stdlib__gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(caml_string_of_bytes(b))}
    function substring(str,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(str) - len | 0) < ofs))
       return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len)
     {return substring(caml_string_of_bytes(b),ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _mU_=10 <= n?87:48;return n + _mU_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _mT_=i + 1 | 0;
        if(15 !== i){var i=_mT_;continue}
        return caml_string_of_bytes(result)}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_mR_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _mR_ | 0));
        var _mS_=i + 1 | 0;
        if(15 !== i){var i=_mS_;continue}
        return caml_string_of_bytes(result)}}
    var
     Stdlib_digest=
      [0,
       compare$5,
       equal$5,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(758,Stdlib_digest,"Stdlib__digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[1 + i$0] = i$0;
        var _mQ_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_mQ_;continue}
        var accu=[0,cst_x$1],_mM_=54 + max(55,l) | 0,_mL_=0;
        if(! (_mM_ < 0))
         {var i=_mL_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[1 + k];
            accu[1] = string(symbol(accu[1],caml_string_of_jsbytes("" + x)));
            var
             _mN_=accu[1],
             _mH_=caml_string_get(_mN_,3) << 24,
             _mI_=caml_string_get(_mN_,2) << 16,
             _mJ_=caml_string_get(_mN_,1) << 8,
             _mK_=((caml_string_get(_mN_,0) + _mJ_ | 0) + _mI_ | 0) + _mH_ | 0,
             _mO_=(caml_check_bound(s[1],j)[1 + j] ^ _mK_) & 1073741823;
            caml_check_bound(s[1],j)[1 + j] = _mO_;
            var _mP_=i + 1 | 0;
            if(_mM_ !== i){var i=_mP_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$2(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$2(caml_sys_random_seed(0))}
    function copy$5(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _mE_=s[2],
       curval=caml_check_bound(s[1],_mE_)[1 + _mE_],
       _mF_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_mF_)[1 + _mF_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _mG_=s[2];
      caml_check_bound(s[1],_mG_)[1 + _mG_] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound) && 0 < bound)
       for(;;)
        {var r=bits(s),v=caml_mod(r,bound);
         if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
         return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b2_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$2,bound),_b1_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b3_.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$4(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$5(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b4_=
      [0,
       make$2,
       make_self_init,
       copy$5,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Stdlib_random=
      [0,
       init$4,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b4_,
       get_state,
       set_state];
    caml_register_global(759,Stdlib_random,"Stdlib__random");
    function hash$1(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function ongoing_traversal(h)
     {var _mC_=h.length - 1 < 4?1:0,_mD_=_mC_ || (h[4] < 0?1:0);return _mD_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cK_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cK_}
    catch(_mA_)
     {_mA_ = caml_wrap_exception(_mA_);
      if(_mA_ !== Not_found)throw _mA_;
      try
       {var _cJ_=caml_sys_getenv(cst_CAMLRUNPARAM),_b5_=_cJ_}
      catch(_mB_)
       {_mB_ = caml_wrap_exception(_mB_);
        if(_mB_ !== Not_found)throw _mB_;
        var _b5_=cst$64}
      var params=_b5_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_mz_){return caml_call1(_b4_[2],0)}];
    function create$3(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var x=16;
      for(;;)
       {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
         {var x$0=x * 2 | 0,x=x$0;continue}
        if(random)
         var
          _mx_=caml_obj_tag(prng),
          _my_=250 === _mx_?prng[1]:246 === _mx_?force_lazy_block(prng):prng,
          seed=caml_call1(_b4_[4],_my_);
        else
         var seed=0;
        return [0,0,caml_make_vect(x,0),seed,x]}}
    function clear$2(h)
     {h[1] = 0;
      var len=h[2].length - 1,_mv_=len - 1 | 0,_mu_=0;
      if(! (_mv_ < 0))
       {var i=_mu_;
        for(;;)
         {caml_check_bound(h[2],i)[1 + i] = 0;
          var _mw_=i + 1 | 0;
          if(_mv_ !== i){var i=_mw_;continue}
          break}}
      return 0}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1 && len !== abs(h[4]))
       {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_b6_]}
          return prec$0}}
      return 0}
    function copy$6(init)
     {var _mr_=init[4],_ms_=init[3],_mt_=map$5(copy_bucketlist,init[2]);
      return [0,init[1],_mt_,_ms_,_mr_]}
    function length$4(h){return h[1]}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _mi_=nsize < max_array_length?1:0;
      if(_mi_)
       {var
         ndata=caml_make_vect(nsize,0),
         ndata_tail=caml_make_vect(nsize,0),
         inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        var _mk_=osize - 1 | 0,_mj_=0;
        if(! (_mk_ < 0))
         {var i$0=_mj_;
          a:
          for(;;)
           {var cell$1=caml_check_bound(odata,i$0)[1 + i$0],cell=cell$1;
            for(;;)
             {if(cell)
               {var
                 key=cell[1],
                 data=cell[2],
                 next=cell[3],
                 cell$0=inplace?cell:[0,key,data,0],
                 nidx=caml_call2(indexfun,h,key),
                 match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
                if(match)
                 match[3] = cell$0;
                else
                 caml_check_bound(ndata,nidx)[1 + nidx] = cell$0;
                caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$0;
                var cell=next;
                continue}
              var _mq_=i$0 + 1 | 0;
              if(_mk_ !== i$0){var i$0=_mq_;continue a}
              break}
            break}}
        if(inplace)
         {var _mm_=nsize - 1 | 0,_ml_=0;
          if(! (_mm_ < 0))
           {var i=_ml_;
            for(;;)
             {var match$0=caml_check_bound(ndata_tail,i)[1 + i];
              if(match$0)match$0[3] = 0;
              var _mp_=i + 1 | 0;
              if(_mm_ !== i){var i=_mp_;continue}
              break}}
          var _mn_=0}
        else
         var _mn_=inplace;
        var _mo_=_mn_}
      else
       var _mo_=_mi_;
      return _mo_}
    function key_index(h,key)
     {return 3 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :caml_mod
                (runtime.caml_hash_univ_param(10,100,key),h[2].length - 1)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
      caml_check_bound(h[2],i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _mh_=h[2].length - 1 << 1 < h[1]?1:0;
      return _mh_?resize$0(key_index,h):_mh_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[1 + i],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :(caml_check_bound(h[2],i)[1 + i] = next,0)}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _mg_=key_index(h,key),match=caml_check_bound(h[2],_mg_)[1 + _mg_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _mf_=key_index(h,key),match=caml_check_bound(h[2],_mf_)[1 + _mf_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _me_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_me_)[1 + _me_])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[1 + i],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _mb_=0}
        else
         var _mb_=1;
        if(_mb_)
         {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _mc_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_mc_)return resize$0(key_index,h);
          var _md_=_mc_}
        else
         var _md_=_mb_;
        return _md_}}
    function mem$2(h,key)
     {var
       _ma_=key_index(h,key),
       param$0=caml_check_bound(h[2],_ma_)[1 + _ma_],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_l$_=0 === caml_compare(k,key)?1:0;
          if(_l$_)return _l$_;
          var param=next;
          continue}
        return 0}}
    function iter$10(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_l7_=d.length - 1 - 1 | 0,_l6_=0;
        if(! (_l7_ < 0))
         {var i=_l6_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[1 + i]);
            var _l__=i + 1 | 0;
            if(_l7_ !== i){var i=_l__;continue}
            break}}
        var _l8_=1 - old_trav,_l9_=_l8_?flip_ongoing_traversal(h):_l8_;
        return _l9_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[1 + i] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0
                ?(prec$0[3] = 0,0)
                :(caml_check_bound(h[2],i)[1 + i] = 0,0)}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _l3_=d.length - 1 - 1 | 0,_l2_=0;
        if(! (_l3_ < 0))
         {var i=_l2_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[1 + i]);
            var _l5_=i + 1 | 0;
            if(_l3_ !== i){var i=_l5_;continue}
            break}}
        var _l4_=0;
        return _l4_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$3(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_lY_=d.length - 1 - 1 | 0,_lX_=0;
        if(! (_lY_ < 0))
         {var i=_lX_;
          for(;;)
           {var _l0_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[1 + i],_l0_);
            var _l1_=i + 1 | 0;
            if(_lY_ !== i){var i=_l1_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _lZ_=accu[1];
        return _lZ_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _lU_=h[2],
       _lV_=0,
       mbl=
        fold_left$1(function(m,b){return max(m,bucket_length(0,b))},_lV_,_lU_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _lW_=h[2];
      iter$5
       (function(b)
         {var l=bucket_length(0,b);
          histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
          return 0},
        _lW_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq$9(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_lT_){return aux(i$0,next,_lT_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _lQ_=0,_lR_=0;
      return function(_lS_){return aux(_lR_,_lQ_,_lS_)}}
    function to_seq_keys(m)
     {var _lM_=to_seq$9(m);
      function _lN_(_lP_){return _lP_[1]}
      return function(_lO_){return map(_lN_,_lM_,_lO_)}}
    function to_seq_values(m)
     {var _lI_=to_seq$9(m);
      function _lJ_(_lL_){return _lL_[2]}
      return function(_lK_){return map(_lJ_,_lI_,_lK_)}}
    function add_seq$2(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return add$0(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq$7(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _lH_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _lH_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _lG_=h[2].length - 1 << 1 < h[1]?1:0;
        return _lG_?resize$0(key_index,h):_lG_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[1 + i],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :(caml_check_bound(h[2],i)[1 + i] = next,0)}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _lF_=key_index(h,key),match=caml_check_bound(h[2],_lF_)[1 + _lF_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _lE_=key_index(h,key),match=caml_check_bound(h[2],_lE_)[1 + _lE_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _lD_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_lD_)[1 + _lD_])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[1 + i],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _lA_=0}
          else
           var _lA_=1;
          if(_lA_)
           {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _lB_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_lB_)return resize$0(key_index,h);
            var _lC_=_lB_}
          else
           var _lC_=_lA_;
          return _lC_}}
      function mem(h,key)
       {var
         _lz_=key_index(h,key),
         param$0=caml_check_bound(h[2],_lz_)[1 + _lz_],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_ly_=caml_call2(H[1],k,key);
            if(_ly_)return _ly_;
            var param=next;
            continue}
          return 0}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create$3,
              clear$2,
              reset$0,
              copy$6,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$10,
              filter_map_inplace,
              fold$3,
              length$4,
              stats,
              to_seq$9,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function Make(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       _lx_=include[1];
      function create(sz){return caml_call2(_lx_,_b7_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    var
     Stdlib_hashtbl=
      [0,
       create$3,
       clear$2,
       reset$0,
       copy$6,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$2,
       remove,
       replace,
       iter$10,
       filter_map_inplace,
       fold$3,
       length$4,
       randomize,
       is_randomized,
       stats,
       to_seq$9,
       to_seq_keys,
       to_seq_values,
       add_seq$2,
       replace_seq,
       of_seq$7,
       Make,
       MakeSeeded,
       hash$1,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(760,Stdlib_hashtbl,"Stdlib__hashtbl");
    function weak_create(l)
     {var _lv_=0 <= l?1:0,_lw_=_lv_?l <= _s_[15]?1:0:_lv_;
      if(1 - _lw_)invalid_arg(cst_Weak_create);
      return runtime.caml_weak_create(l)}
    function length$5(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset$0(e,o,msg)
     {var _ls_=0 <= o?1:0,_lt_=_ls_?o < length$5(e)?1:0:_ls_,_lu_=1 - _lt_;
      return _lu_?invalid_arg(msg):_lu_}
    function set(e,o,x)
     {raise_if_invalid_offset$0(e,o,cst_Weak_set);
      if(x){var x$0=x[1];return caml_ephe_set_key(e,o,x$0)}
      return caml_ephe_unset_key(e,o)}
    function get$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get);
      return runtime.caml_weak_get(e,o)}
    function get_copy(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get_copy);
      return runtime.caml_weak_get_copy(e,o)}
    function check$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_check);
      return runtime.caml_weak_check(e,o)}
    function blit$4(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$5(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$5(e2) - l | 0) < o2))
       {var
         _lq_=0 !== l?1:0,
         _lr_=_lq_?runtime.caml_weak_blit(e1,o1,e2,o2,l):_lq_;
        return _lr_}
      return invalid_arg(cst_Weak_blit)}
    function fill$2(ar,ofs,len,x)
     {if(0 <= ofs && 0 <= len && ! ((length$5(ar) - len | 0) < ofs))
       {var _lo_=(ofs + len | 0) - 1 | 0;
        if(! (_lo_ < ofs))
         {var i=ofs;
          for(;;)
           {set(ar,i,x);
            var _lp_=i + 1 | 0;
            if(_lo_ !== i){var i=_lp_;continue}
            break}}
        return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$0(H)
     {var emptybucket=weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _lm_=t[1].length - 1 - 1 | 0,_ll_=0;
        if(! (_lm_ < 0))
         {var i=_ll_;
          for(;;)
           {caml_check_bound(t[1],i)[1 + i] = emptybucket;
            caml_check_bound(t[2],i)[1 + i] = [0];
            var _ln_=i + 1 | 0;
            if(_lm_ !== i){var i=_ln_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _lk_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=get$0(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _lk_,
                 init)}
      function iter(f,t)
       {var _lj_=t[1],i=0;
        return iter$5
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=get$0(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _lj_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _li_=check$0(b,i$0)?1:0,
           accu$1=accu$0 + _li_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _ld_=0,_le_=t[1],_lf_=0;
        return fold_right$0
                (function(_lg_,_lh_){return count_bucket(_lf_,_lg_,_lh_)},
                 _le_,
                 _ld_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)failwith(cst_Weak_Make_hash_bucket_cann);
            var
             newbucket$0=weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            blit$4(bucket$0,0,newbucket$0,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket$0,sz,d);
            caml_check_bound(newhashes,sz)[1 + sz] = h;
            caml_check_bound(t[1],index)[1 + index] = newbucket$0;
            caml_check_bound(t[2],index)[1 + index] = newhashes;
            var _k$_=sz <= t[3]?1:0,_la_=_k$_?t[3] < newsz?1:0:_k$_;
            if(_la_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _k1_=t[5],
                 bucket=caml_check_bound(t[1],_k1_)[1 + _k1_],
                 _k2_=t[5],
                 hbucket=caml_check_bound(t[2],_k2_)[1 + _k2_],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(check$0(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(check$0(bucket,j))
                       {blit$4(bucket,j,bucket,i$0,1);
                        var _k3_=caml_check_bound(hbucket,j)[1 + j];
                        caml_check_bound(hbucket,i$0)[1 + i$0] = _k3_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _k4_=t[5];
                      caml_check_bound(t[1],_k4_)[1 + _k4_] = emptybucket;
                      var _k5_=t[5];
                      caml_check_bound(t[2],_k5_)[1 + _k5_] = [0]}
                    else
                     {var newbucket=weak_create(prev_len);
                      blit$4(bucket,0,newbucket,0,prev_len);
                      var _k8_=t[5];
                      caml_check_bound(t[1],_k8_)[1 + _k8_] = newbucket;
                      var _k9_=sub$1(hbucket,0,prev_len),_k__=t[5];
                      caml_check_bound(t[2],_k__)[1 + _k__] = _k9_}
                    var _k6_=t[3] < n?1:0,_k7_=_k6_?prev_len <= t[3]?1:0:_k6_;
                    if(_k7_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _lc_=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_lc_;continue}
                break}}
            var _lb_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_lb_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_k0_=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=check$0(ob,i$0);
                      if(0 === match){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      var
                       oh=caml_check_bound(t[2],j)[1 + j],
                       setter$0=
                        function(i)
                         {function setter(nb,ni,param){return blit$4(ob,i,nb,ni,1)}
                          return setter},
                       setter=setter$0(i$0),
                       h=caml_check_bound(oh,i$0)[1 + i$0];
                      add_aux(newt,setter,0,h,get_index(newt,h));
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _k0_);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _lb_}
          if(check$0(bucket$0,i$3)){var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          caml_check_bound(hashes,i$3)[1 + i$3] = h;
          return 0}}
      function add(t,d)
       {var h=caml_call1(H[2],d);return add_aux(t,set,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$0(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,d,function(h,index){add_aux(t,set,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=get$0(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _kZ_=0;
        return find_shadow(t,d,function(w,i){return set(w,i,0)},_kZ_)}
      function mem(t,d)
       {var _kY_=0;return find_shadow(t,d,function(w,i){return 1},_kY_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$0(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$5(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _kQ_=0,
         totlen=
          fold_left$1(function(_kX_,_kW_){return _kX_ + _kW_ | 0},_kQ_,lens),
         _kR_=len - 1 | 0,
         _kT_=len / 2 | 0,
         _kS_=caml_check_bound(lens,_kR_)[1 + _kR_],
         _kU_=caml_check_bound(lens,_kT_)[1 + _kT_],
         _kV_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_kV_,_kU_,_kS_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Stdlib_weak=
      [0,weak_create,length$5,set,get$0,get_copy,check$0,fill$2,blit$4,Make$0];
    caml_register_global(761,Stdlib_weak,"Stdlib__weak");
    function id$0(x){return x}
    var
     String_tag=[248,cst_Stdlib_Format_String_tag,caml_fresh_oo_id(0)],
     size=0,
     unknown=-1;
    function pp_enqueue(state,token)
     {state[13] = state[13] + token[3] | 0;return add(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function format_pp_text(state,size,text)
     {state[9] = state[9] - size | 0;
      pp_output_string(state,text);
      state[11] = 0;
      return 0}
    function format_string(state,s)
     {var _kP_=caml_string_notequal(s,cst$65);
      return _kP_?format_pp_text(state,caml_ml_string_length(s),s):_kP_}
    function break_new_line(state,param,width)
     {var after=param[3],offset=param[2],before=param[1];
      format_string(state,before);
      pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      caml_call1(state[21],state[10]);
      return format_string(state,after)}
    function break_line(state,width){return break_new_line(state,_b8_,width)}
    function break_same_line(state,param)
     {var after=param[3],width=param[2],before=param[1];
      format_string(state,before);
      state[9] = state[9] - width | 0;
      caml_call1(state[20],width);
      return format_string(state,after)}
    function advance_left(state)
     {for(;;)
       {var match$12=peek_opt(state[28]);
        if(match$12)
         {var
           match$13=match$12[1],
           size$0=match$13[1],
           length$0=match$13[3],
           token=match$13[2],
           pending_count=state[13] - state[12] | 0,
           _kN_=0 <= size$0?1:0,
           _kO_=_kN_ || (state[9] <= pending_count?1:0);
          if(_kO_)
           {take(state[28]);
            var size$1=0 <= size$0?size$0:pp_infinity;
            if(typeof token === "number")
             switch(token)
              {case 0:
                var match$3=top_opt(state[3]);
                if(match$3)
                 {var
                   match$4=match$3[1],
                   tabs=match$4[1],
                   add_tab=
                    function(n,ls)
                     {if(ls)
                       {var l=ls[2],x=ls[1];
                        return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                      return [0,n,0]};
                  tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1])}
                break;
               case 1:pop_opt(state[2]);break;
               case 2:pop_opt(state[3]);break;
               case 3:
                var match$5=top_opt(state[2]);
                if(match$5)
                 {var match$6=match$5[1],width$0=match$6[2];
                  break_line(state,width$0)}
                else
                 pp_output_newline(state);
                break;
               case 4:
                if(state[10] !== (state[6] - state[9] | 0))
                 {var match$1=take_opt(state[28]);
                  if(match$1)
                   {var match$2=match$1[1],size=match$2[1],length=match$2[3];
                    state[12] = state[12] - length | 0;
                    state[9] = state[9] + size | 0}}
                break;
               default:
                var match$7=pop_opt(state[5]);
                if(match$7)
                 {var
                   tag_name=match$7[1],
                   marker=caml_call1(state[25],tag_name);
                  pp_output_string(state,marker)}}
            else
             switch(token[0])
              {case 0:var s=token[1];format_pp_text(state,size$1,s);break;
               case 1:
                var
                 breaks=token[2],
                 fits=token[1],
                 off=breaks[2],
                 before=breaks[1],
                 match$8=top_opt(state[2]);
                if(match$8)
                 {var
                   match$9=match$8[1],
                   width$1=match$9[2],
                   box_type$0=match$9[1];
                  switch(box_type$0)
                   {case 0:break_same_line(state,fits);break;
                    case 1:break_new_line(state,breaks,width$1);break;
                    case 2:break_new_line(state,breaks,width$1);break;
                    case 3:
                     if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                      break_new_line(state,breaks,width$1);
                     else
                      break_same_line(state,fits);
                     break;
                    case 4:
                     if(state[11])
                      break_same_line(state,fits);
                     else
                      if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                       break_new_line(state,breaks,width$1);
                      else
                       if(((state[6] - width$1 | 0) + off | 0) < state[10])
                        break_new_line(state,breaks,width$1);
                       else
                        break_same_line(state,fits);
                     break;
                    default:break_same_line(state,fits)}}
                break;
               case 2:
                var
                 off$0=token[2],
                 n=token[1],
                 insertion_point=state[6] - state[9] | 0,
                 match$10=top_opt(state[3]);
                if(match$10)
                 {var match$11=match$10[1],tabs$0=match$11[1],_kL_=tabs$0[1];
                  if(_kL_)
                   {var first=_kL_[1],param=tabs$0[1];
                    for(;;)
                     {if(param)
                       {var tail=param[2],head=param[1];
                        if(! (insertion_point <= head)){var param=tail;continue}
                        var _kM_=head}
                      else
                       var _kM_=first;
                      var tab=_kM_;
                      break}}
                  else
                   var tab=insertion_point;
                  var offset=tab - insertion_point | 0;
                  if(0 <= offset)
                   break_same_line(state,[0,cst$67,offset + n | 0,cst$66]);
                  else
                   break_new_line
                    (state,[0,cst$69,tab + off$0 | 0,cst$68],state[6])}
                break;
               case 3:
                var
                 ty=token[2],
                 off$1=token[1],
                 insertion_point$0=state[6] - state[9] | 0;
                if(state[8] < insertion_point$0)
                 {var match=top_opt(state[2]);
                  if(match)
                   {var match$0=match[1],width=match$0[2],box_type=match$0[1];
                    if(state[9] < width)
                     {var switcher=box_type - 1 | 0;
                      if(! (3 < switcher >>> 0))break_line(state,width)}}
                  else
                   pp_output_newline(state)}
                var
                 width$2=state[9] - off$1 | 0,
                 box_type$1=1 === ty?1:state[9] < size$1?ty:5;
                push([0,box_type$1,width$2],state[2]);
                break;
               case 4:var tbox=token[1];push(tbox,state[3]);break;
               default:
                var
                 tag_name$0=token[1],
                 marker$0=caml_call1(state[24],tag_name$0);
                pp_output_string(state,marker$0);
                push(tag_name$0,state[5])}
            state[12] = length$0 + state[12] | 0;
            continue}
          return _kO_}
        return 0}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    function initialize_scan_stack(stack)
     {clear(stack);
      var queue_elem=[0,unknown,_b9_,0];
      return push([0,-1,queue_elem],stack)}
    function set_size(state,ty)
     {var match=top_opt(state[1]);
      if(match)
       {var
         match$0=match[1],
         queue_elem=match$0[2],
         left_total=match$0[1],
         _kI_=queue_elem[1];
        if(left_total < state[12])return initialize_scan_stack(state[1]);
        var _kJ_=queue_elem[2];
        if(typeof _kJ_ !== "number")
         switch(_kJ_[0])
          {case 3:
            var _kK_=1 - ty;
            return _kK_
                    ?(queue_elem[1] = state[13] + _kI_ | 0,pop_opt(state[1]),0)
                    :_kK_;
           case 1:
           case 2:
            return ty
                    ?(queue_elem[1] = state[13] + _kI_ | 0,pop_opt(state[1]),0)
                    :ty
           }
        return 0}
      return 0}
    function scan_push(state,b,token)
     {pp_enqueue(state,token);
      if(b)set_size(state,1);
      var elem=[0,state[13],token];
      return push(elem,state[1])}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var size=- state[13] | 0,elem=[0,size,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _kG_=state[14] === state[15]?1:0;
      if(_kG_)
       {var _kH_=state[16];
        return enqueue_string_as(state,caml_ml_string_length(_kH_),_kH_)}
      return _kG_}
    function pp_close_box(state,param)
     {var _kE_=1 < state[14]?1:0;
      if(_kE_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,size,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _kF_=0}
      else
       var _kF_=_kE_;
      return _kF_}
    function pp_open_stag(state,tag_name)
     {if(state[22]){push(tag_name,state[4]);caml_call1(state[26],tag_name)}
      var _kD_=state[23];
      if(_kD_)
       {var token=[5,tag_name];return pp_enqueue(state,[0,size,token,0])}
      return _kD_}
    function pp_close_stag(state,param)
     {if(state[23])pp_enqueue(state,[0,size,5,0]);
      var _kB_=state[22];
      if(_kB_)
       {var match=pop_opt(state[4]);
        if(match){var tag_name=match[1];return caml_call1(state[27],tag_name)}
        var _kC_=0}
      else
       var _kC_=_kB_;
      return _kC_}
    function pp_open_tag(state,s){return pp_open_stag(state,[0,String_tag,s])}
    function pp_close_tag(state,param){return pp_close_stag(state,0)}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_stag_function(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_stag_function(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      clear$0(state[28]);
      initialize_scan_stack(state[1]);
      clear(state[2]);
      clear(state[3]);
      clear(state[4]);
      clear(state[5]);
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _kA_=state[4];
      iter$7(function(param){return pp_close_tag(state,0)},_kA_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _kz_=state[14] < state[15]?1:0;
      return _kz_?enqueue_string_as(state,size,s):_kz_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_string_of_jsbytes("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,to_string(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _ky_=state[14] < state[15]?1:0;
      return _ky_?enqueue_advance(state,[0,size,3,0]):_ky_}
    function pp_print_if_newline(state,param)
     {var _kx_=state[14] < state[15]?1:0;
      return _kx_?enqueue_advance(state,[0,size,4,0]):_kx_}
    function pp_print_custom_break(state,fits,breaks)
     {var
       after=fits[3],
       width=fits[2],
       before=fits[1],
       _kw_=state[14] < state[15]?1:0;
      if(_kw_)
       {var
         size=- state[13] | 0,
         token=[1,fits,breaks],
         length=
          (caml_ml_string_length(before) + width | 0)
          +
          caml_ml_string_length(after)
          |
          0,
         elem=[0,size,token,length];
        return scan_push(state,1,elem)}
      return _kw_}
    function pp_print_break(state,width,offset)
     {return pp_print_custom_break
              (state,[0,cst$73,width,cst$72],[0,cst$71,offset,cst$70])}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _kv_=state[14] < state[15]?1:0;
      if(_kv_)
       {var elem=[0,size,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _kv_}
    function pp_close_tbox(state,param)
     {var _ks_=1 < state[14]?1:0;
      if(_ks_)
       {var _kt_=state[14] < state[15]?1:0;
        if(_kt_)
         {var elem=[0,size,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _ku_=0}
        else
         var _ku_=_kt_}
      else
       var _ku_=_ks_;
      return _ku_}
    function pp_print_tbreak(state,width,offset)
     {var _kr_=state[14] < state[15]?1:0;
      if(_kr_)
       {var size=- state[13] | 0,elem=[0,size,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _kr_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _kq_=state[14] < state[15]?1:0;
      if(_kq_){var elem=[0,size,0,0];return enqueue_advance(state,elem)}
      return _kq_}
    function pp_set_max_boxes(state,n)
     {var _ko_=1 < n?1:0,_kp_=_ko_?(state[15] = n,0):_ko_;return _kp_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var _kn_=1 < n$0?1:0;
      if(_kn_)
       {var n$1=state[6] - n$0 | 0,_km_=1 <= n$1?1:0;
        if(_km_)
         {var n=pp_limit(n$1);
          state[7] = n;
          state[8] = state[6] - state[7] | 0;
          return pp_rinit(state)}
        return _km_}
      return _kn_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _kl_=1 <= n?1:0;
      if(_kl_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _kl_}
    function check_geometry(geometry)
     {var
       _kj_=1 < geometry[1]?1:0,
       _kk_=_kj_?geometry[1] < geometry[2]?1:0:_kj_;
      return _kk_}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_geometry(state,max_indent,margin)
     {if(2 <= max_indent)
       {if(margin <= max_indent)
         throw [0,Invalid_argument,cst_Format_pp_set_geometry_mar];
        pp_set_margin(state,margin);
        return pp_set_max_indent(state,max_indent)}
      throw [0,Invalid_argument,cst_Format_pp_set_geometry_max]}
    function pp_safe_set_geometry(state,max_indent,margin)
     {return check_geometry([0,max_indent,margin])
              ?pp_set_geometry(state,max_indent,margin)
              :0}
    function pp_get_geometry(state,param){return [0,state[8],state[6]]}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functi(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functi(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$74,0,1)}
    var blank_line=make$0(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _ki_=0 < n$0?1:0;
        if(_ki_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _ki_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_kf_,_kg_,_kh_){return output_substring(oc,_kf_,_kg_,_kh_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_ke_){return display_newline(state,_ke_)};
      state[20] = function(_kd_){return display_indent(state,_kd_)};
      state[21] = function(_kc_){return display_indent(state,_kc_)};
      return 0}
    function default_pp_mark_open_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$76,symbol(s,cst$75))}
      return cst$77}
    function default_pp_mark_close_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$79,symbol(s,cst$78))}
      return cst$80}
    function default_pp_print_open_tag(_kb_){return 0}
    function default_pp_print_close_tag(_ka_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=create$1(0),sys_tok=[0,unknown,_b__,0];
      add(sys_tok,pp_queue);
      var scan_stack=create$0(0);
      initialize_scan_stack(scan_stack);
      push([0,1,sys_tok],scan_stack);
      var _j9_=create$0(0),_j__=create$0(0),_j$_=create$0(0);
      return [0,
              scan_stack,
              create$0(0),
              _j$_,
              _j__,
              _j9_,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$81,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _j1_(_j8_){return 0}
      function _j2_(_j7_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_j6_){return 0},_j2_,_j1_);
      ppf[19] = function(_j5_){return display_newline(ppf,_j5_)};
      ppf[20] = function(_j4_){return display_indent(ppf,_j4_)};
      ppf[21] = function(_j3_){return display_indent(ppf,_j3_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _jX_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_jY_,_jZ_,_j0_)
                {return output_substring(oc,_jY_,_jZ_,_j0_)},
               _jX_)}
    function formatter_of_buffer(b)
     {function _jS_(_jW_){return 0}
      return make_formatter
              (function(_jT_,_jU_,_jV_)
                {return add_substring(b,_jT_,_jU_,_jV_)},
               _jS_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$2(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_b(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_jR_){return add_symbolic_output_item(sob,0)}
      function h(_jQ_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_jP_){return pp_open_hbox(std_formatter,_jP_)}
    function open_vbox(_jO_){return pp_open_vbox(std_formatter,_jO_)}
    function open_hvbox(_jN_){return pp_open_hvbox(std_formatter,_jN_)}
    function open_hovbox(_jM_){return pp_open_hovbox(std_formatter,_jM_)}
    function open_box(_jL_){return pp_open_box(std_formatter,_jL_)}
    function close_box(_jK_){return pp_close_box(std_formatter,_jK_)}
    function open_tag(_jJ_){return pp_open_tag(std_formatter,_jJ_)}
    function close_tag(_jI_){return pp_close_tag(std_formatter,_jI_)}
    function open_stag(_jH_){return pp_open_stag(std_formatter,_jH_)}
    function close_stag(_jG_){return pp_close_stag(std_formatter,_jG_)}
    function print_as(_jE_,_jF_){return pp_print_as(std_formatter,_jE_,_jF_)}
    function print_string$0(_jD_){return pp_print_string(std_formatter,_jD_)}
    function print_int$0(_jC_){return pp_print_int(std_formatter,_jC_)}
    function print_float$0(_jB_){return pp_print_float(std_formatter,_jB_)}
    function print_char$0(_jA_){return pp_print_char(std_formatter,_jA_)}
    function print_bool(_jz_){return pp_print_bool(std_formatter,_jz_)}
    function print_break(_jx_,_jy_)
     {return pp_print_break(std_formatter,_jx_,_jy_)}
    function print_cut(_jw_){return pp_print_cut(std_formatter,_jw_)}
    function print_space(_jv_){return pp_print_space(std_formatter,_jv_)}
    function force_newline(_ju_){return pp_force_newline(std_formatter,_ju_)}
    function print_flush(_jt_){return pp_print_flush(std_formatter,_jt_)}
    function print_newline$0(_js_)
     {return pp_print_newline(std_formatter,_js_)}
    function print_if_newline(_jr_)
     {return pp_print_if_newline(std_formatter,_jr_)}
    function open_tbox(_jq_){return pp_open_tbox(std_formatter,_jq_)}
    function close_tbox(_jp_){return pp_close_tbox(std_formatter,_jp_)}
    function print_tbreak(_jn_,_jo_)
     {return pp_print_tbreak(std_formatter,_jn_,_jo_)}
    function set_tab(_jm_){return pp_set_tab(std_formatter,_jm_)}
    function print_tab(_jl_){return pp_print_tab(std_formatter,_jl_)}
    function set_margin(_jk_){return pp_set_margin(std_formatter,_jk_)}
    function get_margin(_jj_){return std_formatter[6]}
    function set_max_indent(_ji_)
     {return pp_set_max_indent(std_formatter,_ji_)}
    function get_max_indent(_jh_){return std_formatter[8]}
    function set_geometry(_jf_,_jg_)
     {return pp_set_geometry(std_formatter,_jf_,_jg_)}
    function safe_set_geometry(_jd_,_je_)
     {return pp_safe_set_geometry(std_formatter,_jd_,_je_)}
    function get_geometry(_jc_){return pp_get_geometry(std_formatter,_jc_)}
    function set_max_boxes(_jb_){return pp_set_max_boxes(std_formatter,_jb_)}
    function get_max_boxes(_ja_){return std_formatter[15]}
    function over_max_boxes(_i$_)
     {return pp_over_max_boxes(std_formatter,_i$_)}
    function set_ellipsis_text(_i__)
     {return pp_set_ellipsis_text(std_formatter,_i__)}
    function get_ellipsis_text(_i9_){return std_formatter[16]}
    function set_formatter_out_channel(_i8_)
     {return pp_set_formatter_out_channel(std_formatter,_i8_)}
    function set_formatter_out_functions(_i7_)
     {return pp_set_formatter_out_functions(std_formatter,_i7_)}
    function get_formatter_out_functions(_i6_)
     {return pp_get_formatter_out_functions(std_formatter,_i6_)}
    function set_formatter_output_functions(_i4_,_i5_)
     {return pp_set_formatter_output_functi(std_formatter,_i4_,_i5_)}
    function get_formatter_output_functions(_i3_)
     {return pp_get_formatter_output_functi(std_formatter,_i3_)}
    function set_formatter_stag_functions(_i2_)
     {return pp_set_formatter_stag_function(std_formatter,_i2_)}
    function get_formatter_stag_functions(_i1_)
     {return pp_get_formatter_stag_function(std_formatter,_i1_)}
    function set_print_tags(_i0_)
     {return pp_set_print_tags(std_formatter,_i0_)}
    function get_print_tags(_iZ_){return std_formatter[22]}
    function set_mark_tags(_iY_){return pp_set_mark_tags(std_formatter,_iY_)}
    function get_mark_tags(_iX_){return std_formatter[23]}
    function set_tags(_iW_){return pp_set_tags(std_formatter,_iW_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _iU_=param$0[2],_iV_=param$0[1];
          if(_iU_)
           {caml_call2(pp_v,ppf,_iV_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=_iU_;
            continue}
          return caml_call2(pp_v,ppf,_iV_)}
        return 0}}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _iT_=left[1] !== len?1:0;
        return _iT_?flush(0):_iT_}}
    function pp_print_option(opt,pp_v,ppf,param)
     {if(opt)
       var sth=opt[1],none=sth;
      else
       var none=function(param,_iS_){return 0};
      if(param){var v=param[1];return caml_call2(pp_v,ppf,v)}
      return caml_call2(none,ppf,0)}
    function pp_print_result(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call2(ok,ppf,v)}
      var e=param[1];
      return caml_call2(error,ppf,e)}
    function compute_tag(output,tag_acc)
     {var buf=create$2(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$3(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _iI_=acc[2],_iJ_=acc[1];
          if(0 === _iI_[0])
           {var acc$0=_iI_[1];
            output_acc$0(ppf,_iJ_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(output_acc$0,acc$0)])}
          var acc$1=_iI_[1];
          output_acc$0(ppf,_iJ_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _iK_=acc[1],switch$1=0;
          if(typeof _iK_ !== "number" && 0 === _iK_[0])
           {var _iL_=_iK_[2],switch$2=0;
            if(typeof _iL_ !== "number" && 1 === _iL_[0])
             {var p$1=_iK_[1],size=_iL_[2],s$0=acc[2];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var p$0=_iK_,s=acc[2];switch$0 = 2}
          break;
         case 3:
          var _iM_=acc[1],switch$3=0;
          if(typeof _iM_ !== "number" && 0 === _iM_[0])
           {var _iN_=_iM_[2],switch$4=0;
            if(typeof _iN_ !== "number" && 1 === _iN_[0])
             {var p$3=_iM_[1],size$0=_iN_[2],c$0=acc[2];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var p$2=_iM_,c=acc[2];switch$0 = 3}
          break;
         case 4:
          var _iO_=acc[1],switch$5=0;
          if(typeof _iO_ !== "number" && 0 === _iO_[0])
           {var _iP_=_iO_[2],switch$6=0;
            if(typeof _iP_ !== "number" && 1 === _iP_[0])
             {var p$1=_iO_[1],size=_iP_[2],s$0=acc[2];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var p$0=_iO_,s=acc[2];switch$0 = 2}
          break;
         case 5:
          var _iQ_=acc[1],switch$7=0;
          if(typeof _iQ_ === "number" || ! (0 === _iQ_[0]))
           switch$7 = 1;
          else
           {var _iR_=_iQ_[2],switch$8=0;
            if(typeof _iR_ !== "number" && 1 === _iR_[0])
             {var p$3=_iQ_[1],size$0=_iR_[2],c$0=acc[2];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var p$2=_iQ_,c=acc[2];switch$0 = 3}
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _iw_=acc[2],_ix_=acc[1];
          if(0 === _iw_[0])
           {var acc$0=_iw_[1];
            strput_acc$0(ppf,_ix_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(strput_acc$0,acc$0)])}
          var acc$1=_iw_[1];
          strput_acc$0(ppf,_ix_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _iy_=acc[1],switch$1=0;
          if(typeof _iy_ !== "number" && 0 === _iy_[0])
           {var _iz_=_iy_[2],switch$2=0;
            if(typeof _iz_ !== "number" && 1 === _iz_[0])
             {var p$1=_iy_[1],size=_iz_[2],s$0=acc[2];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var p$0=_iy_,s=acc[2];switch$0 = 2}
          break;
         case 3:
          var _iA_=acc[1],switch$3=0;
          if(typeof _iA_ !== "number" && 0 === _iA_[0])
           {var _iB_=_iA_[2],switch$4=0;
            if(typeof _iB_ !== "number" && 1 === _iB_[0])
             {var p$3=_iA_[1],size$0=_iB_[2],c$0=acc[2];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var p$2=_iA_,c=acc[2];switch$0 = 3}
          break;
         case 4:
          var _iC_=acc[1],switch$5=0;
          if(typeof _iC_ !== "number" && 0 === _iC_[0])
           {var _iD_=_iC_[2],switch$6=0;
            if(typeof _iD_ !== "number" && 1 === _iD_[0])
             {var p$1=_iC_[1],size=_iD_[2],s$0=acc[2];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var p$0=_iC_,s=acc[2];switch$0 = 2}
          break;
         case 5:
          var _iE_=acc[1],switch$7=0;
          if(typeof _iE_ === "number" || ! (0 === _iE_[0]))
           switch$7 = 1;
          else
           {var _iF_=_iE_[2],switch$8=0;
            if(typeof _iF_ !== "number" && 1 === _iF_[0])
             {var p$3=_iE_[1],size$0=_iF_[2],c$0=acc[2];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var p$2=_iE_,c=acc[2];switch$0 = 3}
          break;
         case 6:
          var _iG_=acc[1];
          if(typeof _iG_ !== "number" && 0 === _iG_[0])
           {var _iH_=_iG_[2];
            if(typeof _iH_ !== "number" && 1 === _iH_[0])
             {var f$1=acc[2],size$1=_iH_[2],p$4=_iG_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_iG_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_iv_=0;
      return make_printf
              (function(acc){output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               _iv_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function ifprintf$0(ppf,param)
     {var fmt=param[1],_it_=0;
      return make_iprintf(function(_iu_){return 0},_it_,fmt)}
    function fprintf$0(ppf)
     {function _iq_(_is_){return 0}
      return function(_ir_){return kfprintf$0(_iq_,ppf,_ir_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function kdprintf(k,param)
     {var fmt=param[1],_ip_=0;
      return make_printf
              (function(acc)
                {return caml_call1
                         (k,function(ppf){return output_acc$0(ppf,acc)})},
               _ip_,
               fmt)}
    function dprintf(fmt){return kdprintf(function(i){return i},fmt)}
    function kprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function sprintf$0(fmt){return kprintf(id$0,fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function asprintf(fmt){return kasprintf(id$0,fmt)}
    function flush_standard_formatters(param)
     {pp_print_flush(std_formatter,0);return pp_print_flush(err_formatter,0)}
    at_exit(flush_standard_formatters);
    function pp_set_all_formatter_output_fu(state,f,g,h,i)
     {pp_set_formatter_output_functi(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_fu(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_funct(_il_,_im_,_in_,_io_)
     {return pp_set_all_formatter_output_fu(std_formatter,_il_,_im_,_in_,_io_)}
    function get_all_formatter_output_funct(_ik_)
     {return pp_get_all_formatter_output_fu(std_formatter,_ik_)}
    function bprintf$0(b,param)
     {var fmt=param[1],ppf=formatter_of_buffer(b);
      function k(acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,0,fmt)}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      function stringify(f,e,param)
       {if(param[1] === String_tag){var s=param[2];return caml_call1(f,s)}
        return e}
      state[24] = function(_ij_){return stringify(mot,cst$82,_ij_)};
      state[25] = function(_ii_){return stringify(mct,cst$83,_ii_)};
      var _ie_=0;
      state[26] = function(_ih_){return stringify(pot,_ie_,_ih_)};
      var _if_=0;
      state[27] = function(_ig_){return stringify(pct,_if_,_ig_)};
      return 0}
    function pp_get_formatter_tag_functions(fmt,param)
     {var funs=pp_get_formatter_stag_function(fmt,0);
      function mark_open_tag(s){return caml_call1(funs[1],[0,String_tag,s])}
      function mark_close_tag(s){return caml_call1(funs[2],[0,String_tag,s])}
      function print_open_tag(s){return caml_call1(funs[3],[0,String_tag,s])}
      function print_close_tag(s){return caml_call1(funs[4],[0,String_tag,s])}
      return [0,mark_open_tag,mark_close_tag,print_open_tag,print_close_tag]}
    function set_formatter_tag_functions(_id_)
     {return pp_set_formatter_tag_functions(std_formatter,_id_)}
    function get_formatter_tag_functions(_ic_)
     {return pp_get_formatter_tag_functions(std_formatter,_ic_)}
    var
     Stdlib_format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_list,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       dprintf,
       ifprintf$0,
       kfprintf$0,
       kdprintf,
       ikfprintf$0,
       kprintf,
       kasprintf,
       bprintf$0,
       kprintf,
       set_all_formatter_output_funct,
       get_all_formatter_output_funct,
       pp_set_all_formatter_output_fu,
       pp_get_all_formatter_output_fu,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions];
    caml_register_global(762,Stdlib_format,"Stdlib__format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_ib_)
       {_ib_ = caml_wrap_exception(_ib_);
        if(_ib_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _ib_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _ia_=ib[9];
      if(typeof _ia_ === "number")
       return 0 === _ia_?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _ia_[0])return cst_unnamed_Stdlib_input_chann;
        var fname=_ia_[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$4(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$2(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$4(1,next)}
    var _b$_=0;
    function from_function$0(_h$_){return create$4(_b$_,_h$_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$4(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$84,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$85))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_h__){return open_in_file(open_in,_h__)}
    function from_file_bin(_h9_){return open_in_file(open_in_bin,_h9_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in$0(ib)
     {var _h8_=ib[9];
      if(typeof _h8_ === "number")
       return 0;
      else
       {if(0 === _h8_[0]){var ic=_h8_[1];return caml_ml_close_channel(ic)}
        var ic$0=_h8_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _h6_=assq(ic,memo[1]);return _h6_}
      catch(_h7_)
       {_h7_ = caml_wrap_exception(_h7_);
        if(_h7_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _h7_}}
    function memo_from_channel(_h5_)
     {return memo_from_ic(scan_raise_at_end,_h5_)}
    var Scan_failure=[248,cst_Stdlib_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_ca_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_cb_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_fo)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexad)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_cd_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_h3_=1 - ib[1];
         if(_h3_)
          {var _h4_=c - 9 | 0,switch$0=0;
           if(4 < _h4_ >>> 0)
            {if(23 === _h4_)switch$0 = 1}
           else
            if(1 < (_h4_ - 2 | 0) >>> 0)switch$0 = 1;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _h3_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$3)
              ?caml_string_notequal(s,cst_true$3)
                ?bad_input(caml_call1(sprintf(_ce_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cf_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=symbol(cst_0b,token_string(ib));break;
        case 3:var tok=symbol(cst_0o,token_string(ib));break;
        case 4:var tok=symbol(cst_0u,token_string(ib));break;
        case 5:var tok=symbol(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l && 43 === caml_string_get(tok,0))
       return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_cg_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_ch_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_h1_,_h2_)
     {return scan_digit_plus(cst_binary,is_binary_digit,_h1_,_h2_)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_hZ_,_h0_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_hZ_,_h0_)}
    function is_hexa_digit(param)
     {var _hY_=param - 48 | 0,switch$0=0;
      if(22 < _hY_ >>> 0)
       {if(! (5 < (_hY_ - 49 | 0) >>> 0))switch$0 = 1}
      else
       if(6 < (_hY_ - 10 | 0) >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function scan_hexadecimal_int(_hW_,_hX_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_hW_,_hX_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           var switch$0=0;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             if(120 === c$0)switch$0 = 1}
           else
            if(88 === c$0)
             switch$0 = 1;
            else
             if(98 <= c$0)return scan_binary_int(store_char(width,ib,c$0),ib);
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c && 101 !== c)return width;
      return scan_optionally_signed_decimal(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _hT_=len - 1 | 0,
       _hS_=0;
      if(! (_hT_ < 0))
       {var i=_hS_;
        for(;;)
         {var c=peek_char(ib),_hU_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _hU_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _hV_=i + 1 | 0;
          if(_hT_ !== i){var i=_hV_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _hF_=0 === width?1:0,_hG_=_hF_ || end_of_input(ib);
      if(_hG_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _hH_=0 === width$0?1:0,
       _hI_=_hH_ || end_of_input(ib);
      if(_hI_)bad_hex_float(0);
      var c=peek_char(ib),switch$0=0;
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _hJ_=0 === width$1?1:0,
             _hK_=_hJ_ || end_of_input(ib);
            if(_hK_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}}
        else
         if(26 === switcher)switch$0 = 1}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _hN_=0 === width$3?1:0,
           _hO_=_hN_ || end_of_input(ib);
          if(_hO_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4 && ! end_of_input(ib))
           {var match=peek_char(ib),_hP_=match - 46 | 0,switch$1=0;
            if(34 < _hP_ >>> 0)
             {if(66 === _hP_)switch$1 = 1}
            else
             if(32 < (_hP_ - 1 | 0) >>> 0)switch$1 = 1;
            var width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
            if(0 !== width$5 && ! end_of_input(ib))
             {var c$0=peek_char(ib);
              if(46 === c$0)
               {var width$6=store_char(width$5,ib,c$0),switch$2=0;
                if(0 !== width$6 && ! end_of_input(ib))
                 {var match$0=peek_char(ib),switch$3=0;
                  if(80 !== match$0 && 112 !== match$0)
                   {var
                     precision$0=min(width$6,precision),
                     width$10=
                      width$6
                      -
                      (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                      |
                      0;
                    switch$3 = 1}
                  if(! switch$3)var width$10=width$6;
                  var width$7=width$10;
                  switch$2 = 1}
                if(! switch$2)var width$7=width$6;
                var width$8=width$7}
              else
               var width$8=width$5;
              if(0 !== width$8 && ! end_of_input(ib))
               {var c$1=peek_char(ib);
                if(80 !== c$1 && 112 !== c$1)return width$8;
                var
                 width$9=store_char(width$8,ib,c$1),
                 _hQ_=0 === width$9?1:0,
                 _hR_=_hQ_ || end_of_input(ib);
                if(_hR_)bad_hex_float(0);
                return scan_optionally_signed_decimal(width$9,ib)}
              return width$8}
            return width$5}
          return width$4}
        if(73 === c)switch$0 = 1}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _hL_=0 === width$2?1:0,
         _hM_=_hL_ || end_of_input(ib);
        if(_hM_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _hB_=0 === width?1:0,_hC_=_hB_ || end_of_input(ib);
      if(_hC_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _hD_=0 === width$0?1:0,
       _hE_=_hD_ || end_of_input(ib);
      if(_hE_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _hn_=0 === width?1:0,_ho_=_hn_ || end_of_input(ib);
      if(_ho_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _hp_=0 === width$0?1:0,
       _hq_=_hp_ || end_of_input(ib);
      if(_hq_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _hr_=0 === width$1?1:0,
           _hs_=_hr_ || end_of_input(ib);
          if(_hs_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _ht_=0 === width$2?1:0,
          _hu_=_ht_ || end_of_input(ib);
         if(_hu_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0 && 120 !== c$0)
          return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _hv_=0 === width$3?1:0,
          _hw_=_hv_ || end_of_input(ib);
         if(_hw_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _hx_=0 === width$4?1:0,
          _hy_=_hx_ || end_of_input(ib);
         if(_hy_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0,switch$0=0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1),switch$1=0;
            if(0 !== width$5 && ! end_of_input(ib))
             {var match=peek_char(ib),switch$2=0;
              if(80 !== match && 112 !== match)
               {var
                 precision$0=min(width$5,precision),
                 width$10=
                  width$5
                  -
                  (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                  |
                  0;
                switch$2 = 1}
              if(! switch$2)var width$10=width$5;
              var width$6=width$10;
              switch$1 = 1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6}
          else
           switch$0 = 1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)var width$7=width$4;else switch$0 = 1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8 && ! end_of_input(ib))
          {var c$2=peek_char(ib);
           if(80 !== c$2 && 112 !== c$2)return width$8;
           var
            width$9=store_char(width$8,ib,c$2),
            _hz_=0 === width$9?1:0,
            _hA_=_hz_ || end_of_input(ib);
           if(_hA_)bad_hex_float(0);
           return scan_optionally_signed_decimal(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var _hm_=c - 9 | 0,switch$0=0;
        if(4 < _hm_ >>> 0)
         {if(23 === _hm_)switch$0 = 1}
        else
         if(1 < (_hm_ - 2 | 0) >>> 0)switch$0 = 1;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_cc_),message)):c}
    function check_next_char_for_char(_hk_,_hl_)
     {return check_next_char(cst_a_Char,_hk_,_hl_)}
    function check_next_char_for_string(_hi_,_hj_)
     {return check_next_char(cst_a_String,_hi_,_hj_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib),switch$0=0;
      if(40 <= c0)
       {if(58 <= c0)
         {var switcher$0=c0 - 92 | 0;
          if(! (28 < switcher$0 >>> 0))
           switch(switcher$0)
            {case 28:
              var
               get_digit=
                function(param)
                 {var c=next_char(ib),_hh_=c - 48 | 0,switch$0=0;
                  if(22 < _hh_ >>> 0)
                   {if(! (5 < (_hh_ - 49 | 0) >>> 0))switch$0 = 1}
                  else
                   if(6 < (_hh_ - 10 | 0) >>> 0)switch$0 = 1;
                  return switch$0?c:bad_input_escape(c)},
               c1=get_digit(0),
               c2=get_digit(0),
               _hd_=hexadecimal_value_of_char(c2),
               c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _hd_ | 0,
               switch$1=0;
              if(0 <= c$0 && ! (255 < c$0))
               {var _hf_=char_of_int(c$0);switch$1 = 1}
              if(! switch$1)
               var _hf_=bad_input(caml_call2(sprintf(_cj_),c1,c2));
              return store_char(width - 2 | 0,ib,_hf_);
             case 0:
             case 6:
             case 18:
             case 22:
             case 24:switch$0 = 1;break
             }}
        else
         if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0,
            switch$2=0;
           if(0 <= c && ! (255 < c)){var _hg_=char_of_int(c);switch$2 = 1}
           if(! switch$2)
            var _hg_=bad_input(caml_call3(sprintf(_ci_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_hg_)}}
      else
       if(34 === c0 || 39 <= c0)switch$0 = 1;
      if(switch$0)
       {var switch$3=0;
        if(110 <= c0)
         if(117 <= c0)
          switch$3 = 1;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _he_=10;break;
             case 4:var _he_=13;break;
             case 6:var _he_=9;break;
             default:switch$3 = 1}}
        else
         if(98 === c0)var _he_=8;else switch$3 = 1;
        if(switch$3)var _he_=c0;
        return store_char(width,ib,_he_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _hb_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_hb_)}
              return caml_trampoline_return(skip_spaces,[0,_hb_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _hc_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_hc_)}
                return caml_trampoline_return(skip_spaces,[0,_hc_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_g9_=0 < i$0?1:0;
          if(_g9_)
           {var _g__=1 - ib[1];
            if(_g__)
             var _g$_=is_in_char_set(char_set,c),_ha_=_g$_?c !== stp?1:0:_g$_;
            else
             var _ha_=_g__}
          else
           var _ha_=_g9_;
          if(_ha_)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _ha_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _g8_=1 - ib[1];
        if(_g8_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _g8_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_cl_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cm_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_g6_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_g6_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_g6_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _g7_=fmt$0[1];
           if(0 === _g7_[0])
            {var
              rest$0=fmt$0[2],
              match=_g7_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_g7_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _gR_=fmt$0[2],_gS_=fmt$0[1];
           if(typeof _gR_ !== "number")
            switch(_gR_[0])
             {case 17:
               var
                rest$1=_gR_[2],
                fmting_lit=_gR_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$1];
               return pad_prec_scanf
                       (ib,str_rest,readers,_gS_,0,scan$0,token_string);
              case 18:
               var _gT_=_gR_[1];
               if(0 === _gT_[0])
                {var
                  rest$2=_gR_[2],
                  match$0=_gT_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cn_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$2),
                          readers,
                          _gS_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$3=_gR_[2],
                match$1=_gT_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_co_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$3),
                        readers,
                        _gS_,
                        0,
                        scan$2,
                        token_string)
              }
           var scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,_gR_,readers,_gS_,0,scan,token_string);
          case 3:
           var
            rest$4=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$4,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$5=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$5,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$6=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$7=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$8=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           var _gU_=fmt$0[1][2];
           if(5 === _gU_)
            {var rest$9=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$9,readers,pad$4,prec$3,scan_caml_float,token_float)}
           if(6 <= _gU_)
            {var rest$10=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$10,readers,pad$5,prec$4,scan_hex_float,token_float)}
           var rest$11=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
           return pad_prec_scanf
                   (ib,rest$11,readers,pad$6,prec$5,scan_float,token_float);
          case 9:
           var
            rest$12=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_g5_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_ck_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$12,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$13=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$13;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$14=fmt$0[2],str$0=fmt$0[1];
           iter$4(function(_g4_){return check_char(ib,_g4_)},str$0);
           var fmt$0=rest$14;
           continue;
          case 12:
           var rest$15=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$15;
           continue;
          case 13:
           var rest$16=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _gV_=format_of_string_fmtty(s,fmtty),fmt$3=_gV_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$16,readers)];
          case 14:
           var rest$17=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _gX_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=_gX_,
              fmt$4=fmt$8}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _gW_=bad_input(msg$0),
              fmt$5=_gW_[1],
              fmt$4=_gW_[2]}
           return [0,
                   [0,fmt$5,s$0],
                   make_scanf(ib,concat_fmt(fmt$4,rest$17),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$18=fmt$0[2],
            formatting_lit=fmt$0[1],
            _gY_=string_of_formatting_lit(formatting_lit);
           iter$4(function(_g3_){return check_char(ib,_g3_)},_gY_);
           var fmt$0=rest$18;
           continue;
          case 18:
           var _gZ_=fmt$0[1];
           if(0 === _gZ_[0])
            {var rest$19=fmt$0[2],match$4=_gZ_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$19),fmt$0=fmt$10;
             continue}
           var rest$20=fmt$0[2],match$5=_gZ_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$20),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _g0_=fmt$0[3],_g1_=fmt$0[2],_g2_=fmt$0[1];
           if(typeof _g0_ !== "number" && 17 === _g0_[0])
            {var
              rest$21=_g0_[2],
              fmting_lit$0=_g0_[1],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_g2_);
             scan_chars_in_char_set(_g1_,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$21];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var width=width_of_pad_opt(_g2_);
           scan_chars_in_char_set(_g1_,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,_g0_,readers)];
          case 21:
           var
            rest$22=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$22,readers)];
          case 22:
           var rest$23=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$23,readers)];
          case 23:
           var
            rest$24=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$24),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cp_];
          default:return invalid_arg(cst_scanf_bad_conversion_custo)}}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {caml_call3(scan,max_int,max_int,ib);
            var x=caml_call1(token,ib);
            return [0,x,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion)}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(0 === pad[1])return invalid_arg(cst_scanf_bad_conversion$0);
          var _gQ_=pad[2];
          if(typeof prec === "number")
           {if(0 === prec)
             {caml_call3(scan,_gQ_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            return invalid_arg(cst_scanf_bad_conversion$1)}
          var p$0=prec[1];
          caml_call3(scan,_gQ_,p$0,ib);
          var x$2=caml_call1(token,ib);
          return [0,x$2,make_scanf(ib,fmt,readers)]}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _gP_=[0,make_scanf(ib,fmt,readers)],_gO_=_gP_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var switch$0=0;
          if
           (exc[1]
            !==
            Scan_failure
            &&
            exc[1]
            !==
            Failure
            &&
            exc
            !==
            End_of_file)
           {if(exc[1] !== Invalid_argument)throw exc;
            var
             msg=exc[2],
             _gN_=
              invalid_arg
               (symbol
                 (msg,symbol(cst_in_format,symbol(escaped$1(str),cst$86))));
            switch$0 = 1}
          if(! switch$0)var _gN_=[1,exc];
          var _gO_=_gN_}
        if(0 === _gO_[0]){var args=_gO_[1];return apply(f,args)}
        var exc=_gO_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _gM_=format_of_string_format(str,format),fmt=_gM_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {function _gL_(x){return x}
      return sscanf_format
              (symbol(cst$88,symbol(escaped$1(s),cst$87)),fmt,_gL_)}
    function unescaped(s)
     {function _gK_(x){return x}
      return caml_call1(sscanf(symbol(cst$90,symbol(s,cst$89)),_cq_),_gK_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Stdlib_scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in$0,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(763,Stdlib_scanf,"Stdlib__scanf");
    var register=caml_register_named_value;
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Stdlib_callback=[0,register,register_exception];
    caml_register_global(764,Stdlib_callback,"Stdlib__callback");
    function copy$7(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_gH_=caml_ml_string_length(s) - 1 | 0,_gG_=0;
      if(! (_gH_ < 0))
       {var i=_gG_;
        for(;;)
         {var _gI_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _gI_ | 0;
          var _gJ_=i + 1 | 0;
          if(_gH_ !== i){var i=_gJ_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    var
     compare$11=caml_string_compare,
     Vars=caml_call1(Stdlib_map[1],[0,compare$11]),
     compare$12=caml_string_compare,
     Meths=caml_call1(Stdlib_map[1],[0,compare$12]),
     compare$13=caml_int_compare,
     Labs=caml_call1(Stdlib_map[1],[0,compare$13]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _gA_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _gA_;
      var _gC_=len - 1 | 0,_gB_=0;
      if(! (_gC_ < 0))
       {var i=_gB_;
        for(;;)
         {var
           _gE_=(i * 2 | 0) + 3 | 0,
           _gD_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_gE_)[1 + _gE_] = _gD_;
          var _gF_=i + 1 | 0;
          if(_gC_ !== i){var i=_gF_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_gy_=old_size < new_size?1:0;
      if(_gy_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _gz_=0}
      else
       var _gz_=_gy_;
      return _gz_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _gw_=caml_call2(Meths[27],name,table[3]);return _gw_}
      catch(_gx_)
       {_gx_ = caml_wrap_exception(_gx_);
        if(_gx_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _gx_}}
    function get_method_labels(table,names)
     {return map$5(function(_gv_){return get_method_label(table,_gv_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[27],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[1 + label]
                =
                element,
                0)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _gt_=assoc(label,table[6]);return _gt_}
      catch(_gu_)
       {_gu_ = caml_wrap_exception(_gu_);
        if(_gu_ === Not_found)
         return caml_check_bound(table[2],label)[1 + label];
        throw _gu_}}
    function to_list$3(arr){return 0 === arr?0:to_list$1(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$3(vars),
       virt_meths$0=to_list$3(virt_meths),
       concr_meths$0=to_list$3(concr_meths),
       virt_meth_labs=
        map$2
         (function(_gs_){return get_method_label(table,_gs_)},virt_meths$0),
       concr_meth_labs=
        map$2
         (function(_gr_){return get_method_label(table,_gr_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _gi_=Vars[1],_gj_=table[7];
      function _gk_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_gk_,_gj_,_gi_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _gn_=by_label[1];
          try
           {var _gp_=caml_call2(Labs[27],label,table[4]),_go_=_gp_}
          catch(_gq_)
           {_gq_ = caml_wrap_exception(_gq_);
            if(_gq_ !== Not_found)throw _gq_;
            var _go_=1}
          by_label[1] = caml_call3(Labs[4],label,_go_,_gn_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _gl_=0,_gm_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _gm_,
        _gl_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left$0
       (function(s,v)
         {var _gh_=caml_call2(Vars[27],v,table[7]);
          return caml_call3(Vars[4],v,_gh_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _gg_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _gg_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _ge_=caml_call2(Vars[27],name,table[7]);return _ge_}
      catch(_gf_)
       {_gf_ = caml_wrap_exception(_gf_);
        if(_gf_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$91))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _gf_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _f8_=nmeths - 1 | 0,
       _f7_=0;
      if(! (_f8_ < 0))
       {var i$0=_f7_;
        for(;;)
         {var
           _gc_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[1 + i$0]);
          caml_check_bound(res,i$0)[1 + i$0] = _gc_;
          var _gd_=i$0 + 1 | 0;
          if(_f8_ !== i$0){var i$0=_gd_;continue}
          break}}
      var _f__=nvals - 1 | 0,_f9_=0;
      if(! (_f__ < 0))
       {var i=_f9_;
        for(;;)
         {var
           _ga_=i + nmeths | 0,
           _f$_=new_variable(table,caml_check_bound(vals,i)[1 + i]);
          caml_check_bound(res,_ga_)[1 + _ga_] = _f$_;
          var _gb_=i + 1 | 0;
          if(_f__ !== i){var i=_gb_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _f5_=caml_call2(Vars[27],name,table[7]);return _f5_}
      catch(_f6_)
       {_f6_ = caml_wrap_exception(_f6_);
        if(_f6_ === Not_found)throw [0,Assert_failure,_cr_];
        throw _f6_}}
    function get_variables(table,names)
     {return map$5(function(_f4_){return get_variable(table,_f4_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(0 === public_methods)return new_table([0]);
      var
       tags=map$5(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _fZ_=0,
       _f0_=to_array(concr_meths),
       _f1_=
        [0,
         map$5
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_f0_),
         _fZ_],
       _f2_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$5(function(_f3_){return get_variable(cla,_f3_)},_f2_),
                 _f1_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_fY_=0 !== inits?1:0;
      return _fY_?iter_f(obj,inits):_fY_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initiali(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cv_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_fU_=0;
      if(! (n < 0))
       {var i=_fU_;
        for(;;)
         {var _fW_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[1 + i],_fW_,0];
          var _fX_=i + 1 | 0;
          if(n !== i){var i=_fX_;continue}
          break}}
      var _fV_=r[1];
      if(tables){tables[2] = _fV_;return res}
      throw [0,Assert_failure,_cs_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[1 + i],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cx_]}
                if(tables$0)
                 {var _fT_=tables$0[3];
                  if(_fT_){var tables$0=_fT_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_ct_]}
                throw [0,Assert_failure,_cw_]}
              throw [0,Assert_failure,_cu_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table),switch$0=0;
      if
       (0
        !==
        (n % 2 | 0)
        &&
        !
        ((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n))
       {var n$0=new_method(table);switch$0 = 1}
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[1 + n$0] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _fN_=i[1],
           label=caml_check_bound(methods,_fN_)[1 + _fN_],
           next=
            function(param)
             {i[1]++;
              var _fS_=i[1];
              return caml_check_bound(methods,_fS_)[1 + _fS_]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[1 + n]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[1 + e][1 + n]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[1 + n] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[1 + n])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[1 + e][1 + n])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][1 + n],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[1 + n])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[1 + e][1 + n])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][1 + n],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[1 + n],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[1 + e][1 + n],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][1 + n],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _fQ_=caml_call1(obj[1][1 + m],obj);
                     return caml_call2(obj[1][1 + n],obj,_fQ_)}}
                 (n$15,m$1);
              break;
             case 20:
              var
               m$2=next(0),
               x$9=next(0),
               c=new_cache(table),
               clo$0=
                function(m,x,c)
                  {return function(obj)
                    {return caml_call2(caml_get_public_method(x,m,0),x,c)}}
                 (m$2,x$9,c);
              break;
             case 21:
              var
               m$3=next(0),
               n$16=next(0),
               c$0=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _fP_=obj[1 + n];
                     return caml_call2(caml_get_public_method(_fP_,m,0),_fP_,c)}}
                 (m$3,n$16,c$0);
              break;
             case 22:
              var
               m$4=next(0),
               e$4=next(0),
               n$17=next(0),
               c$1=new_cache(table),
               clo$0=
                function(m,e,n,c)
                  {return function(obj)
                    {var _fO_=obj[1 + e][1 + n];
                     return caml_call2(caml_get_public_method(_fO_,m,0),_fO_,c)}}
                 (m$4,e$4,n$17,c$1);
              break;
             default:
              var
               m$5=next(0),
               n$18=next(0),
               c$2=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _fR_=caml_call1(obj[1][1 + n],obj);
                     return caml_call2(caml_get_public_method(_fR_,m,0),_fR_,c)}}
                 (m$5,n$18,c$2)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$7,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(765,CamlinternalOO,"CamlinternalOO");
    var Stdlib_oo=[0,copy$7,public_method_label,public_method_label];
    caml_register_global(766,Stdlib_oo,"Stdlib__oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(767,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Stdlib_hashtbl[1],0,17);
      iter$2
       (function(s){return caml_call3(Stdlib_hashtbl[5],kwd_table,s,[0,s])},
        keywords);
      function ident_or_keyword(id)
       {try
         {var _fL_=caml_call2(Stdlib_hashtbl[6],kwd_table,id);return _fL_}
        catch(_fM_)
         {_fM_ = caml_wrap_exception(_fM_);
          if(_fM_ === Not_found)return [1,id];
          throw _fM_}}
      function keyword_or_error(c)
       {var s=make$0(1,c);
        try
         {var _fJ_=caml_call2(Stdlib_hashtbl[6],kwd_table,s);return _fJ_}
        catch(_fK_)
         {_fK_ = caml_wrap_exception(_fK_);
          if(_fK_ === Not_found)
           throw [0,Error,symbol(cst_Illegal_character,s)];
          throw _fK_}}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _fI_=match$1[1];
                    if(41 === _fI_){junk(strm);return 0}
                    if(42 === _fI_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _fF_=match[1];
          if(58 <= _fF_)
           {var switcher=_fF_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _fF_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _fG_=match$0[1],switcher$0=_fG_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _fH_=match$1[1],switcher$1=_fH_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_fF_ - 48 | 0) * 100 | 0)
                               +
                               ((_fG_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_fH_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$97]}}
             throw [0,Error,cst$96]}
          junk(strm);
          return _fF_}
        throw Failure$0}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fE_=match[1],switcher=_fE_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_fE_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _fD_=match[1],switch$0=0;
          if(43 !== _fD_ && 45 !== _fD_)switch$0 = 1;
          if(! switch$0)
           {junk(strm);store(_fD_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _fA_=match[1];
            if(58 <= _fA_)
             {var switch$0=0;
              if(69 === _fA_ || 101 === _fA_)switch$0 = 1;
              if(switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _fA_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _fB_=match$0[1],_fC_=_fB_ - 69 | 0;
                    if(32 < _fC_ >>> 0)
                     {var switcher=_fC_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_fB_);continue}}
                    else
                     {var switcher$0=_fC_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _fA_){junk(s);store(_fA_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fy_=match[1],switch$0=0;
            if(94 <= _fy_)
             {var _fz_=_fy_ - 95 | 0;
              if(30 < _fz_ >>> 0)
               {if(! (32 <= _fz_))switch$0 = 1}
              else
               if(29 === _fz_)switch$0 = 1}
            else
             if(65 <= _fy_)
              {if(92 === _fy_)switch$0 = 1}
             else
              if(33 <= _fy_)
               switch(_fy_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:switch$0 = 1;break
                 }
            if(switch$0){junk(strm);store(_fy_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _fx_=match[1],switcher=_fx_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_fx_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fv_=match[1],switch$0=0;
            if(91 <= _fv_)
             {var _fw_=_fv_ - 95 | 0;
              if(27 < _fw_ >>> 0)
               {if(97 <= _fw_)switch$0 = 1}
              else
               if(1 !== _fw_)switch$0 = 1}
            else
             if(48 <= _fv_)
              {if(6 < (_fv_ - 58 | 0) >>> 0)switch$0 = 1}
             else
              if(39 === _fv_)switch$0 = 1;
            if(switch$0){junk(strm);store(_fv_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fl_=match[1],switch$0=0;
            if(124 <= _fl_)
             {if(127 <= _fl_)
               {if(192 <= _fl_)switch$0 = 1}
              else
               if(125 !== _fl_)switch$0 = 2}
            else
             {var _fm_=_fl_ - 65 | 0;
              if(57 < _fm_ >>> 0)
               {if(! (58 <= _fm_))
                 {var switcher=_fm_ + 65 | 0;
                  switch(switcher)
                   {case 34:
                     junk(strm);
                     reset_buffer(0);
                     for(;;)
                      {var match$1=peek$0(strm);
                       if(match$1)
                        {var _fo_=match$1[1];
                         if(34 === _fo_){junk(strm);return [0,[4,get_string(0)]]}
                         if(92 === _fo_)
                          {junk(strm);
                           try
                            {var c$0=escape(strm)}
                           catch(_fu_)
                            {_fu_ = caml_wrap_exception(_fu_);
                             if(_fu_ === Failure$0)throw [0,Error,cst$94];
                             throw _fu_;
                             var _fr_=_fu_}
                           store(c$0);
                           continue}
                         junk(strm);
                         store(_fo_);
                         continue}
                       throw Failure$0}
                    case 39:
                     junk(strm);
                     try
                      {var match$2=peek$0(strm);
                       if(! match$2)throw Failure$0;
                       var _fp_=match$2[1];
                       if(92 === _fp_)
                        {junk(strm);
                         try
                          {var _fq_=escape(strm)}
                         catch(_ft_)
                          {_ft_ = caml_wrap_exception(_ft_);
                           if(_ft_ === Failure$0)throw [0,Error,cst$95];
                           throw _ft_}
                         var c=_fq_}
                       else
                        {junk(strm);var c=_fp_}}
                     catch(_fs_)
                      {_fs_ = caml_wrap_exception(_fs_);
                       if(_fs_ === Failure$0)throw [0,Error,cst$92];
                       throw _fs_}
                     var match$0=peek$0(strm);
                     if(match$0 && 39 === match$0[1])
                      {junk(strm);return [0,[5,c]]}
                     throw [0,Error,cst$93];
                    case 40:
                     junk(strm);
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return maybe_comment(counter$0,strm)}
                     return caml_trampoline_return(maybe_comment,[0,strm]);
                    case 45:junk(strm);return neg_number(strm);
                    case 9:
                    case 10:
                    case 12:
                    case 13:
                    case 26:
                    case 32:junk(strm);continue;
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                     junk(strm);reset_buffer(0);store(_fl_);return number(strm);
                    case 33:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 42:
                    case 43:
                    case 47:
                    case 58:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:switch$0 = 2;break
                    }}}
              else
               {var _fn_=_fm_ - 26 | 0;
                if(5 < _fn_ >>> 0)
                 switch$0 = 1;
                else
                 switch(_fn_)
                  {case 4:switch$0 = 1;break;case 1:case 3:switch$0 = 2;break}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_fl_)];
              case 1:
               junk(strm);reset_buffer(0);store(_fl_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_fl_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match && 42 === match[1])
         {junk(strm);
          comment(strm);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return next_token$0(counter$0,strm)}
          return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Stdlib_genlex=[0,make_lexer];
    caml_register_global(768,Stdlib_genlex,"Stdlib__genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_fk_){return caml_call1(_b4_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Stdlib_hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
           {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _fi_=caml_obj_tag(prng),
            _fj_=250 === _fi_?prng[1]:246 === _fi_?force_lazy_block(prng):prng,
            seed=caml_call1(_b4_[4],_fj_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_fg_=len - 1 | 0,_ff_=0;
        if(! (_fg_ < 0))
         {var i=_ff_;
          for(;;)
           {caml_check_bound(h[2],i)[1 + i] = 0;
            var _fh_=i + 1 | 0;
            if(_fg_ !== i){var i=_fh_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _fc_=init[4],_fd_=init[3],_fe_=copy$1(init[2]);
        return [0,init[1],_fe_,_fd_,_fc_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hkey=param$0[1];
              if(caml_call1(H[7],c))return [0,hkey,c,do_bucket(rest)];
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_e$_=d.length - 1 - 1 | 0,_e__=0;
        if(! (_e$_ < 0))
         {var i=_e__;
          for(;;)
           {var _fa_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _fa_;
            var _fb_=i + 1 | 0;
            if(_e$_ !== i){var i=_fb_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _e4_=nsize < max_array_length?1:0,
         _e5_=_e4_?(osize >>> 1 | 0) <= h[1]?1:0:_e4_;
        if(_e5_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var nidx=key_index(h,hkey);
                ndata[1 + nidx]
                =
                [0,hkey,data,caml_check_bound(ndata,nidx)[1 + nidx]];
                return 0}
              return 0},
           _e7_=osize - 1 | 0,
           _e6_=0;
          if(! (_e7_ < 0))
           {var i=_e6_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[1 + i]);
              var _e9_=i + 1 | 0;
              if(_e7_ !== i){var i=_e9_;continue}
              break}}
          var _e8_=0}
        else
         var _e8_=_e5_;
        return _e8_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _e3_=h[2].length - 1 << 1 < h[1]?1:0;
        return _e3_?resize(h):_e3_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              return [0,hk,c,remove_bucket(next)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _e2_=remove_bucket(caml_check_bound(h[2],i)[1 + i]);
        caml_check_bound(h[2],i)[1 + i] = _e2_;
        return 0}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _e1_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_e1_)[1 + _e1_],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _e0_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_e0_)[1 + _e0_],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$0=rest;
              continue}
            return 0}}
        var _eZ_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_eZ_)[1 + _eZ_])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(0 === match)return caml_call3(H[6],c,key,info);
                var param$0=next;
                continue}
              var param$0=next;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[1 + i];
        try
         {var _eX_=replace_bucket(l);return _eX_}
        catch(_eY_)
         {_eY_ = caml_wrap_exception(_eY_);
          if(_eY_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[1 + i] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _eW_=h[2].length - 1 << 1 < h[1]?1:0;
            return _eW_?resize(h):_eW_}
          throw _eY_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _eV_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_eV_)[1 + _eV_],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(0 === match)return 1;
              var param=rest;
              continue}
            var param=rest;
            continue}
          return 0}}
      function iter$0(f,h)
       {var d$0=h[2],_eT_=d$0.length - 1 - 1 | 0,_eS_=0;
        if(! (_eT_ < 0))
         {var i=_eS_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[1 + i],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1];caml_call2(f,k,d);switch$0 = 1}
                var param=rest;
                continue}
              var _eU_=i + 1 | 0;
              if(_eT_ !== i){var i=_eU_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_eP_=d$0.length - 1 - 1 | 0,_eO_=0;
        if(! (_eP_ < 0))
         {var i=_eO_;
          a:
          for(;;)
           {var
             _eQ_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[1 + i],
             b=b$0,
             accu=_eQ_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1],accu$0=caml_call3(f,k,d,accu);
                  switch$0 = 1}
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _eR_=i + 1 | 0;
              if(_eP_ !== i){var i=_eR_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                if(match$1)
                 {var new_d=match$1[1];
                  caml_call3(H[6],c,k,new_d);
                  return [0,hk,c,do_bucket(rest)]}
                var param$0=rest;
                continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_eL_=d.length - 1 - 1 | 0,_eK_=0;
        if(! (_eL_ < 0))
         {var i=_eK_;
          for(;;)
           {var _eM_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _eM_;
            var _eN_=i + 1 | 0;
            if(_eL_ !== i){var i=_eN_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _eH_=h[2],
         _eI_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length(0,b))},_eI_,_eH_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _eJ_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length(0,b);
            histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
            return 0},
          _eJ_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$0=rest;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _eE_=h[2],
         _eF_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length_alive(0,b))},_eF_,_eE_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _eG_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
            return 0},
          _eG_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      function to_seq(tbl)
       {var tbl_data=tbl[2];
        function aux(i,buck,param)
         {var i$0=i,buck$0=buck;
          for(;;)
           {if(buck$0)
             {var
               next=buck$0[3],
               c=buck$0[2],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var data=match$0[1],key=match[1];
                return [0,
                        [0,key,data],
                        function(_eD_){return aux(i$0,next,_eD_)}]}
              var buck$0=next;
              continue}
            if(i$0 === tbl_data.length - 1)return 0;
            var
             buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
             i$1=i$0 + 1 | 0,
             i$0=i$1,
             buck$0=buck$1;
            continue}}
        var _eA_=0,_eB_=0;
        return function(_eC_){return aux(_eB_,_eA_,_eC_)}}
      function to_seq_keys(m)
       {var _ew_=to_seq(m);
        function _ex_(_ez_){return _ez_[1]}
        return function(_ey_){return map(_ex_,_ew_,_ey_)}}
      function to_seq_values(m)
       {var _es_=to_seq(m);
        function _et_(_ev_){return _ev_[2]}
        return function(_eu_){return map(_et_,_es_,_eu_)}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$0,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_s_[1],1)}
    function get_key$0(t){return caml_call2(_s_[3],t,0)}
    function get_key_copy$0(t){return caml_call2(_s_[4],t,0)}
    function set_key$0(t,k){return caml_call3(_s_[5],t,0,k)}
    function unset_key$0(t){return caml_call2(_s_[6],t,0)}
    function check_key$0(t){return caml_call2(_s_[7],t,0)}
    function blit_key$0(t1,t2){return caml_call5(_s_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_s_[9],t)}
    function get_data_copy(t){return caml_call1(_s_[10],t)}
    function set_data(t,d){return caml_call2(_s_[11],t,d)}
    function unset_data(t){return caml_call1(_s_[12],t)}
    function check_data(t){return caml_call1(_s_[13],t)}
    function blit_data(t1,t2){return caml_call2(_s_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$5(0);set_data(c,d);set_key$0(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key$0(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key$0(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,
                create,
                hash,
                equal,
                get_data$1,
                get_key$0,
                set_key_data,
                check_key$0])}
    function Make$1(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _er_=include[1];
      function create(sz){return caml_call2(_er_,_cy_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$6(param){return caml_call1(_s_[1],2)}
    function get_key1(t){return caml_call2(_s_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_s_[4],t,0)}
    function set_key1(t,k){return caml_call3(_s_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_s_[6],t,0)}
    function check_key1(t){return caml_call2(_s_[7],t,0)}
    function get_key2(t){return caml_call2(_s_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_s_[4],t,1)}
    function set_key2(t,k){return caml_call3(_s_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_s_[6],t,1)}
    function check_key2(t){return caml_call2(_s_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_s_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_s_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_s_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_s_[9],t)}
    function get_data_copy$0(t){return caml_call1(_s_[10],t)}
    function set_data$0(t,d){return caml_call2(_s_[11],t,d)}
    function unset_data$0(t){return caml_call1(_s_[12],t)}
    function check_data$0(t){return caml_call1(_s_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_s_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$6(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _eq_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _eq_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2$0=match$0[1],k1$0=match[1];
          if(caml_call2(H1[1],k1,k1$0) && caml_call2(H2[1],k2,k2$0))return 0;
          return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _ep_=check_key1(c);return _ep_?check_key2(c):_ep_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$2(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_en_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_en_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _eo_=include[1];
      function create(sz){return caml_call2(_eo_,_cz_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$7(n){return caml_call1(_s_[1],n)}
    function length$6(k){return caml_call1(_s_[2],k)}
    function get_key$1(t,n){return caml_call2(_s_[3],t,n)}
    function get_key_copy$1(t,n){return caml_call2(_s_[4],t,n)}
    function set_key$1(t,n,k){return caml_call3(_s_[5],t,n,k)}
    function unset_key$1(t,n){return caml_call2(_s_[6],t,n)}
    function check_key$1(t,n){return caml_call2(_s_[7],t,n)}
    function blit_key$1(t1,o1,t2,o2,l)
     {return caml_call5(_s_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_s_[9],t)}
    function get_data_copy$1(t){return caml_call1(_s_[10],t)}
    function set_data$1(t,d){return caml_call2(_s_[11],t,d)}
    function unset_data$1(t){return caml_call1(_s_[12],t)}
    function check_data$1(t){return caml_call1(_s_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_s_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$7(k.length - 1);
        set_data$1(c,d);
        var _el_=k.length - 1 - 1 | 0,_ek_=0;
        if(! (_el_ < 0))
         {var i=_ek_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _em_=i + 1 | 0;
            if(_el_ !== i){var i=_em_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_eg_=k.length - 1 - 1 | 0,_ef_=0;
        if(! (_eg_ < 0))
         {var i=_ef_;
          for(;;)
           {var _eh_=h[1],_ei_=caml_check_bound(k,i)[1 + i];
            h[1] = (caml_call2(H[2],seed,_ei_) * 65599 | 0) + _eh_ | 0;
            var _ej_=i + 1 | 0;
            if(_eg_ !== i){var i=_ej_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$1(c,i);
            if(match)
             {var ki=match[1],_ee_=caml_check_bound(k,i)[1 + i];
              if(caml_call2(H[1],_ee_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$1(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$1(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[1 + i] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _ec_=k.length - 1 - 1 | 0,_eb_=0;
        if(! (_ec_ < 0))
         {var i=_eb_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _ed_=i + 1 | 0;
            if(_ec_ !== i){var i=_ed_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _d__=i < 0?1:0;
          if(_d__)
           var _d$_=_d__;
          else
           {var _ea_=check_key$1(c,i);
            if(_ea_){var i$0=i - 1 | 0,i=i$0;continue}
            var _d$_=_ea_}
          return _d$_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$3(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _d9_=include[1];
      function create(sz){return caml_call2(_d9_,_cA_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    var
     Stdlib_ephemeron=
      [0,
       [0,
        create$5,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$1,
        MakeSeeded$1],
       [0,
        create$6,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$2,
        MakeSeeded$2],
       [0,
        create$7,
        get_key$1,
        get_key_copy$1,
        set_key$1,
        unset_key$1,
        check_key$1,
        blit_key$1,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$3,
        MakeSeeded$3],
       [0,
        function(_d8_)
         {return MakeSeeded$0
                  ([0,_d8_[3],_d8_[1],_d8_[2],_d8_[5],_d8_[4],_d8_[6],_d8_[7]])}]];
    caml_register_global(769,Stdlib_ephemeron,"Stdlib__ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$98))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$99))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _d6_=caml_ml_string_length(n) < 1?1:0,
       _d7_=_d6_ || (47 !== caml_string_get(n,0)?1:0);
      return _d7_}
    function is_implicit(n)
     {var _d1_=is_relative(n);
      if(_d1_)
       {var
         _d2_=caml_ml_string_length(n) < 2?1:0,
         _d3_=_d2_ || caml_string_notequal(sub$0(n,0,2),cst$101);
        if(_d3_)
         var
          _d4_=caml_ml_string_length(n) < 3?1:0,
          _d5_=_d4_ || caml_string_notequal(sub$0(n,0,3),cst$100);
        else
         var _d5_=_d3_}
      else
       var _d5_=_d1_;
      return _d5_}
    function check_suffix(name,suff)
     {var
       _dZ_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _d0_=
        _dZ_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_dZ_;
      return _d0_}
    function chop_suffix_opt(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var r=sub$0(filename,len_f - len_s | 0,len_s);
        return caml_string_equal(r,suffix)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cI_=caml_sys_getenv(cst_TMPDIR),_cB_=_cI_}
    catch(_dY_)
     {_dY_ = caml_wrap_exception(_dY_);
      if(_dY_ !== Not_found)throw _dY_;
      var _cB_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,39);
      var _dW_=l - 1 | 0,_dV_=0;
      if(! (_dW_ < 0))
       {var i=_dV_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _dX_=i + 1 | 0;
          if(_dW_ !== i){var i=_dX_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function basename(_dU_)
     {return generic_basename(is_dir_sep,current_dir_name,_dU_)}
    function dirname(_dT_)
     {return generic_dirname(is_dir_sep,current_dir_name,_dT_)}
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_dQ_=47 === c?1:0;
      if(_dQ_)
       var _dR_=_dQ_;
      else
       var _dS_=92 === c?1:0,_dR_=_dS_ || (58 === c?1:0);
      return _dR_}
    function is_relative$0(n)
     {var
       _dK_=caml_ml_string_length(n) < 1?1:0,
       _dL_=_dK_ || (47 !== caml_string_get(n,0)?1:0);
      if(_dL_)
       {var
         _dM_=caml_ml_string_length(n) < 1?1:0,
         _dN_=_dM_ || (92 !== caml_string_get(n,0)?1:0);
        if(_dN_)
         var
          _dO_=caml_ml_string_length(n) < 2?1:0,
          _dP_=_dO_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _dP_=_dN_}
      else
       var _dP_=_dL_;
      return _dP_}
    function is_implicit$0(n)
     {var _dB_=is_relative$0(n);
      if(_dB_)
       {var
         _dC_=caml_ml_string_length(n) < 2?1:0,
         _dD_=_dC_ || caml_string_notequal(sub$0(n,0,2),cst$105);
        if(_dD_)
         {var
           _dE_=caml_ml_string_length(n) < 2?1:0,
           _dF_=_dE_ || caml_string_notequal(sub$0(n,0,2),cst$104);
          if(_dF_)
           {var
             _dG_=caml_ml_string_length(n) < 3?1:0,
             _dH_=_dG_ || caml_string_notequal(sub$0(n,0,3),cst$103);
            if(_dH_)
             var
              _dI_=caml_ml_string_length(n) < 3?1:0,
              _dJ_=_dI_ || caml_string_notequal(sub$0(n,0,3),cst$102);
            else
             var _dJ_=_dH_}
          else
           var _dJ_=_dF_}
        else
         var _dJ_=_dD_}
      else
       var _dJ_=_dB_;
      return _dJ_}
    function check_suffix$0(name,suff)
     {var _dy_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_dy_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _dz_=lowercase_ascii$1(suff),
        _dA_=caml_string_equal(lowercase_ascii$1(s),_dz_);
      else
       var _dA_=_dy_;
      return _dA_}
    function chop_suffix_opt$0(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var
         r=sub$0(filename,len_f - len_s | 0,len_s),
         _dx_=lowercase_ascii$1(suffix);
        return caml_string_equal(lowercase_ascii$1(r),_dx_)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cH_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cH_}
    catch(_dw_)
     {_dw_ = caml_wrap_exception(_dw_);
      if(_dw_ !== Not_found)throw _dw_;
      var temp_dir_name=cst$106}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _du_=1;
        if(! (n < 1))
         {var j=_du_;
          for(;;)
           {add_char(b,92);
            var _dv_=j + 1 | 0;
            if(n !== j){var j=_dv_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _ds_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_ds_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_ds_,i$0])}
          if(92 === c)
           {var _dt_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_dt_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_dt_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _dr_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_dr_)}
            return caml_trampoline_return(loop$0,[0,_dr_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function drive_and_path(s)
     {var _dn_=2 <= caml_ml_string_length(s)?1:0;
      if(_dn_)
       {var param=caml_string_get(s,0),switch$0=0;
        if(91 <= param)
         {if(! (25 < (param - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= param)switch$0 = 1;
        var _do_=switch$0?1:0,_dp_=_do_?58 === caml_string_get(s,1)?1:0:_do_}
      else
       var _dp_=_dn_;
      if(_dp_)
       {var _dq_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_dq_]}
      return [0,cst$107,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return symbol(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    function basename$1(_dm_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_dm_)}
    function dirname$1(_dl_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_dl_)}
    var switch$0=0;
    if(caml_string_notequal(os_type,cst_Cygwin))
     if(caml_string_notequal(os_type,cst_Win32))
      {var
        current_dir_name$2=current_dir_name,
        parent_dir_name$2=parent_dir_name,
        dir_sep$2=dir_sep,
        is_dir_sep$1=is_dir_sep,
        is_relative$1=is_relative,
        is_implicit$1=is_implicit,
        check_suffix$1=check_suffix,
        chop_suffix_opt$1=chop_suffix_opt,
        temp_dir_name$0=_cB_,
        quote$1=quote,
        basename$2=basename,
        dirname$2=dirname;
       switch$0 = 1}
     else
      var
       _cG_=
        [0,
         current_dir_name$0,
         parent_dir_name$0,
         dir_sep$0,
         is_dir_sep$0,
         is_relative$0,
         is_implicit$0,
         check_suffix$0,
         chop_suffix_opt$0,
         temp_dir_name,
         quote$0,
         basename$0,
         dirname$0];
    else
     var
      _cG_=
       [0,
        current_dir_name$1,
        parent_dir_name$1,
        dir_sep$1,
        is_dir_sep$0,
        is_relative$0,
        is_implicit$0,
        check_suffix$0,
        chop_suffix_opt$0,
        _cB_,
        quote,
        basename$1,
        dirname$1];
    if(! switch$0)
     var
      current_dir_name$2=_cG_[1],
      parent_dir_name$2=_cG_[2],
      dir_sep$2=_cG_[3],
      is_dir_sep$1=is_dir_sep$0,
      is_relative$1=is_relative$0,
      is_implicit$1=is_implicit$0,
      check_suffix$1=check_suffix$0,
      chop_suffix_opt$1=chop_suffix_opt$0,
      temp_dir_name$0=_cG_[9],
      quote$1=_cG_[10],
      basename$2=_cG_[11],
      dirname$2=_cG_[12];
    function concat$3(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l && ! is_dir_sep$1(dirname,l - 1 | 0))
       return symbol(dirname,symbol(dir_sep$2,filename));
      return symbol(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1 && ! is_dir_sep$1(name,i$1))
         {if(46 === caml_string_get(name,i$1))
           {var i$2=i$1 - 1 | 0,i=i$2;
            for(;;)
             {if(0 <= i && ! is_dir_sep$1(name,i))
               {if(46 === caml_string_get(name,i))
                 {var i$0=i - 1 | 0,i=i$0;continue}
                return caml_ml_string_length(name) - i$1 | 0}
              return 0}}
          var i$3=i$1 - 1 | 0,i$1=i$3;
          continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$108:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_dk_){return caml_call1(_b4_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _di_=caml_obj_tag(prng$0),
       _dj_=
        250 === _di_?prng$0[1]:246 === _di_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b4_[4],_dj_) & 16777215;
      return concat$3(temp_dir,caml_call3(sprintf(_cC_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cD_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_dg_,_df_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cE_;
      if(_dg_)var sth$0=_dg_[1],perms=sth$0;else var perms=384;
      if(_df_)
       var sth$1=_df_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _dh_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _dh_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Stdlib_filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$3,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1];
    caml_register_global(770,Stdlib_filename,"Stdlib__filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$4(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$4,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0. && x[2] == 0.)return _cF_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _de_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_de_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Stdlib_complex=
      [0,
       zero$4,
       one$4,
       i,
       neg,
       conj,
       add$1,
       sub$4,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(771,Stdlib_complex,"Stdlib__complex");
    var
     Stdlib_arrayLabels=
      [0,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       map$5,
       iteri$2,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       exists$0,
       for_all$0,
       mem$0,
       memq$0,
       make_float,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(772,Stdlib_arrayLabels,"Stdlib__arrayLabels");
    var
     Stdlib_listLabels=
      [0,
       length,
       hd,
       compare_lengths,
       compare_length_with,
       cons,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$2,
       iteri,
       map$2,
       mapi,
       rev_map,
       filter_map$0,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(773,Stdlib_listLabels,"Stdlib__listLabels");
    var
     Stdlib_bytesLabels=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$3,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$4,
       equal$4,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(774,Stdlib_bytesLabels,"Stdlib__bytesLabels");
    var
     Stdlib_stringLabels=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$4,
       iteri$1,
       map$4,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$5,
       equal$5,
       split_on_char,
       to_seq$3,
       to_seqi$0,
       of_seq$1];
    caml_register_global(775,Stdlib_stringLabels,"Stdlib__stringLabels");
    var Stdlib_moreLabels=[0,Stdlib_hashtbl,Stdlib_map,Stdlib_set];
    caml_register_global(776,Stdlib_moreLabels,"Stdlib__moreLabels");
    var Stdlib_stdLabels=[0];
    caml_register_global(777,Stdlib_stdLabels,"Stdlib__stdLabels");
    var enabled=caml_spacetime_enabled(0);
    function if_spacetime_enabled(f){return enabled?caml_call1(f,0):0}
    function create$8(path)
     {if(caml_spacetime_enabled(0))
       {var channel=open_out(path),t=[0,channel,0];
        caml_spacetime_only_works_for_(t[1]);
        return t}
      return [0,stdout,1]}
    function save_event(time,t,event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_(time,t[1],event_name)})}
    function save_and_close(time,t)
     {return if_spacetime_enabled
              (function(param)
                {if(t[2])failwith(cst_Series_is_closed);
                 caml_spacetime_only_works_for_(time,t[1]);
                 close_out(t[1]);
                 t[2] = 1;
                 return 0})}
    var Series=[0,create$8,save_event,save_and_close];
    function take$0(time,param)
     {var channel=param[1],closed=param[2];
      return if_spacetime_enabled
              (function(param)
                {if(closed)failwith(cst_Series_is_closed$0);
                 runtime.caml_gc_minor(0);
                 return caml_spacetime_only_works_for_(time,channel)})}
    var Snapshot=[0,take$0];
    function save_event_for_automatic_snaps(event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_(event_name)})}
    var
     Stdlib_spacetime=
      [0,enabled,Series,Snapshot,save_event_for_automatic_snaps];
    caml_register_global(778,Stdlib_spacetime,"Stdlib__spacetime");
    var
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32$1=6,
     int64$1=7,
     int$2=8,
     nativeint$1=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return 4;
        case 9:return 4;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_db_=n - 1 | 0,_da_=0;
      if(! (_db_ < 0))
       {var i=_da_;
        for(;;)
         {var _dc_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[1 + i] = _dc_;
          var _dd_=i + 1 | 0;
          if(_db_ !== i){var i=_dd_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var _c$_=fold_left$1(caml_mul,1,dims(arr));
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c$_)}
    var Genarray=[0,dims,size_in_bytes];
    function create$9(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get$1(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set$0(arr)
     {var _c9_=[0];
      return function(_c__){return runtime.caml_ba_set_generic(arr,_c9_,_c__)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create$9(kind,layout);caml_call1(set$0(a),v);return a}
    function create$10(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _c8_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c8_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return 0 === match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function of_array(kind,layout,data)
     {var
       ba=create$10(kind,layout,data.length - 1),
       ofs=0 === layout?0:1,
       _c6_=data.length - 1 - 1 | 0,
       _c5_=0;
      if(! (_c6_ < 0))
       {var i=_c5_;
        for(;;)
         {runtime.caml_ba_set_1
           (ba,i + ofs | 0,caml_check_bound(data,i)[1 + i]);
          var _c7_=i + 1 | 0;
          if(_c6_ !== i){var i=_c7_;continue}
          break}}
      return ba}
    function create$11(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _c3_=caml_ba_dim_2(arr),_c4_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c4_),_c3_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$11(kind,layout,dim1,dim2),
       ofs=0 === layout?0:1,
       _cY_=dim1 - 1 | 0,
       _cX_=0;
      if(! (_cY_ < 0))
       {var i=_cX_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array2_of_array_n);
          var _c0_=dim2 - 1 | 0,_cZ_=0;
          if(! (_c0_ < 0))
           {var j=_cZ_;
            for(;;)
             {runtime.caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[1 + j]);
              var _c2_=j + 1 | 0;
              if(_c0_ !== j){var j=_c2_;continue}
              break}}
          var _c1_=i + 1 | 0;
          if(_cY_ !== i){var i=_c1_;continue}
          break}}
      return ba}
    function create$12(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _cU_=runtime.caml_ba_dim_3(arr),
       _cV_=caml_ba_dim_2(arr),
       _cW_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_cW_),_cV_),
               _cU_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$12(kind,layout,dim1,dim2,dim3),
       ofs=0 === layout?0:1,
       _cM_=dim1 - 1 | 0,
       _cL_=0;
      if(! (_cM_ < 0))
       {var i=_cL_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array3_of_array_n);
          var _cO_=dim2 - 1 | 0,_cN_=0;
          if(! (_cO_ < 0))
           {var j=_cN_;
            for(;;)
             {var col=caml_check_bound(row,j)[1 + j];
              if(col.length - 1 !== dim3)
               invalid_arg(cst_Bigarray_Array3_of_array_n$0);
              var _cR_=dim3 - 1 | 0,_cQ_=0;
              if(! (_cR_ < 0))
               {var k=_cQ_;
                for(;;)
                 {runtime.caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[1 + k]);
                  var _cT_=k + 1 | 0;
                  if(_cR_ !== k){var k=_cT_;continue}
                  break}}
              var _cS_=j + 1 | 0;
              if(_cO_ !== j){var j=_cS_;continue}
              break}}
          var _cP_=i + 1 | 0;
          if(_cM_ !== i){var i=_cP_;continue}
          break}}
      return ba}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array0_of_genarra)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array1_of_genarra)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array2_of_genarra)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array3_of_genarra)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Stdlib_bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$2,
       int32$1,
       int64$1,
       nativeint$1,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       Genarray,
       [0,create$9,caml_ba_change_layout,size_in_bytes$0,get$1,set$0,of_value],
       [0,create$10,caml_ba_change_layout,size_in_bytes$1,slice,of_array],
       [0,
        create$11,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$12,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    caml_register_global(779,Stdlib_bigarray,"Stdlib__bigarray");
    return}
  (function(){return this}()));


//# 1 "../../.js/js_of_ocaml/js_of_ocaml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_array=runtime.caml_string_of_array,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_string_of_jsbytes("parseFloat"),
     cst_parseInt=caml_string_of_jsbytes("parseInt"),
     cst_Js_of_ocaml_Js_Error=caml_string_of_jsbytes("Js_of_ocaml__Js.Error"),
     cst_jsError=caml_string_of_jsbytes("jsError"),
     cst_can_t_retrieve_file_name_n=
      caml_string_of_jsbytes("can't retrieve file name: not implemented"),
     cst_endings=caml_string_of_jsbytes("endings"),
     cst_type=caml_string_of_jsbytes("type"),
     cst_loadstart=caml_string_of_jsbytes("loadstart"),
     cst_progress=caml_string_of_jsbytes("progress"),
     cst_abort=caml_string_of_jsbytes("abort"),
     cst_error=caml_string_of_jsbytes("error"),
     cst_load=caml_string_of_jsbytes("load"),
     cst_loadend=caml_string_of_jsbytes("loadend"),
     cst_a$1=caml_string_of_jsbytes("a"),
     cst_area$1=caml_string_of_jsbytes("area"),
     cst_audio$1=caml_string_of_jsbytes("audio"),
     cst_base$1=caml_string_of_jsbytes("base"),
     cst_blockquote$1=caml_string_of_jsbytes("blockquote"),
     cst_body$1=caml_string_of_jsbytes("body"),
     cst_br$1=caml_string_of_jsbytes("br"),
     cst_button$1=caml_string_of_jsbytes("button"),
     cst_canvas$1=caml_string_of_jsbytes("canvas"),
     cst_caption$1=caml_string_of_jsbytes("caption"),
     cst_col$1=caml_string_of_jsbytes("col"),
     cst_colgroup$1=caml_string_of_jsbytes("colgroup"),
     cst_del$1=caml_string_of_jsbytes("del"),
     cst_div$1=caml_string_of_jsbytes("div"),
     cst_dl$1=caml_string_of_jsbytes("dl"),
     cst_embed$1=caml_string_of_jsbytes("embed"),
     cst_fieldset$1=caml_string_of_jsbytes("fieldset"),
     cst_form$1=caml_string_of_jsbytes("form"),
     cst_frame$1=caml_string_of_jsbytes("frame"),
     cst_frameset$1=caml_string_of_jsbytes("frameset"),
     cst_h1$1=caml_string_of_jsbytes("h1"),
     cst_h2$1=caml_string_of_jsbytes("h2"),
     cst_h3$1=caml_string_of_jsbytes("h3"),
     cst_h4$1=caml_string_of_jsbytes("h4"),
     cst_h5$1=caml_string_of_jsbytes("h5"),
     cst_h6$1=caml_string_of_jsbytes("h6"),
     cst_head$1=caml_string_of_jsbytes("head"),
     cst_hr$1=caml_string_of_jsbytes("hr"),
     cst_html$1=caml_string_of_jsbytes("html"),
     cst_iframe$1=caml_string_of_jsbytes("iframe"),
     cst_img$1=caml_string_of_jsbytes("img"),
     cst_input$2=caml_string_of_jsbytes("input"),
     cst_ins$1=caml_string_of_jsbytes("ins"),
     cst_label$1=caml_string_of_jsbytes("label"),
     cst_legend$1=caml_string_of_jsbytes("legend"),
     cst_li$1=caml_string_of_jsbytes("li"),
     cst_link$1=caml_string_of_jsbytes("link"),
     cst_map$1=caml_string_of_jsbytes("map"),
     cst_meta$1=caml_string_of_jsbytes("meta"),
     cst_object$1=caml_string_of_jsbytes("object"),
     cst_ol$1=caml_string_of_jsbytes("ol"),
     cst_optgroup$1=caml_string_of_jsbytes("optgroup"),
     cst_option$1=caml_string_of_jsbytes("option"),
     cst_p$1=caml_string_of_jsbytes("p"),
     cst_param$1=caml_string_of_jsbytes("param"),
     cst_pre$1=caml_string_of_jsbytes("pre"),
     cst_q$1=caml_string_of_jsbytes("q"),
     cst_script$1=caml_string_of_jsbytes("script"),
     cst_select$2=caml_string_of_jsbytes("select"),
     cst_style$1=caml_string_of_jsbytes("style"),
     cst_table$1=caml_string_of_jsbytes("table"),
     cst_tbody$1=caml_string_of_jsbytes("tbody"),
     cst_td$1=caml_string_of_jsbytes("td"),
     cst_textarea$1=caml_string_of_jsbytes("textarea"),
     cst_tfoot$1=caml_string_of_jsbytes("tfoot"),
     cst_th$1=caml_string_of_jsbytes("th"),
     cst_thead$1=caml_string_of_jsbytes("thead"),
     cst_title$1=caml_string_of_jsbytes("title"),
     cst_tr$1=caml_string_of_jsbytes("tr"),
     cst_ul$1=caml_string_of_jsbytes("ul"),
     cst_video$1=caml_string_of_jsbytes("video"),
     cst_KeyH=caml_string_of_jsbytes("KeyH"),
     cst_Digit6=caml_string_of_jsbytes("Digit6"),
     cst_BrowserRefresh=caml_string_of_jsbytes("BrowserRefresh"),
     cst_Backslash=caml_string_of_jsbytes("Backslash"),
     cst_AltLeft=caml_string_of_jsbytes("AltLeft"),
     cst_AltRight=caml_string_of_jsbytes("AltRight"),
     cst_ArrowDown=caml_string_of_jsbytes("ArrowDown"),
     cst_ArrowLeft=caml_string_of_jsbytes("ArrowLeft"),
     cst_ArrowRight=caml_string_of_jsbytes("ArrowRight"),
     cst_ArrowUp=caml_string_of_jsbytes("ArrowUp"),
     cst_Backquote=caml_string_of_jsbytes("Backquote"),
     cst_Backspace=caml_string_of_jsbytes("Backspace"),
     cst_BracketLeft=caml_string_of_jsbytes("BracketLeft"),
     cst_BracketRight=caml_string_of_jsbytes("BracketRight"),
     cst_BrowserBack=caml_string_of_jsbytes("BrowserBack"),
     cst_BrowserFavorites=caml_string_of_jsbytes("BrowserFavorites"),
     cst_BrowserForward=caml_string_of_jsbytes("BrowserForward"),
     cst_BrowserHome=caml_string_of_jsbytes("BrowserHome"),
     cst_Delete=caml_string_of_jsbytes("Delete"),
     cst_BrowserSearch=caml_string_of_jsbytes("BrowserSearch"),
     cst_BrowserStop=caml_string_of_jsbytes("BrowserStop"),
     cst_CapsLock=caml_string_of_jsbytes("CapsLock"),
     cst_Comma=caml_string_of_jsbytes("Comma"),
     cst_ContextMenu=caml_string_of_jsbytes("ContextMenu"),
     cst_ControlLeft=caml_string_of_jsbytes("ControlLeft"),
     cst_ControlRight=caml_string_of_jsbytes("ControlRight"),
     cst_Digit0=caml_string_of_jsbytes("Digit0"),
     cst_Digit1=caml_string_of_jsbytes("Digit1"),
     cst_Digit2=caml_string_of_jsbytes("Digit2"),
     cst_Digit3=caml_string_of_jsbytes("Digit3"),
     cst_Digit4=caml_string_of_jsbytes("Digit4"),
     cst_Digit5=caml_string_of_jsbytes("Digit5"),
     cst_F6=caml_string_of_jsbytes("F6"),
     cst_F1=caml_string_of_jsbytes("F1"),
     cst_Digit7=caml_string_of_jsbytes("Digit7"),
     cst_Digit8=caml_string_of_jsbytes("Digit8"),
     cst_Digit9=caml_string_of_jsbytes("Digit9"),
     cst_End=caml_string_of_jsbytes("End"),
     cst_Enter=caml_string_of_jsbytes("Enter"),
     cst_Equal=caml_string_of_jsbytes("Equal"),
     cst_Escape=caml_string_of_jsbytes("Escape"),
     cst_F10=caml_string_of_jsbytes("F10"),
     cst_F11=caml_string_of_jsbytes("F11"),
     cst_F12=caml_string_of_jsbytes("F12"),
     cst_F2=caml_string_of_jsbytes("F2"),
     cst_F3=caml_string_of_jsbytes("F3"),
     cst_F4=caml_string_of_jsbytes("F4"),
     cst_F5=caml_string_of_jsbytes("F5"),
     cst_KeyA=caml_string_of_jsbytes("KeyA"),
     cst_F7=caml_string_of_jsbytes("F7"),
     cst_F8=caml_string_of_jsbytes("F8"),
     cst_F9=caml_string_of_jsbytes("F9"),
     cst_Home=caml_string_of_jsbytes("Home"),
     cst_Insert=caml_string_of_jsbytes("Insert"),
     cst_IntlBackslash=caml_string_of_jsbytes("IntlBackslash"),
     cst_IntlYen=caml_string_of_jsbytes("IntlYen"),
     cst_KeyB=caml_string_of_jsbytes("KeyB"),
     cst_KeyC=caml_string_of_jsbytes("KeyC"),
     cst_KeyD=caml_string_of_jsbytes("KeyD"),
     cst_KeyE=caml_string_of_jsbytes("KeyE"),
     cst_KeyF=caml_string_of_jsbytes("KeyF"),
     cst_KeyG=caml_string_of_jsbytes("KeyG"),
     cst_Numpad4=caml_string_of_jsbytes("Numpad4"),
     cst_KeyX=caml_string_of_jsbytes("KeyX"),
     cst_KeyP=caml_string_of_jsbytes("KeyP"),
     cst_KeyI=caml_string_of_jsbytes("KeyI"),
     cst_KeyJ=caml_string_of_jsbytes("KeyJ"),
     cst_KeyK=caml_string_of_jsbytes("KeyK"),
     cst_KeyL=caml_string_of_jsbytes("KeyL"),
     cst_KeyM=caml_string_of_jsbytes("KeyM"),
     cst_KeyN=caml_string_of_jsbytes("KeyN"),
     cst_KeyO=caml_string_of_jsbytes("KeyO"),
     cst_KeyQ=caml_string_of_jsbytes("KeyQ"),
     cst_KeyR=caml_string_of_jsbytes("KeyR"),
     cst_KeyS=caml_string_of_jsbytes("KeyS"),
     cst_KeyT=caml_string_of_jsbytes("KeyT"),
     cst_KeyU=caml_string_of_jsbytes("KeyU"),
     cst_KeyV=caml_string_of_jsbytes("KeyV"),
     cst_KeyW=caml_string_of_jsbytes("KeyW"),
     cst_MetaRight=caml_string_of_jsbytes("MetaRight"),
     cst_KeyY=caml_string_of_jsbytes("KeyY"),
     cst_KeyZ=caml_string_of_jsbytes("KeyZ"),
     cst_MediaPlayPause=caml_string_of_jsbytes("MediaPlayPause"),
     cst_MediaStop=caml_string_of_jsbytes("MediaStop"),
     cst_MediaTrackNext=caml_string_of_jsbytes("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_string_of_jsbytes("MediaTrackPrevious"),
     cst_MetaLeft=caml_string_of_jsbytes("MetaLeft"),
     cst_Minus=caml_string_of_jsbytes("Minus"),
     cst_NumLock=caml_string_of_jsbytes("NumLock"),
     cst_Numpad0=caml_string_of_jsbytes("Numpad0"),
     cst_Numpad1=caml_string_of_jsbytes("Numpad1"),
     cst_Numpad2=caml_string_of_jsbytes("Numpad2"),
     cst_Numpad3=caml_string_of_jsbytes("Numpad3"),
     cst_PageUp=caml_string_of_jsbytes("PageUp"),
     cst_NumpadDivide=caml_string_of_jsbytes("NumpadDivide"),
     cst_Numpad5=caml_string_of_jsbytes("Numpad5"),
     cst_Numpad6=caml_string_of_jsbytes("Numpad6"),
     cst_Numpad7=caml_string_of_jsbytes("Numpad7"),
     cst_Numpad8=caml_string_of_jsbytes("Numpad8"),
     cst_Numpad9=caml_string_of_jsbytes("Numpad9"),
     cst_NumpadAdd=caml_string_of_jsbytes("NumpadAdd"),
     cst_NumpadDecimal=caml_string_of_jsbytes("NumpadDecimal"),
     cst_NumpadEnter=caml_string_of_jsbytes("NumpadEnter"),
     cst_NumpadEqual=caml_string_of_jsbytes("NumpadEqual"),
     cst_NumpadMultiply=caml_string_of_jsbytes("NumpadMultiply"),
     cst_NumpadSubtract=caml_string_of_jsbytes("NumpadSubtract"),
     cst_OSLeft=caml_string_of_jsbytes("OSLeft"),
     cst_OSRight=caml_string_of_jsbytes("OSRight"),
     cst_PageDown=caml_string_of_jsbytes("PageDown"),
     cst_ShiftRight=caml_string_of_jsbytes("ShiftRight"),
     cst_Pause=caml_string_of_jsbytes("Pause"),
     cst_Period=caml_string_of_jsbytes("Period"),
     cst_PrintScreen=caml_string_of_jsbytes("PrintScreen"),
     cst_Quote=caml_string_of_jsbytes("Quote"),
     cst_ScrollLock=caml_string_of_jsbytes("ScrollLock"),
     cst_Semicolon=caml_string_of_jsbytes("Semicolon"),
     cst_ShiftLeft=caml_string_of_jsbytes("ShiftLeft"),
     cst_Slash=caml_string_of_jsbytes("Slash"),
     cst_Space=caml_string_of_jsbytes("Space"),
     cst_Tab=caml_string_of_jsbytes("Tab"),
     cst_VolumeDown=caml_string_of_jsbytes("VolumeDown"),
     cst_VolumeMute=caml_string_of_jsbytes("VolumeMute"),
     cst_VolumeUp=caml_string_of_jsbytes("VolumeUp"),
     cst_mouseout$0=caml_string_of_jsbytes("mouseout"),
     cst_mouseover$0=caml_string_of_jsbytes("mouseover"),
     cst_video$0=caml_string_of_jsbytes("video"),
     cst_audio$0=caml_string_of_jsbytes("audio"),
     cst_ul$0=caml_string_of_jsbytes("ul"),
     cst_tr$0=caml_string_of_jsbytes("tr"),
     cst_title$0=caml_string_of_jsbytes("title"),
     cst_thead$0=caml_string_of_jsbytes("thead"),
     cst_th$0=caml_string_of_jsbytes("th"),
     cst_tfoot$0=caml_string_of_jsbytes("tfoot"),
     cst_textarea$0=caml_string_of_jsbytes("textarea"),
     cst_td$0=caml_string_of_jsbytes("td"),
     cst_tbody$0=caml_string_of_jsbytes("tbody"),
     cst_table$0=caml_string_of_jsbytes("table"),
     cst_style$0=caml_string_of_jsbytes("style"),
     cst_select$1=caml_string_of_jsbytes("select"),
     cst_script$0=caml_string_of_jsbytes("script"),
     cst_q$0=caml_string_of_jsbytes("q"),
     cst_pre$0=caml_string_of_jsbytes("pre"),
     cst_param$0=caml_string_of_jsbytes("param"),
     cst_p$0=caml_string_of_jsbytes("p"),
     cst_option$0=caml_string_of_jsbytes("option"),
     cst_optgroup$0=caml_string_of_jsbytes("optgroup"),
     cst_ol$0=caml_string_of_jsbytes("ol"),
     cst_object$0=caml_string_of_jsbytes("object"),
     cst_meta$0=caml_string_of_jsbytes("meta"),
     cst_map$0=caml_string_of_jsbytes("map"),
     cst_link$0=caml_string_of_jsbytes("link"),
     cst_li$0=caml_string_of_jsbytes("li"),
     cst_legend$0=caml_string_of_jsbytes("legend"),
     cst_label$0=caml_string_of_jsbytes("label"),
     cst_ins$0=caml_string_of_jsbytes("ins"),
     cst_input$1=caml_string_of_jsbytes("input"),
     cst_img$0=caml_string_of_jsbytes("img"),
     cst_iframe$0=caml_string_of_jsbytes("iframe"),
     cst_html$0=caml_string_of_jsbytes("html"),
     cst_hr$0=caml_string_of_jsbytes("hr"),
     cst_head$0=caml_string_of_jsbytes("head"),
     cst_h6$0=caml_string_of_jsbytes("h6"),
     cst_h5$0=caml_string_of_jsbytes("h5"),
     cst_h4$0=caml_string_of_jsbytes("h4"),
     cst_h3$0=caml_string_of_jsbytes("h3"),
     cst_h2$0=caml_string_of_jsbytes("h2"),
     cst_h1$0=caml_string_of_jsbytes("h1"),
     cst_frame$0=caml_string_of_jsbytes("frame"),
     cst_frameset$0=caml_string_of_jsbytes("frameset"),
     cst_form$0=caml_string_of_jsbytes("form"),
     cst_embed$0=caml_string_of_jsbytes("embed"),
     cst_fieldset$0=caml_string_of_jsbytes("fieldset"),
     cst_dl$0=caml_string_of_jsbytes("dl"),
     cst_div$0=caml_string_of_jsbytes("div"),
     cst_del$0=caml_string_of_jsbytes("del"),
     cst_colgroup$0=caml_string_of_jsbytes("colgroup"),
     cst_col$0=caml_string_of_jsbytes("col"),
     cst_caption$0=caml_string_of_jsbytes("caption"),
     cst_canvas$0=caml_string_of_jsbytes("canvas"),
     cst_button$0=caml_string_of_jsbytes("button"),
     cst_br$0=caml_string_of_jsbytes("br"),
     cst_body$0=caml_string_of_jsbytes("body"),
     cst_blockquote$0=caml_string_of_jsbytes("blockquote"),
     cst_base$0=caml_string_of_jsbytes("base"),
     cst_area$0=caml_string_of_jsbytes("area"),
     cst_a$0=caml_string_of_jsbytes("a"),
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_video=caml_string_of_jsbytes("video"),
     cst_audio=caml_string_of_jsbytes("audio"),
     cst_iframe=caml_string_of_jsbytes("iframe"),
     cst_frame=caml_string_of_jsbytes("frame"),
     cst_frameset=caml_string_of_jsbytes("frameset"),
     cst_address=caml_string_of_jsbytes("address"),
     cst_noscript=caml_string_of_jsbytes("noscript"),
     cst_dt=caml_string_of_jsbytes("dt"),
     cst_dd=caml_string_of_jsbytes("dd"),
     cst_abbr=caml_string_of_jsbytes("abbr"),
     cst_var=caml_string_of_jsbytes("var"),
     cst_kbd=caml_string_of_jsbytes("kbd"),
     cst_samp=caml_string_of_jsbytes("samp"),
     cst_code=caml_string_of_jsbytes("code"),
     cst_dfn=caml_string_of_jsbytes("dfn"),
     cst_cite=caml_string_of_jsbytes("cite"),
     cst_strong=caml_string_of_jsbytes("strong"),
     cst_em=caml_string_of_jsbytes("em"),
     cst_small=caml_string_of_jsbytes("small"),
     cst_big=caml_string_of_jsbytes("big"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_i=caml_string_of_jsbytes("i"),
     cst_tt=caml_string_of_jsbytes("tt"),
     cst_span=caml_string_of_jsbytes("span"),
     cst_sup=caml_string_of_jsbytes("sup"),
     cst_sub=caml_string_of_jsbytes("sub"),
     cst_td=caml_string_of_jsbytes("td"),
     cst_th=caml_string_of_jsbytes("th"),
     cst_tr=caml_string_of_jsbytes("tr"),
     cst_tbody=caml_string_of_jsbytes("tbody"),
     cst_tfoot=caml_string_of_jsbytes("tfoot"),
     cst_thead=caml_string_of_jsbytes("thead"),
     cst_colgroup=caml_string_of_jsbytes("colgroup"),
     cst_col=caml_string_of_jsbytes("col"),
     cst_caption=caml_string_of_jsbytes("caption"),
     cst_table=caml_string_of_jsbytes("table"),
     cst_script=caml_string_of_jsbytes("script"),
     cst_area=caml_string_of_jsbytes("area"),
     cst_map=caml_string_of_jsbytes("map"),
     cst_param=caml_string_of_jsbytes("param"),
     cst_object=caml_string_of_jsbytes("object"),
     cst_img=caml_string_of_jsbytes("img"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_del=caml_string_of_jsbytes("del"),
     cst_ins=caml_string_of_jsbytes("ins"),
     cst_hr=caml_string_of_jsbytes("hr"),
     cst_br=caml_string_of_jsbytes("br"),
     cst_pre=caml_string_of_jsbytes("pre"),
     cst_blockquote=caml_string_of_jsbytes("blockquote"),
     cst_q=caml_string_of_jsbytes("q"),
     cst_h6=caml_string_of_jsbytes("h6"),
     cst_h5=caml_string_of_jsbytes("h5"),
     cst_h4=caml_string_of_jsbytes("h4"),
     cst_h3=caml_string_of_jsbytes("h3"),
     cst_h2=caml_string_of_jsbytes("h2"),
     cst_h1=caml_string_of_jsbytes("h1"),
     cst_p=caml_string_of_jsbytes("p"),
     cst_embed=caml_string_of_jsbytes("embed"),
     cst_div=caml_string_of_jsbytes("div"),
     cst_li=caml_string_of_jsbytes("li"),
     cst_dl=caml_string_of_jsbytes("dl"),
     cst_ol=caml_string_of_jsbytes("ol"),
     cst_ul=caml_string_of_jsbytes("ul"),
     cst_legend=caml_string_of_jsbytes("legend"),
     cst_fieldset=caml_string_of_jsbytes("fieldset"),
     cst_label=caml_string_of_jsbytes("label"),
     cst_button=caml_string_of_jsbytes("button"),
     cst_textarea=caml_string_of_jsbytes("textarea"),
     cst_input$0=caml_string_of_jsbytes("input"),
     cst_select$0=caml_string_of_jsbytes("select"),
     cst_option=caml_string_of_jsbytes("option"),
     cst_optgroup=caml_string_of_jsbytes("optgroup"),
     cst_form=caml_string_of_jsbytes("form"),
     cst_body=caml_string_of_jsbytes("body"),
     cst_style=caml_string_of_jsbytes("style"),
     cst_base=caml_string_of_jsbytes("base"),
     cst_meta=caml_string_of_jsbytes("meta"),
     cst_title=caml_string_of_jsbytes("title"),
     cst_link=caml_string_of_jsbytes("link"),
     cst_head=caml_string_of_jsbytes("head"),
     cst_html=caml_string_of_jsbytes("html"),
     cst_click=caml_string_of_jsbytes("click"),
     cst_dblclick=caml_string_of_jsbytes("dblclick"),
     cst_mousedown=caml_string_of_jsbytes("mousedown"),
     cst_mouseup=caml_string_of_jsbytes("mouseup"),
     cst_mouseover=caml_string_of_jsbytes("mouseover"),
     cst_mousemove=caml_string_of_jsbytes("mousemove"),
     cst_mouseout=caml_string_of_jsbytes("mouseout"),
     cst_keypress=caml_string_of_jsbytes("keypress"),
     cst_keydown=caml_string_of_jsbytes("keydown"),
     cst_keyup=caml_string_of_jsbytes("keyup"),
     cst_mousewheel=caml_string_of_jsbytes("mousewheel"),
     cst_DOMMouseScroll=caml_string_of_jsbytes("DOMMouseScroll"),
     cst_touchstart=caml_string_of_jsbytes("touchstart"),
     cst_touchmove=caml_string_of_jsbytes("touchmove"),
     cst_touchend=caml_string_of_jsbytes("touchend"),
     cst_touchcancel=caml_string_of_jsbytes("touchcancel"),
     cst_dragstart=caml_string_of_jsbytes("dragstart"),
     cst_dragend=caml_string_of_jsbytes("dragend"),
     cst_dragenter=caml_string_of_jsbytes("dragenter"),
     cst_dragover=caml_string_of_jsbytes("dragover"),
     cst_dragleave=caml_string_of_jsbytes("dragleave"),
     cst_drag=caml_string_of_jsbytes("drag"),
     cst_drop=caml_string_of_jsbytes("drop"),
     cst_hashchange=caml_string_of_jsbytes("hashchange"),
     cst_change=caml_string_of_jsbytes("change"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_timeupdate=caml_string_of_jsbytes("timeupdate"),
     cst_submit=caml_string_of_jsbytes("submit"),
     cst_scroll=caml_string_of_jsbytes("scroll"),
     cst_focus=caml_string_of_jsbytes("focus"),
     cst_blur=caml_string_of_jsbytes("blur"),
     cst_load$0=caml_string_of_jsbytes("load"),
     cst_unload=caml_string_of_jsbytes("unload"),
     cst_beforeunload=caml_string_of_jsbytes("beforeunload"),
     cst_resize=caml_string_of_jsbytes("resize"),
     cst_orientationchange=caml_string_of_jsbytes("orientationchange"),
     cst_popstate=caml_string_of_jsbytes("popstate"),
     cst_error$0=caml_string_of_jsbytes("error"),
     cst_abort$0=caml_string_of_jsbytes("abort"),
     cst_select=caml_string_of_jsbytes("select"),
     cst_online=caml_string_of_jsbytes("online"),
     cst_offline=caml_string_of_jsbytes("offline"),
     cst_checking=caml_string_of_jsbytes("checking"),
     cst_noupdate=caml_string_of_jsbytes("noupdate"),
     cst_downloading=caml_string_of_jsbytes("downloading"),
     cst_progress$0=caml_string_of_jsbytes("progress"),
     cst_updateready=caml_string_of_jsbytes("updateready"),
     cst_cached=caml_string_of_jsbytes("cached"),
     cst_obsolete=caml_string_of_jsbytes("obsolete"),
     cst_DOMContentLoaded=caml_string_of_jsbytes("DOMContentLoaded"),
     cst_animationstart=caml_string_of_jsbytes("animationstart"),
     cst_animationend=caml_string_of_jsbytes("animationend"),
     cst_animationiteration=caml_string_of_jsbytes("animationiteration"),
     cst_animationcancel=caml_string_of_jsbytes("animationcancel"),
     cst_canplay=caml_string_of_jsbytes("canplay"),
     cst_canplaythrough=caml_string_of_jsbytes("canplaythrough"),
     cst_durationchange=caml_string_of_jsbytes("durationchange"),
     cst_emptied=caml_string_of_jsbytes("emptied"),
     cst_ended=caml_string_of_jsbytes("ended"),
     cst_gotpointercapture=caml_string_of_jsbytes("gotpointercapture"),
     cst_loadeddata=caml_string_of_jsbytes("loadeddata"),
     cst_loadedmetadata=caml_string_of_jsbytes("loadedmetadata"),
     cst_loadstart$0=caml_string_of_jsbytes("loadstart"),
     cst_lostpointercapture=caml_string_of_jsbytes("lostpointercapture"),
     cst_pause=caml_string_of_jsbytes("pause"),
     cst_play=caml_string_of_jsbytes("play"),
     cst_playing=caml_string_of_jsbytes("playing"),
     cst_pointerenter=caml_string_of_jsbytes("pointerenter"),
     cst_pointercancel=caml_string_of_jsbytes("pointercancel"),
     cst_pointerdown=caml_string_of_jsbytes("pointerdown"),
     cst_pointerleave=caml_string_of_jsbytes("pointerleave"),
     cst_pointermove=caml_string_of_jsbytes("pointermove"),
     cst_pointerout=caml_string_of_jsbytes("pointerout"),
     cst_pointerover=caml_string_of_jsbytes("pointerover"),
     cst_pointerup=caml_string_of_jsbytes("pointerup"),
     cst_ratechange=caml_string_of_jsbytes("ratechange"),
     cst_seeked=caml_string_of_jsbytes("seeked"),
     cst_seeking=caml_string_of_jsbytes("seeking"),
     cst_stalled=caml_string_of_jsbytes("stalled"),
     cst_suspend=caml_string_of_jsbytes("suspend"),
     cst_volumechange=caml_string_of_jsbytes("volumechange"),
     cst_waiting=caml_string_of_jsbytes("waiting"),
     cst_Js_of_ocaml_Dom_html_Canva=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_html.Canvas_not_available"),
     cst_checkbox=caml_string_of_jsbytes("checkbox"),
     cst_file=caml_string_of_jsbytes("file"),
     cst_password=caml_string_of_jsbytes("password"),
     cst_radio=caml_string_of_jsbytes("radio"),
     cst_reset=caml_string_of_jsbytes("reset"),
     cst_submit$0=caml_string_of_jsbytes("submit"),
     cst_text=caml_string_of_jsbytes("text"),
     cst_readystatechange=caml_string_of_jsbytes("readystatechange"),
     cst_loadstart$1=caml_string_of_jsbytes("loadstart"),
     cst_progress$1=caml_string_of_jsbytes("progress"),
     cst_abort$1=caml_string_of_jsbytes("abort"),
     cst_error$1=caml_string_of_jsbytes("error"),
     cst_load$1=caml_string_of_jsbytes("load"),
     cst_timeout=caml_string_of_jsbytes("timeout"),
     cst_loadend$0=caml_string_of_jsbytes("loadend"),
     cst_Worker_onmessage_is_undefi$0=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefi=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_u=
      caml_string_of_jsbytes("Worker.import_scripts is undefined"),
     cst_webglcontextlost=caml_string_of_jsbytes("webglcontextlost"),
     cst_webglcontextrestored=caml_string_of_jsbytes("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_string_of_jsbytes("webglcontextcreationerror"),
     cst_g=caml_string_of_jsbytes("g"),
     cst=caml_string_of_jsbytes("[\\][()\\\\|+*.?{}^$]"),
     cst$37=caml_string_of_jsbytes(""),
     cst$13=caml_string_of_jsbytes(""),
     cst$21=caml_string_of_jsbytes(""),
     cst$14=caml_string_of_jsbytes("#"),
     cst$15=caml_string_of_jsbytes("?"),
     cst$20=caml_string_of_jsbytes(""),
     cst$16=caml_string_of_jsbytes("/"),
     cst$17=caml_string_of_jsbytes("/"),
     cst$19=caml_string_of_jsbytes(":"),
     cst$18=caml_string_of_jsbytes(""),
     cst_http$1=caml_string_of_jsbytes("http://"),
     cst$22=caml_string_of_jsbytes(""),
     cst$30=caml_string_of_jsbytes(""),
     cst$23=caml_string_of_jsbytes("#"),
     cst$24=caml_string_of_jsbytes("?"),
     cst$29=caml_string_of_jsbytes(""),
     cst$25=caml_string_of_jsbytes("/"),
     cst$26=caml_string_of_jsbytes("/"),
     cst$28=caml_string_of_jsbytes(":"),
     cst$27=caml_string_of_jsbytes(""),
     cst_https$1=caml_string_of_jsbytes("https://"),
     cst$31=caml_string_of_jsbytes(""),
     cst$36=caml_string_of_jsbytes(""),
     cst$32=caml_string_of_jsbytes("#"),
     cst$33=caml_string_of_jsbytes("?"),
     cst$35=caml_string_of_jsbytes(""),
     cst$34=caml_string_of_jsbytes("/"),
     cst_file$2=caml_string_of_jsbytes("file://"),
     cst$12=caml_string_of_jsbytes(""),
     cst$11=caml_string_of_jsbytes(""),
     cst$10=caml_string_of_jsbytes(""),
     cst$9=caml_string_of_jsbytes(""),
     cst$8=caml_string_of_jsbytes(""),
     cst$7=caml_string_of_jsbytes(""),
     cst$6=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes("="),
     cst$5=caml_string_of_jsbytes("&"),
     cst$2=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_file$0=caml_string_of_jsbytes("file"),
     cst_file$1=caml_string_of_jsbytes("file:"),
     cst_http=caml_string_of_jsbytes("http"),
     cst_http$0=caml_string_of_jsbytes("http:"),
     cst_https=caml_string_of_jsbytes("https"),
     cst_https$0=caml_string_of_jsbytes("https:"),
     cst$1=caml_string_of_jsbytes(" "),
     cst_2B=caml_string_of_jsbytes("%2B"),
     cst_Js_of_ocaml_Url_Local_exn=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Local_exn"),
     cst$0=caml_string_of_jsbytes("+"),
     cst_Js_of_ocaml_Url_Not_an_htt=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0=
      caml_string_of_jsbytes
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_string_of_jsbytes
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     s=caml_string_of_jsbytes("3.8.0"),
     git_version=caml_string_of_jsbytes(""),
     cst$38=caml_string_of_jsbytes(""),
     cst$41=caml_string_of_jsbytes("+"),
     cst_Jstable_keys=caml_string_of_jsbytes("Jstable.keys"),
     dummy_string=caml_string_of_jsbytes(""),
     dummy_int64=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     cst_is_not_a_valid_length$0=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_string_of_jsbytes("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_string_of_jsbytes("length conversion error: "),
     cst_deg$0=caml_string_of_jsbytes("deg"),
     cst_grad$0=caml_string_of_jsbytes("grad"),
     cst_rad$0=caml_string_of_jsbytes("rad"),
     cst_turns$0=caml_string_of_jsbytes("turns"),
     cst_deg=caml_string_of_jsbytes("deg"),
     cst_grad=caml_string_of_jsbytes("grad"),
     cst_rad=caml_string_of_jsbytes("rad"),
     cst_turns=caml_string_of_jsbytes("turns"),
     cst_is_not_a_valid_length=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_d_d_s_S=caml_string_of_jsbytes("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=
      caml_string_of_jsbytes("length conversion error: "),
     cst_pc$0=caml_string_of_jsbytes("pc"),
     cst_ch$0=caml_string_of_jsbytes("ch"),
     cst_cm$0=caml_string_of_jsbytes("cm"),
     cst_em$1=caml_string_of_jsbytes("em"),
     cst_ex$0=caml_string_of_jsbytes("ex"),
     cst_gd$0=caml_string_of_jsbytes("gd"),
     cst_in$0=caml_string_of_jsbytes("in"),
     cst_mm$0=caml_string_of_jsbytes("mm"),
     cst_pt$0=caml_string_of_jsbytes("pt"),
     cst_px$0=caml_string_of_jsbytes("px"),
     cst_rem$0=caml_string_of_jsbytes("rem"),
     cst_vh$0=caml_string_of_jsbytes("vh"),
     cst_vm$0=caml_string_of_jsbytes("vm"),
     cst_vw$0=caml_string_of_jsbytes("vw"),
     cst_0=caml_string_of_jsbytes("0"),
     cst_em$0=caml_string_of_jsbytes("em"),
     cst_ex=caml_string_of_jsbytes("ex"),
     cst_px=caml_string_of_jsbytes("px"),
     cst_gd=caml_string_of_jsbytes("gd"),
     cst_rem=caml_string_of_jsbytes("rem"),
     cst_vw=caml_string_of_jsbytes("vw"),
     cst_vh=caml_string_of_jsbytes("vh"),
     cst_vm=caml_string_of_jsbytes("vm"),
     cst_ch=caml_string_of_jsbytes("ch"),
     cst_mm=caml_string_of_jsbytes("mm"),
     cst_cm=caml_string_of_jsbytes("cm"),
     cst_in=caml_string_of_jsbytes("in"),
     cst_pt=caml_string_of_jsbytes("pt"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst$40=caml_string_of_jsbytes("): "),
     cst_color_conversion_error$0=
      caml_string_of_jsbytes("color conversion error ("),
     cst$39=caml_string_of_jsbytes("): "),
     cst_color_conversion_error=
      caml_string_of_jsbytes("color conversion error ("),
     cst_is_not_a_valid_color$0=
      caml_string_of_jsbytes(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_string_of_jsbytes("rgb"),
     cst_rgba=caml_string_of_jsbytes("rgba"),
     cst_rgb$0=caml_string_of_jsbytes("rgb"),
     cst_rgba$0=caml_string_of_jsbytes("rgba"),
     cst_hsl=caml_string_of_jsbytes("hsl"),
     cst_hsla=caml_string_of_jsbytes("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_string_of_jsbytes("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_string_of_jsbytes(" is not a valid color"),
     cst_is_out_of_valid_range=
      caml_string_of_jsbytes(" is out of valid range"),
     partial=[8,[0,0,0],0,0,[12,41,0]],
     partial$0=[12,41,0],
     partial$1=[0,0,0],
     cst_lightgrey$0=caml_string_of_jsbytes("lightgrey"),
     cst_darkslategray$0=caml_string_of_jsbytes("darkslategray"),
     cst_cornsilk$0=caml_string_of_jsbytes("cornsilk"),
     cst_blue$0=caml_string_of_jsbytes("blue"),
     cst_aliceblue$0=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite$0=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua$0=caml_string_of_jsbytes("aqua"),
     cst_aquamarine$0=caml_string_of_jsbytes("aquamarine"),
     cst_azure$0=caml_string_of_jsbytes("azure"),
     cst_beige$0=caml_string_of_jsbytes("beige"),
     cst_bisque$0=caml_string_of_jsbytes("bisque"),
     cst_black$0=caml_string_of_jsbytes("black"),
     cst_blanchedalmond$0=caml_string_of_jsbytes("blanchedalmond"),
     cst_blueviolet$0=caml_string_of_jsbytes("blueviolet"),
     cst_brown$0=caml_string_of_jsbytes("brown"),
     cst_burlywood$0=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue$0=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse$0=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate$0=caml_string_of_jsbytes("chocolate"),
     cst_coral$0=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue$0=caml_string_of_jsbytes("cornflowerblue"),
     cst_darkkhaki$0=caml_string_of_jsbytes("darkkhaki"),
     cst_crimson$0=caml_string_of_jsbytes("crimson"),
     cst_cyan$0=caml_string_of_jsbytes("cyan"),
     cst_darkblue$0=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan$0=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod$0=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray$0=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen$0=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey$0=caml_string_of_jsbytes("darkgrey"),
     cst_darkmagenta$0=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen$0=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange$0=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid$0=caml_string_of_jsbytes("darkorchid"),
     cst_darkred$0=caml_string_of_jsbytes("darkred"),
     cst_darksalmon$0=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen$0=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue$0=caml_string_of_jsbytes("darkslateblue"),
     cst_greenyellow$0=caml_string_of_jsbytes("greenyellow"),
     cst_floralwhite$0=caml_string_of_jsbytes("floralwhite"),
     cst_darkslategrey$0=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise$0=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet$0=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink$0=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue$0=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray$0=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey$0=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue$0=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick$0=caml_string_of_jsbytes("firebrick"),
     cst_forestgreen$0=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia$0=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro$0=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite$0=caml_string_of_jsbytes("ghostwhite"),
     cst_gold$0=caml_string_of_jsbytes("gold"),
     cst_goldenrod$0=caml_string_of_jsbytes("goldenrod"),
     cst_gray$0=caml_string_of_jsbytes("gray"),
     cst_green$0=caml_string_of_jsbytes("green"),
     cst_lavenderblush$0=caml_string_of_jsbytes("lavenderblush"),
     cst_grey$0=caml_string_of_jsbytes("grey"),
     cst_honeydew$0=caml_string_of_jsbytes("honeydew"),
     cst_hotpink$0=caml_string_of_jsbytes("hotpink"),
     cst_indianred$0=caml_string_of_jsbytes("indianred"),
     cst_indigo$0=caml_string_of_jsbytes("indigo"),
     cst_ivory$0=caml_string_of_jsbytes("ivory"),
     cst_khaki$0=caml_string_of_jsbytes("khaki"),
     cst_lavender$0=caml_string_of_jsbytes("lavender"),
     cst_lawngreen$0=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon$0=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue$0=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral$0=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan$0=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray$0=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen$0=caml_string_of_jsbytes("lightgreen"),
     cst_paleturquoise$0=caml_string_of_jsbytes("paleturquoise"),
     cst_mediumslateblue$0=caml_string_of_jsbytes("mediumslateblue"),
     cst_limegreen$0=caml_string_of_jsbytes("limegreen"),
     cst_lightpink$0=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon$0=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen$0=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue$0=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray$0=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey$0=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue$0=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow$0=caml_string_of_jsbytes("lightyellow"),
     cst_lime$0=caml_string_of_jsbytes("lime"),
     cst_linen$0=caml_string_of_jsbytes("linen"),
     cst_magenta$0=caml_string_of_jsbytes("magenta"),
     cst_maroon$0=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine$0=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue$0=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid$0=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple$0=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen$0=caml_string_of_jsbytes("mediumseagreen"),
     cst_navy$0=caml_string_of_jsbytes("navy"),
     cst_mediumspringgreen$0=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise$0=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred$0=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue$0=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream$0=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose$0=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin$0=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite$0=caml_string_of_jsbytes("navajowhite"),
     cst_oldlace$0=caml_string_of_jsbytes("oldlace"),
     cst_olive$0=caml_string_of_jsbytes("olive"),
     cst_olivedrab$0=caml_string_of_jsbytes("olivedrab"),
     cst_orange$0=caml_string_of_jsbytes("orange"),
     cst_orangered$0=caml_string_of_jsbytes("orangered"),
     cst_orchid$0=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod$0=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen$0=caml_string_of_jsbytes("palegreen"),
     cst_skyblue$0=caml_string_of_jsbytes("skyblue"),
     cst_rosybrown$0=caml_string_of_jsbytes("rosybrown"),
     cst_palevioletred$0=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip$0=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff$0=caml_string_of_jsbytes("peachpuff"),
     cst_peru$0=caml_string_of_jsbytes("peru"),
     cst_pink$0=caml_string_of_jsbytes("pink"),
     cst_plum$0=caml_string_of_jsbytes("plum"),
     cst_powderblue$0=caml_string_of_jsbytes("powderblue"),
     cst_purple$0=caml_string_of_jsbytes("purple"),
     cst_red$0=caml_string_of_jsbytes("red"),
     cst_royalblue$0=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown$0=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon$0=caml_string_of_jsbytes("salmon"),
     cst_sandybrown$0=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen$0=caml_string_of_jsbytes("seagreen"),
     cst_seashell$0=caml_string_of_jsbytes("seashell"),
     cst_sienna$0=caml_string_of_jsbytes("sienna"),
     cst_silver$0=caml_string_of_jsbytes("silver"),
     cst_thistle$0=caml_string_of_jsbytes("thistle"),
     cst_slateblue$0=caml_string_of_jsbytes("slateblue"),
     cst_slategray$0=caml_string_of_jsbytes("slategray"),
     cst_slategrey$0=caml_string_of_jsbytes("slategrey"),
     cst_snow$0=caml_string_of_jsbytes("snow"),
     cst_springgreen$0=caml_string_of_jsbytes("springgreen"),
     cst_steelblue$0=caml_string_of_jsbytes("steelblue"),
     cst_tan$0=caml_string_of_jsbytes("tan"),
     cst_teal$0=caml_string_of_jsbytes("teal"),
     cst_tomato$0=caml_string_of_jsbytes("tomato"),
     cst_turquoise$0=caml_string_of_jsbytes("turquoise"),
     cst_violet$0=caml_string_of_jsbytes("violet"),
     cst_wheat$0=caml_string_of_jsbytes("wheat"),
     cst_white$0=caml_string_of_jsbytes("white"),
     cst_whitesmoke$0=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow$0=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen$0=caml_string_of_jsbytes("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_string_of_jsbytes(" is not a valid color name"),
     cst_aliceblue=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua=caml_string_of_jsbytes("aqua"),
     cst_aquamarine=caml_string_of_jsbytes("aquamarine"),
     cst_azure=caml_string_of_jsbytes("azure"),
     cst_beige=caml_string_of_jsbytes("beige"),
     cst_bisque=caml_string_of_jsbytes("bisque"),
     cst_black=caml_string_of_jsbytes("black"),
     cst_blanchedalmond=caml_string_of_jsbytes("blanchedalmond"),
     cst_blue=caml_string_of_jsbytes("blue"),
     cst_blueviolet=caml_string_of_jsbytes("blueviolet"),
     cst_brown=caml_string_of_jsbytes("brown"),
     cst_burlywood=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate=caml_string_of_jsbytes("chocolate"),
     cst_coral=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue=caml_string_of_jsbytes("cornflowerblue"),
     cst_cornsilk=caml_string_of_jsbytes("cornsilk"),
     cst_crimson=caml_string_of_jsbytes("crimson"),
     cst_cyan=caml_string_of_jsbytes("cyan"),
     cst_darkblue=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey=caml_string_of_jsbytes("darkgrey"),
     cst_darkkhaki=caml_string_of_jsbytes("darkkhaki"),
     cst_darkmagenta=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid=caml_string_of_jsbytes("darkorchid"),
     cst_darkred=caml_string_of_jsbytes("darkred"),
     cst_darksalmon=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue=caml_string_of_jsbytes("darkslateblue"),
     cst_darkslategray=caml_string_of_jsbytes("darkslategray"),
     cst_darkslategrey=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick=caml_string_of_jsbytes("firebrick"),
     cst_floralwhite=caml_string_of_jsbytes("floralwhite"),
     cst_forestgreen=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite=caml_string_of_jsbytes("ghostwhite"),
     cst_gold=caml_string_of_jsbytes("gold"),
     cst_goldenrod=caml_string_of_jsbytes("goldenrod"),
     cst_gray=caml_string_of_jsbytes("gray"),
     cst_grey=caml_string_of_jsbytes("grey"),
     cst_green=caml_string_of_jsbytes("green"),
     cst_greenyellow=caml_string_of_jsbytes("greenyellow"),
     cst_honeydew=caml_string_of_jsbytes("honeydew"),
     cst_hotpink=caml_string_of_jsbytes("hotpink"),
     cst_indianred=caml_string_of_jsbytes("indianred"),
     cst_indigo=caml_string_of_jsbytes("indigo"),
     cst_ivory=caml_string_of_jsbytes("ivory"),
     cst_khaki=caml_string_of_jsbytes("khaki"),
     cst_lavender=caml_string_of_jsbytes("lavender"),
     cst_lavenderblush=caml_string_of_jsbytes("lavenderblush"),
     cst_lawngreen=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen=caml_string_of_jsbytes("lightgreen"),
     cst_lightgrey=caml_string_of_jsbytes("lightgrey"),
     cst_lightpink=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow=caml_string_of_jsbytes("lightyellow"),
     cst_lime=caml_string_of_jsbytes("lime"),
     cst_limegreen=caml_string_of_jsbytes("limegreen"),
     cst_linen=caml_string_of_jsbytes("linen"),
     cst_magenta=caml_string_of_jsbytes("magenta"),
     cst_maroon=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen=caml_string_of_jsbytes("mediumseagreen"),
     cst_mediumslateblue=caml_string_of_jsbytes("mediumslateblue"),
     cst_mediumspringgreen=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite=caml_string_of_jsbytes("navajowhite"),
     cst_navy=caml_string_of_jsbytes("navy"),
     cst_oldlace=caml_string_of_jsbytes("oldlace"),
     cst_olive=caml_string_of_jsbytes("olive"),
     cst_olivedrab=caml_string_of_jsbytes("olivedrab"),
     cst_orange=caml_string_of_jsbytes("orange"),
     cst_orangered=caml_string_of_jsbytes("orangered"),
     cst_orchid=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen=caml_string_of_jsbytes("palegreen"),
     cst_paleturquoise=caml_string_of_jsbytes("paleturquoise"),
     cst_palevioletred=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff=caml_string_of_jsbytes("peachpuff"),
     cst_peru=caml_string_of_jsbytes("peru"),
     cst_pink=caml_string_of_jsbytes("pink"),
     cst_plum=caml_string_of_jsbytes("plum"),
     cst_powderblue=caml_string_of_jsbytes("powderblue"),
     cst_purple=caml_string_of_jsbytes("purple"),
     cst_red=caml_string_of_jsbytes("red"),
     cst_rosybrown=caml_string_of_jsbytes("rosybrown"),
     cst_royalblue=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon=caml_string_of_jsbytes("salmon"),
     cst_sandybrown=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen=caml_string_of_jsbytes("seagreen"),
     cst_seashell=caml_string_of_jsbytes("seashell"),
     cst_sienna=caml_string_of_jsbytes("sienna"),
     cst_silver=caml_string_of_jsbytes("silver"),
     cst_skyblue=caml_string_of_jsbytes("skyblue"),
     cst_slateblue=caml_string_of_jsbytes("slateblue"),
     cst_slategray=caml_string_of_jsbytes("slategray"),
     cst_slategrey=caml_string_of_jsbytes("slategrey"),
     cst_snow=caml_string_of_jsbytes("snow"),
     cst_springgreen=caml_string_of_jsbytes("springgreen"),
     cst_steelblue=caml_string_of_jsbytes("steelblue"),
     cst_tan=caml_string_of_jsbytes("tan"),
     cst_teal=caml_string_of_jsbytes("teal"),
     cst_thistle=caml_string_of_jsbytes("thistle"),
     cst_tomato=caml_string_of_jsbytes("tomato"),
     cst_turquoise=caml_string_of_jsbytes("turquoise"),
     cst_violet=caml_string_of_jsbytes("violet"),
     cst_wheat=caml_string_of_jsbytes("wheat"),
     cst_white=caml_string_of_jsbytes("white"),
     cst_whitesmoke=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen=caml_string_of_jsbytes("yellowgreen"),
     cst_vkern$0=caml_string_of_jsbytes("vkern"),
     cst_view$0=caml_string_of_jsbytes("view"),
     cst_use$0=caml_string_of_jsbytes("use"),
     cst_tspan$0=caml_string_of_jsbytes("tspan"),
     cst_tref$0=caml_string_of_jsbytes("tref"),
     cst_title$3=caml_string_of_jsbytes("title"),
     cst_textpath$0=caml_string_of_jsbytes("textpath"),
     cst_text$1=caml_string_of_jsbytes("text"),
     cst_symbol$0=caml_string_of_jsbytes("symbol"),
     cst_switch$0=caml_string_of_jsbytes("switch"),
     cst_svg$0=caml_string_of_jsbytes("svg"),
     cst_style$3=caml_string_of_jsbytes("style"),
     cst_stop$0=caml_string_of_jsbytes("stop"),
     cst_set$0=caml_string_of_jsbytes("set"),
     cst_script$3=caml_string_of_jsbytes("script"),
     cst_rect$0=caml_string_of_jsbytes("rect"),
     cst_radialgradient$0=caml_string_of_jsbytes("radialgradient"),
     cst_polyline$0=caml_string_of_jsbytes("polyline"),
     cst_polygon$0=caml_string_of_jsbytes("polygon"),
     cst_pattern$0=caml_string_of_jsbytes("pattern"),
     cst_path$0=caml_string_of_jsbytes("path"),
     cst_mpath$0=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph$0=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata$0=caml_string_of_jsbytes("metadata"),
     cst_mask$0=caml_string_of_jsbytes("mask"),
     cst_lineargradient$0=caml_string_of_jsbytes("lineargradient"),
     cst_line$0=caml_string_of_jsbytes("line"),
     cst_image$0=caml_string_of_jsbytes("image"),
     cst_hkern$0=caml_string_of_jsbytes("hkern"),
     cst_glyphref$0=caml_string_of_jsbytes("glyphref"),
     cst_glyph$0=caml_string_of_jsbytes("glyph"),
     cst_g$1=caml_string_of_jsbytes("g"),
     cst_foreignobject=caml_string_of_jsbytes("foreignobject"),
     cst_font_face_uri$0=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src$0=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name$0=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format$0=caml_string_of_jsbytes("font-face-format"),
     cst_font_face$0=caml_string_of_jsbytes("font-face"),
     cst_font$0=caml_string_of_jsbytes("font"),
     cst_filter$0=caml_string_of_jsbytes("filter"),
     cst_ellipse$0=caml_string_of_jsbytes("ellipse"),
     cst_desc$0=caml_string_of_jsbytes("desc"),
     cst_defs$0=caml_string_of_jsbytes("defs"),
     cst_cursor$0=caml_string_of_jsbytes("cursor"),
     cst_clippath$0=caml_string_of_jsbytes("clippath"),
     cst_circle$0=caml_string_of_jsbytes("circle"),
     cst_animatetransform$0=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion$0=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor$0=caml_string_of_jsbytes("animatecolor"),
     cst_animate$0=caml_string_of_jsbytes("animate"),
     cst_altglyphitem$0=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef$0=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph$0=caml_string_of_jsbytes("altglyph"),
     cst_a$3=caml_string_of_jsbytes("a"),
     cst_vkern=caml_string_of_jsbytes("vkern"),
     cst_view=caml_string_of_jsbytes("view"),
     cst_use=caml_string_of_jsbytes("use"),
     cst_tspan=caml_string_of_jsbytes("tspan"),
     cst_tref=caml_string_of_jsbytes("tref"),
     cst_title$2=caml_string_of_jsbytes("title"),
     cst_textpath=caml_string_of_jsbytes("textpath"),
     cst_text$0=caml_string_of_jsbytes("text"),
     cst_symbol=caml_string_of_jsbytes("symbol"),
     cst_switch=caml_string_of_jsbytes("switch"),
     cst_svg=caml_string_of_jsbytes("svg"),
     cst_style$2=caml_string_of_jsbytes("style"),
     cst_stop=caml_string_of_jsbytes("stop"),
     cst_set=caml_string_of_jsbytes("set"),
     cst_script$2=caml_string_of_jsbytes("script"),
     cst_rect=caml_string_of_jsbytes("rect"),
     cst_radialgradient=caml_string_of_jsbytes("radialgradient"),
     cst_polyline=caml_string_of_jsbytes("polyline"),
     cst_polygon=caml_string_of_jsbytes("polygon"),
     cst_pattern=caml_string_of_jsbytes("pattern"),
     cst_path=caml_string_of_jsbytes("path"),
     cst_mpath=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata=caml_string_of_jsbytes("metadata"),
     cst_mask=caml_string_of_jsbytes("mask"),
     cst_lineargradient=caml_string_of_jsbytes("lineargradient"),
     cst_line=caml_string_of_jsbytes("line"),
     cst_image=caml_string_of_jsbytes("image"),
     cst_hkern=caml_string_of_jsbytes("hkern"),
     cst_glyphref=caml_string_of_jsbytes("glyphref"),
     cst_glyph=caml_string_of_jsbytes("glyph"),
     cst_g$0=caml_string_of_jsbytes("g"),
     cst_foreignObject=caml_string_of_jsbytes("foreignObject"),
     cst_font_face_uri=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format=caml_string_of_jsbytes("font-face-format"),
     cst_font_face=caml_string_of_jsbytes("font-face"),
     cst_font=caml_string_of_jsbytes("font"),
     cst_filter=caml_string_of_jsbytes("filter"),
     cst_ellipse=caml_string_of_jsbytes("ellipse"),
     cst_desc=caml_string_of_jsbytes("desc"),
     cst_defs=caml_string_of_jsbytes("defs"),
     cst_cursor=caml_string_of_jsbytes("cursor"),
     cst_clippath=caml_string_of_jsbytes("clippath"),
     cst_circle=caml_string_of_jsbytes("circle"),
     cst_animatetransform=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor=caml_string_of_jsbytes("animatecolor"),
     cst_animate=caml_string_of_jsbytes("animate"),
     cst_altglyphitem=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph=caml_string_of_jsbytes("altglyph"),
     cst_a$2=caml_string_of_jsbytes("a"),
     cst_Js_of_ocaml_Dom_svg_SVGErr=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_svg.SVGError"),
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib=global_data.Stdlib,
     Stdlib_callback=global_data.Stdlib__callback,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Assert_failure=global_data.Assert_failure,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_printf=global_data.Stdlib__printf,
     Js_of_ocaml=[0];
    caml_register_global(1629,Js_of_ocaml,"Js_of_ocaml__");
    var
     Poly=[0],
     _d_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom.ml"),351,67],
     _e_=[0,caml_string_of_jsbytes("transparent")],
     _f_=[0,caml_string_of_jsbytes("native")],
     _j_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2796,58],
     _i_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2795,61],
     _h_=
      [0,
       [11,
        caml_string_of_jsbytes("getElementById_exn: "),
        [3,0,[11,caml_string_of_jsbytes(" not found"),0]]],
       caml_string_of_jsbytes("getElementById_exn: %S not found")],
     _l_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/form.ml"),177,13],
     _k_=[0,1],
     _m_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/regexp.ml"),34,64],
     _n_=[0,caml_string_of_jsbytes(""),0],
     _ch_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ci_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cj_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ck_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b5_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b6_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b7_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b8_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b9_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b__=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b$_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ca_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cb_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cc_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cd_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ce_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cf_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cg_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b4_=
      caml_list_of_js_array
       ([caml_string_of_jsbytes("aliceblue"),
         caml_string_of_jsbytes("antiquewhite"),
         caml_string_of_jsbytes("aqua"),
         caml_string_of_jsbytes("aquamarine"),
         caml_string_of_jsbytes("azure"),
         caml_string_of_jsbytes("beige"),
         caml_string_of_jsbytes("bisque"),
         caml_string_of_jsbytes("black"),
         caml_string_of_jsbytes("blanchedalmond"),
         caml_string_of_jsbytes("blue"),
         caml_string_of_jsbytes("blueviolet"),
         caml_string_of_jsbytes("brown"),
         caml_string_of_jsbytes("burlywood"),
         caml_string_of_jsbytes("cadetblue"),
         caml_string_of_jsbytes("chartreuse"),
         caml_string_of_jsbytes("chocolate"),
         caml_string_of_jsbytes("coral"),
         caml_string_of_jsbytes("cornflowerblue"),
         caml_string_of_jsbytes("cornsilk"),
         caml_string_of_jsbytes("crimson"),
         caml_string_of_jsbytes("cyan"),
         caml_string_of_jsbytes("darkblue"),
         caml_string_of_jsbytes("darkcyan"),
         caml_string_of_jsbytes("darkgoldenrod"),
         caml_string_of_jsbytes("darkgray"),
         caml_string_of_jsbytes("darkgreen"),
         caml_string_of_jsbytes("darkgrey"),
         caml_string_of_jsbytes("darkkhaki"),
         caml_string_of_jsbytes("darkmagenta"),
         caml_string_of_jsbytes("darkolivegreen"),
         caml_string_of_jsbytes("darkorange"),
         caml_string_of_jsbytes("darkorchid"),
         caml_string_of_jsbytes("darkred"),
         caml_string_of_jsbytes("darksalmon"),
         caml_string_of_jsbytes("darkseagreen"),
         caml_string_of_jsbytes("darkslateblue"),
         caml_string_of_jsbytes("darkslategray"),
         caml_string_of_jsbytes("darkslategrey"),
         caml_string_of_jsbytes("darkturquoise"),
         caml_string_of_jsbytes("darkviolet"),
         caml_string_of_jsbytes("deeppink"),
         caml_string_of_jsbytes("deepskyblue"),
         caml_string_of_jsbytes("dimgray"),
         caml_string_of_jsbytes("dimgrey"),
         caml_string_of_jsbytes("dodgerblue"),
         caml_string_of_jsbytes("firebrick"),
         caml_string_of_jsbytes("floralwhite"),
         caml_string_of_jsbytes("forestgreen"),
         caml_string_of_jsbytes("fuchsia"),
         caml_string_of_jsbytes("gainsboro"),
         caml_string_of_jsbytes("ghostwhite"),
         caml_string_of_jsbytes("gold"),
         caml_string_of_jsbytes("goldenrod"),
         caml_string_of_jsbytes("gray"),
         caml_string_of_jsbytes("green"),
         caml_string_of_jsbytes("greenyellow"),
         caml_string_of_jsbytes("grey"),
         caml_string_of_jsbytes("honeydew"),
         caml_string_of_jsbytes("hotpink"),
         caml_string_of_jsbytes("indianred"),
         caml_string_of_jsbytes("indigo"),
         caml_string_of_jsbytes("ivory"),
         caml_string_of_jsbytes("khaki"),
         caml_string_of_jsbytes("lavender"),
         caml_string_of_jsbytes("lavenderblush"),
         caml_string_of_jsbytes("lawngreen"),
         caml_string_of_jsbytes("lemonchiffon"),
         caml_string_of_jsbytes("lightblue"),
         caml_string_of_jsbytes("lightcoral"),
         caml_string_of_jsbytes("lightcyan"),
         caml_string_of_jsbytes("lightgoldenrodyellow"),
         caml_string_of_jsbytes("lightgray"),
         caml_string_of_jsbytes("lightgreen"),
         caml_string_of_jsbytes("lightgrey"),
         caml_string_of_jsbytes("lightpink"),
         caml_string_of_jsbytes("lightsalmon"),
         caml_string_of_jsbytes("lightseagreen"),
         caml_string_of_jsbytes("lightskyblue"),
         caml_string_of_jsbytes("lightslategray"),
         caml_string_of_jsbytes("lightslategrey"),
         caml_string_of_jsbytes("lightsteelblue"),
         caml_string_of_jsbytes("lightyellow"),
         caml_string_of_jsbytes("lime"),
         caml_string_of_jsbytes("limegreen"),
         caml_string_of_jsbytes("linen"),
         caml_string_of_jsbytes("magenta"),
         caml_string_of_jsbytes("maroon"),
         caml_string_of_jsbytes("mediumaquamarine"),
         caml_string_of_jsbytes("mediumblue"),
         caml_string_of_jsbytes("mediumorchid"),
         caml_string_of_jsbytes("mediumpurple"),
         caml_string_of_jsbytes("mediumseagreen"),
         caml_string_of_jsbytes("mediumslateblue"),
         caml_string_of_jsbytes("mediumspringgreen"),
         caml_string_of_jsbytes("mediumturquoise"),
         caml_string_of_jsbytes("mediumvioletred"),
         caml_string_of_jsbytes("midnightblue"),
         caml_string_of_jsbytes("mintcream"),
         caml_string_of_jsbytes("mistyrose"),
         caml_string_of_jsbytes("moccasin"),
         caml_string_of_jsbytes("navajowhite"),
         caml_string_of_jsbytes("navy"),
         caml_string_of_jsbytes("oldlace"),
         caml_string_of_jsbytes("olive"),
         caml_string_of_jsbytes("olivedrab"),
         caml_string_of_jsbytes("orange"),
         caml_string_of_jsbytes("orangered"),
         caml_string_of_jsbytes("orchid"),
         caml_string_of_jsbytes("palegoldenrod"),
         caml_string_of_jsbytes("palegreen"),
         caml_string_of_jsbytes("paleturquoise"),
         caml_string_of_jsbytes("palevioletred"),
         caml_string_of_jsbytes("papayawhip"),
         caml_string_of_jsbytes("peachpuff"),
         caml_string_of_jsbytes("peru"),
         caml_string_of_jsbytes("pink"),
         caml_string_of_jsbytes("plum"),
         caml_string_of_jsbytes("powderblue"),
         caml_string_of_jsbytes("purple"),
         caml_string_of_jsbytes("red"),
         caml_string_of_jsbytes("rosybrown"),
         caml_string_of_jsbytes("royalblue"),
         caml_string_of_jsbytes("saddlebrown"),
         caml_string_of_jsbytes("salmon"),
         caml_string_of_jsbytes("sandybrown"),
         caml_string_of_jsbytes("seagreen"),
         caml_string_of_jsbytes("seashell"),
         caml_string_of_jsbytes("sienna"),
         caml_string_of_jsbytes("silver"),
         caml_string_of_jsbytes("skyblue"),
         caml_string_of_jsbytes("slateblue"),
         caml_string_of_jsbytes("slategray"),
         caml_string_of_jsbytes("slategrey"),
         caml_string_of_jsbytes("snow"),
         caml_string_of_jsbytes("springgreen"),
         caml_string_of_jsbytes("steelblue"),
         caml_string_of_jsbytes("tan"),
         caml_string_of_jsbytes("teal"),
         caml_string_of_jsbytes("thistle"),
         caml_string_of_jsbytes("tomato"),
         caml_string_of_jsbytes("turquoise"),
         caml_string_of_jsbytes("violet"),
         caml_string_of_jsbytes("wheat"),
         caml_string_of_jsbytes("white"),
         caml_string_of_jsbytes("whitesmoke"),
         caml_string_of_jsbytes("yellow"),
         caml_string_of_jsbytes("yellowgreen")]),
     _b3_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_string_of_jsbytes("#%02X%02X%02X")],
     _bX_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_string_of_jsbytes("rgb(%d,%d,%d)")],
     _bY_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_string_of_jsbytes("rgb(%d%%,%d%%,%d%%)")],
     _bZ_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,[0,0,0],0,0,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d,%d,%d,%f)")],
     _b0_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d%%,%d%%,%d%%,%f)")],
     _b1_=
      [0,
       [11,
        caml_string_of_jsbytes("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("hsl(%d,%d%%,%d%%)")],
     _b2_=
      [0,
       [11,
        caml_string_of_jsbytes("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,
            37,
            [12,44,[4,0,0,0,[12,37,[12,44,[8,partial$1,0,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes("hsla(%d,%d%%,%d%%,%f)")],
     _u_=[0,240,248,255],
     _v_=[0,250,235,215],
     _w_=[0,0,255,255],
     _x_=[0,127,255,212],
     _y_=[0,240,255,255],
     _z_=[0,245,245,220],
     _A_=[0,255,228,196],
     _B_=[0,0,0,0],
     _C_=[0,255,235,205],
     _D_=[0,0,0,255],
     _E_=[0,138,43,226],
     _F_=[0,165,42,42],
     _G_=[0,222,184,135],
     _H_=[0,95,158,160],
     _I_=[0,127,255,0],
     _J_=[0,210,105,30],
     _K_=[0,255,127,80],
     _L_=[0,100,149,237],
     _M_=[0,255,248,220],
     _N_=[0,220,20,60],
     _O_=[0,0,255,255],
     _P_=[0,0,0,139],
     _Q_=[0,0,139,139],
     _R_=[0,184,134,11],
     _S_=[0,169,169,169],
     _T_=[0,0,100,0],
     _U_=[0,169,169,169],
     _V_=[0,189,183,107],
     _W_=[0,139,0,139],
     _X_=[0,85,107,47],
     _Y_=[0,255,140,0],
     _Z_=[0,153,50,204],
     ___=[0,139,0,0],
     _$_=[0,233,150,122],
     _aa_=[0,143,188,143],
     _ab_=[0,72,61,139],
     _ac_=[0,47,79,79],
     _ad_=[0,47,79,79],
     _ae_=[0,0,206,209],
     _af_=[0,148,0,211],
     _ag_=[0,255,20,147],
     _ah_=[0,0,191,255],
     _ai_=[0,105,105,105],
     _aj_=[0,105,105,105],
     _ak_=[0,30,144,255],
     _al_=[0,178,34,34],
     _am_=[0,255,250,240],
     _an_=[0,34,139,34],
     _ao_=[0,255,0,255],
     _ap_=[0,220,220,220],
     _aq_=[0,248,248,255],
     _ar_=[0,255,215,0],
     _as_=[0,218,165,32],
     _at_=[0,128,128,128],
     _au_=[0,128,128,128],
     _av_=[0,0,128,0],
     _aw_=[0,173,255,47],
     _ax_=[0,240,255,240],
     _ay_=[0,255,105,180],
     _az_=[0,205,92,92],
     _aA_=[0,75,0,130],
     _aB_=[0,255,255,240],
     _aC_=[0,240,230,140],
     _aD_=[0,230,230,250],
     _aE_=[0,255,240,245],
     _aF_=[0,124,252,0],
     _aG_=[0,255,250,205],
     _aH_=[0,173,216,230],
     _aI_=[0,240,128,128],
     _aJ_=[0,224,255,255],
     _aK_=[0,250,250,210],
     _aL_=[0,211,211,211],
     _aM_=[0,144,238,144],
     _aN_=[0,211,211,211],
     _aO_=[0,255,182,193],
     _aP_=[0,255,160,122],
     _aQ_=[0,32,178,170],
     _aR_=[0,135,206,250],
     _aS_=[0,119,136,153],
     _aT_=[0,119,136,153],
     _aU_=[0,176,196,222],
     _aV_=[0,255,255,224],
     _aW_=[0,0,255,0],
     _aX_=[0,50,205,50],
     _aY_=[0,250,240,230],
     _aZ_=[0,255,0,255],
     _a0_=[0,128,0,0],
     _a1_=[0,102,205,170],
     _a2_=[0,0,0,205],
     _a3_=[0,186,85,211],
     _a4_=[0,147,112,219],
     _a5_=[0,60,179,113],
     _a6_=[0,123,104,238],
     _a7_=[0,0,250,154],
     _a8_=[0,72,209,204],
     _a9_=[0,199,21,133],
     _a__=[0,25,25,112],
     _a$_=[0,245,255,250],
     _ba_=[0,255,228,225],
     _bb_=[0,255,228,181],
     _bc_=[0,255,222,173],
     _bd_=[0,0,0,128],
     _be_=[0,253,245,230],
     _bf_=[0,128,128,0],
     _bg_=[0,107,142,35],
     _bh_=[0,255,165,0],
     _bi_=[0,255,69,0],
     _bj_=[0,218,112,214],
     _bk_=[0,238,232,170],
     _bl_=[0,152,251,152],
     _bm_=[0,175,238,238],
     _bn_=[0,219,112,147],
     _bo_=[0,255,239,213],
     _bp_=[0,255,218,185],
     _bq_=[0,205,133,63],
     _br_=[0,255,192,203],
     _bs_=[0,221,160,221],
     _bt_=[0,176,224,230],
     _bu_=[0,128,0,128],
     _bv_=[0,255,0,0],
     _bw_=[0,188,143,143],
     _bx_=[0,65,105,225],
     _by_=[0,139,69,19],
     _bz_=[0,250,128,114],
     _bA_=[0,244,164,96],
     _bB_=[0,46,139,87],
     _bC_=[0,255,245,238],
     _bD_=[0,160,82,45],
     _bE_=[0,192,192,192],
     _bF_=[0,135,206,235],
     _bG_=[0,106,90,205],
     _bH_=[0,112,128,144],
     _bI_=[0,112,128,144],
     _bJ_=[0,255,250,250],
     _bK_=[0,0,255,127],
     _bL_=[0,70,130,180],
     _bM_=[0,210,180,140],
     _bN_=[0,0,128,128],
     _bO_=[0,216,191,216],
     _bP_=[0,255,99,71],
     _bQ_=[0,64,224,208],
     _bR_=[0,238,130,238],
     _bS_=[0,245,222,179],
     _bT_=[0,255,255,255],
     _bU_=[0,245,245,245],
     _bV_=[0,255,255,0],
     _bW_=[0,154,205,50];
    function symbol(x,y){return x < y?1:0}
    function symbol$0(x,y){return x <= y?1:0}
    function symbol$1(x,y){return x !== y?1:0}
    function symbol$2(x,y){return x === y?1:0}
    function symbol$3(x,y){return y < x?1:0}
    function symbol$4(x,y){return y <= x?1:0}
    var compare=runtime.caml_int_compare;
    function equal(x,y){return x === y?1:0}
    function max(x,y){return y <= x?x:y}
    function min(x,y){return x <= y?x:y}
    var
     Int_replace_polymorphic_compar=
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       compare,
       equal,
       max,
       min],
     make=Stdlib_string[1],
     init=Stdlib_string[2],
     copy=Stdlib_string[3],
     sub=Stdlib_string[4],
     fill=Stdlib_string[5],
     blit=Stdlib_string[6],
     concat=Stdlib_string[7],
     iter=Stdlib_string[8],
     iteri=Stdlib_string[9],
     map=Stdlib_string[10],
     mapi=Stdlib_string[11],
     trim=Stdlib_string[12],
     escaped=Stdlib_string[13],
     index=Stdlib_string[14],
     index_opt=Stdlib_string[15],
     rindex=Stdlib_string[16],
     rindex_opt=Stdlib_string[17],
     index_from=Stdlib_string[18],
     index_from_opt=Stdlib_string[19],
     rindex_from=Stdlib_string[20],
     rindex_from_opt=Stdlib_string[21],
     contains=Stdlib_string[22],
     contains_from=Stdlib_string[23],
     rcontains_from=Stdlib_string[24],
     uppercase=Stdlib_string[25],
     lowercase=Stdlib_string[26],
     capitalize=Stdlib_string[27],
     uncapitalize=Stdlib_string[28],
     uppercase_ascii=Stdlib_string[29],
     lowercase_ascii=Stdlib_string[30],
     capitalize_ascii=Stdlib_string[31],
     uncapitalize_ascii=Stdlib_string[32],
     compare$0=Stdlib_string[33],
     split_on_char=Stdlib_string[35],
     to_seq=Stdlib_string[36],
     to_seqi=Stdlib_string[37],
     of_seq=Stdlib_string[38],
     equal$0=runtime.caml_string_equal,
     String=
      [0,
       make,
       init,
       copy,
       sub,
       fill,
       blit,
       concat,
       iter,
       iteri,
       map,
       mapi,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$0,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       equal$0],
     chr=Stdlib_char[1],
     escaped$0=Stdlib_char[2],
     lowercase$0=Stdlib_char[3],
     uppercase$0=Stdlib_char[4],
     lowercase_ascii$0=Stdlib_char[5],
     uppercase_ascii$0=Stdlib_char[6],
     compare$1=Stdlib_char[7];
    function equal$1(x,y){return x === y?1:0}
    var
     Char=
      [0,
       chr,
       escaped$0,
       lowercase$0,
       uppercase$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$1,
       equal$1],
     symbol$5=Int_replace_polymorphic_compar[1],
     symbol$6=Int_replace_polymorphic_compar[2],
     symbol$7=Int_replace_polymorphic_compar[3],
     symbol$8=Int_replace_polymorphic_compar[4],
     symbol$9=Int_replace_polymorphic_compar[5],
     symbol$10=Int_replace_polymorphic_compar[6],
     compare$2=Int_replace_polymorphic_compar[7],
     equal$2=Int_replace_polymorphic_compar[8],
     max$0=Int_replace_polymorphic_compar[9],
     min$0=Int_replace_polymorphic_compar[10],
     Js_of_ocaml_Import=
      [0,
       Poly,
       Int_replace_polymorphic_compar,
       String,
       Char,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       compare$2,
       equal$2,
       max$0,
       min$0];
    caml_register_global(1632,Js_of_ocaml_Import,"Js_of_ocaml__Import");
    var
     global=joo_global_object,
     Unsafe=[0,global],
     no_handler=null,
     t39=undefined;
    function return$0(_gG_){return _gG_}
    function map$0(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter$0(x,f)
     {var _gF_=1 - (x == no_handler?1:0);return _gF_?caml_call1(f,x):_gF_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gE_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gE_)}
    var
     Opt=
      [0,
       no_handler,
       return$0,
       map$0,
       bind,
       test,
       iter$0,
       case$0,
       get,
       option,
       to_option];
    function return$1(_gD_){return _gD_}
    function map$1(x,f){return x === t39?t39:caml_call1(f,x)}
    function bind$0(x,f){return x === t39?t39:caml_call1(f,x)}
    function test$0(x){return x !== t39?1:0}
    function iter$1(x,f)
     {var _gC_=x !== t39?1:0;return _gC_?caml_call1(f,x):_gC_}
    function case$1(x,f,g){return x === t39?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t39?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t39}
    function to_option$0(x)
     {function _gB_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gB_)}
    var
     Optdef=
      [0,
       t39,
       return$1,
       map$1,
       bind$0,
       test$0,
       iter$1,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gz_(param){return caml_call1(g,x)}
      var _gA_=caml_call1(f,x);
      return caml_call2(Opt[8],_gA_,_gz_)}
    function coerce_opt(x,f,g)
     {function _gx_(param){return caml_call1(g,x)}
      var _gy_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gy_,_gx_)}
    var
     true$0=true,
     false$0=false,
     string_constr=Unsafe[1].String,
     regExp_withFlags=Unsafe[1].RegExp,
     object_constructor=Unsafe[1].Object;
    function object_keys(o){return object_constructor.keys(o)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gw_){return _gw_}
    function match_result(_gv_){return _gv_}
    var
     date_ms=Unsafe[1].Date,
     math=Unsafe[1].Math,
     Error=[248,cst_Js_of_ocaml_Js_Error,caml_fresh_oo_id(0)],
     error_constr=Unsafe[1].Error;
    caml_call2(Stdlib_callback[2],cst_jsError,[0,Error,{}]);
    function raise_js_error(exn){throw exn}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error)
       {var e=param[2];return [0,caml_string_of_jsstring(e.toString())]}
      return 0}
    caml_call1(Stdlib_printexc[9],_a_);
    function _b_(e)
     {return e instanceof array_length
              ?0
              :[0,caml_string_of_jsstring(e.toString())]}
    caml_call1(Stdlib_printexc[9],_b_);
    function string_of_error(e){return caml_string_of_jsstring(e.toString())}
    function export_js(field,x)
     {return runtime.caml_js_export_var(0)[field] = x}
    function export$0(field,x)
     {return export_js(caml_jsstring_of_string(field),x)}
    function export_all(obj)
     {var keys=object_keys(obj);
      return keys.forEach
              (caml_js_wrap_callback
                (function(key,param,_gu_){return export_js(key,obj[key])}))}
    function _c_(_gt_){return _gt_}
    var
     Js_of_ocaml_Js=
      [0,
       no_handler,
       function(_gs_){return _gs_},
       t39,
       _c_,
       Opt,
       Optdef,
       true$0,
       false$0,
       string_constr,
       regExp_withFlags,
       regExp_withFlags,
       regExp_withFlags,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       math,
       error_constr,
       string_of_error,
       raise_js_error,
       Error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe];
    caml_register_global(1636,Js_of_ocaml_Js,"Js_of_ocaml__Js");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(caml_call2(symbol$5,i,length))
         {var _gr_=nodeList.item(i),match=caml_call1(Opt[10],_gr_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(Stdlib_list[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains$0=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return caml_call2(symbol$8,t & mask,mask)}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains$0,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(0 !== match)
       {var switcher=match - 1 | 0;
        switch(switcher)
         {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType && 4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var e$0=event,res$0=caml_call1(f,e$0);
        if(1 - (res$0 | 0))e$0.returnValue = res$0;
        return res$0}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var e$0=event,res$0=caml_call2(f,this$0,e$0);
                 if(1 - (res$0 | 0))e$0.returnValue = res$0;
                 return res$0})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _go_(param)
       {function _gq_(param){throw Stdlib[8]}
        return caml_call2(Opt[8],e.srcElement,_gq_)}
      var target=caml_call2(Opt[8],e.target,_go_);
      if(target instanceof Unsafe[1].Node)
       {if(3 === target.nodeType)
         {var _gp_=function(param){throw [0,Assert_failure,_d_]};
          return caml_call2(Opt[8],target.parentNode,_gp_)}
        return target}
      return target}
    var make$0=caml_jsstring_of_string,Event=[0,make$0];
    function addEventListenerWithOptions(e,typ,capture,once,passive,h)
     {if(e.addEventListener === t39)
       {var
         ev="on".concat(typ),
         callback=
          function(e)
           {var _gl_=[0,h,e,[0]];
            return function(_gm_,_gn_)
             {return runtime.caml_js_call(_gl_,_gm_,_gn_)}};
        e.attachEvent(ev,callback);
        return function(param){return e.detachEvent(ev,callback)}}
      var opts={};
      function iter(t,f){if(t){var b=t[1];return caml_call1(f,b)}return 0}
      iter(capture,function(b){return opts.capture = b});
      iter(once,function(b){return opts.once = b});
      iter(passive,function(b){return opts.passive = b});
      e.addEventListener(typ,h,opts);
      return function(param){return e.removeEventListener(typ,h,opts)}}
    function addEventListener(e,typ,h,capt)
     {return addEventListenerWithOptions(e,typ,[0,capt],0,0,h)}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(ev)
     {return caml_call1(Optdef[5],ev.preventDefault)
              ?ev.preventDefault()
              :ev.returnValue = ! ! 0}
    function createCustomEvent(bubbles,cancelable,detail,typ)
     {function opt_iter(f,param)
       {if(param){var x=param[1];return caml_call1(f,x)}return 0}
      var opts={};
      opt_iter(function(x){return opts.bubbles = ! ! x},bubbles);
      opt_iter(function(x){return opts.cancelable = ! ! x},cancelable);
      opt_iter(function(x){return opts.detail = x},detail);
      var constr=Unsafe[1].CustomEvent;
      return new constr(typ,opts)}
    var
     Js_of_ocaml_Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       preventDefault,
       createCustomEvent];
    caml_register_global(1639,Js_of_ocaml_Dom,"Js_of_ocaml__Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     uint8Array_fromBuffer=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set,
     get$1=caml_js_get,
     unsafe_get=caml_js_get,
     dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new uint8Array_fromBuffer(ab);
      return caml_string_of_array(uint8)}
    var
     Js_of_ocaml_Typed_array=
      [0,
       arrayBuffer,
       runtime.caml_ba_kind_of_typed_array,
       runtime.caml_ba_to_typed_array,
       runtime.caml_ba_from_typed_array,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,
        runtime.bigstring_to_array_buffer,
        runtime.bigstring_to_typed_array,
        runtime.bigstring_of_array_buffer,
        runtime.bigstring_of_typed_array],
       [0,of_arrayBuffer,caml_string_of_array]];
    caml_register_global
     (1640,Js_of_ocaml_Typed_array,"Js_of_ocaml__Typed_array");
    var blob_constr=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _gh_=0;
      if(endings)
       var _gi_=116179762 <= endings[1]?_e_:_f_,_gj_=_gi_;
      else
       var _gj_=0;
      var
       _gk_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_gj_],_gh_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v)
             {var v$0=v[1];return [0,[0,name,caml_jsstring_of_string(v$0)]]}
            return 0},
          _gk_),
       options$0=
        options
         ?runtime.caml_js_object(caml_call1(Stdlib_array[12],options))
         :t39;
      return new blob_constr(caml_js_from_array(a),options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,caml_jsstring_of_string(s)])}
    function blob_from_any(contentType,endings,l)
     {function _gf_(param)
       {var _gg_=param[1];
        if(155580615 === _gg_){var s=param[2];return s}
        if(486041214 <= _gg_)
         {if(1037850489 <= _gg_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _gg_)
         {var s$0=param[2];return caml_jsstring_of_string(s$0)}
        var b=param[2];
        return b}
      var l$0=caml_call2(Stdlib_list[17],_gf_,l);
      return blob_raw(contentType,endings,caml_call1(Stdlib_array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1(Stdlib[2],cst_can_t_retrieve_file_name_n)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof blob_constr?e:no_handler}
    function string(e){return typeof e === "string"?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     Js_of_ocaml_File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_ge_){return _ge_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1642,Js_of_ocaml_File,"Js_of_ocaml__File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     gotpointercapture=caml_call1(Event[1],cst_gotpointercapture),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     lostpointercapture=caml_call1(Event[1],cst_lostpointercapture),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     pointerenter=caml_call1(Event[1],cst_pointerenter),
     pointercancel=caml_call1(Event[1],cst_pointercancel),
     pointerdown=caml_call1(Event[1],cst_pointerdown),
     pointerleave=caml_call1(Event[1],cst_pointerleave),
     pointermove=caml_call1(Event[1],cst_pointermove),
     pointerout=caml_call1(Event[1],cst_pointerout),
     pointerover=caml_call1(Event[1],cst_pointerover),
     pointerup=caml_call1(Event[1],cst_pointerup),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$1=Event[1],
     Event$0=
      [0,
       click,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       gotpointercapture,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       lostpointercapture,
       pause,
       play,
       playing,
       pointerenter,
       pointercancel,
       pointerdown,
       pointerleave,
       pointermove,
       pointerout,
       pointerover,
       pointerup,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$1],
     d="2d";
    function location_origin(loc)
     {function _gc_(o){return o}
      function _gd_(param)
       {var protocol=loc.protocol,hostname=loc.hostname,port=loc.port;
        if
         (caml_call2(symbol$8,protocol.length,0)
          &&
          caml_call2(symbol$8,hostname.length,0))
         return "";
        var origin=protocol.concat("//",hostname);
        return caml_call2(symbol$9,port.length,0)
                ?origin.concat(":",loc.port)
                :origin}
      return caml_call3(Optdef[7],loc.origin,_gd_,_gc_)}
    var _g_=Unsafe[1],document$0=_g_.document;
    function getElementById(id)
     {function _f$_(pnode){return pnode}
      function _ga_(param){throw Stdlib[8]}
      var _gb_=document$0.getElementById(caml_jsstring_of_string(id));
      return caml_call3(Opt[7],_gb_,_ga_,_f$_)}
    function getElementById_exn(id)
     {function _f7_(pnode){return pnode}
      function _f8_(param)
       {var _f__=caml_call2(Stdlib_printf[4],_h_,id);
        return caml_call1(Stdlib[2],_f__)}
      var _f9_=document$0.getElementById(caml_jsstring_of_string(id));
      return caml_call3(Opt[7],_f9_,_f8_,_f7_)}
    function getElementById_opt(id)
     {var _f6_=document$0.getElementById(caml_jsstring_of_string(id));
      return caml_call1(Opt[10],_f6_)}
    function getElementById_coerce(id,coerce)
     {function _f2_(e)
       {var _f5_=caml_call1(coerce,e);return caml_call1(Opt[10],_f5_)}
      function _f3_(param){return 0}
      var _f4_=document$0.getElementById(caml_jsstring_of_string(id));
      return caml_call3(Opt[7],_f4_,_f3_,_f2_)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(doc,name)
     {return doc.createElement(caml_jsstring_of_string(name))}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type && 0 === name)return createElement(doc,elt);
        var _fW_=createElementSyntax[1];
        if(785140586 === _fW_)
         {try
           {var
             el=document$0.createElement('<input name="x">'),
             _fZ_=el.tagName.toLowerCase() === "input"?1:0,
             _f0_=_fZ_?el.name === "x"?1:0:_fZ_,
             _fX_=_f0_}
          catch(_f1_){var _fX_=0}
          var _fY_=_fX_?982028505:-1003883683;
          createElementSyntax[1] = _fY_;
          continue}
        if(982028505 <= _fW_)
         {var a=new array_length();
          a.push("<",caml_jsstring_of_string(elt));
          opt_iter
           (type,
            function(t){a.push(' type="',caml_js_html_escape(t),'"');return 0});
          opt_iter
           (name,
            function(n){a.push(' name="',caml_js_html_escape(n),'"');return 0});
          a.push(">");
          return doc.createElement(a.join(""))}
        var res=createElement(doc,elt);
        opt_iter(type,function(t){return res.type = t});
        opt_iter(name,function(n){return res.name = n});
        return res}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Js_of_ocaml_Dom_html_Canva,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var c=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],c.getContext))throw Canvas_not_available;
      return c}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t39
       ?function(e){return e.innerHTML === t39?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var _fV_=caml_jsstring_of_string(tag);
      return e.tagName.toLowerCase() === _fV_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$2(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t39 && ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function eventRelatedTarget(e)
     {function _fS_(param)
       {var match=caml_string_of_jsstring(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _fT_=function(param){throw [0,Assert_failure,_i_]};
          return caml_call2(Optdef[8],e.fromElement,_fT_)}
        function _fU_(param){throw [0,Assert_failure,_j_]}
        return caml_call2(Optdef[8],e.toElement,_fU_)}
      return caml_call2(Optdef[8],e.relatedTarget,_fS_)}
    function eventAbsolutePosition(e)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              (e.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
              (e.clientY + body.scrollTop | 0) + html.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _fO_(x)
       {function _fQ_(y){return [0,x,y]}
        function _fR_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_fR_,_fQ_)}
      function _fP_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_fP_,_fO_)}
    function elementClientPosition(e)
     {var
       r=e.getBoundingClientRect(),
       body=document$0.body,
       html=document$0.documentElement;
      return [0,
              ((r.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
              ((r.top | 0) - body.clientTop | 0) - html.clientTop | 0]}
    function getDocumentScroll(param)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              body.scrollLeft + html.scrollLeft | 0,
              body.scrollTop + html.scrollTop | 0]}
    function buttonPressed(ev)
     {function _fM_(x){return x}
      function _fN_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_fN_,_fM_)}
    function addMousewheelEventListenerWith(e,capture,once,passive,h)
     {var d=createDiv(document$0);
      d.setAttribute("onmousewheel","return;");
      if(typeof d.onmousewheel === "function")
       {var
         _fI_=
          handler
           (function(e)
             {function _fK_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_fK_) | 0) / 40 | 0;
              function _fL_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_fL_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListenerWithOptions
                (e,Event$0[11],capture,once,passive,_fI_)}
      var
       _fJ_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListenerWithOptions
              (e,Event$0[12],capture,once,passive,_fJ_)}
    function addMousewheelEventListener(e,h,capt)
     {return addMousewheelEventListenerWith(e,[0,capt],0,0,h)}
    function f(v)
     {var
       match=caml_string_of_jsstring(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 90;case 1:return 86;default:return 92}}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 91;case 1:return 87;default:return 93}}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        {var switcher$0=param - 12 | 0;
         switch(switcher$0)
          {case 0:return 73;
           case 1:return 83;
           case 21:return 77;
           case 22:return 71;
           case 23:return 69;
           case 24:return 75;
           case 25:return 72;
           case 26:return 76;
           case 27:return 74;
           case 28:return 70;
           case 33:return 68;
           case 34:return 81
           }}
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _fH_=switcher;
        if(67 <= _fH_)
         switch(_fH_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_fH_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return 0 === v?caml_call1(f,value):v}
    function symbol$11(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _fA_=evt.keyCode;
      function _fB_(_fG_){return run_next(_fA_,try_key_code_normal,_fG_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _fC_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _fx_=evt.keyCode,
           _fC_=function(_fE_){return run_next(_fx_,try_key_code_left,_fE_)};
          break;
         case 1:
          var
           _fy_=evt.keyCode,
           _fC_=function(_fD_){return run_next(_fy_,try_key_code_right,_fD_)};
          break;
         default:
          var
           _fz_=evt.keyCode,
           _fC_=function(_fF_){return run_next(_fz_,try_key_code_numpad,_fF_)}}
      var value=evt.code;
      return symbol$11
              (symbol$11
                (symbol$11
                  (0,
                   function(v)
                    {return 0 === v
                             ?caml_call3(Optdef[7],value,make_unidentified,f)
                             :v}),
                 _fC_),
               _fB_)}
    function char_of_int(value)
     {if(caml_call2(symbol$5,0,value))
       try
        {var _fv_=[0,caml_call1(Stdlib_uchar[8],value)];return _fv_}
       catch(_fw_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var key=caml_call2(Optdef[8],evt.key,empty_string),match=key.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(key.charCodeAt(0) | 0):0}
    function element$1(_fu_){return _fu_}
    function tagged(e)
     {var tag=caml_string_of_jsbytes(e.tagName.toLowerCase());
      if(caml_call2(symbol$8,caml_ml_string_length(tag),0))return [61,e];
      var match=runtime.caml_string_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _fs_(e){return [0,tagged(e)]}
      function _ft_(param){return 0}
      return caml_call3(Opt[7],e,_ft_,_fs_)}
    function taggedEvent(ev)
     {function _fd_(ev){return [0,ev]}
      function _fe_(param)
       {function _fg_(ev){return [1,ev]}
        function _fh_(param)
         {function _fj_(ev){return [2,ev]}
          function _fk_(param)
           {function _fm_(ev){return [3,ev]}
            function _fn_(param)
             {function _fp_(ev){return [4,ev]}
              function _fq_(param){return [5,ev]}
              var _fr_=popStateEvent(ev);
              return caml_call3(Opt[7],_fr_,_fq_,_fp_)}
            var _fo_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_fo_,_fn_,_fm_)}
          var _fl_=wheelEvent(ev);
          return caml_call3(Opt[7],_fl_,_fk_,_fj_)}
        var _fi_=keyboardEvent(ev);
        return caml_call3(Opt[7],_fi_,_fh_,_fg_)}
      var _ff_=mouseEvent(ev);
      return caml_call3(Opt[7],_ff_,_fe_,_fd_)}
    function opt_taggedEvent(ev)
     {function _fb_(ev){return [0,taggedEvent(ev)]}
      function _fc_(param){return 0}
      return caml_call3(Opt[7],ev,_fc_,_fb_)}
    function stopPropagation(ev)
     {function _e$_(param){return ev.stopPropagation()}
      function _fa_(param){return ev.cancelBubble = true$0}
      return caml_call3(Optdef[7],ev.stopPropagation,_fa_,_e$_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _g_.requestAnimationFrame,
             [0,
              _g_.mozRequestAnimationFrame,
              [0,
               _g_.webkitRequestAnimationFrame,
               [0,
                _g_.oRequestAnimationFrame,
                [0,_g_.msRequestAnimationFrame,0]]]]];
          try
           {var
             _e8_=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(Stdlib_list[34],_e8_,l),
             _e9_=function(callback){return req(callback)};
            return _e9_}
          catch(_e__)
           {_e__ = caml_wrap_exception(_e__);
            if(_e__ === Stdlib[8])
             {var
               now=function(param){return new date_ms().getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0.?0.:dt;
                last[1] = t;
                _g_.setTimeout(callback,dt$0);
                return 0}}
            throw _e__}});
    function hasPushState(param)
     {return caml_call1(Optdef[5],_g_.history.pushState)}
    function hasPlaceholder(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.placeholder)}
    function hasRequired(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.required)}
    var overflow_limit=2147483000.;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483000. < step)
         var step$0=overflow_limit,remain=step - 2147483000.;
        else
         var step$0=step,remain=0.;
        var cb=remain == 0.?callback:function(_e7_){return loop(remain,_e7_)};
        id[1] = [0,_g_.setTimeout(caml_js_wrap_callback(cb),step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _e6_=id[1];
      if(_e6_){var x=_e6_[1];id[1] = 0;return _g_.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Js_of_ocaml_Dom_html=
      [0,
       d,
       document$0,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _g_,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       addMousewheelEventListenerWith,
       addMousewheelEventListener,
       createCustomEvent,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$2,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1645,Js_of_ocaml_Dom_html,"Js_of_ocaml__Dom_html");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var
       _e4_=caml_call2(symbol$9,elt.name.length,0),
       _e5_=_e4_?1 - (elt.disabled | 0):_e4_;
      return _e5_}
    function form_elements(get,form)
     {var length=form.elements.length;
      function _eS_(i)
       {var _e3_=form.elements.item(i);return caml_call1(Opt[10],_e3_)}
      var
       _eT_=caml_call2(Stdlib_array[2],length,_eS_),
       elements=caml_call1(Stdlib_array[11],_eT_);
      function _eU_(param)
       {if(param)
         {var v=param[1],match$3=tagged(v);
          switch(match$3[0])
           {case 31:
             var v$0=match$3[1];
             if(get)var sth=get[1],get$0=sth;else var get$0=0;
             if(have_content(v$0))
              {var
                name$1=caml_string_of_jsstring(v$0.name),
                value=v$0.value,
                match=caml_string_of_jsbytes(v$0.type.toLowerCase());
               if(caml_string_notequal(match,cst_checkbox))
                {if(! caml_string_notequal(match,cst_file))
                  {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                   var match$0=caml_call1(Optdef[10],v$0.files);
                   if(match$0)
                    {var list=match$0[1];
                     if(caml_call2(symbol$8,list.length,0))
                      return [0,[0,name$1,[0,-976970511,""]],0];
                     var match$1=caml_call1(Optdef[10],v$0.multiple);
                     if(match$1 && 0 !== match$1[1])
                      {var
                        _eZ_=function(i){return list.item(i)},
                        _e0_=caml_call2(Stdlib_array[2],list.length,_eZ_),
                        _e1_=caml_call1(Stdlib_array[11],_e0_);
                       return filter_map$0
                               (function(f)
                                 {var match=caml_call1(Opt[10],f);
                                  if(match)
                                   {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                  return 0},
                                _e1_)}
                     var _eY_=list.item(0),match$2=caml_call1(Opt[10],_eY_);
                     if(match$2)
                      {var file=match$2[1];
                       return [0,[0,name$1,[0,781515420,file]],0]}
                     return 0}
                   return 0}
                 var switch$0=0;
                 if(caml_string_notequal(match,cst_password))
                  {if(caml_string_notequal(match,cst_radio))
                    {var switch$1=0;
                     if
                      (caml_string_notequal(match,cst_reset)
                       &&
                       caml_string_notequal(match,cst_submit$0))
                      {if(caml_string_notequal(match,cst_text))
                        return [0,[0,name$1,[0,-976970511,value]],0];
                       switch$0 = 1;
                       switch$1 = 1}
                     if(! switch$1)return 0}}
                 else
                  switch$0 = 1;
                 if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
               return v$0.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
             return 0;
            case 48:
             var v$1=match$3[1];
             if(have_content(v$1))
              {var name$0=caml_string_of_jsstring(v$1.name);
               if(v$1.multiple | 0)
                {var
                  _eW_=
                   function(i)
                    {var _e2_=v$1.options.item(i);
                     return caml_call1(Opt[10],_e2_)},
                  options=caml_call2(Stdlib_array[2],v$1.options.length,_eW_),
                  _eX_=caml_call1(Stdlib_array[11],options);
                 return filter_map$0
                         (function(param)
                           {if(param)
                             {var e=param[1];
                              return e.selected | 0
                                      ?[0,[0,name$0,[0,-976970511,e.value]]]
                                      :0}
                            return 0},
                          _eX_)}
               return [0,[0,name$0,[0,-976970511,v$1.value]],0]}
             return 0;
            case 53:
             var v$2=match$3[1];
             if(have_content(v$2))
              {var name=caml_string_of_jsstring(v$2.name);
               return [0,[0,name,[0,-976970511,v$2.value]],0]}
             return 0;
            default:return 0}}
        return 0}
      var
       _eV_=caml_call2(Stdlib_list[17],_eU_,elements),
       contents=caml_call1(Stdlib_list[14],_eV_);
      return contents}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_eQ_=form_elt[2],_eR_=form_elt[1];
      if(781515420 <= _eQ_[1])
       {var file=_eQ_[2];return f.append(caml_jsstring_of_string(_eR_),file)}
      var s=_eQ_[2];
      return f.append(caml_jsstring_of_string(_eR_),s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_eN_=form_elements(0,form);
      function _eO_(_eP_){return append(contents,_eP_)}
      caml_call2(Stdlib_list[15],_eO_,_eN_);
      return contents}
    function get_form_contents(form)
     {var _eJ_=form_elements(_k_,form);
      function _eK_(param)
       {var _eL_=param[2],_eM_=param[1];
        if(typeof _eL_ !== "number" && -976970511 === _eL_[1])
         {var s=_eL_[2];return [0,_eM_,caml_string_of_jsstring(s)]}
        throw [0,Assert_failure,_l_]}
      return caml_call2(Stdlib_list[17],_eK_,_eJ_)}
    var
     Js_of_ocaml_Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1646,Js_of_ocaml_Form,"Js_of_ocaml__Form");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$1=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0],
     Js_of_ocaml_XmlHttpRequest=[0,runtime.caml_xmlhttprequest_create,Event$1];
    caml_register_global
     (1647,Js_of_ocaml_XmlHttpRequest,"Js_of_ocaml__XmlHttpRequest");
    var worker=Unsafe[1].Worker;
    function create(script)
     {return new worker(caml_jsstring_of_string(script))}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t39)
       caml_call1(Stdlib[1],cst_Worker_import_scripts_is_u);
      var
       _eH_=caml_call1(Stdlib_array[12],scripts),
       _eI_=caml_call2(Stdlib_array[15],caml_jsstring_of_string,_eH_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_eI_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return Unsafe[1].onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(msg)
     {if(Unsafe[1].postMessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi$0);
      return Unsafe[1].postMessage(msg)}
    var
     Js_of_ocaml_Worker=
      [0,create,import_scripts,set_onmessage,post_message];
    caml_register_global(1648,Js_of_ocaml_Worker,"Js_of_ocaml__Worker");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported(param){return caml_call1(Optdef[5],webSocket)}
    var Js_of_ocaml_WebSockets=[0,webSocket,webSocket,webSocket,is_supported];
    caml_register_global
     (1649,Js_of_ocaml_WebSockets,"Js_of_ocaml__WebSockets");
    var
     defaultContextAttributes=
      {"alpha":true$0,
       "depth":true$0,
       "stencil":false$0,
       "antialias":true$0,
       "premultipliedAlpha":false$0,
       "preserveDrawingBuffer":false$0,
       "preferLowPowerToHighPerformance":false$0,
       "failIfMajorPerformanceCaveat":false$0},
     webglcontextlost=caml_call1(Event$0[83],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[83],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[83],cst_webglcontextcreationerror),
     Event$2=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(c)
     {var ctx=c.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:c.getContext("experimental-webgl")}
    function getContextWithAttributes(c,attribs)
     {var ctx=c.getContext("webgl",attribs);
      return caml_call1(Opt[5],ctx)
              ?ctx
              :c.getContext("experimental-webgl",attribs)}
    var
     Js_of_ocaml_WebGL=
      [0,defaultContextAttributes,Event$2,getContext,getContextWithAttributes];
    caml_register_global(1650,Js_of_ocaml_WebGL,"Js_of_ocaml__WebGL");
    function regexp(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"g")}
    function regexp_case_fold(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"gi")}
    function regexp_with_flag(s,f)
     {return new
              regExp_withFlags
              (caml_jsbytes_of_string(s),
               caml_jsstring_of_string(caml_call2(Stdlib[28],cst_g,f)))}
    function blunt_str_array_get(a,i)
     {function _eG_(param){throw [0,Assert_failure,_m_]}
      return caml_string_of_jsbytes(caml_call2(Optdef[8],a[i],_eG_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       _eE_=r.exec(caml_jsbytes_of_string(s)),
       _eF_=caml_call2(Opt[3],_eE_,match_result);
      return caml_call1(Opt[10],_eF_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      function _eB_(res){return [0,res.index,res]}
      var
       _eC_=r.exec(caml_jsbytes_of_string(s)),
       _eD_=caml_call2(Opt[3],_eC_,_eB_);
      return caml_call1(Opt[10],_eD_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _eA_=caml_call2(Optdef[3],r[i],caml_string_of_jsbytes);
      return caml_call1(Optdef[10],_eA_)}
    var quote_repl_re=new regExp_withFlags("[$]","g");
    function quote_repl(s)
     {return caml_jsbytes_of_string(s).replace(quote_repl_re,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      return caml_string_of_jsbytes
              (caml_jsbytes_of_string(s).replace(r,quote_repl(s_by)))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=0 === match?0 === match$0?"":"m":0 === match$0?"i":"mi",
       r$0=new regExp_withFlags(r.source,flags);
      return caml_string_of_jsbytes
              (caml_jsbytes_of_string(s).replace(r$0,quote_repl(s_by)))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(caml_call2(symbol$5,idx,0))return accu;
        var
         idx$0=idx - 1 | 0,
         accu$0=[0,blunt_str_array_get(a,idx),accu],
         accu=accu$0,
         idx=idx$0;
        continue}}
    function split(r,s)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r,i))}
    var quote_re=regexp(cst);
    function quote(s)
     {return caml_string_of_jsbytes
              (caml_jsbytes_of_string(s).replace(quote_re,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Js_of_ocaml_Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1651,Js_of_ocaml_Regexp,"Js_of_ocaml__Regexp");
    var Local_exn=[248,cst_Js_of_ocaml_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var
     plus_re=regexp_string(cst$0),
     plus_re_js_string=new regExp_withFlags("\\+","g");
    function urldecode_js_string_string(s)
     {plus_re_js_string.lastIndex = 0;
      return caml_string_of_jsbytes
              (unescape(s.replace(plus_re_js_string," ")))}
    function urldecode(s)
     {return caml_string_of_jsbytes
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$1))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Js_of_ocaml_Url_Not_an_htt,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _ey_=caml_call3(String[18],s,i,47),j=_ey_}
        catch(_ez_)
         {_ez_ = caml_wrap_exception(_ez_);
          if(_ez_ !== Stdlib[8])throw _ez_;
          var j=l}
        var word=caml_call3(String[4],s,i,j - i | 0);
        return caml_call2(symbol$10,j,l)?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a && ! caml_string_notequal(a[1],cst$2))
       {var _ex_=a[2];
        if(! _ex_)return 0;
        if(! caml_string_notequal(_ex_[1],cst$3) && ! _ex_[2])return _n_}
      return a}
    function encode_arguments(l)
     {function _es_(param)
       {var
         v=param[2],
         n=param[1],
         _eu_=urlencode(0,v),
         _ev_=caml_call2(Stdlib[28],cst$4,_eu_),
         _ew_=urlencode(0,n);
        return caml_call2(Stdlib[28],_ew_,_ev_)}
      var _et_=caml_call2(Stdlib_list[17],_es_,l);
      return caml_call2(String[7],cst$5,_et_)}
    function decode_arguments_js_string(s)
     {var
       arr=s.split(caml_jsstring_of_string(caml_call2(String[1],1,38))),
       len=arr.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(caml_call2(symbol$5,idx$0,0))return acc;
          try
           {var
             _ek_=idx$0 - 1 | 0,
             _el_=
              function(s)
               {function _eq_(param)
                 {var
                   y=param[2],
                   x=param[1],
                   _er_=urldecode_js_string_string(y);
                  return [0,urldecode_js_string_string(x),_er_]}
                var
                 index=
                  s.indexOf
                   (caml_jsstring_of_string(caml_call2(String[1],1,61)));
                if(caml_call2(symbol$5,index,0))
                 var _ep_=t39;
                else
                 var
                  _eo_=s.slice(index + 1 | 0),
                  _ep_=[0,s.slice(0,index),_eo_];
                return caml_call3(Optdef[7],_ep_,interrupt,_eq_)},
             _em_=
              aux
               ([0,caml_call3(Optdef[7],arr[idx$0],interrupt,_el_),acc],_ek_);
            return _em_}
          catch(_en_)
           {_en_ = caml_wrap_exception(_en_);
            if(_en_ === Local_exn)
             {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
            throw _en_}}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     url_re=
      new
       regExp_withFlags
       (caml_jsbytes_of_string(cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0)),
     file_re=new regExp_withFlags(caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee));
    function url_of_js_string(s)
     {function _d3_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_string_of_jsbytes(prot_string.toLowerCase());
        if
         (caml_string_notequal(match,cst_file$0)
          &&
          caml_string_notequal(match,cst_file$1))
         {var switch$0=0;
          if
           (caml_string_notequal(match,cst_http)
            &&
            caml_string_notequal(match,cst_http$0))
           {var switch$1=0;
            if
             (caml_string_notequal(match,cst_https)
              &&
              caml_string_notequal(match,cst_https$0))
             switch$1 = 1;
            if(! switch$1){var ssl=1;switch$0 = 2}}
          else
           switch$0 = 1;
          var switch$2=0;
          switch(switch$0)
           {case 1:var ssl=0;switch$2 = 1;break;
            case 0:break;
            default:switch$2 = 1}
          if(switch$2)
           {var
             _eb_=function(param){return caml_jsbytes_of_string(cst$7)},
             path_str=
              urldecode_js_string_string(caml_call2(Optdef[8],res[6],_eb_)),
             _ec_=function(param){return caml_jsbytes_of_string(cst$8)},
             _ed_=
              urldecode_js_string_string(caml_call2(Optdef[8],res[10],_ec_)),
             _ee_=function(param){return caml_jsbytes_of_string(cst$9)},
             _ef_=
              decode_arguments_js_string(caml_call2(Optdef[8],res[8],_ee_)),
             _eg_=path_of_path_string(path_str),
             _eh_=function(param){return caml_jsbytes_of_string(cst$10)},
             s=caml_string_of_jsbytes(caml_call2(Optdef[8],res[4],_eh_)),
             _ei_=
              caml_string_notequal(s,cst$6)?caml_int_of_string(s):ssl?443:80,
             url=
              [0,
               urldecode_js_string_string
                (caml_call2(Optdef[8],res[2],interrupt)),
               _ei_,
               _eg_,
               path_str,
               _ef_,
               _ed_],
             _ej_=ssl?[1,url]:[0,url];
            return [0,_ej_]}}
        throw Not_an_http_protocol}
      function _d4_(param)
       {function _d6_(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _d9_(param){return caml_jsbytes_of_string(cst$11)}
          var _d__=caml_string_of_jsbytes(caml_call2(Optdef[8],res[6],_d9_));
          function _d$_(param){return caml_jsbytes_of_string(cst$12)}
          var
           _ea_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_d$_));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_ea_,_d__]]]}
        function _d7_(param){return 0}
        var _d8_=file_re.exec(s);
        return caml_call3(Opt[7],_d8_,_d7_,_d6_)}
      var _d5_=url_re.exec(s);
      return caml_call3(Opt[7],_d5_,_d4_,_d3_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$13))
          var _dq_=urlencode(0,frag),_dr_=caml_call2(Stdlib[28],cst$14,_dq_);
         else
          var _dr_=cst$21;
         if(args)
          var
           _ds_=encode_arguments(args),
           _dt_=caml_call2(Stdlib[28],cst$15,_ds_);
         else
          var _dt_=cst$20;
         var
          _du_=caml_call2(Stdlib[28],_dt_,_dr_),
          _dv_=function(x){return urlencode(0,x)},
          _dw_=caml_call2(Stdlib_list[17],_dv_,path),
          _dx_=caml_call2(String[7],cst$16,_dw_),
          _dy_=caml_call2(Stdlib[28],_dx_,_du_),
          _dz_=caml_call2(Stdlib[28],cst$17,_dy_);
         if(80 === port)
          var _dA_=cst$18;
         else
          var
           _dE_=caml_call1(Stdlib[33],port),
           _dA_=caml_call2(Stdlib[28],cst$19,_dE_);
         var
          _dB_=caml_call2(Stdlib[28],_dA_,_dz_),
          _dC_=urlencode(0,host),
          _dD_=caml_call2(Stdlib[28],_dC_,_dB_);
         return caml_call2(Stdlib[28],cst_http$1,_dD_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$22))
          var
           _dF_=urlencode(0,frag$0),
           _dG_=caml_call2(Stdlib[28],cst$23,_dF_);
         else
          var _dG_=cst$30;
         if(args$0)
          var
           _dH_=encode_arguments(args$0),
           _dI_=caml_call2(Stdlib[28],cst$24,_dH_);
         else
          var _dI_=cst$29;
         var
          _dJ_=caml_call2(Stdlib[28],_dI_,_dG_),
          _dK_=function(x){return urlencode(0,x)},
          _dL_=caml_call2(Stdlib_list[17],_dK_,path$0),
          _dM_=caml_call2(String[7],cst$25,_dL_),
          _dN_=caml_call2(Stdlib[28],_dM_,_dJ_),
          _dO_=caml_call2(Stdlib[28],cst$26,_dN_);
         if(443 === port$0)
          var _dP_=cst$27;
         else
          var
           _dT_=caml_call1(Stdlib[33],port$0),
           _dP_=caml_call2(Stdlib[28],cst$28,_dT_);
         var
          _dQ_=caml_call2(Stdlib[28],_dP_,_dO_),
          _dR_=urlencode(0,host$0),
          _dS_=caml_call2(Stdlib[28],_dR_,_dQ_);
         return caml_call2(Stdlib[28],cst_https$1,_dS_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$31))
          var
           _dU_=urlencode(0,frag$1),
           _dV_=caml_call2(Stdlib[28],cst$32,_dU_);
         else
          var _dV_=cst$36;
         if(args$1)
          var
           _dW_=encode_arguments(args$1),
           _dX_=caml_call2(Stdlib[28],cst$33,_dW_);
         else
          var _dX_=cst$35;
         var
          _dY_=caml_call2(Stdlib[28],_dX_,_dV_),
          _dZ_=function(x){return urlencode(0,x)},
          _d0_=caml_call2(Stdlib_list[17],_dZ_,path$1),
          _d1_=caml_call2(String[7],cst$34,_d0_),
          _d2_=caml_call2(Stdlib[28],_d1_,_dY_);
         return caml_call2(Stdlib[28],cst_file$2,_d2_)}}
    var _o_=caml_call1(Optdef[2],_g_.location);
    if(caml_call1(Optdef[5],_o_))
     var _p_=_g_.location;
    else
     var
      t42=function(param,_dp_){return 0},
      t41=function(param,_do_){return 0},
      t40=function(param){return 0},
      _p_=
       {"href":"",
        "protocol":"",
        "host":"",
        "hostname":"",
        "port":"",
        "pathname":"",
        "search":"",
        "hash":"",
        "origin":t39,
        "reload":caml_js_wrap_meth_callback(t40),
        "replace":caml_js_wrap_meth_callback(t41),
        "assign":caml_js_wrap_meth_callback(t42)};
    var
     host=urldecode_js_string_string(_p_.hostname),
     protocol=urldecode_js_string_string(_p_.protocol),
     _q_=0,
     port=
      function(param)
        {try
          {var _dm_=[0,caml_int_of_string(caml_string_of_jsbytes(_p_.port))];
           return _dm_}
         catch(_dn_)
          {_dn_ = caml_wrap_exception(_dn_);
           if(_dn_[1] === Stdlib[7])return 0;
           throw _dn_}}
       (_q_),
     path_string=urldecode_js_string_string(_p_.pathname),
     path=path_of_path_string(path_string),
     _r_=_p_.search.charAt(0) === "?"?_p_.search.slice(1):_p_.search,
     arguments$0=decode_arguments_js_string(_r_);
    function get_fragment(param)
     {function _di_(res){return caml_string_of_jsstring(res[1])}
      function _dj_(param){return cst$37}
      var _dk_=new regExp_withFlags("#(.*)"),_dl_=_p_.href.match(_dk_);
      return caml_call3(Opt[7],_dl_,_dj_,_di_)}
    function set_fragment(s)
     {return _p_.hash = caml_jsbytes_of_string(urlencode(0,s))}
    function get$2(param){return url_of_js_string(_p_.href)}
    function set$0(u)
     {return _p_.href = caml_jsbytes_of_string(string_of_url(u))}
    var
     as_string=urldecode_js_string_string(_p_.href),
     Js_of_ocaml_Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$0,
        as_string]];
    caml_register_global(1653,Js_of_ocaml_Url,"Js_of_ocaml__Url");
    var Js_of_ocaml_Lib_version=[0,s,git_version];
    caml_register_global
     (1654,Js_of_ocaml_Lib_version,"Js_of_ocaml__Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Stdlib[60],name);
      caml_call2(Stdlib[66],oc,content);
      return caml_call1(Stdlib[76],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_string_of_jsbytes(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    var unmount=runtime.caml_unmount;
    if(caml_call2(String[38],git_version,cst$38))
     var js_of_ocaml_version=s;
    else
     var
      _cl_=caml_call2(Stdlib[28],cst$41,git_version),
      js_of_ocaml_version=caml_call2(Stdlib[28],s,_cl_);
    var
     _s_=runtime.caml_create_file,
     _t_=runtime.caml_read_file_content,
     Js_of_ocaml_Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_dh_){return runtime.caml_list_mount_point(_dh_)},
       unmount,
       mount,
       _t_,
       _s_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1655,Js_of_ocaml_Sys_js,"Js_of_ocaml__Sys_js");
    function empty_resize_observer_options(param){return {}}
    var resizeObserver=Unsafe[1].ResizeObserver;
    function is_supported$0(param)
     {return caml_call1(Optdef[5],resizeObserver)}
    function observe(node,f,box,param)
     {var obs=new resizeObserver(caml_js_wrap_callback(f));
      if(box)
       {var box$0=box[1],opts={};opts.box = box$0;obs.observe(node,opts)}
      else
       obs.observe(node);
      return obs}
    var
     Js_of_ocaml_ResizeObserver=
      [0,empty_resize_observer_options,resizeObserver,is_supported$0,observe];
    caml_register_global
     (1656,Js_of_ocaml_ResizeObserver,"Js_of_ocaml__ResizeObserver");
    function empty_mutation_observer_init(param){return {}}
    var mutationObserver=Unsafe[1].MutationObserver;
    function is_supported$1(param)
     {return caml_call1(Optdef[5],mutationObserver)}
    function observe$0
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var obs=new mutationObserver(caml_js_wrap_callback(f)),cfg={};
      opt_iter(child_list,function(v){return cfg.childList = v});
      opt_iter(attributes,function(v){return cfg.attributes = v});
      opt_iter(character_data,function(v){return cfg.characterData = v});
      opt_iter(subtree,function(v){return cfg.subtree = v});
      opt_iter
       (attribute_old_value,function(v){return cfg.attributeOldValue = v});
      opt_iter
       (character_data_old_value,
        function(v){return cfg.characterDataOldValue = v});
      opt_iter
       (attribute_filter,
        function(l)
         {return cfg.attributeFilter
                 =
                 caml_js_from_array(caml_call1(Stdlib_array[12],l))});
      obs.observe(node,cfg);
      return obs}
    var
     Js_of_ocaml_MutationObserver=
      [0,
       empty_mutation_observer_init,
       mutationObserver,
       is_supported$1,
       observe$0];
    caml_register_global
     (1657,Js_of_ocaml_MutationObserver,"Js_of_ocaml__MutationObserver");
    var obj=Unsafe[1].Object;
    function create$0(param){return new obj()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       key_array=Unsafe[1].Object.keys(t),
       res=[0,0],
       _dd_=key_array.length - 1 | 0,
       _dc_=0;
      if(! (_dd_ < 0))
       {var i=_dc_;
        for(;;)
         {var
           _de_=function(param){return caml_call1(Stdlib[2],cst_Jstable_keys)},
           key=caml_call2(Optdef[8],key_array[i],_de_),
           _df_=res[1];
          res[1] = [0,key.substring(0,key.length - 1 | 0),_df_];
          var _dg_=i + 1 | 0;
          if(_dd_ !== i){var i=_dg_;continue}
          break}}
      return caml_call1(Stdlib_list[9],res[1])}
    var Js_of_ocaml_Jstable=[0,create$0,add$0,remove,find,keys];
    caml_register_global(1658,Js_of_ocaml_Jstable,"Js_of_ocaml__Jstable");
    var json=Unsafe[1].JSON;
    function reviver(this$0,key,value)
     {if(typeof value == typeof "foo")return caml_string_of_jsbytes(value);
      if
       (value instanceof array_length
        &&
        4
        ===
        value.length
        &&
        255
        ===
        value[0])
       return runtime.caml_int64_create_lo_mi_hi(value[1],value[2],value[3]);
      return value}
    var input_reviver=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(s){return json.parse(s,input_reviver)}
    var
     mlString_constr=dummy_string.constructor,
     mlInt64_constr=dummy_int64.constructor;
    function output_reviver(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value instanceof mlInt64_constr
                ?caml_js_from_array([0,255,value.lo,value.mi,value.hi])
                :value}
    function output(obj){return json.stringify(obj,output_reviver)}
    var Js_of_ocaml_Json=[0,output,unsafe_input];
    caml_register_global(1659,Js_of_ocaml_Json,"Js_of_ocaml__Json");
    function string_of_name(param)
     {var _db_=param;
      if(74 <= _db_)
       {if(111 <= _db_)
         switch(_db_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_db_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _db_)
       switch(_db_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_db_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      var _da_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color_name);
      throw [0,Stdlib[6],_da_]}
    function rgb_of_name(param)
     {var _c$_=param;
      if(74 <= _c$_)
       {if(111 <= _c$_)
         switch(_c$_)
          {case 111:return _bn_;
           case 112:return _bo_;
           case 113:return _bp_;
           case 114:return _bq_;
           case 115:return _br_;
           case 116:return _bs_;
           case 117:return _bt_;
           case 118:return _bu_;
           case 119:return _bv_;
           case 120:return _bw_;
           case 121:return _bx_;
           case 122:return _by_;
           case 123:return _bz_;
           case 124:return _bA_;
           case 125:return _bB_;
           case 126:return _bC_;
           case 127:return _bD_;
           case 128:return _bE_;
           case 129:return _bF_;
           case 130:return _bG_;
           case 131:return _bH_;
           case 132:return _bI_;
           case 133:return _bJ_;
           case 134:return _bK_;
           case 135:return _bL_;
           case 136:return _bM_;
           case 137:return _bN_;
           case 138:return _bO_;
           case 139:return _bP_;
           case 140:return _bQ_;
           case 141:return _bR_;
           case 142:return _bS_;
           case 143:return _bT_;
           case 144:return _bU_;
           case 145:return _bV_;
           default:return _bW_}
        switch(_c$_)
         {case 74:return _aO_;
          case 75:return _aP_;
          case 76:return _aQ_;
          case 77:return _aR_;
          case 78:return _aS_;
          case 79:return _aT_;
          case 80:return _aU_;
          case 81:return _aV_;
          case 82:return _aW_;
          case 83:return _aX_;
          case 84:return _aY_;
          case 85:return _aZ_;
          case 86:return _a0_;
          case 87:return _a1_;
          case 88:return _a2_;
          case 89:return _a3_;
          case 90:return _a4_;
          case 91:return _a5_;
          case 92:return _a6_;
          case 93:return _a7_;
          case 94:return _a8_;
          case 95:return _a9_;
          case 96:return _a__;
          case 97:return _a$_;
          case 98:return _ba_;
          case 99:return _bb_;
          case 100:return _bc_;
          case 101:return _bd_;
          case 102:return _be_;
          case 103:return _bf_;
          case 104:return _bg_;
          case 105:return _bh_;
          case 106:return _bi_;
          case 107:return _bj_;
          case 108:return _bk_;
          case 109:return _bl_;
          default:return _bm_}}
      if(37 <= _c$_)
       switch(_c$_)
        {case 37:return _ad_;
         case 38:return _ae_;
         case 39:return _af_;
         case 40:return _ag_;
         case 41:return _ah_;
         case 42:return _ai_;
         case 43:return _aj_;
         case 44:return _ak_;
         case 45:return _al_;
         case 46:return _am_;
         case 47:return _an_;
         case 48:return _ao_;
         case 49:return _ap_;
         case 50:return _aq_;
         case 51:return _ar_;
         case 52:return _as_;
         case 53:return _at_;
         case 54:return _au_;
         case 55:return _av_;
         case 56:return _aw_;
         case 57:return _ax_;
         case 58:return _ay_;
         case 59:return _az_;
         case 60:return _aA_;
         case 61:return _aB_;
         case 62:return _aC_;
         case 63:return _aD_;
         case 64:return _aE_;
         case 65:return _aF_;
         case 66:return _aG_;
         case 67:return _aH_;
         case 68:return _aI_;
         case 69:return _aJ_;
         case 70:return _aK_;
         case 71:return _aL_;
         case 72:return _aM_;
         default:return _aN_}
      switch(_c$_)
       {case 0:return _u_;
        case 1:return _v_;
        case 2:return _w_;
        case 3:return _x_;
        case 4:return _y_;
        case 5:return _z_;
        case 6:return _A_;
        case 7:return _B_;
        case 8:return _C_;
        case 9:return _D_;
        case 10:return _E_;
        case 11:return _F_;
        case 12:return _G_;
        case 13:return _H_;
        case 14:return _I_;
        case 15:return _J_;
        case 16:return _K_;
        case 17:return _L_;
        case 18:return _M_;
        case 19:return _N_;
        case 20:return _O_;
        case 21:return _P_;
        case 22:return _Q_;
        case 23:return _R_;
        case 24:return _S_;
        case 25:return _T_;
        case 26:return _U_;
        case 27:return _V_;
        case 28:return _W_;
        case 29:return _X_;
        case 30:return _Y_;
        case 31:return _Z_;
        case 32:return ___;
        case 33:return _$_;
        case 34:return _aa_;
        case 35:return _ab_;
        default:return _ac_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Stdlib_printf[4],_bX_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Stdlib_printf[4],_bY_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Stdlib_printf[4],_bZ_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Stdlib_printf[4],_b0_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Stdlib_printf[4],_b1_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Stdlib_printf[4],_b2_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var
         _c7_=caml_call2(symbol$5,i,0),
         _c8_=_c7_ || caml_call2(symbol$9,i,255);
        if(_c8_)
         {var
           _c9_=caml_call1(Stdlib[33],i),
           _c__=caml_call2(Stdlib[28],_c9_,cst_is_out_of_valid_range);
          throw [0,Stdlib[6],_c__]}
        return _c8_}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Stdlib_printf[4],_b3_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       rgb_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d)),
       rgb_pct_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0)),
       rgba_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d)),
       rgba_pct_re=
        new
         regExp_withFlags
         (caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0)),
       hsl_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d)),
       hsla_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d));
      if
       (!
        (rgb_re.test(s) | 0)
        &&
        !
        (rgba_re.test(s) | 0)
        &&
        !
        (rgb_pct_re.test(s) | 0)
        &&
        !
        (rgba_pct_re.test(s) | 0)
        &&
        !
        (hsl_re.test(s) | 0)
        &&
        !
        (hsla_re.test(s) | 0))
       {var _c4_=caml_string_of_jsstring(s);
        if(caml_call2(Stdlib_list[32],_c4_,_b4_))return s;
        var
         _c5_=caml_string_of_jsstring(s),
         _c6_=caml_call2(Stdlib[28],_c5_,cst_is_not_a_valid_color);
        throw [0,Stdlib[6],_c6_]}
      return s}
    function js(c)
     {if(0 === c[0])
       {var n=c[1];return caml_jsstring_of_string(string_of_name(n))}
      return caml_jsstring_of_string(string_of_t(c))}
    function ml(c)
     {var s=caml_string_of_jsstring(c);
      try
       {var _cR_=[0,name_of_string(s)];return _cR_}
      catch(_cS_)
       {_cS_ = caml_wrap_exception(_cS_);
        if(_cS_[1] === Stdlib[6])
         {var
           fail=
            function(param)
             {var _c3_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color$0);
              throw [0,Stdlib[6],_c3_]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _c1_=caml_int_of_string(i);return _c1_}
                catch(_c2_)
                 {_c2_ = caml_wrap_exception(_c2_);
                  if(_c2_[1] === Stdlib[6])
                   var s=_c2_[2];
                  else
                   {if(_c2_[1] !== Stdlib[7])throw _c2_;var s=_c2_[2]}
                  var
                   _cY_=caml_call2(Stdlib[28],cst$39,s),
                   _cZ_=caml_call2(Stdlib[28],i,_cY_),
                   _c0_=caml_call2(Stdlib[28],cst_color_conversion_error,_cZ_);
                  throw [0,Stdlib[6],_c0_]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _cW_=caml_float_of_string(f);return _cW_}
              catch(_cX_)
               {_cX_ = caml_wrap_exception(_cX_);
                if(_cX_[1] === Stdlib[6])
                 var s=_cX_[2];
                else
                 {if(_cX_[1] !== Stdlib[7])throw _cX_;var s=_cX_[2]}
                var
                 _cT_=caml_call2(Stdlib[28],cst$40,s),
                 _cU_=caml_call2(Stdlib[28],f,_cT_),
                 _cV_=caml_call2(Stdlib[28],cst_color_conversion_error$0,_cU_);
                throw [0,Stdlib[6],_cV_]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _cz_=match$0[1];
              if(! caml_string_notequal(_cz_,cst_rgb))
               {if(alpha)return fail(0);
                var _cD_=i_of_s_o(blue),_cE_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_cE_,_cD_]]}
              if(! caml_string_notequal(_cz_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _cA_=f_of_s(a),
                   _cB_=i_of_s_o(blue),
                   _cC_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_cC_,_cB_,_cA_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _cF_=match$2[1];
              if(! caml_string_notequal(_cF_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _cJ_=i_of_s_o(blue$0),_cK_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_cK_,_cJ_]]}
              if(! caml_string_notequal(_cF_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _cG_=f_of_s(a$0),
                   _cH_=i_of_s_o(blue$0),
                   _cI_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_cI_,_cH_,_cG_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _cL_=match$4[1];
              if(! caml_string_notequal(_cL_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _cP_=i_of_s_o(blue$1),_cQ_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_cQ_,_cP_]]}
              if(! caml_string_notequal(_cL_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _cM_=f_of_s(a$1),
                   _cN_=i_of_s_o(blue$1),
                   _cO_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_cO_,_cN_,_cM_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _cS_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:
          var f=param[1];return caml_call3(Stdlib_printf[4],_b5_,f,cst_em$0);
         case 1:
          var f$0=param[1];
          return caml_call3(Stdlib_printf[4],_b6_,f$0,cst_ex);
         case 2:
          var f$1=param[1];
          return caml_call3(Stdlib_printf[4],_b7_,f$1,cst_px);
         case 3:
          var f$2=param[1];
          return caml_call3(Stdlib_printf[4],_b8_,f$2,cst_gd);
         case 4:
          var f$3=param[1];
          return caml_call3(Stdlib_printf[4],_b9_,f$3,cst_rem);
         case 5:
          var f$4=param[1];
          return caml_call3(Stdlib_printf[4],_b__,f$4,cst_vw);
         case 6:
          var f$5=param[1];
          return caml_call3(Stdlib_printf[4],_b$_,f$5,cst_vh);
         case 7:
          var f$6=param[1];
          return caml_call3(Stdlib_printf[4],_ca_,f$6,cst_vm);
         case 8:
          var f$7=param[1];
          return caml_call3(Stdlib_printf[4],_cb_,f$7,cst_ch);
         case 9:
          var f$8=param[1];
          return caml_call3(Stdlib_printf[4],_cc_,f$8,cst_mm);
         case 10:
          var f$9=param[1];
          return caml_call3(Stdlib_printf[4],_cd_,f$9,cst_cm);
         case 11:
          var f$10=param[1];
          return caml_call3(Stdlib_printf[4],_ce_,f$10,cst_in);
         case 12:
          var f$11=param[1];
          return caml_call3(Stdlib_printf[4],_cf_,f$11,cst_pt);
         default:
          var f$12=param[1];
          return caml_call3(Stdlib_printf[4],_cg_,f$12,cst_pc)}}
    function js$0(t){return caml_jsstring_of_string(string_of_t$0(t))}
    function ml$0(t)
     {var s=caml_string_of_jsstring(t);
      if(caml_call2(String[38],s,cst_0$0))return 0;
      function fail(param)
       {var _cy_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length);
        throw [0,Stdlib[6],_cy_]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cw_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cv_=caml_call2(Stdlib[28],cst_length_conversion_error,s$0);
              throw [0,Stdlib[6],_cv_]}
            throw exn}
          var f$0=_cw_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cx_=match$1[1],switch$0=caml_string_compare(_cx_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_cx_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_cx_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_cx_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_cx_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_cx_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_cx_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_cx_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_cx_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_cx_,cst_em$1))return [0,f$0];
            if(! caml_string_notequal(_cx_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_cx_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_cx_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_cx_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:
         var f=param[1];return caml_call3(Stdlib_printf[4],_ch_,f,cst_deg);
        case 1:
         var f$0=param[1];
         return caml_call3(Stdlib_printf[4],_ci_,f$0,cst_grad);
        case 2:
         var f$1=param[1];
         return caml_call3(Stdlib_printf[4],_cj_,f$1,cst_rad);
        default:
         var f$2=param[1];
         return caml_call3(Stdlib_printf[4],_ck_,f$2,cst_turns)}}
    function js$1(t){return caml_jsstring_of_string(string_of_t$1(t))}
    function ml$1(j)
     {var s=caml_string_of_jsstring(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {var _cu_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length$0);
        throw [0,Stdlib[6],_cu_]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cs_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cr_=caml_call2(Stdlib[28],cst_length_conversion_error$0,s$0);
              throw [0,Stdlib[6],_cr_]}
            throw exn}
          var f$0=_cs_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _ct_=match$1[1];
          if(! caml_string_notequal(_ct_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_ct_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_ct_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_ct_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     Js_of_ocaml_CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1660,Js_of_ocaml_CSS,"Js_of_ocaml__CSS");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _cq_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _cq_)}
    var Js_of_ocaml_Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global
     (1661,Js_of_ocaml_Dom_events,"Js_of_ocaml__Dom_events");
    var
     xmlns="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Js_of_ocaml_Dom_svg_SVGErr,caml_fresh_oo_id(0)];
    function createElement$0(doc,name)
     {return doc.createElementNS
              ("http://www.w3.org/2000/svg",caml_jsstring_of_string(name))}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignObject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createPattern(doc){return unsafeCreateElement$0(doc,cst_pattern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text$0)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$1=Unsafe[1].document;
    function getElementById$0(id)
     {function _cn_(e){if(e instanceof svg_element)return e;throw Stdlib[8]}
      function _co_(param){throw Stdlib[8]}
      var _cp_=Unsafe[1].document.getElementById(caml_jsstring_of_string(id));
      return caml_call3(Opt[7],_cp_,_co_,_cn_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var _cm_=caml_jsstring_of_string(tag);
      return e.tagName.toLowerCase() === _cm_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path$0(e){return unsafeCoerce$0(e,cst_path$0)}
    function pattern(e){return unsafeCoerce$0(e,cst_pattern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$1(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol$12(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$1)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Js_of_ocaml_Dom_svg=
      [0,
       xmlns,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createPattern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$1,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path$0,
        pattern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$1,
        stop,
        style$0,
        svg,
        switch$0,
        symbol$12,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1662,Js_of_ocaml_Dom_svg,"Js_of_ocaml__Dom_svg");
    function withCredentials(b)
     {var init={};init.withCredentials = ! ! b;return init}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     Js_of_ocaml_EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global
     (1663,Js_of_ocaml_EventSource,"Js_of_ocaml__EventSource");
    var
     console=runtime.caml_js_get_console(0),
     Js_of_ocaml_Firebug=[0,console];
    caml_register_global(1664,Js_of_ocaml_Firebug,"Js_of_ocaml__Firebug");
    function empty_position_options(param){return {}}
    var
     x=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],x)?x.geolocation:x;
    function is_supported$2(param){return caml_call1(Optdef[5],geolocation)}
    var
     Js_of_ocaml_Geolocation=
      [0,empty_position_options,geolocation,is_supported$2];
    caml_register_global
     (1665,Js_of_ocaml_Geolocation,"Js_of_ocaml__Geolocation");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":false$0,
              "numeric":false$0,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t39,
              "hour12":t39,
              "hourCycle":t39,
              "formatMatcher":"best fit",
              "weekday":t39,
              "era":t39,
              "year":t39,
              "month":t39,
              "day":t39,
              "hour":t39,
              "minute":t39,
              "second":t39,
              "timeZoneName":t39}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t39,
              "currencyDisplay":t39,
              "useGrouping":true$0,
              "minimumIntegerDigits":t39,
              "minimumFractionDigits":t39,
              "maximumFractionDigits":t39,
              "minimumSignificantDigits":t39,
              "maximumSignificantDigits":t39}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     collator_constr=Unsafe[1].Intl.Collator,
     dateTimeFormat_constr=Unsafe[1].Intl.DateTimeFormat,
     numberFormat_constr=Unsafe[1].Intl.NumberFormat,
     pluralRules_constr=Unsafe[1].Intl.PluralRules;
    function is_supported$3(param){return caml_call1(Optdef[5],intl)}
    var
     Js_of_ocaml_Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$3];
    caml_register_global(1666,Js_of_ocaml_Intl,"Js_of_ocaml__Intl");
    var Js_of_ocaml$0=[0];
    caml_register_global(1667,Js_of_ocaml$0,"Js_of_ocaml");
    function empty_intersection_observer_op(param){return {}}
    var intersectionObserver_unsafe=Unsafe[1].IntersectionObserver;
    function is_supported$4(param)
     {return caml_call1(Optdef[5],intersectionObserver_unsafe)}
    var
     Js_of_ocaml_IntersectionObserv=
      [0,
       empty_intersection_observer_op,
       is_supported$4,
       intersectionObserver_unsafe];
    caml_register_global
     (1668,Js_of_ocaml_IntersectionObserv,"Js_of_ocaml__IntersectionObserver");
    return}
  (function(){return this}()));


//# 1 "../../.js/uutf/uutf.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_UTF_8$0=caml_string_of_jsbytes("UTF-8"),
     cst_US_ASCII$0=caml_string_of_jsbytes("US-ASCII"),
     cst_ISO_8859_1$1=caml_string_of_jsbytes("ISO-8859-1"),
     cst_UTF_16$0=caml_string_of_jsbytes("UTF-16"),
     cst_UTF_16LE$0=caml_string_of_jsbytes("UTF-16LE"),
     cst_UTF_16BE$0=caml_string_of_jsbytes("UTF-16BE"),
     cst_ISO646_US=caml_string_of_jsbytes("ISO646-US"),
     cst_CSISOLATIN1=caml_string_of_jsbytes("CSISOLATIN1"),
     cst_ANSI_X3_4_1968=caml_string_of_jsbytes("ANSI_X3.4-1968"),
     cst_ANSI_X3_4_1986=caml_string_of_jsbytes("ANSI_X3.4-1986"),
     cst_ASCII=caml_string_of_jsbytes("ASCII"),
     cst_CP367=caml_string_of_jsbytes("CP367"),
     cst_CP819=caml_string_of_jsbytes("CP819"),
     cst_CSASCII=caml_string_of_jsbytes("CSASCII"),
     cst_IBM367=caml_string_of_jsbytes("IBM367"),
     cst_IBM819=caml_string_of_jsbytes("IBM819"),
     cst_ISO_8859_1$0=caml_string_of_jsbytes("ISO-8859-1"),
     cst_ISO_IR_100=caml_string_of_jsbytes("ISO-IR-100"),
     cst_ISO_IR_6=caml_string_of_jsbytes("ISO-IR-6"),
     cst_US=caml_string_of_jsbytes("US"),
     cst_ISO_646_IRV_1991=caml_string_of_jsbytes("ISO_646.IRV:1991"),
     cst_ISO_8859_1=caml_string_of_jsbytes("ISO_8859-1"),
     cst_ISO_8859_1_1987=caml_string_of_jsbytes("ISO_8859-1:1987"),
     cst_L1=caml_string_of_jsbytes("L1"),
     cst_LATIN1=caml_string_of_jsbytes("LATIN1"),
     cst_US_ASCII=caml_string_of_jsbytes("US-ASCII"),
     cst_UTF_16=caml_string_of_jsbytes("UTF-16"),
     cst_UTF_16BE=caml_string_of_jsbytes("UTF-16BE"),
     cst_UTF_16LE=caml_string_of_jsbytes("UTF-16LE"),
     cst_UTF_8=caml_string_of_jsbytes("UTF-8"),
     cst_expected_Await_encode=
      caml_string_of_jsbytes("expected `Await encode"),
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib=global_data.Stdlib,
     Assert_failure=global_data.Assert_failure,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_format=global_data.Stdlib__format,
     _a_=Stdlib_format[123],
     _B_=[0,caml_string_of_jsbytes("src/uutf.ml"),364,9],
     _u_=
      [0,
       [11,caml_string_of_jsbytes("`Await"),0],
       caml_string_of_jsbytes("`Await")],
     _v_=
      [0,[11,caml_string_of_jsbytes("`End"),0],caml_string_of_jsbytes("`End")],
     _w_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,caml_string_of_jsbytes("`Uchar U+"),[4,8,[0,2,4],0,[17,0,0]]]],
       caml_string_of_jsbytes("@[`Uchar U+%04X@]")],
     _x_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,caml_string_of_jsbytes("`Malformed ("),0]],
       caml_string_of_jsbytes("@[`Malformed (")],
     _y_=[0,[4,8,[0,2,2],0,0],caml_string_of_jsbytes("%02X")],
     _A_=[0,[12,32,[4,8,[0,2,2],0,0]],caml_string_of_jsbytes(" %02X")],
     _z_=[0,[12,41,[17,0,0]],caml_string_of_jsbytes(")@]")],
     _p_=[0,-211555818,3299808],
     _k_=[0,-211558048,3299808],
     _q_=[0,684370880,3299808],
     _o_=[0,684370880,427938126],
     _l_=[0,-211558048,427938126],
     _m_=[0,caml_string_of_jsbytes("src/uutf.ml"),154,55],
     _n_=[0,684370880,427938126],
     _r_=[0,caml_string_of_jsbytes("src/uutf.ml"),153,55],
     _s_=[0,caml_string_of_jsbytes("src/uutf.ml"),155,55],
     _t_=[0,684370880,3455931],
     _j_=[0,caml_string_of_jsbytes("src/uutf.ml"),121,9],
     _c_=[0,684370880],
     _d_=[0,-211555818],
     _e_=[0,-211558048],
     _f_=[0,143365725],
     _g_=[0,423112016],
     _h_=[0,338302576],
     _b_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid bounds (index "),
        [4,0,0,0,[11,caml_string_of_jsbytes(", length "),[4,0,0,0,[12,41,0]]]]],
       caml_string_of_jsbytes("invalid bounds (index %d, length %d)")],
     _i_=
      [0,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       4,
       4,
       4,
       4,
       4,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0];
    function invalid_bounds(j,l)
     {var _aF_=caml_call3(Stdlib_printf[4],_b_,j,l);
      return caml_call1(Stdlib[1],_aF_)}
    function unsafe_set_byte(s,j,byte$0)
     {runtime.caml_bytes_unsafe_set(s,j,byte$0);return 0}
    var
     u_bom=caml_call1(Stdlib_uchar[9],65279),
     u_rep=caml_call1(Stdlib_uchar[9],65533);
    function encoding_of_string(s)
     {var
       match=caml_call1(Stdlib_string[25],s),
       _aD_=caml_string_compare(match,cst_ISO646_US),
       switch$1=0;
      if(0 <= _aD_)
       {if(0 < _aD_)
         {var switch$0=caml_string_compare(match,cst_US);
          if(0 <= switch$0)
           {if(0 < switch$0 && caml_string_notequal(match,cst_US_ASCII))
             {if(! caml_string_notequal(match,cst_UTF_16))return _f_;
              if(! caml_string_notequal(match,cst_UTF_16BE))return _e_;
              if(! caml_string_notequal(match,cst_UTF_16LE))return _d_;
              if(! caml_string_notequal(match,cst_UTF_8))return _c_;
              switch$1 = 2}}
          else
           if(caml_string_notequal(match,cst_ISO_646_IRV_1991))
            if
             (caml_string_notequal(match,cst_ISO_8859_1)
              &&
              caml_string_notequal(match,cst_ISO_8859_1_1987)
              &&
              caml_string_notequal(match,cst_L1)
              &&
              caml_string_notequal(match,cst_LATIN1))
             switch$1 = 2;
            else
             switch$1 = 1}}
      else
       {var _aE_=caml_string_compare(match,cst_CSISOLATIN1);
        if(0 <= _aE_)
         if(0 < _aE_)
          {if(caml_string_notequal(match,cst_IBM367))
            if
             (caml_string_notequal(match,cst_IBM819)
              &&
              caml_string_notequal(match,cst_ISO_8859_1$0)
              &&
              caml_string_notequal(match,cst_ISO_IR_100))
             {if(caml_string_notequal(match,cst_ISO_IR_6))switch$1 = 2}
            else
             switch$1 = 1}
         else
          switch$1 = 1;
        else
         if
          (caml_string_notequal(match,cst_ANSI_X3_4_1968)
           &&
           caml_string_notequal(match,cst_ANSI_X3_4_1986)
           &&
           caml_string_notequal(match,cst_ASCII)
           &&
           caml_string_notequal(match,cst_CP367))
          if(caml_string_notequal(match,cst_CP819))
           {if(caml_string_notequal(match,cst_CSASCII))switch$1 = 2}
          else
           switch$1 = 1}
      switch(switch$1){case 2:return 0;case 0:return _g_;default:return _h_}}
    function encoding_to_string(param)
     {return 143365725 <= param
              ?423112016 <= param
                ?684370880 <= param?cst_UTF_8$0:cst_US_ASCII$0
                :338302576 <= param?cst_ISO_8859_1$1:cst_UTF_16$0
              :-211555818 <= param?cst_UTF_16LE$0:cst_UTF_16BE$0}
    function malformed(s,j,l)
     {return [0,659980059,caml_call3(Stdlib_bytes[8],s,j,l)]}
    function malformed_pair(be,hi,s,j,l)
     {var bs1=caml_call3(Stdlib_bytes[7],s,j,l),bs0=caml_create_bytes(2);
      if(be)var j0=0,j1=1;else var j0=1,j1=0;
      unsafe_set_byte(bs0,j0,hi >>> 8 | 0);
      unsafe_set_byte(bs0,j1,hi & 255);
      var _aC_=caml_call2(Stdlib_bytes[14],bs0,bs1);
      return [0,659980059,caml_call1(Stdlib_bytes[42],_aC_)]}
    var utf_8_len=_i_.slice();
    function r_utf_8(s,j,l)
     {function uchar(c){return [0,852405675,caml_call1(Stdlib_uchar[9],c)]}
      var switcher=l - 1 | 0;
      if(3 < switcher >>> 0)throw [0,Assert_failure,_j_];
      switch(switcher)
       {case 0:return uchar(caml_bytes_unsafe_get(s,j));
        case 1:
         var
          b0=caml_bytes_unsafe_get(s,j),
          b1=caml_bytes_unsafe_get(s,j + 1 | 0);
         return 2 === (b1 >>> 6 | 0)
                 ?uchar((b0 & 31) << 6 | b1 & 63)
                 :malformed(s,j,l);
        case 2:
         var
          b0$0=caml_bytes_unsafe_get(s,j),
          b1$0=caml_bytes_unsafe_get(s,j + 1 | 0),
          b2=caml_bytes_unsafe_get(s,j + 2 | 0),
          c=(b0$0 & 15) << 12 | (b1$0 & 63) << 6 | b2 & 63;
         if(2 === (b2 >>> 6 | 0))
          {if(224 === b0$0)
            {if(160 <= b1$0 && ! (191 < b1$0))return uchar(c);
             return malformed(s,j,l)}
           if(237 === b0$0)
            {if(128 <= b1$0 && ! (159 < b1$0))return uchar(c);
             return malformed(s,j,l)}
           return 2 === (b1$0 >>> 6 | 0)?uchar(c):malformed(s,j,l)}
         return malformed(s,j,l);
        default:
         var
          b0$1=caml_bytes_unsafe_get(s,j),
          b1$1=caml_bytes_unsafe_get(s,j + 1 | 0),
          b2$0=caml_bytes_unsafe_get(s,j + 2 | 0),
          b3=caml_bytes_unsafe_get(s,j + 3 | 0),
          c$0=
           (b0$1 & 7)
           <<
           18
           |
           (b1$1 & 63)
           <<
           12
           |
           (b2$0 & 63)
           <<
           6
           |
           b3
           &
           63;
         if(2 === (b3 >>> 6 | 0) && 2 === (b2$0 >>> 6 | 0))
          {if(240 === b0$1)
            {if(144 <= b1$1 && ! (191 < b1$1))return uchar(c$0);
             return malformed(s,j,l)}
           if(244 === b0$1)
            {if(128 <= b1$1 && ! (143 < b1$1))return uchar(c$0);
             return malformed(s,j,l)}
           return 2 === (b1$1 >>> 6 | 0)?uchar(c$0):malformed(s,j,l)}
         return malformed(s,j,l)}}
    function r_utf_16(s,j0,j1)
     {var
       b0=caml_bytes_unsafe_get(s,j0),
       b1=caml_bytes_unsafe_get(s,j1),
       u=b0 << 8 | b1;
      if(55296 <= u && ! (57343 < u))
       return 56319 < u
               ?malformed(s,caml_call2(Stdlib[16],j0,j1),2)
               :[0,16161,u];
      return [0,852405675,caml_call1(Stdlib_uchar[9],u)]}
    function r_utf_16_lo(hi,s,j0,j1)
     {var
       b0=caml_bytes_unsafe_get(s,j0),
       b1=caml_bytes_unsafe_get(s,j1),
       lo=b0 << 8 | b1;
      if(56320 <= lo && ! (57343 < lo))
       return [0,
               852405675,
               caml_call1
                (Stdlib_uchar[9],((hi & 1023) << 10 | lo & 1023) + 65536 | 0)];
      return malformed_pair(j0 < j1?1:0,hi,s,caml_call2(Stdlib[16],j0,j1),2)}
    function r_encoding(s,j,l)
     {function some(i){return i < l?[0,caml_bytes_unsafe_get(s,j + i | 0)]:0}
      var match=some(0),match$0=some(1),match$1=some(2);
      if(match)
       {var _aB_=match[1],switch$0=0;
        if(240 <= _aB_)
         if(254 === _aB_)
          {if(match$0){if(255 === match$0[1])return _k_;switch$0 = 1}}
         else
          if(255 === _aB_)
           {if(match$0){if(254 === match$0[1])return _p_;switch$0 = 1}}
          else
           switch$0 = 1;
        else
         if(0 === _aB_)
          {if(match$0)
            {var p=match$0[1];
             if(0 < p)return [0,-211558048,[0,605782321,p]];
             switch$0 = 1}}
         else
          if(239 <= _aB_)
           {if(match$0)
             if(187 === match$0[1])
              {if(match$1 && 191 === match$1[1])return _q_}
             else
              switch$0 = 1}
          else
           switch$0 = 1;
        if(switch$0 && match$0 && 0 === match$0[1] && 0 < _aB_)
         return [0,-211555818,[0,605782321,_aB_]];
        if(0 === caml_check_bound(utf_8_len,_aB_)[1 + _aB_])
         {if(match$0)return _l_;
          if(match$1)throw [0,Assert_failure,_m_];
          return _n_}
        return _o_}
      if(match$0)throw [0,Assert_failure,_r_];
      if(match$1)throw [0,Assert_failure,_s_];
      return _t_}
    function pp_decode(ppf,param)
     {if(typeof param === "number")
       return 1006505782 <= param
               ?caml_call2(_a_,ppf,_u_)
               :caml_call2(_a_,ppf,_v_);
      if(852405675 <= param[1])
       {var u=param[2];
        return caml_call3(_a_,ppf,_w_,caml_call1(Stdlib_uchar[10],u))}
      var bs=param[2],l=caml_ml_string_length(bs);
      caml_call2(_a_,ppf,_x_);
      if(0 < l)caml_call3(_a_,ppf,_y_,caml_string_get(bs,0));
      var _az_=l - 1 | 0,_ay_=1;
      if(! (_az_ < 1))
       {var i=_ay_;
        for(;;)
         {caml_call3(_a_,ppf,_A_,caml_string_get(bs,i));
          var _aA_=i + 1 | 0;
          if(_az_ !== i){var i=_aA_;continue}
          break}}
      return caml_call2(_a_,ppf,_z_)}
    function i_rem(d){return (d[7] - d[6] | 0) + 1 | 0}
    function eoi(d)
     {d[5] = Stdlib_bytes[3];d[6] = 0;d[7] = Stdlib[20];return 0}
    function src(d,s,j,l)
     {if(0 <= j && 0 <= l && ! (caml_ml_bytes_length(s) < (j + l | 0)))
       return 0 === l?eoi(d):(d[5] = s,d[6] = j,d[7] = (j + l | 0) - 1 | 0,0);
      return invalid_bounds(j,l)}
    function refill(k,d)
     {var _ax_=d[1];
      if(typeof _ax_ === "number"){d[18] = k;return 1006505782}
      if(438511779 <= _ax_[1])
       {var
         ic=_ax_[2],
         rc=caml_call4(Stdlib[84],ic,d[5],0,caml_ml_bytes_length(d[5]));
        src(d,d[5],0,rc);
        return caml_call1(k,d)}
      eoi(d);
      return caml_call1(k,d)}
    function t_need(d,need){d[9] = 0;d[10] = need;return 0}
    function t_fill(k,d)
     {function blit(d,l)
       {caml_blit_bytes(d[5],d[6],d[8],d[9],l);
        d[6] = d[6] + l | 0;
        d[9] = d[9] + l | 0;
        return 0}
      var rem=i_rem(d);
      if(0 <= rem)
       {var need=d[10] - d[9] | 0;
        return rem < need
                ?(blit(d,rem),refill(function(_aw_){return t_fill(k,_aw_)},d))
                :(blit(d,need),caml_call1(k,d))}
      return caml_call1(k,d)}
    function ret(k,v,byte_count,d)
     {d[18] = k;d[15] = d[15] + byte_count | 0;return caml_call2(d[17],d,v)}
    function decode_us_ascii(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var j=d[6];
        d[6] = d[6] + 1 | 0;
        var
         _au_=d[5],
         b0=caml_bytes_unsafe_get(_au_,j),
         _at_=1,
         _av_=
          127 < b0
           ?malformed(_au_,j,1)
           :[0,852405675,caml_call1(Stdlib_uchar[9],b0)];
        return ret(decode_us_ascii,_av_,_at_,d)}
      return 0 <= rem?refill(decode_us_ascii,d):3455931}
    function decode_iso_8859_1(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var j=d[6];
        d[6] = d[6] + 1 | 0;
        return ret
                (decode_iso_8859_1,
                 [0,
                  852405675,
                  caml_call1(Stdlib_uchar[9],caml_bytes_unsafe_get(d[5],j))],
                 1,
                 d)}
      return 0 <= rem?refill(decode_iso_8859_1,d):3455931}
    function t_decode_utf_8(d)
     {if(d[9] < d[10])
       {var _ar_=d[9];return ret(decode_utf_8,malformed(d[8],0,d[9]),_ar_,d)}
      var _as_=d[9];
      return ret(decode_utf_8,r_utf_8(d[8],0,d[9]),_as_,d)}
    function decode_utf_8(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var need=utf_8_len[1 + caml_bytes_unsafe_get(d[5],d[6])];
        if(rem < need){t_need(d,need);return t_fill(t_decode_utf_8,d)}
        var j=d[6];
        return 0 === need
                ?(d[6]
                  =
                  d[6]
                  +
                  1
                  |
                  0,
                  ret(decode_utf_8,malformed(d[5],j,1),1,d))
                :(d[6]
                  =
                  d[6]
                  +
                  need
                  |
                  0,
                  ret(decode_utf_8,r_utf_8(d[5],j,need),need,d))}
      return 0 <= rem?refill(decode_utf_8,d):3455931}
    function t_decode_utf_16be_lo(hi,d)
     {var bcount=d[9] + 2 | 0;
      return d[9] < d[10]
              ?ret(decode_utf_16be,malformed_pair(1,hi,d[8],0,d[9]),bcount,d)
              :ret(decode_utf_16be,r_utf_16_lo(hi,d[8],0,1),bcount,d)}
    function decode_utf_16be_lo(v,d)
     {if(659980059 <= v[1])return ret(decode_utf_16be,v,2,d);
      var hi=v[2],rem=i_rem(d);
      if(2 <= rem)
       {var j=d[6];
        d[6] = d[6] + 2 | 0;
        return ret(decode_utf_16be,r_utf_16_lo(hi,d[5],j,j + 1 | 0),4,d)}
      t_need(d,2);
      return t_fill(function(_aq_){return t_decode_utf_16be_lo(hi,_aq_)},d)}
    function t_decode_utf_16be(d)
     {if(d[9] < d[10])
       {var _ap_=d[9];
        return ret(decode_utf_16be,malformed(d[8],0,d[9]),_ap_,d)}
      return decode_utf_16be_lo(r_utf_16(d[8],0,1),d)}
    function decode_utf_16be(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {if(2 <= rem)
         {var j=d[6];
          d[6] = d[6] + 2 | 0;
          return decode_utf_16be_lo(r_utf_16(d[5],j,j + 1 | 0),d)}
        t_need(d,2);
        return t_fill(t_decode_utf_16be,d)}
      return 0 <= rem?refill(decode_utf_16be,d):3455931}
    function t_decode_utf_16_lo(hi,d)
     {var bcount=d[9] + 2 | 0;
      return d[9] < d[10]
              ?ret(decode_utf_16,malformed_pair(0,hi,d[8],0,d[9]),bcount,d)
              :ret(decode_utf_16,r_utf_16_lo(hi,d[8],1,0),bcount,d)}
    function decode_utf_16le_lo(v,d)
     {if(659980059 <= v[1])return ret(decode_utf_16,v,2,d);
      var hi=v[2],rem=i_rem(d);
      if(2 <= rem)
       {var j=d[6];
        d[6] = d[6] + 2 | 0;
        return ret(decode_utf_16,r_utf_16_lo(hi,d[5],j + 1 | 0,j),4,d)}
      t_need(d,2);
      return t_fill(function(_ao_){return t_decode_utf_16_lo(hi,_ao_)},d)}
    function t_decode_utf_16(d)
     {if(d[9] < d[10])
       {var _an_=d[9];return ret(decode_utf_16,malformed(d[8],0,d[9]),_an_,d)}
      return decode_utf_16le_lo(r_utf_16(d[8],1,0),d)}
    function decode_utf_16(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {if(2 <= rem)
         {var j=d[6];
          d[6] = d[6] + 2 | 0;
          return decode_utf_16le_lo(r_utf_16(d[5],j + 1 | 0,j),d)}
        t_need(d,2);
        return t_fill(t_decode_utf_16,d)}
      return 0 <= rem?refill(decode_utf_16,d):3455931}
    function guessed_utf_16(d,be,v)
     {if(be)
       var
        decode_utf_16$0=decode_utf_16be,
        t_decode_utf_16$0=t_decode_utf_16be,
        t_decode_utf_16_lo$0=t_decode_utf_16be_lo,
        j0=0,
        j1=1;
      else
       var
        decode_utf_16$0=decode_utf_16,
        t_decode_utf_16$0=t_decode_utf_16,
        t_decode_utf_16_lo$0=t_decode_utf_16_lo,
        j0=1,
        j1=0;
      function b3(k,d)
       {return 3 <= d[9]
                ?(d[10]
                  =
                  2,
                  d[9]
                  =
                  1,
                  unsafe_set_byte(d[8],0,caml_bytes_unsafe_get(d[8],2)),
                  t_fill(k,d))
                :decode_utf_16$0(d)}
      if(typeof v === "number")
       {if(427938126 <= v)
         {var v$0=r_utf_16(d[8],j0,j1);
          if(659980059 <= v$0[1])
           {var _ad_=2;
            return ret
                    (function(_am_){return b3(t_decode_utf_16$0,_am_)},
                     v$0,
                     _ad_,
                     d)}
          var hi=v$0[2];
          if(3 <= d[9])
           return b3(function(_al_){return t_decode_utf_16_lo$0(hi,_al_)},d);
          var _ae_=d[9];
          return ret
                  (decode_utf_16$0,
                   malformed_pair(be,hi,Stdlib_bytes[3],0,0),
                   _ae_,
                   d)}
        var _af_=2,_ag_=[0,852405675,u_bom];
        return ret
                (function(_ak_){return b3(t_decode_utf_16$0,_ak_)},
                 _ag_,
                 _af_,
                 d)}
      var u=v[2],_ah_=2,_ai_=[0,852405675,caml_call1(Stdlib_uchar[9],u)];
      return ret
              (function(_aj_){return b3(t_decode_utf_16$0,_aj_)},_ai_,_ah_,d)}
    function k(d)
     {function setup(d)
       {var match=r_encoding(d[8],0,d[9]),_ac_=match[1];
        if(-211555818 === _ac_)
         {var r=match[2];
          d[2] = -211555818;
          d[18] = decode_utf_16;
          return guessed_utf_16(d,0,r)}
        if(684370880 <= _ac_)
         {var r$0=match[2];
          d[2] = 684370880;
          d[18] = decode_utf_8;
          if(3455931 === r$0)return 3455931;
          if(427938126 <= r$0)
           {var
             b3=
              function(d)
               {var
                 b3=caml_bytes_unsafe_get(d[8],2),
                 n=caml_check_bound(utf_8_len,b3)[1 + b3];
                return 0 === n
                        ?ret(decode_utf_8,malformed(d[8],2,1),1,d)
                        :(d[10]
                          =
                          n,
                          d[9]
                          =
                          1,
                          unsafe_set_byte(d[8],0,b3),
                          t_fill(t_decode_utf_8,d))},
             b2=
              function(d)
               {var
                 b2=caml_bytes_unsafe_get(d[8],1),
                 b3$0=2 < d[9]?b3:decode_utf_8,
                 n=caml_check_bound(utf_8_len,b2)[1 + b2];
                if(0 === n)return ret(b3$0,malformed(d[8],1,1),1,d);
                if(1 === n)return ret(b3$0,r_utf_8(d[8],1,1),1,d);
                d[10] = n;
                unsafe_set_byte(d[8],0,b2);
                if(3 <= d[9])
                 {d[9] = 2;
                  unsafe_set_byte(d[8],1,caml_bytes_unsafe_get(d[8],2))}
                else
                 d[9] = 1;
                return t_fill(t_decode_utf_8,d)},
             b1=caml_bytes_unsafe_get(d[8],0),
             b2$0=1 < d[9]?b2:decode_utf_8,
             n=caml_check_bound(utf_8_len,b1)[1 + b1];
            if(4 < n >>> 0)throw [0,Assert_failure,_B_];
            switch(n)
             {case 0:return ret(b2$0,malformed(d[8],0,1),1,d);
              case 1:return ret(b2$0,r_utf_8(d[8],0,1),1,d);
              case 2:
               return 2 <= d[9]
                       ?3 <= d[9]
                         ?ret(b3,r_utf_8(d[8],0,2),2,d)
                         :ret(decode_utf_8,r_utf_8(d[8],0,2),2,d)
                       :ret(decode_utf_8,malformed(d[8],0,1),1,d);
              case 3:
               if(3 <= d[9])return ret(decode_utf_8,r_utf_8(d[8],0,3),3,d);
               var _aa_=d[9];
               return ret(decode_utf_8,malformed(d[8],0,d[9]),_aa_,d);
              default:
               if(3 <= d[9]){d[10] = 4;return t_fill(t_decode_utf_8,d)}
               var _ab_=d[9];
               return ret(decode_utf_8,malformed(d[8],0,d[9]),_ab_,d)}}
          return ret(decode_utf_8,[0,852405675,u_bom],3,d)}
        var r$1=match[2];
        d[2] = -211558048;
        d[18] = decode_utf_16be;
        return guessed_utf_16(d,1,r$1)}
      t_need(d,3);
      return t_fill(setup,d)}
    function nline(d){d[14] = 0;d[13] = d[13] + 1 | 0;return 0}
    function ncol(d){d[14] = d[14] + 1 | 0;return 0}
    function ncount(d){d[16] = d[16] + 1 | 0;return 0}
    function cr(d,b){d[12] = b;return 0}
    function pp(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         _$_=match - 133 | 0,
         switch$0=0;
        if(8100 < _$_ >>> 0)
         {var switcher=_$_ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              ncount(d);
              return last_cr?v:(nline(d),v);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return v}}
        else
         if(8097 < (_$_ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_readline(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         ___=match - 133 | 0,
         switch$0=0;
        if(8100 < ___ >>> 0)
         {var switcher=___ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(8097 < (___ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),[0,852405675,d[4]])
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_nlf(d,v)
     {if(852405675 <= v[1])
       {var u=v[2],match=caml_call1(Stdlib_uchar[10],u),switch$0=0;
        if(14 <= match)
         {if(8232 <= match)
           {if(! (8234 <= match))switch$0 = 1}
          else
           if(133 === match)
            {cr(d,0);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(10 <= match)
          {var switcher=match - 10 | 0;
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_ascii(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         _Z_=match - 133 | 0,
         switch$0=0;
        if(8100 < _Z_ >>> 0)
         {var switcher=_Z_ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(8097 < (_Z_ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function decode_fun(param)
     {return 143365725 <= param
              ?423112016 <= param
                ?684370880 <= param?decode_utf_8:decode_us_ascii
                :338302576 <= param?decode_iso_8859_1:decode_utf_16be
              :-211555818 <= param?decode_utf_16:decode_utf_16be}
    function decoder(nln,encoding,src)
     {if(nln)
       {var _X_=nln[1],_Y_=_X_[1];
        if(3895880 === _Y_)
         var nl=_X_[2],pp$0=pp_nln_nlf,nl$0=nl;
        else
         if(605782321 <= _Y_)
          var nl$1=_X_[2],pp$0=pp_nln_ascii,nl$0=nl$1;
         else
          var nl$2=_X_[2],pp$0=pp_nln_readline,nl$0=nl$2}
      else
       var nl$3=caml_call1(Stdlib_uchar[9],10),pp$0=pp,nl$0=nl$3;
      if(encoding)
       var e=encoding[1],encoding$0=e,k$0=decode_fun(e);
      else
       var encoding$0=684370880,k$0=k;
      if(typeof src === "number")
       var i=Stdlib_bytes[3],i_pos=1,i_max=0;
      else
       if(438511779 <= src[1])
        var i=caml_create_bytes(65536),i_pos=1,i_max=0;
       else
        var
         s=src[2],
         i_max$0=caml_ml_string_length(s) - 1 | 0,
         i$0=caml_call1(Stdlib_bytes[43],s),
         i=i$0,
         i_pos=0,
         i_max=i_max$0;
      var utf16=143365725 === encoding$0?1:0;
      return [0,
              src,
              encoding$0,
              nln,
              nl$0,
              i,
              i_pos,
              i_max,
              caml_create_bytes(4),
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              function(d,v)
               {if(852405675 <= v[1])
                 {var u=v[2],match=caml_call1(Stdlib_uchar[10],u);
                  if(65279 === match)
                   {if(utf16){d[2] = -211558048;d[18] = decode_utf_16be}
                    d[11] = 1;
                    d[17] = pp$0;
                    return caml_call1(d[18],d)}
                  if(65534 === match && utf16)
                   {d[2] = -211555818;
                    d[18] = decode_utf_16;
                    d[11] = 1;
                    d[17] = pp$0;
                    return caml_call1(d[18],d)}
                  d[11] = 0;
                  d[17] = pp$0;
                  return caml_call2(d[17],d,v)}
                d[11] = 0;
                d[17] = pp$0;
                return caml_call2(d[17],d,v)},
              k$0]}
    function decode(d){return caml_call1(d[18],d)}
    function decoder_line(d){return d[13]}
    function decoder_col(d){return d[14]}
    function decoder_byte_count(d){return d[15]}
    function decoder_count(d){return d[16]}
    function decoder_removed_bom(d){return d[11]}
    function decoder_src(d){return d[1]}
    function decoder_nln(d){return d[3]}
    function decoder_encoding(d){return d[2]}
    function set_decoder_encoding(d,e)
     {d[2] = e;d[18] = decode_fun(e);return 0}
    function o_rem(e){return (e[5] - e[4] | 0) + 1 | 0}
    function dst(e,s,j,l)
     {var _U_=j < 0?1:0;
      if(_U_)
       var _V_=_U_;
      else
       var
        _W_=l < 0?1:0,
        _V_=_W_ || (caml_ml_bytes_length(s) < (j + l | 0)?1:0);
      if(_V_)invalid_bounds(j,l);
      e[3] = s;
      e[4] = j;
      e[5] = (j + l | 0) - 1 | 0;
      return 0}
    function flush(k,e)
     {var _T_=e[1];
      if(typeof _T_ === "number")
       {e[9]
        =
        function(e,param)
         {if(typeof param === "number" && 1006505782 <= param)
           return caml_call1(k,e);
          return caml_call1(Stdlib[1],cst_expected_Await_encode)};
        return 939392865}
      if(438511779 <= _T_[1])
       {var oc=_T_[2];
        caml_call4(Stdlib[68],oc,e[3],0,e[4]);
        e[4] = 0;
        return caml_call1(k,e)}
      var b=_T_[2],o=caml_call1(Stdlib_bytes[42],e[3]);
      caml_call4(Stdlib_buffer[16],b,o,0,e[4]);
      e[4] = 0;
      return caml_call1(k,e)}
    function t_range(e,max){e[7] = 0;e[8] = max;return 0}
    function t_flush(k,e)
     {function blit(e,l)
       {caml_blit_bytes(e[6],e[7],e[3],e[4],l);
        e[4] = e[4] + l | 0;
        e[7] = e[7] + l | 0;
        return 0}
      var rem=o_rem(e),len=(e[8] - e[7] | 0) + 1 | 0;
      return rem < len
              ?(blit(e,rem),flush(function(_S_){return t_flush(k,_S_)},e))
              :(blit(e,len),caml_call1(k,e))}
    function encode_utf_8(e,v)
     {function k(e){e[9] = encode_utf_8;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(127 < u$0)
       {if(2047 < u$0)
         {if(65535 < u$0)
           {if(4 <= rem)
             {var j=e[4];e[4] = e[4] + 4 | 0;var s=e[3],j$0=j,k$0=k}
            else
             {t_range(e,3);
              var
               _M_=function(_R_){return t_flush(k,_R_)},
               s=e[6],
               j$0=0,
               k$0=_M_}
            unsafe_set_byte(s,j$0,240 | u$0 >>> 18 | 0);
            unsafe_set_byte(s,j$0 + 1 | 0,128 | (u$0 >>> 12 | 0) & 63);
            unsafe_set_byte(s,j$0 + 2 | 0,128 | (u$0 >>> 6 | 0) & 63);
            unsafe_set_byte(s,j$0 + 3 | 0,128 | u$0 & 63);
            return k$0(e)}
          if(3 <= rem)
           {var j$1=e[4];e[4] = e[4] + 3 | 0;var s$0=e[3],j$2=j$1,k$1=k}
          else
           {t_range(e,2);
            var
             _N_=function(_Q_){return t_flush(k,_Q_)},
             s$0=e[6],
             j$2=0,
             k$1=_N_}
          unsafe_set_byte(s$0,j$2,224 | u$0 >>> 12 | 0);
          unsafe_set_byte(s$0,j$2 + 1 | 0,128 | (u$0 >>> 6 | 0) & 63);
          unsafe_set_byte(s$0,j$2 + 2 | 0,128 | u$0 & 63);
          return k$1(e)}
        if(2 <= rem)
         {var j$3=e[4];e[4] = e[4] + 2 | 0;var s$1=e[3],j$4=j$3,k$2=k}
        else
         {t_range(e,1);
          var _O_=function(_P_){return t_flush(k,_P_)},s$1=e[6],j$4=0,k$2=_O_}
        unsafe_set_byte(s$1,j$4,192 | u$0 >>> 6 | 0);
        unsafe_set_byte(s$1,j$4 + 1 | 0,128 | u$0 & 63);
        return k$2(e)}
      return 1 <= rem
              ?(unsafe_set_byte(e[3],e[4],u$0),e[4] = e[4] + 1 | 0,k(e))
              :flush(function(e){return encode_utf_8(e,v)},e)}
    function encode_utf_16be(e,v)
     {function k(e){e[9] = encode_utf_16be;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(65536 <= u$0)
       {if(4 <= rem)
         {var j=e[4];e[4] = e[4] + 4 | 0;var s=e[3],j$0=j,k$0=k}
        else
         {t_range(e,3);
          var _I_=function(_L_){return t_flush(k,_L_)},s=e[6],j$0=0,k$0=_I_}
        var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        unsafe_set_byte(s,j$0,hi >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 1 | 0,hi & 255);
        unsafe_set_byte(s,j$0 + 2 | 0,lo >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 3 | 0,lo & 255);
        return k$0(e)}
      if(2 <= rem)
       {var j$1=e[4];e[4] = e[4] + 2 | 0;var s$0=e[3],j$2=j$1,k$1=k}
      else
       {t_range(e,1);
        var _J_=function(_K_){return t_flush(k,_K_)},s$0=e[6],j$2=0,k$1=_J_}
      unsafe_set_byte(s$0,j$2,u$0 >>> 8 | 0);
      unsafe_set_byte(s$0,j$2 + 1 | 0,u$0 & 255);
      return k$1(e)}
    function encode_utf_16le(e,v)
     {function k(e){e[9] = encode_utf_16le;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(65536 <= u$0)
       {if(4 <= rem)
         {var j=e[4];e[4] = e[4] + 4 | 0;var s=e[3],j$0=j,k$0=k}
        else
         {t_range(e,3);
          var _E_=function(_H_){return t_flush(k,_H_)},s=e[6],j$0=0,k$0=_E_}
        var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        unsafe_set_byte(s,j$0,hi & 255);
        unsafe_set_byte(s,j$0 + 1 | 0,hi >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 2 | 0,lo & 255);
        unsafe_set_byte(s,j$0 + 3 | 0,lo >>> 8 | 0);
        return k$0(e)}
      if(2 <= rem)
       {var j$1=e[4];e[4] = e[4] + 2 | 0;var s$0=e[3],j$2=j$1,k$1=k}
      else
       {t_range(e,1);
        var _F_=function(_G_){return t_flush(k,_G_)},s$0=e[6],j$2=0,k$1=_F_}
      unsafe_set_byte(s$0,j$2,u$0 & 255);
      unsafe_set_byte(s$0,j$2 + 1 | 0,u$0 >>> 8 | 0);
      return k$1(e)}
    function encoder(encoding,dst)
     {if(typeof dst === "number")
       var o=Stdlib_bytes[3],o_pos=1,o_max=0;
      else
       var o$0=caml_create_bytes(65536),o=o$0,o_pos=0,o_max=65535;
      var
       _D_=
        143365725 <= encoding
         ?684370880 <= encoding?encode_utf_8:encode_utf_16be
         :-211555818 <= encoding?encode_utf_16le:encode_utf_16be;
      return [0,dst,encoding,o,o_pos,o_max,caml_create_bytes(4),1,0,_D_]}
    function encode(e,v){return caml_call2(e[9],e,v)}
    function encoder_encoding(e){return e[2]}
    function encoder_dst(e){return e[1]}
    var Manual=[0,src,dst,o_rem];
    function encoding_guess(s)
     {var
       s$0=caml_call1(Stdlib_bytes[43],s),
       match=
        r_encoding(s$0,0,caml_call2(Stdlib[17],caml_ml_bytes_length(s$0),3)),
       _C_=match[1];
      if(-211555818 === _C_)
       {var d=match[2];return [0,-211555818,3299808 === d?1:0]}
      if(684370880 <= _C_)
       {var d$0=match[2];return [0,684370880,3299808 === d$0?1:0]}
      var d$1=match[2];
      return [0,-211558048,3299808 === d$1?1:0]}
    function fold_utf_8(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var need=utf_8_len[1 + caml_bytes_unsafe_get(s$0,i)];
        if(0 === need)
         {var
           i$0=i + 1 | 0,
           acc$1=caml_call3(f,acc$0,i,malformed(s$0,i,1)),
           acc$0=acc$1,
           i=i$0;
          continue}
        var rem=(last - i | 0) + 1 | 0;
        if(rem < need)return caml_call3(f,acc$0,i,malformed(s$0,i,rem));
        var
         i$1=i + need | 0,
         acc$2=caml_call3(f,acc$0,i,r_utf_8(s$0,i,need)),
         acc$0=acc$2,
         i=i$1;
        continue}}
    function fold_utf_16be(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var rem=(last - i | 0) + 1 | 0;
        if(2 <= rem)
         {var v=r_utf_16(s$0,i,i + 1 | 0);
          if(659980059 <= v[1])
           {var i$0=i + 2 | 0,acc$1=caml_call3(f,acc$0,i,v),acc$0=acc$1,i=i$0;
            continue}
          var hi=v[2];
          if(4 <= rem)
           {var
             i$1=i + 4 | 0,
             acc$2=
              caml_call3(f,acc$0,i,r_utf_16_lo(hi,s$0,i + 2 | 0,i + 3 | 0)),
             acc$0=acc$2,
             i=i$1;
            continue}
          return caml_call3(f,acc$0,i,malformed(s$0,i,rem))}
        return caml_call3(f,acc$0,i,malformed(s$0,i,1))}}
    function fold_utf_16le(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var rem=(last - i | 0) + 1 | 0;
        if(2 <= rem)
         {var v=r_utf_16(s$0,i + 1 | 0,i);
          if(659980059 <= v[1])
           {var i$0=i + 2 | 0,acc$1=caml_call3(f,acc$0,i,v),acc$0=acc$1,i=i$0;
            continue}
          var hi=v[2];
          if(4 <= rem)
           {var
             i$1=i + 4 | 0,
             acc$2=
              caml_call3(f,acc$0,i,r_utf_16_lo(hi,s$0,i + 3 | 0,i + 2 | 0)),
             acc$0=acc$2,
             i=i$1;
            continue}
          return caml_call3(f,acc$0,i,malformed(s$0,i,rem))}
        return caml_call3(f,acc$0,i,malformed(s$0,i,1))}}
    var String=[0,encoding_guess,fold_utf_8,fold_utf_16be,fold_utf_16le];
    function add_utf_8(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      return 127 < u$0
              ?2047 < u$0
                ?65535 < u$0
                  ?(w(240 | u$0 >>> 18 | 0),
                    w(128 | (u$0 >>> 12 | 0) & 63),
                    w(128 | (u$0 >>> 6 | 0) & 63),
                    w(128 | u$0 & 63))
                  :(w(224 | u$0 >>> 12 | 0),
                    w(128 | (u$0 >>> 6 | 0) & 63),
                    w(128 | u$0 & 63))
                :(w(192 | u$0 >>> 6 | 0),w(128 | u$0 & 63))
              :w(u$0)}
    function add_utf_16be(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      if(65536 <= u$0)
       {var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        w(hi >>> 8 | 0);
        w(hi & 255);
        w(lo >>> 8 | 0);
        return w(lo & 255)}
      w(u$0 >>> 8 | 0);
      return w(u$0 & 255)}
    function add_utf_16le(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      if(65536 <= u$0)
       {var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        w(hi & 255);
        w(hi >>> 8 | 0);
        w(lo & 255);
        return w(lo >>> 8 | 0)}
      w(u$0 & 255);
      return w(u$0 >>> 8 | 0)}
    var
     Buffer=[0,add_utf_8,add_utf_16be,add_utf_16le],
     Uutf=
      [0,
       u_bom,
       u_rep,
       encoding_of_string,
       encoding_to_string,
       decoder,
       decode,
       decoder_encoding,
       set_decoder_encoding,
       decoder_line,
       decoder_col,
       decoder_byte_count,
       decoder_count,
       decoder_removed_bom,
       decoder_src,
       decoder_nln,
       pp_decode,
       encoder,
       encode,
       encoder_encoding,
       encoder_dst,
       Manual,
       String,
       Buffer];
    runtime.caml_register_global(66,Uutf,"Uutf");
    return}
  (function(){return this}()));


//# 1 "../../.js/re/re.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_equal=runtime.caml_equal,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_compare=runtime.caml_int_compare,
     caml_lessthan=runtime.caml_lessthan,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Re_cset_pick=caml_string_of_jsbytes("Re_cset.pick"),
     cany=[0,[0,0,255],0],
     cst_eps=caml_string_of_jsbytes("eps"),
     cst_cst=caml_string_of_jsbytes("cst"),
     cst_alt=caml_string_of_jsbytes("alt"),
     cst_seq=caml_string_of_jsbytes("seq"),
     cst_rep=caml_string_of_jsbytes("rep"),
     cst_mark=caml_string_of_jsbytes("mark"),
     cst_erase=caml_string_of_jsbytes("erase"),
     cst_before=caml_string_of_jsbytes("before"),
     cst_after=caml_string_of_jsbytes("after"),
     cst_pmark=caml_string_of_jsbytes("pmark"),
     cst_Non_greedy=caml_string_of_jsbytes("Non_greedy"),
     cst_Greedy=caml_string_of_jsbytes("Greedy"),
     cst_first=caml_string_of_jsbytes("first"),
     cst_short=caml_string_of_jsbytes("short"),
     cst_long=caml_string_of_jsbytes("long"),
     eps_expr=[0,0,0],
     cst_Group=caml_string_of_jsbytes("Group"),
     dummy_offset=[0,-1,-1],
     dummy_string=caml_string_of_jsbytes(""),
     cst_Beg_of_line=caml_string_of_jsbytes("Beg_of_line"),
     cst_End_of_line=caml_string_of_jsbytes("End_of_line"),
     cst_Beg_of_word=caml_string_of_jsbytes("Beg_of_word"),
     cst_End_of_word=caml_string_of_jsbytes("End_of_word"),
     cst_Not_bound=caml_string_of_jsbytes("Not_bound"),
     cst_Beg_of_str=caml_string_of_jsbytes("Beg_of_str"),
     cst_End_of_str=caml_string_of_jsbytes("End_of_str"),
     cst_Last_end_of_line=caml_string_of_jsbytes("Last_end_of_line"),
     cst_Start=caml_string_of_jsbytes("Start"),
     cst_Stop=caml_string_of_jsbytes("Stop"),
     cst_Set=caml_string_of_jsbytes("Set"),
     cst_Sequence=caml_string_of_jsbytes("Sequence"),
     cst_Alternative=caml_string_of_jsbytes("Alternative"),
     cst_Repeat=caml_string_of_jsbytes("Repeat"),
     cst_Sem=caml_string_of_jsbytes("Sem"),
     cst_Sem_greedy=caml_string_of_jsbytes("Sem_greedy"),
     cst_Group$0=caml_string_of_jsbytes("Group"),
     cst_No_group=caml_string_of_jsbytes("No_group"),
     cst_Nest=caml_string_of_jsbytes("Nest"),
     cst_Case=caml_string_of_jsbytes("Case"),
     cst_No_case=caml_string_of_jsbytes("No_case"),
     cst_Intersection=caml_string_of_jsbytes("Intersection"),
     cst_Complement=caml_string_of_jsbytes("Complement"),
     cst_Difference=caml_string_of_jsbytes("Difference"),
     cst_Pmark=caml_string_of_jsbytes("Pmark"),
     cst$1=caml_string_of_jsbytes(""),
     cst$2=caml_string_of_jsbytes(""),
     cst_Re_replace=caml_string_of_jsbytes("Re.replace"),
     cst_Re_replace$0=caml_string_of_jsbytes("Re.replace"),
     cst_Re_split=caml_string_of_jsbytes("Re.split"),
     cst_Re_split$0=caml_string_of_jsbytes("Re.split"),
     cst_Re_all=caml_string_of_jsbytes("Re.all"),
     cst_Re_all$0=caml_string_of_jsbytes("Re.all"),
     cst_Re_exec_partial=caml_string_of_jsbytes("Re.exec_partial"),
     cst_Re_execp=caml_string_of_jsbytes("Re.execp"),
     cst_Re_exec_opt=caml_string_of_jsbytes("Re.exec_opt"),
     cst_Re_exec=caml_string_of_jsbytes("Re.exec"),
     cst_Re_diff=caml_string_of_jsbytes("Re.diff"),
     cst_Re_compl=caml_string_of_jsbytes("Re.compl"),
     cst_Re_inter=caml_string_of_jsbytes("Re.inter"),
     cst_Re_repn=caml_string_of_jsbytes("Re.repn"),
     cst_Re_repn$0=caml_string_of_jsbytes("Re.repn"),
     cst$0=caml_string_of_jsbytes("\t "),
     cst_Re_Emacs_Parse_error=caml_string_of_jsbytes("Re__Emacs.Parse_error"),
     cst_Re_Emacs_Not_supported=
      caml_string_of_jsbytes("Re__Emacs.Not_supported"),
     cst_Str_replace_illegal_backsl=
      caml_string_of_jsbytes("Str.replace: illegal backslash sequence"),
     cst$5=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_Str_group_end=caml_string_of_jsbytes("Str.group_end"),
     cst_Str_group_beginning=caml_string_of_jsbytes("Str.group_beginning"),
     beg=[0,caml_string_of_jsbytes(""),0],
     cst_Re_Glob_Parse_error=caml_string_of_jsbytes("Re__Glob.Parse_error"),
     cst$6=caml_string_of_jsbytes(":]"),
     cst_lower=caml_string_of_jsbytes("lower"),
     cst_alnum=caml_string_of_jsbytes("alnum"),
     cst_ascii=caml_string_of_jsbytes("ascii"),
     cst_blank=caml_string_of_jsbytes("blank"),
     cst_cntrl=caml_string_of_jsbytes("cntrl"),
     cst_digit=caml_string_of_jsbytes("digit"),
     cst_graph=caml_string_of_jsbytes("graph"),
     cst_print=caml_string_of_jsbytes("print"),
     cst_punct=caml_string_of_jsbytes("punct"),
     cst_space=caml_string_of_jsbytes("space"),
     cst_upper=caml_string_of_jsbytes("upper"),
     cst_word=caml_string_of_jsbytes("word"),
     cst_xdigit=caml_string_of_jsbytes("xdigit"),
     cst_Invalid_pcre_class=caml_string_of_jsbytes("Invalid pcre class: "),
     cst_Re_Perl_Parse_error=caml_string_of_jsbytes("Re__Perl.Parse_error"),
     cst_Re_Perl_Not_supported=
      caml_string_of_jsbytes("Re__Perl.Not_supported"),
     posix_class_strings=
      caml_list_of_js_array
       ([caml_string_of_jsbytes("alnum"),
         caml_string_of_jsbytes("ascii"),
         caml_string_of_jsbytes("blank"),
         caml_string_of_jsbytes("cntrl"),
         caml_string_of_jsbytes("digit"),
         caml_string_of_jsbytes("lower"),
         caml_string_of_jsbytes("print"),
         caml_string_of_jsbytes("space"),
         caml_string_of_jsbytes("upper"),
         caml_string_of_jsbytes("word"),
         caml_string_of_jsbytes("punct"),
         caml_string_of_jsbytes("graph"),
         caml_string_of_jsbytes("xdigit")]),
     cst_Re_Posix_Parse_error=caml_string_of_jsbytes("Re__Posix.Parse_error"),
     cst_Re_Posix_Not_supported=
      caml_string_of_jsbytes("Re__Posix.Not_supported"),
     include=global_data.Stdlib__format,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib=global_data.Stdlib,
     Assert_failure=global_data.Assert_failure,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_map=global_data.Stdlib__map,
     Stdlib_set=global_data.Stdlib__set,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_hashtbl=global_data.Stdlib__hashtbl,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_seq=global_data.Stdlib__seq,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Re=[0];
    caml_register_global(134,Re,"Re__");
    var
     _bG_=
      [0,
       [12,59,[17,[0,caml_string_of_jsbytes("@ "),1,0],0]],
       caml_string_of_jsbytes(";@ ")],
     _bH_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<3>"),0],
          caml_string_of_jsbytes("<3>")]],
        [12,
         91,
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [15,[17,[0,caml_string_of_jsbytes("@ "),1,0],[12,93,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<3>[@ %a@ ]@]")],
     _bF_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _bE_=
      [0,
       [17,[0,caml_string_of_jsbytes("@ "),1,0],[4,0,0,0,0]],
       caml_string_of_jsbytes("@ %d")],
     _bD_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<3>"),0],
          caml_string_of_jsbytes("<3>")]],
        [12,
         40,
         [2,0,[17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<3>(%s@ %a)@]")],
     _bL_=[0,caml_string_of_jsbytes("lib/cset.ml"),153,9],
     _bI_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bJ_=[0,[4,0,0,0,[12,45,[4,0,0,0,0]]],caml_string_of_jsbytes("%d-%d")],
     _bZ_=[0,caml_string_of_jsbytes("lib/automata.ml"),360,21],
     _bQ_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<2>"),0],
          caml_string_of_jsbytes("<2>")]],
        [11,
         caml_string_of_jsbytes("(Seq"),
         [17,[0,caml_string_of_jsbytes("@ "),1,0],0]]],
       caml_string_of_jsbytes("@[<2>(Seq@ ")],
     _bR_=[0,[12,32,[15,[12,41,[17,0,0]]]],caml_string_of_jsbytes(" %a)@]")],
     _bS_=
      [0,
       [11,
        caml_string_of_jsbytes("(Exp "),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" ("),
          [15,[11,caml_string_of_jsbytes(") (eps))"),0]]]]],
       caml_string_of_jsbytes("(Exp %d (%a) (eps))")],
     _bT_=
      [0,
       [11,
        caml_string_of_jsbytes("(Exp "),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" ("),
          [15,[11,caml_string_of_jsbytes(") "),[15,[12,41,0]]]]]]],
       caml_string_of_jsbytes("(Exp %d (%a) %a)")],
     _bU_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<2>"),0],
          caml_string_of_jsbytes("<2>")]],
        [11,
         caml_string_of_jsbytes("(Match"),
         [17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]],
       caml_string_of_jsbytes("@[<2>(Match@ %a)@]")],
     _bV_=
      [0,[11,caml_string_of_jsbytes(" | "),0],caml_string_of_jsbytes(" | ")],
     _bW_=[0,[11,caml_string_of_jsbytes("()"),0],caml_string_of_jsbytes("()")],
     _bX_=[0,0,0],
     _bP_=[1,0],
     _bO_=
      [0,
       [12,32,[4,0,0,0,[12,45,[4,0,0,0,0]]]],
       caml_string_of_jsbytes(" %d-%d")],
     _bN_=[0,[4,0,0,0,[12,45,[4,0,0,0,0]]],caml_string_of_jsbytes("%d-%d")],
     _b2_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [12,
         40,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(" ("),
           [4,
            0,
            0,
            0,
            [12,32,[4,0,0,0,[11,caml_string_of_jsbytes("))"),[17,0,0]]]]]]]]],
       caml_string_of_jsbytes("@[(%s (%d %d))@]")],
     _b4_=
      [0,
       [15,[17,[0,caml_string_of_jsbytes("@ "),1,0],[4,0,0,0,[15,0]]]],
       caml_string_of_jsbytes("%a@ %d%a")],
     _b__=[0,caml_string_of_jsbytes("lib/core.ml"),690,4],
     _cv_=[0,caml_string_of_jsbytes("lib/core.ml"),1149,24],
     _cw_=[0,caml_string_of_jsbytes("lib/core.ml"),1160,27],
     _ca_=[0,1],
     _b$_=[0,caml_string_of_jsbytes("lib/core.ml"),723,13],
     _b9_=[0,caml_string_of_jsbytes("lib/core.ml"),493,35],
     _b3_=[0,0,0,0,0,0,0,0,0,0,0],
     _b8_=[0,170,[0,181,[0,186,[0,223,[0,255,0]]]]],
     _cB_=[0,1],
     _cA_=[0,1],
     _cy_=[0,caml_string_of_jsbytes(""),0],
     _cz_=[0,caml_string_of_jsbytes(""),0],
     _cx_=[0,45],
     _cC_=[0,748194550,8],
     _cD_=[0,748194550,10],
     _cE_=[0,748194550,13],
     _cF_=[0,748194550,9],
     _cG_=[0,-1,-1];
    function equal(x,y){return x === y?1:0}
    var compare=caml_int_compare;
    function to_int(x){return x}
    var pp=include[17];
    function intersect(x,y){return 0 !== (x & y)?1:0}
    function symbol(x,y){return x | y}
    var
     dummy=-1,
     inexistant=1,
     letter=2,
     not_letter=4,
     newline=8,
     lastnewline=16,
     search_boundary=32;
    function from_char(param)
     {var switch$0=0;
      if(170 <= param)
       if(187 <= param)
        {var _jd_=param - 192 | 0;
         if(54 < _jd_ >>> 0)
          {if(56 <= _jd_)switch$0 = 1}
         else
          if(23 !== _jd_)switch$0 = 1}
       else
        {var _je_=param - 171 | 0;
         if(14 < _je_ >>> 0 || 10 === _je_)switch$0 = 1}
      else
       if(65 <= param)
        {var _jf_=param - 91 | 0;
         if(5 < _jf_ >>> 0)
          {if(! (32 <= _jf_))switch$0 = 1}
         else
          if(4 === _jf_)switch$0 = 1}
       else
        if(48 <= param)
         {if(! (58 <= param))switch$0 = 1}
        else
         if(10 === param)return 12;
      return switch$0?letter:not_letter}
    var
     Re_Category=
      [0,
       symbol,
       from_char,
       dummy,
       inexistant,
       letter,
       not_letter,
       newline,
       lastnewline,
       search_boundary,
       to_int,
       equal,
       compare,
       intersect,
       pp];
    caml_register_global(136,Re_Category,"Re__Category");
    var
     _m_=include[13],
     _q_=include[17],
     _y_=include[25],
     _A_=include[27],
     _bd_=include[123],
     _a_=include[1],
     _b_=include[2],
     _c_=include[3],
     _d_=include[4],
     _e_=include[5],
     _f_=include[6],
     _g_=include[7],
     _h_=include[8],
     _i_=include[9],
     _j_=include[10],
     _k_=include[11],
     _l_=include[12],
     _n_=include[14],
     _o_=include[15],
     _p_=include[16],
     _r_=include[18],
     _s_=include[19],
     _t_=include[20],
     _u_=include[21],
     _v_=include[22],
     _w_=include[23],
     _x_=include[24],
     _z_=include[26],
     _B_=include[28],
     _C_=include[29],
     _D_=include[30],
     _E_=include[31],
     _F_=include[32],
     _G_=include[33],
     _H_=include[34],
     _I_=include[35],
     _J_=include[36],
     _K_=include[37],
     _L_=include[38],
     _M_=include[39],
     _N_=include[40],
     _O_=include[41],
     _P_=include[42],
     _Q_=include[43],
     _R_=include[44],
     _S_=include[45],
     _T_=include[46],
     _U_=include[47],
     _V_=include[48],
     _W_=include[49],
     _X_=include[50],
     _Y_=include[51],
     _Z_=include[52],
     ___=include[53],
     _$_=include[54],
     _aa_=include[55],
     _ab_=include[56],
     _ac_=include[57],
     _ad_=include[58],
     _ae_=include[59],
     _af_=include[60],
     _ag_=include[61],
     _ah_=include[62],
     _ai_=include[63],
     _aj_=include[64],
     _ak_=include[65],
     _al_=include[66],
     _am_=include[67],
     _an_=include[68],
     _ao_=include[69],
     _ap_=include[70],
     _aq_=include[71],
     _ar_=include[72],
     _as_=include[73],
     _at_=include[74],
     _au_=include[75],
     _av_=include[76],
     _aw_=include[77],
     _ax_=include[78],
     _ay_=include[79],
     _az_=include[80],
     _aA_=include[81],
     _aB_=include[82],
     _aC_=include[83],
     _aD_=include[84],
     _aE_=include[85],
     _aF_=include[86],
     _aG_=include[87],
     _aH_=include[88],
     _aI_=include[89],
     _aJ_=include[90],
     _aK_=include[91],
     _aL_=include[92],
     _aM_=include[93],
     _aN_=include[94],
     _aO_=include[95],
     _aP_=include[96],
     _aQ_=include[97],
     _aR_=include[98],
     _aS_=include[99],
     _aT_=include[100],
     _aU_=include[101],
     _aV_=include[102],
     _aW_=include[103],
     _aX_=include[104],
     _aY_=include[105],
     _aZ_=include[106],
     _a0_=include[107],
     _a1_=include[108],
     _a2_=include[109],
     _a3_=include[110],
     _a4_=include[111],
     _a5_=include[112],
     _a6_=include[113],
     _a7_=include[114],
     _a8_=include[115],
     _a9_=include[116],
     _a__=include[117],
     _a$_=include[118],
     _ba_=include[120],
     _bb_=include[121],
     _bc_=include[122],
     _be_=include[124],
     _bf_=include[125],
     _bg_=include[126],
     _bh_=include[127],
     _bi_=include[128],
     _bj_=include[129],
     _bk_=include[130],
     _bl_=include[131],
     _bm_=include[132],
     _bn_=include[133],
     _bo_=include[134],
     _bp_=include[135],
     _bq_=include[136],
     _br_=include[137],
     _bs_=include[138],
     _bt_=include[139],
     _bu_=include[140],
     _bv_=include[141],
     _bw_=include[142],
     _bx_=include[143],
     _by_=include[144],
     _bz_=include[145],
     _bA_=include[146],
     _bB_=include[147],
     _bC_=include[148];
    function pp_print_list(opt,pp,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=_A_;
        if(param$0)
         {var _jb_=param$0[2],_jc_=param$0[1];
          if(_jb_)
           {caml_call2(pp,ppf,_jc_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=_jb_;
            continue}
          return caml_call2(pp,ppf,_jc_)}
        return 0}}
    function sexp(fmt,s,pp,x){return caml_call5(_bd_,fmt,_bD_,s,pp,x)}
    function pair(pp1,pp2,fmt,param)
     {var v2=param[2],v1=param[1];
      caml_call2(pp1,fmt,v1);
      caml_call2(_y_,fmt,0);
      return caml_call2(pp2,fmt,v2)}
    function triple(pp1,pp2,pp3,fmt,param)
     {var v3=param[3],v2=param[2],v1=param[1];
      caml_call2(pp1,fmt,v1);
      caml_call2(_y_,fmt,0);
      caml_call2(pp2,fmt,v2);
      caml_call2(_y_,fmt,0);
      return caml_call2(pp3,fmt,v3)}
    function optint(fmt,param)
     {if(param){var i=param[1];return caml_call3(_bd_,fmt,_bE_,i)}return 0}
    function quote(fmt,s){return caml_call3(include[123],fmt,_bF_,s)}
    function pp_olist(pp_elem,fmt)
     {var _i9_=[0,function(fmt,param){return caml_call2(_bd_,fmt,_bG_)}];
      function _i__(_i$_,_ja_){return pp_print_list(_i9_,pp_elem,_i$_,_ja_)}
      return caml_call3(include[123],fmt,_bH_,_i__)}
    function pp_str_list(_i8_){return pp_olist(quote,_i8_)}
    function to_to_string(pp,x)
     {var b=caml_call1(Stdlib_buffer[1],16),fmt=caml_call1(include[107],b);
      caml_call2(pp,fmt,x);
      return caml_call1(Stdlib_buffer[2],b)}
    var
     Re_Fmt=
      [0,
       _a_,
       _b_,
       _c_,
       _d_,
       _e_,
       _f_,
       _g_,
       _h_,
       _i_,
       _j_,
       _k_,
       _l_,
       _m_,
       _n_,
       _o_,
       _p_,
       _q_,
       _r_,
       _s_,
       _t_,
       _u_,
       _v_,
       _w_,
       _x_,
       _y_,
       _z_,
       _A_,
       _B_,
       _C_,
       _D_,
       _E_,
       _F_,
       _G_,
       _H_,
       _I_,
       _J_,
       _K_,
       _L_,
       _M_,
       _N_,
       _O_,
       _P_,
       _Q_,
       _R_,
       _S_,
       _T_,
       _U_,
       _V_,
       _W_,
       _X_,
       _Y_,
       _Z_,
       ___,
       _$_,
       _aa_,
       _ab_,
       _ac_,
       _ad_,
       _ae_,
       _af_,
       _ag_,
       _ah_,
       _ai_,
       _aj_,
       _ak_,
       _al_,
       _am_,
       _an_,
       _ao_,
       _ap_,
       _aq_,
       _ar_,
       _as_,
       _at_,
       _au_,
       _av_,
       _aw_,
       _ax_,
       _ay_,
       _az_,
       _aA_,
       _aB_,
       _aC_,
       _aD_,
       _aE_,
       _aF_,
       _aG_,
       _aH_,
       _aI_,
       _aJ_,
       _aK_,
       _aL_,
       _aM_,
       _aN_,
       _aO_,
       _aP_,
       _aQ_,
       _aR_,
       _aS_,
       _aT_,
       _aU_,
       _aV_,
       _aW_,
       _aX_,
       _aY_,
       _aZ_,
       _a0_,
       _a1_,
       _a2_,
       _a3_,
       _a4_,
       _a5_,
       _a6_,
       _a7_,
       _a8_,
       _a9_,
       _a__,
       _a$_,
       _ba_,
       _bb_,
       _bc_,
       _bd_,
       _be_,
       _bf_,
       _bg_,
       _bh_,
       _bi_,
       _bj_,
       _bk_,
       _bl_,
       _bm_,
       _bn_,
       _bo_,
       _bp_,
       _bq_,
       _br_,
       _bs_,
       _bt_,
       _bu_,
       _bv_,
       _bw_,
       _bx_,
       _by_,
       _bz_,
       _bA_,
       _bB_,
       _bC_,
       pp_print_list,
       pp_print_list,
       _m_,
       sexp,
       pair,
       triple,
       _q_,
       optint,
       quote,
       pp_olist,
       pp_str_list,
       to_to_string];
    caml_register_global(138,Re_Fmt,"Re__Fmt");
    function union(l$0,l)
     {var l$2=l$0,l$1=l;
      for(;;)
       {if(l$1)
         {if(l$2)
           {var
             r=l$1[2],
             _i7_=l$1[1],
             c2=_i7_[2],
             c1=_i7_[1],
             r$0=l$2[2],
             match=l$2[1],
             c2$0=match[2],
             c1$0=match[1];
            if((c2$0 + 1 | 0) < c1)return [0,[0,c1$0,c2$0],union(r$0,l$1)];
            if((c2 + 1 | 0) < c1$0)return [0,[0,c1,c2],union(l$2,r)];
            if(c2$0 < c2)
             {var
               l$3=[0,[0,caml_call2(Stdlib[16],c1$0,c1),c2],r],
               l$2=r$0,
               l$1=l$3;
              continue}
            var
             l$4=[0,[0,caml_call2(Stdlib[16],c1$0,c1),c2$0],r$0],
             l$2=l$4,
             l$1=r;
            continue}
          return l$1}
        return l$2}}
    function inter(l$0,l)
     {var l$2=l$0,l$1=l;
      for(;;)
       {if(l$1)
         {if(l$2)
           {var
             r=l$1[2],
             _i4_=l$1[1],
             c2=_i4_[2],
             c1=_i4_[1],
             r$0=l$2[2],
             match=l$2[1],
             c2$0=match[2],
             c1$0=match[1];
            if(caml_lessthan(c2$0,c1)){var l$2=r$0;continue}
            if(caml_lessthan(c2,c1$0)){var l$1=r;continue}
            if(caml_lessthan(c2$0,c2))
             {var _i5_=inter(r$0,l$1);
              return [0,[0,caml_call2(Stdlib[17],c1$0,c1),c2$0],_i5_]}
            var _i6_=inter(l$2,r);
            return [0,[0,caml_call2(Stdlib[17],c1$0,c1),c2],_i6_]}
          return 0}
        return 0}}
    function diff(l$0,l)
     {var l$2=l$0,l$1=l;
      for(;;)
       {if(l$1)
         {if(l$2)
           {var
             r=l$1[2],
             _i3_=l$1[1],
             c2=_i3_[2],
             c1=_i3_[1],
             r$0=l$2[2],
             match=l$2[1],
             c2$0=match[2],
             c1$0=match[1];
            if(c2$0 < c1)return [0,[0,c1$0,c2$0],diff(r$0,l$1)];
            if(c2 < c1$0){var l$1=r;continue}
            var r$1=c2 < c2$0?[0,[0,c2 + 1 | 0,c2$0],r$0]:r$0;
            if(c1$0 < c1)return [0,[0,c1$0,c1 - 1 | 0],diff(r$1,r)];
            var l$2=r$1,l$1=r;
            continue}
          return 0}
        return l$2}}
    function single(c){return [0,[0,c,c],0]}
    function add(c,l){return union(single(c),l)}
    function seq(c$0,c)
     {return runtime.caml_lessequal(c$0,c)?[0,[0,c$0,c],0]:[0,[0,c,c$0],0]}
    function offset(o,l)
     {if(l)
       {var r=l[2],match=l[1],c2=match[2],c1=match[1];
        return [0,[0,c1 + o | 0,c2 + o | 0],offset(o,r)]}
      return 0}
    var empty=0;
    function mem(c,s)
     {var s$0=s;
      for(;;)
       {if(s$0)
         {var rem=s$0[2],match=s$0[1],c2=match[2],c1=match[1];
          if(c <= c2)return c1 <= c?1:0;
          var s$0=rem;
          continue}
        return 0}}
    function hash_rec(param)
     {if(param)
       {var r=param[2],match=param[1],j=match[2],i=match[1];
        return (i + (13 * j | 0) | 0) + (257 * hash_rec(r) | 0) | 0}
      return 0}
    function hash(l){return hash_rec(l) & 1073741823}
    function print_one(ch,param)
     {var c2=param[2],c1=param[1];
      return c1 === c2
              ?caml_call3(include[123],ch,_bI_,c1)
              :caml_call4(include[123],ch,_bJ_,c1,c2)}
    var _bK_=0;
    function pp$0(_i1_,_i2_){return pp_print_list(_bK_,print_one,_i1_,_i2_)}
    function iter(t,f)
     {var t$0=t;
      for(;;)
       {if(t$0)
         {var xs=t$0[2],match=t$0[1],y=match[2],x=match[1];
          caml_call2(f,x,y);
          var t$0=xs;
          continue}
        return 0}}
    function one_char(param)
     {if(param && ! param[2])
       {var match=param[1],j=match[2],i=match[1];
        if(caml_equal(i,j))return [0,i]}
      return 0}
    function compare$0(param,_i0_)
     {var v=_i0_[2],j=_i0_[1],u=param[2],i=param[1],c=caml_compare(i,j);
      return 0 === c?caml_compare(u,v):c}
    var CSetMap=caml_call1(Stdlib_map[1],[0,compare$0]);
    function fold_right(t,init,f){return caml_call3(Stdlib_list[22],f,t,init)}
    function csingle(c){return single(c)}
    function is_empty(param){return param?0:1}
    function prepend(s,x,l)
     {var s$0=s;
      for(;;)
       {if(s$0)
         {if(l)
           {var _iV_=l[1],_iW_=_iV_[1];
            if(_iW_ && ! _iW_[2])
             {var
               r=l[2],
               x$0=_iV_[2],
               _iX_=_iW_[1],
               d=_iX_[2],
               d$0=_iX_[1],
               r$0=s$0[2],
               match=s$0[1],
               c=match[2],
               c$0=match[1];
              if(c < d$0){var s$0=r$0;continue}
              if(c$0 <= d$0)
               {if(c < d)
                 {var _iY_=prepend(r$0,x,[0,[0,[0,[0,c + 1 | 0,d],0],x$0],r]);
                  return [0,
                          [0,[0,[0,d$0,c],0],caml_call2(Stdlib[37],x,x$0)],
                          _iY_]}
                var _iZ_=prepend(s$0,x,r);
                return [0,
                        [0,[0,[0,d$0,d],0],caml_call2(Stdlib[37],x,x$0)],
                        _iZ_]}
              return d < c$0
                      ?[0,[0,[0,[0,d$0,d],0],x$0],prepend(s$0,x,r)]
                      :[0,
                        [0,[0,[0,d$0,c$0 - 1 | 0],0],x$0],
                        prepend(s$0,x,[0,[0,[0,[0,c$0,d],0],x$0],r])]}
            throw [0,Assert_failure,_bL_]}
          return 0}
        return l}}
    function pick(param)
     {if(param){var match=param[1],x=match[1];return x}
      return caml_call1(Stdlib[1],cst_Re_cset_pick)}
    var
     Re_Cset=
      [0,
       iter,
       union,
       inter,
       diff,
       offset,
       empty,
       single,
       seq,
       add,
       mem,
       hash,
       pp$0,
       one_char,
       fold_right,
       hash_rec,
       CSetMap,
       cany,
       csingle,
       is_empty,
       prepend,
       pick];
    caml_register_global(143,Re_Cset,"Re__Cset");
    function equal$0(x,y){return x === y?1:0}
    var compare$1=caml_int_compare,r=[0,0];
    function gen(param){r[1]++;return r[1]}
    var
     pp$1=include[17],
     Set=caml_call1(Stdlib_set[1],[0,compare$1]),
     Re_Pmark=[0,equal$0,compare$1,gen,pp$1,Set];
    caml_register_global(145,Re_Pmark,"Re__Pmark");
    function hash_combine(h,accu){return (accu * 65599 | 0) + h | 0}
    var empty$0=[0,0,Set[1]];
    function merge_marks_offset(old,param)
     {if(param)
       {var
         rem=param[2],
         match=param[1],
         v=match[2],
         i=match[1],
         nw=merge_marks_offset(caml_call2(Stdlib_list[46],i,old),rem);
        return -2 === v?nw:[0,[0,i,v],nw]}
      return old}
    function merge(old,nw)
     {var _iU_=caml_call2(Set[7],old[2],nw[2]);
      return [0,merge_marks_offset(old[1],nw[1]),_iU_]}
    function hash$0(m,accu$1)
     {var
       accu$2=hash_combine(caml_call1(Stdlib_hashtbl[27],m[2]),accu$1),
       l=m[1],
       accu=accu$2;
      for(;;)
       {if(l)
         {var
           r=l[2],
           match=l[1],
           i=match[2],
           a=match[1],
           accu$0=hash_combine(a,hash_combine(i,accu)),
           l=r,
           accu=accu$0;
          continue}
        return accu}}
    function _bM_(idx,marks)
     {if(marks)
       {var _iT_=marks[1];
        if(-1 === _iT_[2])
         {var rem=marks[2],a=_iT_[1];return [0,[0,a,idx],_bM_(idx,rem)]}}
      return marks}
    function marks_set_idx(marks,idx)
     {var _iS_=marks[2];return [0,_bM_(idx,marks[1]),_iS_]}
    function pp_marks(ch,t)
     {var _iQ_=t[1];
      if(_iQ_)
       {var r=_iQ_[2],match=_iQ_[1],i=match[2],a=match[1];
        caml_call4(include[123],ch,_bN_,a,i);
        var
         _iR_=
          function(param)
           {var i=param[2],a=param[1];
            return caml_call4(include[123],ch,_bO_,a,i)};
        return caml_call2(Stdlib_list[15],_iR_,r)}
      return 0}
    function pp_sem(ch,k)
     {var _iP_=-730718166 === k?cst_long:332064784 <= k?cst_first:cst_short;
      return caml_call2(include[13],ch,_iP_)}
    function pp_rep_kind(fmt,param)
     {return 620821490 <= param
              ?caml_call2(include[13],fmt,cst_Non_greedy)
              :caml_call2(include[13],fmt,cst_Greedy)}
    function pp$2(ch,e)
     {var _iC_=e[2];
      if(typeof _iC_ === "number")
       return caml_call2(_m_,ch,cst_eps);
      else
       switch(_iC_[0])
        {case 0:var l=_iC_[1];return sexp(ch,cst_cst,pp$0,l);
         case 1:
          var l$0=_iC_[1],_iD_=0;
          return sexp
                  (ch,
                   cst_alt,
                   function(_iN_,_iO_)
                    {return pp_print_list(_iD_,pp$2,_iN_,_iO_)},
                   l$0);
         case 2:
          var e$0=_iC_[3],e$1=_iC_[2],k=_iC_[1],_iE_=[0,k,e$1,e$0];
          return sexp
                  (ch,
                   cst_seq,
                   function(_iL_,_iM_)
                    {return triple(pp_sem,pp$2,pp$2,_iL_,_iM_)},
                   _iE_);
         case 3:
          var e$2=_iC_[3],k$0=_iC_[2],_iF_=[0,k$0,e$2];
          return sexp
                  (ch,
                   cst_rep,
                   function(_iJ_,_iK_){return pair(pp_sem,pp$2,_iJ_,_iK_)},
                   _iF_);
         case 4:var i=_iC_[1];return sexp(ch,cst_mark,_q_,i);
         case 5:
          var e$3=_iC_[2],b=_iC_[1],_iG_=[0,b,e$3];
          return sexp
                  (ch,
                   cst_erase,
                   function(_iH_,_iI_){return pair(_q_,_q_,_iH_,_iI_)},
                   _iG_);
         case 6:var c=_iC_[1];return sexp(ch,cst_before,pp,c);
         case 7:var c$0=_iC_[1];return sexp(ch,cst_after,pp,c$0);
         default:var i$0=_iC_[1];return sexp(ch,cst_pmark,_q_,i$0)}}
    function first(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var r=param$0[2],x=param$0[1],res=caml_call1(f,x);
          if(res)return res;
          var param$0=r;
          continue}
        return 0}}
    function create_ids(param){return [0,0]}
    function mk_expr(ids,def){ids[1]++;return [0,ids[1],def]}
    function empty$1(ids){return mk_expr(ids,_bP_)}
    function cst(ids,s){return is_empty(s)?empty$1(ids):mk_expr(ids,[0,s])}
    function alt(ids,l)
     {if(l){if(l[2])return mk_expr(ids,[1,l]);var c=l[1];return c}
      return empty$1(ids)}
    function seq$0(ids,kind,x,y)
     {var _iA_=x[2],_iB_=y[2];
      if(typeof _iA_ !== "number" && 1 === _iA_[0] && ! _iA_[1])return x;
      if(typeof _iB_ !== "number" && 1 === _iB_[0] && ! _iB_[1])return y;
      if(typeof _iA_ === "number")return y;
      if(typeof _iB_ === "number" && 332064784 === kind)return x;
      return mk_expr(ids,[2,kind,x,y])}
    function is_eps(expr){return typeof expr[2] === "number"?1:0}
    function eps(ids){return mk_expr(ids,0)}
    function rep(ids,kind,sem,x){return mk_expr(ids,[3,kind,sem,x])}
    function mark(ids,m){return mk_expr(ids,[4,m])}
    function pmark(ids,i){return mk_expr(ids,[8,i])}
    function erase(ids,m$0,m){return mk_expr(ids,[5,m$0,m])}
    function before(ids,c){return mk_expr(ids,[6,c])}
    function after(ids,c){return mk_expr(ids,[7,c])}
    function rename(ids,x)
     {var _iw_=x[2];
      if(typeof _iw_ !== "number")
       switch(_iw_[0])
        {case 1:
          var l=_iw_[1],_ix_=function(_iz_){return rename(ids,_iz_)};
          return mk_expr(ids,[1,caml_call2(Stdlib_list[17],_ix_,l)]);
         case 2:
          var z=_iw_[3],y=_iw_[2],k=_iw_[1],_iy_=rename(ids,z);
          return mk_expr(ids,[2,k,rename(ids,y),_iy_]);
         case 3:
          var y$0=_iw_[3],k$0=_iw_[2],g=_iw_[1];
          return mk_expr(ids,[3,g,k$0,rename(ids,y$0)])
         }
      return mk_expr(ids,x[2])}
    function equal$1(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var _id_=l1$0[1];
          switch(_id_[0])
           {case 0:
             if(l2$0)
              {var _ie_=l2$0[1],_if_=l1$0[2],_ig_=_id_[2],_ih_=_id_[1];
               if(0 === _ie_[0])
                {var
                  r2=l2$0[2],
                  e2=_ie_[2],
                  l2$1=_ie_[1],
                  _ii_=_ig_[1] === e2[1]?1:0;
                 if(_ii_)
                  {var _ij_=equal$1(_ih_,l2$1);
                   if(_ij_){var l1$0=_if_,l2$0=r2;continue}
                   var _ik_=_ij_}
                 else
                  var _ik_=_ii_;
                 return _ik_}}
             break;
            case 1:
             if(l2$0)
              {var _il_=l2$0[1],_im_=l1$0[2],_in_=_id_[2],_io_=_id_[1];
               if(1 === _il_[0])
                {var
                  r2$0=l2$0[2],
                  e2$0=_il_[2],
                  marks2=_il_[1],
                  _ip_=_in_[1] === e2$0[1]?1:0;
                 if(_ip_)
                  {var _iq_=caml_equal(_io_,marks2);
                   if(_iq_){var l1$0=_im_,l2$0=r2$0;continue}
                   var _ir_=_iq_}
                 else
                  var _ir_=_ip_;
                 return _ir_}}
             break;
            default:
             if(l2$0)
              {var _is_=l2$0[1],_it_=l1$0[2],_iu_=_id_[1];
               if(2 === _is_[0])
                {var
                  r2$1=l2$0[2],
                  marks2$0=_is_[1],
                  _iv_=caml_equal(_iu_,marks2$0);
                 if(_iv_){var l1$0=_it_,l2$0=r2$1;continue}
                 return _iv_}}}}
        else
         if(! l2$0)return 1;
        return 0}}
    function hash$1(l,accu)
     {var l$0=l,accu$0=accu;
      for(;;)
       {if(l$0)
         {var _ia_=l$0[1];
          switch(_ia_[0])
           {case 0:
             var
              r=l$0[2],
              e=_ia_[2],
              l$1=_ia_[1],
              _ib_=hash$1(l$1,accu$0),
              accu$1=hash_combine(388635598,hash_combine(e[1],_ib_)),
              l$0=r,
              accu$0=accu$1;
             continue;
            case 1:
             var
              r$0=l$0[2],
              e$0=_ia_[2],
              marks=_ia_[1],
              _ic_=hash$0(marks,accu$0),
              accu$2=hash_combine(726404471,hash_combine(e$0[1],_ic_)),
              l$0=r$0,
              accu$0=accu$2;
             continue;
            default:
             var
              r$1=l$0[2],
              marks$0=_ia_[1],
              accu$3=hash_combine(471882453,hash$0(marks$0,accu$0)),
              l$0=r$1,
              accu$0=accu$3;
             continue}}
        return accu$0}}
    function tseq(kind,x,y,rem)
     {if(x)
       {var _h$_=x[1];
        if(1 === _h$_[0] && typeof _h$_[2][2] === "number" && ! x[2])
         {var marks=_h$_[1];return [0,[1,marks,y],rem]}
        return [0,[0,x,y,kind],rem]}
      return rem}
    function print_state_lst(ch,l,y)
     {if(l)
       {var rem=l[2],e=l[1];
        print_state_rec(ch,e,y);
        var
         _h__=
          function(e)
           {caml_call2(include[123],ch,_bV_);return print_state_rec(ch,e,y)};
        return caml_call2(Stdlib_list[15],_h__,rem)}
      return caml_call2(include[123],ch,_bW_)}
    function print_state_rec(ch,e,y)
     {switch(e[0])
       {case 0:
         var x=e[2],l=e[1];
         caml_call2(include[123],ch,_bQ_);
         print_state_lst(ch,l,x);
         return caml_call4(include[123],ch,_bR_,pp$2,x);
        case 1:
         var _h8_=e[2],_h9_=e[1];
         return typeof _h8_[2] === "number"
                 ?caml_call5(include[123],ch,_bS_,y[1],pp_marks,_h9_)
                 :caml_call7
                   (include[123],ch,_bT_,_h8_[1],pp_marks,_h9_,pp$2,_h8_);
        default:
         var marks=e[1];return caml_call4(include[123],ch,_bU_,pp_marks,marks)}}
    function pp$3(ch,t){return print_state_lst(ch,[0,t,0],_bX_)}
    var dummy$0=[0,-1,dummy,0,0,-1];
    function mk(idx,cat,desc)
     {return [0,
              idx,
              cat,
              desc,
              0,
              hash$1(desc,hash_combine(idx,hash_combine(cat,0))) & 1073741823]}
    function create(cat,e){return mk(0,cat,[0,[1,empty$0,e],0])}
    function equal$2(x,y)
     {var _h4_=x[5] === y[5]?1:0;
      if(_h4_)
       {var _h5_=x[1] === y[1]?1:0;
        if(_h5_)
         {var _h6_=x[2] === y[2]?1:0;
          if(_h6_)return equal$1(x[3],y[3]);
          var _h7_=_h6_}
        else
         var _h7_=_h5_}
      else
       var _h7_=_h4_;
      return _h7_}
    function hash$2(t){return t[5]}
    var Table=caml_call1(Stdlib_hashtbl[25],[0,equal$2,hash$2]);
    function create_working_area(param){return [0,[0,0]]}
    function index_count(w){return w[1].length - 1}
    function mark_used_indices(tbl)
     {function _hZ_(param)
       {if(0 === param[0])
         {var l=param[1];return caml_call1(mark_used_indices(tbl),l)}
        var marks=param[1],_h0_=marks[1];
        function _h1_(param)
         {var
           i=param[2],
           _h2_=0 <= i?1:0,
           _h3_=_h2_?(caml_check_bound(tbl,i)[1 + i] = 1,0):_h2_;
          return _h3_}
        return caml_call2(Stdlib_list[15],_h1_,_h0_)}
      return caml_call1(Stdlib_list[15],_hZ_)}
    function free_index(tbl_ref,l)
     {var tbl=tbl_ref[1];
      caml_call4(Stdlib_array[9],tbl,0,tbl.length - 1,0);
      caml_call1(mark_used_indices(tbl),l);
      var len=tbl.length - 1,idx=0;
      for(;;)
       {if(idx !== len && caml_check_bound(tbl,idx)[1 + idx])
         {var idx$0=idx + 1 | 0,idx=idx$0;continue}
        if(idx === len)tbl_ref[1] = caml_make_vect(2 * len | 0,0);
        return idx}}
    function _bY_(param){return 2 === param[0]?0:1}
    var remove_matches=caml_call1(Stdlib_list[36],_bY_);
    function split_at_match(l$1)
     {var l=0,param=l$1;
      for(;;)
       {if(param)
         {var _hX_=param[1];
          if(2 === _hX_[0])
           {var r=param[2],_hY_=caml_call1(remove_matches,r);
            return [0,caml_call1(Stdlib_list[9],l),_hY_]}
          var param$0=param[2],l$0=[0,_hX_,l],l=l$0,param=param$0;
          continue}
        throw [0,Assert_failure,_bZ_]}}
    function remove_duplicates(prev,l,y)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var _hV_=l$0[1];
          switch(_hV_[0])
           {case 0:
             var
              r=l$0[2],
              kind=_hV_[3],
              x=_hV_[2],
              l$1=_hV_[1],
              match=remove_duplicates(prev,l$1,x),
              prev$0=match[2],
              l$2=match[1],
              match$0=remove_duplicates(prev$0,r,y),
              prev$1=match$0[2],
              r$0=match$0[1];
             return [0,tseq(kind,l$2,x,r$0),prev$1];
            case 1:
             var _hW_=_hV_[2];
             if(typeof _hW_[2] === "number")
              {var r$1=l$0[2];
               if(caml_call2(Stdlib_list[33],y[1],prev)){var l$0=r$1;continue}
               var
                match$1=remove_duplicates([0,y[1],prev],r$1,y),
                prev$2=match$1[2],
                r$2=match$1[1];
               return [0,[0,_hV_,r$2],prev$2]}
             var r$3=l$0[2];
             if(caml_call2(Stdlib_list[33],_hW_[1],prev))
              {var l$0=r$3;continue}
             var
              match$2=remove_duplicates([0,_hW_[1],prev],r$3,y),
              prev$3=match$2[2],
              r$4=match$2[1];
             return [0,[0,_hV_,r$4],prev$3];
            default:return [0,[0,_hV_,0],prev]}}
        return [0,0,prev]}}
    function set_idx(idx,param)
     {if(param)
       {var _hR_=param[1];
        switch(_hR_[0])
         {case 0:
           var
            r=param[2],
            kind=_hR_[3],
            x=_hR_[2],
            l=_hR_[1],
            _hS_=set_idx(idx,r);
           return [0,[0,set_idx(idx,l),x,kind],_hS_];
          case 1:
           var r$0=param[2],x$0=_hR_[2],marks=_hR_[1],_hT_=set_idx(idx,r$0);
           return [0,[1,marks_set_idx(marks,idx),x$0],_hT_];
          default:
           var r$1=param[2],marks$0=_hR_[1],_hU_=set_idx(idx,r$1);
           return [0,[2,marks_set_idx(marks$0,idx)],_hU_]}}
      return 0}
    function filter_marks(b,e,marks)
     {var _hM_=marks[2],_hN_=marks[1];
      function _hO_(param)
       {var i=param[1],_hP_=i < b?1:0,_hQ_=_hP_ || (e < i?1:0);return _hQ_}
      return [0,caml_call2(Stdlib_list[36],_hO_,_hN_),_hM_]}
    function delta_1$0(counter,init,c,next_cat,prev_cat,x,rem)
     {var _hJ_=x[2];
      if(typeof _hJ_ === "number")
       return [0,[2,init],rem];
      else
       switch(_hJ_[0])
        {case 0:var s=_hJ_[1];return mem(c,s)?[0,[1,init,eps_expr],rem]:rem;
         case 1:
          var l=_hJ_[1];
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return delta_2$0(counter$1,init,c,next_cat,prev_cat,l,rem)}
          return caml_trampoline_return
                  (delta_2$0,[0,init,c,next_cat,prev_cat,l,rem]);
         case 2:
          var
           z=_hJ_[3],
           y=_hJ_[2],
           kind=_hJ_[1],
           y$0=delta_1(init,c,next_cat,prev_cat,y,0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return delta_seq$0(counter$0,c,next_cat,prev_cat,kind,y$0,z,rem)}
          return caml_trampoline_return
                  (delta_seq$0,[0,c,next_cat,prev_cat,kind,y$0,z,rem]);
         case 3:
          var
           y$1=_hJ_[3],
           kind$0=_hJ_[2],
           rep_kind=_hJ_[1],
           y$2=delta_1(init,c,next_cat,prev_cat,y$1,0),
           match=
            first
             (function(param)
               {if(2 === param[0]){var marks=param[1];return [0,marks]}
                return 0},
              y$2);
          if(match)
           var
            marks=match[1],
            y$3=caml_call1(remove_matches,y$2),
            marks$0=marks;
          else
           var y$3=y$2,marks$0=init;
          return 620821490 <= rep_kind
                  ?[0,[2,init],tseq(kind$0,y$3,x,rem)]
                  :tseq(kind$0,y$3,x,[0,[2,marks$0],rem]);
         case 4:
          var
           i=_hJ_[1],
           _hK_=init[2],
           marks$1=[0,[0,[0,i,-1],caml_call2(Stdlib_list[46],i,init[1])],_hK_];
          return [0,[2,marks$1],rem];
         case 5:
          var e=_hJ_[2],b=_hJ_[1];return [0,[2,filter_marks(b,e,init)],rem];
         case 6:
          var cat=_hJ_[1];return intersect(next_cat,cat)?[0,[2,init],rem]:rem;
         case 7:
          var cat$0=_hJ_[1];
          return intersect(prev_cat,cat$0)?[0,[2,init],rem]:rem;
         default:
          var
           i$0=_hJ_[1],
           _hL_=caml_call2(Set[4],i$0,init[2]),
           marks$2=[0,init[1],_hL_];
          return [0,[2,marks$2],rem]}}
    function delta_2$0(counter,marks,c,next_cat,prev_cat,l,rem)
     {if(l)
       {var r=l[2],y=l[1],_hI_=delta_2(marks,c,next_cat,prev_cat,r,rem);
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return delta_1$0(counter$0,marks,c,next_cat,prev_cat,y,_hI_)}
        return caml_trampoline_return
                (delta_1$0,[0,marks,c,next_cat,prev_cat,y,_hI_])}
      return rem}
    function delta_seq$0(counter,c,next_cat,prev_cat,kind,y,z,rem)
     {var
       match=
        first
         (function(param)
           {if(2 === param[0]){var marks=param[1];return [0,marks]}return 0},
          y);
      if(match)
       {var marks=match[1];
        if(-730718166 === kind)
         {var _hG_=delta_1(marks,c,next_cat,prev_cat,z,rem);
          return tseq(kind,caml_call1(remove_matches,y),z,_hG_)}
        if(332064784 <= kind)
         {var match$0=split_at_match(y),y$0=match$0[2],y$1=match$0[1];
          return tseq
                  (kind,
                   y$1,
                   z,
                   delta_1(marks,c,next_cat,prev_cat,z,tseq(kind,y$0,z,rem)))}
        var _hH_=tseq(kind,caml_call1(remove_matches,y),z,rem);
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return delta_1$0(counter$0,marks,c,next_cat,prev_cat,z,_hH_)}
        return caml_trampoline_return
                (delta_1$0,[0,marks,c,next_cat,prev_cat,z,_hH_])}
      return tseq(kind,y,z,rem)}
    function delta_1(init,c,next_cat,prev_cat,x,rem)
     {return caml_trampoline(delta_1$0(0,init,c,next_cat,prev_cat,x,rem))}
    function delta_2(marks,c,next_cat,prev_cat,l,rem)
     {return caml_trampoline(delta_2$0(0,marks,c,next_cat,prev_cat,l,rem))}
    function delta_seq(c,next_cat,prev_cat,kind,y,z,rem)
     {return caml_trampoline(delta_seq$0(0,c,next_cat,prev_cat,kind,y,z,rem))}
    function delta_4(c,next_cat,prev_cat,l,rem)
     {if(l)
       {var r=l[2],y$1=l[1],rem$0=delta_4(c,next_cat,prev_cat,r,rem);
        switch(y$1[0])
         {case 0:
           var
            kind=y$1[3],
            z=y$1[2],
            y=y$1[1],
            y$0=delta_4(c,next_cat,prev_cat,y,0);
           return delta_seq(c,next_cat,prev_cat,kind,y$0,z,rem$0);
          case 1:
           var e=y$1[2],marks=y$1[1];
           return delta_1(marks,c,next_cat,prev_cat,e,rem$0);
          default:return [0,y$1,rem$0]}}
      return rem}
    function delta(tbl_ref,next_cat,char$0,st)
     {var
       prev_cat=st[2],
       match=
        remove_duplicates
         (0,delta_4(char$0,next_cat,prev_cat,st[3],0),eps_expr),
       expr=match[1],
       idx=free_index(tbl_ref,expr),
       expr$0=set_idx(idx,expr);
      return mk(idx,next_cat,expr$0)}
    function red_tr(l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var _hF_=l$0[2];
          if(_hF_)
           {var
             rem=_hF_[2],
             tr2=_hF_[1],
             st2=tr2[2],
             s2=tr2[1],
             tr1=l$0[1],
             st1=tr1[2],
             s1=tr1[1];
            if(equal$2(st1,st2))
             {var l$1=[0,[0,union(s1,s2),st1],rem],l$0=l$1;continue}
            return [0,tr1,red_tr([0,tr2,rem])]}}
        return l$0}}
    function _b0_(param,l){var x=param[2],s=param[1];return prepend(s,x,l)}
    var prepend_deriv=caml_call1(Stdlib_list[22],_b0_);
    function restrict(s,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           rem=param$0[2],
           match=param$0[1],
           x=match[2],
           s$0=match[1],
           s$1=inter(s,s$0);
          if(is_empty(s$1)){var param$0=rem;continue}
          return [0,[0,s$1,x],restrict(s,rem)]}
        return 0}}
    function prepend_marks_expr_lst(m,l)
     {function _hE_(param)
       {switch(param[0])
         {case 0:
           var s=param[3],e=param[2],l=param[1];
           return [0,prepend_marks_expr_lst(m,l),e,s];
          case 1:var e$0=param[2],m$0=param[1];return [1,merge(m,m$0),e$0];
          default:var m$1=param[1];return [2,merge(m,m$1)]}}
      return caml_call2(Stdlib_list[17],_hE_,l)}
    function deriv_seq(all_chars,categories,cat,kind,y,z,rem)
     {function _hv_(param)
       {var xl=param[2];
        function _hD_(param){return 2 === param[0]?1:0}
        return caml_call2(Stdlib_list[29],_hD_,xl)}
      if(caml_call2(Stdlib_list[29],_hv_,y))
       {var
         z$0=deriv_1(all_chars,categories,empty$0,cat,z,[0,[0,all_chars,0],0]),
         _hw_=
          function(param,rem)
           {var
             y=param[2],
             s=param[1],
             match=
              first
               (function(param)
                 {if(2 === param[0]){var marks=param[1];return [0,marks]}
                  return 0},
                y);
            if(match)
             {var
               marks=match[1],
               _hy_=
                function(param)
                 {var x=param[2],s=param[1];
                  return [0,s,prepend_marks_expr_lst(marks,x)]},
               z$1=caml_call1(caml_call1(Stdlib_list[17],_hy_),z$0);
              if(-730718166 === kind)
               {var _hz_=caml_call2(prepend_deriv,restrict(s,z$1),rem);
                return prepend
                        (s,tseq(kind,caml_call1(remove_matches,y),z,0),_hz_)}
              if(332064784 <= kind)
               {var
                 match$0=split_at_match(y),
                 y$0=match$0[2],
                 y$1=match$0[1],
                 _hA_=prepend(s,tseq(kind,y$0,z,0),rem),
                 _hB_=caml_call2(prepend_deriv,restrict(s,z$1),_hA_);
                return prepend(s,tseq(kind,y$1,z,0),_hB_)}
              var
               _hC_=
                prepend(s,tseq(kind,caml_call1(remove_matches,y),z,0),rem);
              return caml_call2(prepend_deriv,restrict(s,z$1),_hC_)}
            return prepend(s,tseq(kind,y,z,0),rem)};
        return caml_call3(Stdlib_list[22],_hw_,y,rem)}
      function _hx_(param,rem)
       {var xl=param[2],s=param[1];return prepend(s,tseq(kind,xl,z,0),rem)}
      return caml_call3(Stdlib_list[22],_hx_,y,rem)}
    function deriv_1$0(counter,all_chars,categories,marks,cat,x,rem$1)
     {var _hp_=x[2];
      if(typeof _hp_ === "number")
       return prepend(all_chars,[0,[2,marks],0],rem$1);
      else
       switch(_hp_[0])
        {case 0:
          var s=_hp_[1];return prepend(s,[0,[1,marks,eps_expr],0],rem$1);
         case 1:
          var l=_hp_[1];
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return deriv_2$0(counter$0,all_chars,categories,marks,cat,l,rem$1)}
          return caml_trampoline_return
                  (deriv_2$0,[0,all_chars,categories,marks,cat,l,rem$1]);
         case 2:
          var
           z=_hp_[3],
           y=_hp_[2],
           kind=_hp_[1],
           y$0=deriv_1(all_chars,categories,marks,cat,y,[0,[0,all_chars,0],0]);
          return deriv_seq(all_chars,categories,cat,kind,y$0,z,rem$1);
         case 3:
          var
           y$1=_hp_[3],
           kind$0=_hp_[2],
           rep_kind=_hp_[1],
           y$2=
            deriv_1(all_chars,categories,marks,cat,y$1,[0,[0,all_chars,0],0]),
           _hq_=
            function(param,rem)
             {var
               z=param[2],
               s=param[1],
               match=
                first
                 (function(param)
                   {if(2 === param[0]){var marks=param[1];return [0,marks]}
                    return 0},
                  z);
              if(match)
               var
                marks$0=match[1],
                z$0=caml_call1(remove_matches,z),
                marks$1=marks$0;
              else
               var z$0=z,marks$1=marks;
              var
               _hu_=
                620821490 <= rep_kind
                 ?[0,[2,marks],tseq(kind$0,z$0,x,0)]
                 :tseq(kind$0,z$0,x,[0,[2,marks$1],0]);
              return prepend(s,_hu_,rem)};
          return caml_call3(Stdlib_list[22],_hq_,y$2,rem$1);
         case 4:
          var i=_hp_[1],_hr_=marks[2];
          return prepend
                  (all_chars,
                   [0,
                    [2,
                     [0,[0,[0,i,-1],caml_call2(Stdlib_list[46],i,marks[1])],_hr_]],
                    0],
                   rem$1);
         case 5:
          var
           e$1=_hp_[2],
           b=_hp_[1],
           _ht_=marks[2],
           e=e$1,
           rem=filter_marks(b,e$1,marks)[1],
           _hs_=0;
          for(;;)
           {if(e < b)
             return prepend(all_chars,[0,[2,[0,rem,_ht_]],_hs_],rem$1);
            var rem$0=[0,[0,e,-2],rem],e$0=e - 1 | 0,e=e$0,rem=rem$0;
            continue}
         case 6:
          var cat$0=_hp_[1];
          return prepend
                  (caml_call2(Stdlib_list[41],cat$0,categories),
                   [0,[2,marks],0],
                   rem$1);
         case 7:
          var cat$1=_hp_[1];
          return intersect(cat,cat$1)
                  ?prepend(all_chars,[0,[2,marks],0],rem$1)
                  :rem$1;
         default:return prepend(all_chars,[0,[2,marks],0],rem$1)}}
    function deriv_2$0(counter,all_chars,categories,marks,cat,l,rem)
     {if(l)
       {var r=l[2],y=l[1],_ho_=deriv_2(all_chars,categories,marks,cat,r,rem);
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return deriv_1$0(counter$0,all_chars,categories,marks,cat,y,_ho_)}
        return caml_trampoline_return
                (deriv_1$0,[0,all_chars,categories,marks,cat,y,_ho_])}
      return rem}
    function deriv_1(all_chars,categories,marks,cat,x,rem)
     {return caml_trampoline
              (deriv_1$0(0,all_chars,categories,marks,cat,x,rem))}
    function deriv_2(all_chars,categories,marks,cat,l,rem)
     {return caml_trampoline
              (deriv_2$0(0,all_chars,categories,marks,cat,l,rem))}
    function deriv_4(all_chars,categories,cat,l,rem)
     {if(l)
       {var r=l[2],y$1=l[1],rem$0=deriv_4(all_chars,categories,cat,r,rem);
        switch(y$1[0])
         {case 0:
           var
            kind=y$1[3],
            z=y$1[2],
            y=y$1[1],
            y$0=deriv_4(all_chars,categories,cat,y,[0,[0,all_chars,0],0]);
           return deriv_seq(all_chars,categories,cat,kind,y$0,z,rem$0);
          case 1:
           var e=y$1[2],marks=y$1[1];
           return deriv_1(all_chars,categories,marks,cat,e,rem$0);
          default:return prepend(all_chars,[0,y$1,0],rem$0)}}
      return rem}
    function deriv(tbl_ref,all_chars,categories,st)
     {var
       der=deriv_4(all_chars,categories,st[2],st[3],[0,[0,all_chars,0],0]),
       _hj_=0;
      function _hk_(param,rem)
       {var
         expr=param[2],
         s=param[1],
         match=remove_duplicates(0,expr,eps_expr),
         expr$0=match[1],
         idx=free_index(tbl_ref,expr$0),
         expr$1=set_idx(idx,expr$0);
        function _hn_(param,rem)
         {var s$0=param[2],cat=param[1],s$1=inter(s,s$0);
          return is_empty(s$1)?rem:[0,[0,s$1,mk(idx,cat,expr$1)],rem]}
        return caml_call3(Stdlib_list[22],_hn_,categories,rem)}
      var l=caml_call3(Stdlib_list[22],_hk_,der,_hj_);
      function _hg_(param,_hm_)
       {var st2=_hm_[2],st1=param[2],c=caml_int_compare(st1[5],st2[5]);
        if(0 === c)
         {var c$0=caml_int_compare(st1[2],st2[2]);
          return 0 === c$0?caml_compare(st1[3],st2[3]):c$0}
        return c}
      var _hh_=red_tr(caml_call2(Stdlib_list[49],_hg_,l));
      function _hi_(param,_hl_)
       {var s2=_hl_[1],s1=param[1];return caml_compare(s1,s2)}
      return caml_call2(Stdlib_list[49],_hi_,_hh_)}
    function status(s)
     {var _hb_=s[4];
      if(_hb_){var st=_hb_[1];return st}
      var _hc_=s[3];
      if(_hc_)
       {var _hd_=_hc_[1];
        if(2 === _hd_[0])
         {var
           m=_hd_[1],
           _hf_=m[1],
           _he_=m[2],
           _g__=-1,
           _g$_=
            function(ma,param)
             {var i=param[1];return caml_call2(Stdlib[17],ma,i)},
           ma=caml_call3(Stdlib_list[21],_g$_,_g__,_hf_),
           res=caml_make_vect(ma + 1 | 0,-1),
           _ha_=
            function(param)
             {var v=param[2],i=param[1];
              caml_check_bound(res,i)[1 + i] = v;
              return 0};
          caml_call2(Stdlib_list[15],_ha_,_hf_);
          var st$0=[0,res,_he_]}
        else
         var st$0=1}
      else
       var st$0=0;
      s[4] = [0,st$0];
      return st$0}
    var
     _b1_=[0,dummy$0,create,Table],
     Re_Automata=
      [0,
       pp_sem,
       pp_rep_kind,
       is_eps,
       pp$2,
       create_ids,
       cst,
       empty$1,
       alt,
       seq$0,
       eps,
       rep,
       mark,
       pmark,
       erase,
       before,
       after,
       rename,
       [0],
       [0,pp$3],
       _b1_,
       create_working_area,
       index_count,
       delta,
       deriv,
       status];
    caml_register_global(148,Re_Automata,"Re__Automata");
    function make(param){return caml_call2(Stdlib_bytes[1],257,0)}
    function flatten(cm)
     {var c=caml_create_bytes(256),color_repr=caml_create_bytes(256),v=[0,0];
      caml_bytes_set(c,0,0);
      caml_bytes_set(color_repr,0,0);
      var i=1;
      for(;;)
       {if(0 !== caml_bytes_get(cm,i))v[1]++;
        caml_bytes_set(c,i,caml_call1(Stdlib_char[1],v[1]));
        var _g8_=caml_call1(Stdlib_char[1],i);
        caml_bytes_set(color_repr,v[1],_g8_);
        var _g9_=i + 1 | 0;
        if(255 !== i){var i=_g9_;continue}
        var _g7_=v[1] + 1 | 0;
        return [0,
                c,
                caml_call3(Stdlib_bytes[7],color_repr,0,v[1] + 1 | 0),
                _g7_]}}
    function split(s,cm)
     {return iter
              (s,
               function(i,j)
                {caml_bytes_set(cm,i,1);return caml_bytes_set(cm,j + 1 | 0,1)})}
    var Re_Color_map=[0,make,flatten,split];
    caml_register_global(151,Re_Color_map,"Re__Color_map");
    function offset$0(t,i)
     {if(t[2].length - 1 <= ((2 * i | 0) + 1 | 0))throw Stdlib[8];
      var _g4_=2 * i | 0,m1=caml_check_bound(t[2],_g4_)[1 + _g4_];
      if(-1 === m1)throw Stdlib[8];
      var
       p1=caml_check_bound(t[4],m1)[1 + m1] - 1 | 0,
       _g5_=(2 * i | 0) + 1 | 0,
       _g6_=caml_check_bound(t[2],_g5_)[1 + _g5_],
       p2=caml_check_bound(t[4],_g6_)[1 + _g6_] - 1 | 0;
      return [0,p1,p2]}
    function get(t,i)
     {var match=offset$0(t,i),p2=match[2],p1=match[1];
      return caml_call3(Stdlib_string[4],t[1],p1,p2 - p1 | 0)}
    function start(subs,i){return offset$0(subs,i)[1]}
    function stop(subs,i){return offset$0(subs,i)[2]}
    function test(t,i)
     {if(t[2].length - 1 <= (2 * i | 0))return 0;
      var _g3_=2 * i | 0,idx=caml_check_bound(t[2],_g3_)[1 + _g3_];
      return -1 !== idx?1:0}
    function all_offset(t)
     {var
       res=caml_make_vect(t[5],dummy_offset),
       _gY_=((t[2].length - 1) / 2 | 0) - 1 | 0,
       _gX_=0;
      if(! (_gY_ < 0))
       {var i=_gX_;
        for(;;)
         {var _gZ_=2 * i | 0,m1=caml_check_bound(t[2],_gZ_)[1 + _gZ_];
          if(-1 !== m1)
           {var
             p1=caml_check_bound(t[4],m1)[1 + m1],
             _g0_=(2 * i | 0) + 1 | 0,
             _g1_=caml_check_bound(t[2],_g0_)[1 + _g0_],
             p2=caml_check_bound(t[4],_g1_)[1 + _g1_];
            caml_check_bound(res,i)[1 + i] = [0,p1 - 1 | 0,p2 - 1 | 0]}
          var _g2_=i + 1 | 0;
          if(_gY_ !== i){var i=_g2_;continue}
          break}}
      return res}
    function all(t)
     {var
       res=caml_make_vect(t[5],dummy_string),
       _gR_=((t[2].length - 1) / 2 | 0) - 1 | 0,
       _gQ_=0;
      if(! (_gR_ < 0))
       {var i=_gQ_;
        for(;;)
         {var _gS_=2 * i | 0,m1=caml_check_bound(t[2],_gS_)[1 + _gS_];
          if(-1 !== m1)
           {var
             p1=caml_check_bound(t[4],m1)[1 + m1],
             _gT_=(2 * i | 0) + 1 | 0,
             _gU_=caml_check_bound(t[2],_gT_)[1 + _gT_],
             p2=caml_check_bound(t[4],_gU_)[1 + _gU_],
             _gV_=caml_call3(Stdlib_string[4],t[1],p1 - 1 | 0,p2 - p1 | 0);
            caml_check_bound(res,i)[1 + i] = _gV_}
          var _gW_=i + 1 | 0;
          if(_gR_ !== i){var i=_gW_;continue}
          break}}
      return res}
    function pp$4(fmt,t)
     {var offsets=all_offset(t),strs=all(t);
      function _gK_(i)
       {var _gP_=caml_check_bound(offsets,i)[1 + i];
        return [0,caml_check_bound(strs,i)[1 + i],_gP_]}
      var
       _gL_=caml_call2(Stdlib_array[2],strs.length - 1,_gK_),
       matches=caml_call1(Stdlib_array[11],_gL_);
      function pp_match(fmt,param)
       {var match=param[2],stop=match[2],start=match[1],str=param[1];
        return caml_call5(_bd_,fmt,_b2_,str,start,stop)}
      var _gM_=0;
      return sexp
              (fmt,
               cst_Group,
               function(_gN_,_gO_)
                {return pp_print_list(_gM_,pp_match,_gN_,_gO_)},
               matches)}
    function nb_groups(t){return t[5]}
    var Group=[0,get,offset$0,start,stop,all,all_offset,test,nb_groups,pp$4];
    caml_register_global(153,Group,"Re__Group");
    function iter$0(n,f,v)
     {var n$0=n,v$0=v;
      for(;;)
       {if(0 === n$0)return v$0;
        var v$1=caml_call1(f,v$0),n$1=n$0 - 1 | 0,n$0=n$1,v$0=v$1;
        continue}}
    var unknown=-2,break$0=-3;
    function print_re(ch,re){return pp$2(ch,re[1])}
    function category(re,color)
     {return -1 === color
              ?inexistant
              :color === re[6]?28:from_char(caml_bytes_get(re[4],color))}
    var dummy_next=[0],unknown_state=[0,unknown,0,dummy_next,0,_b1_[1]];
    function mk_state(ncol,desc)
     {var match=status(desc),switch$0=0;
      if(typeof match === "number" && 0 !== match)
       {var break_state=0;switch$0 = 1}
      if(! switch$0)var break_state=1;
      var
       _gG_=0,
       _gH_=break_state?dummy_next:caml_make_vect(ncol,unknown_state),
       _gI_=desc[1],
       _gJ_=break_state?break$0:desc[1];
      return [0,_gJ_,_gI_,_gH_,_gG_,desc]}
    function find_state(re,desc)
     {try
       {var _gE_=caml_call2(_b1_[3][7],re[8],desc);return _gE_}
      catch(_gF_)
       {_gF_ = caml_wrap_exception(_gF_);
        if(_gF_ === Stdlib[8])
         {var st=mk_state(re[5],desc);
          caml_call3(_b1_[3][5],re[8],desc,st);
          return st}
        throw _gF_}}
    function delta$0(info,cat,color,st)
     {var
       desc=delta(info[1][7],cat,color,st[5]),
       len=info[3].length - 1,
       _gC_=desc[1] === len?1:0,
       _gD_=_gC_?0 < len?1:0:_gC_;
      if(_gD_)
       {var pos=info[3];
        info[3] = caml_make_vect(2 * len | 0,0);
        caml_call5(Stdlib_array[10],pos,0,info[3],0,len)}
      return desc}
    function validate(info,s,pos,st)
     {var
       _gB_=caml_string_get(s,pos),
       color=caml_bytes_get(info[2],_gB_),
       cat=category(info[1],color),
       desc=delta$0(info,cat,color,st),
       st$0=find_state(info[1],desc);
      caml_check_bound(st[3],color)[1 + color] = st$0;
      return 0}
    function final$0(info,st,cat)
     {try
       {var _gz_=caml_call2(Stdlib_list[41],cat,st[4]);return _gz_}
      catch(_gA_)
       {_gA_ = caml_wrap_exception(_gA_);
        if(_gA_ === Stdlib[8])
         {var
           st$0=delta$0(info,cat,-1,st),
           _gy_=status(st$0),
           res=[0,st$0[1],_gy_];
          st[4] = [0,[0,cat,res],st[4]];
          return res}
        throw _gA_}}
    function find_initial_state(re,cat)
     {try
       {var _gw_=caml_call2(Stdlib_list[41],cat,re[2]);return _gw_}
      catch(_gx_)
       {_gx_ = caml_wrap_exception(_gx_);
        if(_gx_ === Stdlib[8])
         {var st=find_state(re,caml_call2(_b1_[2],cat,re[1]));
          re[2] = [0,[0,cat,st],re[2]];
          return st}
        throw _gx_}}
    function get_color(re,s,pos)
     {if(0 <= pos)
       {var slen=caml_ml_string_length(s);
        if(slen <= pos)return -1;
        if
         (pos
          ===
          (slen - 1 | 0)
          &&
          -1
          !==
          re[6]
          &&
          10
          ===
          caml_string_get(s,pos))
         return re[6];
        var _gv_=caml_string_get(s,pos);
        return caml_bytes_get(re[3],_gv_)}
      return -1}
    function scan_str(info,s,st$8,groups)
     {var pos$4=info[4],last=info[5];
      if
       (last
        ===
        caml_ml_string_length(s)
        &&
        -1
        !==
        info[1][6]
        &&
        pos$4
        <
        last
        &&
        10
        ===
        caml_string_get(s,last - 1 | 0))
       {var
         info$0=[0,info[1],info[2],info[3],info[4],last - 1 | 0],
         st$9=scan_str(info$0,s,st$8,groups);
        if(st$9[1] === -3)return st$9;
        var pos$5=last - 1 | 0;
        for(;;)
         {var _gs_=info$0[1][6],st$6=caml_check_bound(st$9[3],_gs_)[1 + _gs_];
          if(0 <= st$6[1])
           {if(groups)
             {var _gt_=st$6[1];
              caml_check_bound(info$0[3],_gt_)[1 + _gt_] = pos$5 + 1 | 0}
            return st$6}
          if(st$6[1] === -3)
           {if(groups)
             {var _gu_=st$6[2];
              caml_check_bound(info$0[3],_gu_)[1 + _gu_] = pos$5 + 1 | 0}
            return st$6}
          var
           color=info$0[1][6],
           real_c=caml_bytes_get(info$0[2],10),
           cat=category(info$0[1],color),
           desc=delta$0(info$0,cat,real_c,st$9),
           st$7=find_state(info$0[1],desc);
          caml_check_bound(st$9[3],color)[1 + color] = st$7;
          continue}}
      if(groups)
       {var pos=pos$4,st=st$8;
        a:
        for(;;)
         {if(pos < info[5])
           {var
             _gj_=caml_string_get(s,pos),
             _gk_=caml_bytes_get(info[2],_gj_),
             st$0=caml_check_bound(st[3],_gk_)[1 + _gk_],
             pos$0=pos,
             st$2=st,
             st$1=st$0;
            for(;;)
             {if(0 <= st$1[1])
               {var pos$1=pos$0 + 1 | 0;
                if(pos$1 < info[5])
                 {var
                   _gl_=caml_string_get(s,pos$1),
                   _gm_=caml_bytes_get(info[2],_gl_),
                   st$3=caml_check_bound(st$1[3],_gm_)[1 + _gm_],
                   _gn_=st$1[1];
                  caml_check_bound(info[3],_gn_)[1 + _gn_] = pos$1;
                  var pos$0=pos$1,st$2=st$1,st$1=st$3;
                  continue}
                var _go_=st$1[1];
                caml_check_bound(info[3],_go_)[1 + _go_] = pos$1;
                return st$1}
              if(st$1[1] === -3)
               {var _gp_=st$1[2];
                caml_check_bound(info[3],_gp_)[1 + _gp_] = pos$0 + 1 | 0;
                return st$1}
              validate(info,s,pos$0,st$2);
              var pos=pos$0,st=st$2;
              continue a}}
          return st}}
      var pos$2=pos$4,st$4=st$8;
      for(;;)
       {if(pos$2 < last)
         {var
           _gq_=caml_string_get(s,pos$2),
           _gr_=caml_bytes_get(info[2],_gq_),
           st$5=caml_check_bound(st$4[3],_gr_)[1 + _gr_];
          if(0 <= st$5[1])
           {var pos$3=pos$2 + 1 | 0,pos$2=pos$3,st$4=st$5;continue}
          if(st$5[1] === -3)return st$5;
          validate(info,s,pos$2,st$4);
          continue}
        return st$4}}
    function match_str(groups,partial,re,s,pos,len)
     {var slen=caml_ml_string_length(s),last=-1 === len?slen:pos + len | 0;
      if(groups)
       var
        n=index_count(re[7]) + 1 | 0,
        _gh_=10 < n?caml_make_vect(n,0):_b3_.slice(),
        _gi_=_gh_;
      else
       var _gi_=[0];
      var
       info=[0,re,re[3],_gi_,pos,last],
       initial_cat=0 === pos?33:32 | category(re,get_color(re,s,pos - 1 | 0)),
       initial_state=find_initial_state(re,initial_cat),
       st=scan_str(info,s,initial_state,groups),
       switch$0=0;
      if(st[1] !== -3 && ! partial)
       {var
         final_cat=last === slen?33:32 | category(re,get_color(re,s,last)),
         match=final$0(info,st,final_cat),
         res$0=match[2],
         idx=match[1];
        if(groups)caml_check_bound(info[3],idx)[1 + idx] = last + 1 | 0;
        var res=res$0;
        switch$0 = 1}
      if(! switch$0)var res=status(st[5]);
      if(typeof res === "number")return 0 === res?0:1;
      var pmarks=res[2],marks=res[1];
      return [0,[0,s,marks,pmarks,info[3],re[9]]]}
    function cseq(c$0,c){return seq(c$0,c)}
    function cadd(c,s){return add(c,s)}
    function trans_set(cache,cm,s)
     {var match=one_char(s);
      if(match){var i=match[1];return csingle(caml_bytes_get(cm,i))}
      var v=[0,hash_rec(s),s];
      try
       {var _ge_=caml_call2(CSetMap[27],v,cache[1]);return _ge_}
      catch(_gf_)
       {_gf_ = caml_wrap_exception(_gf_);
        if(_gf_ === Stdlib[8])
         {var
           l=
            fold_right
             (s,
              empty,
              function(param,l)
               {var j=param[2],i=param[1],_gg_=caml_bytes_get(cm,j);
                return union(cseq(caml_bytes_get(cm,i),_gg_),l)});
          cache[1] = caml_call3(CSetMap[4],v,l,cache[1]);
          return l}
        throw _gf_}}
    function view(t){return t}
    var View=[0,view];
    function pp$5(fmt,t)
     {function var$0(s,re){return sexp(fmt,s,pp$5,re)}
      function seq(s,rel)
       {var _gb_=0;
        return sexp
                (fmt,
                 s,
                 function(_gc_,_gd_)
                  {return pp_print_list(_gb_,pp$5,_gc_,_gd_)},
                 rel)}
      if(typeof t === "number")
       switch(t)
        {case 0:return caml_call2(_m_,fmt,cst_Beg_of_line);
         case 1:return caml_call2(_m_,fmt,cst_End_of_line);
         case 2:return caml_call2(_m_,fmt,cst_Beg_of_word);
         case 3:return caml_call2(_m_,fmt,cst_End_of_word);
         case 4:return caml_call2(_m_,fmt,cst_Not_bound);
         case 5:return caml_call2(_m_,fmt,cst_Beg_of_str);
         case 6:return caml_call2(_m_,fmt,cst_End_of_str);
         case 7:return caml_call2(_m_,fmt,cst_Last_end_of_line);
         case 8:return caml_call2(_m_,fmt,cst_Start);
         default:return caml_call2(_m_,fmt,cst_Stop)}
      else
       switch(t[0])
        {case 0:var s=t[1];return sexp(fmt,cst_Set,pp$0,s);
         case 1:var sq=t[1];return seq(cst_Sequence,sq);
         case 2:var alt=t[1];return seq(cst_Alternative,alt);
         case 3:
          var
           stop=t[3],
           start=t[2],
           re=t[1],
           pp=
            function(fmt,param)
             {return caml_call7(_bd_,fmt,_b4_,pp$5,re,start,optint,stop)};
          return sexp(fmt,cst_Repeat,pp,0);
         case 4:
          var re$0=t[2],sem=t[1],_f1_=[0,sem,re$0];
          return sexp
                  (fmt,
                   cst_Sem,
                   function(_f9_,_f__){return pair(pp_sem,pp$5,_f9_,_f__)},
                   _f1_);
         case 5:
          var re$1=t[2],k=t[1],_f2_=[0,k,re$1];
          return sexp
                  (fmt,
                   cst_Sem_greedy,
                   function(_f7_,_f8_){return pair(pp_rep_kind,pp$5,_f7_,_f8_)},
                   _f2_);
         case 6:var c=t[1];return var$0(cst_Group$0,c);
         case 7:var c$0=t[1];return var$0(cst_No_group,c$0);
         case 8:var c$1=t[1];return var$0(cst_Nest,c$1);
         case 9:var c$2=t[1];return var$0(cst_Case,c$2);
         case 10:var c$3=t[1];return var$0(cst_No_case,c$3);
         case 11:var c$4=t[1];return seq(cst_Intersection,c$4);
         case 12:var c$5=t[1];return seq(cst_Complement,c$5);
         case 13:
          var b=t[2],a=t[1],_f3_=[0,a,b];
          return sexp
                  (fmt,
                   cst_Difference,
                   function(_f5_,_f6_){return pair(pp$5,pp$5,_f5_,_f6_)},
                   _f3_);
         default:
          var r=t[2],m=t[1],_f4_=[0,m,r];
          return sexp
                  (fmt,
                   cst_Pmark,
                   function(_f$_,_ga_){return pair(pp$1,pp$5,_f$_,_ga_)},
                   _f4_)}}
    function is_charset(param)
     {var param$0=param;
      for(;;)
       {var switch$0=0;
        if(typeof param$0 === "number")
         switch$0 = 1;
        else
         switch(param$0[0])
          {case 0:return 1;
           case 13:
            var r=param$0[2],r$0=param$0[1],_f0_=is_charset(r$0);
            if(_f0_){var param$0=r;continue}
            return _f0_;
           case 4:
           case 5:var param$1=param$0[2];break;
           case 2:
           case 11:
           case 12:
            var l=param$0[1];return caml_call2(Stdlib_list[28],is_charset,l);
           case 7:
           case 9:
           case 10:var param$1=param$0[1];break;
           default:switch$0 = 1}
        if(switch$0)return 0;
        var param$0=param$1;
        continue}}
    var
     _b5_=cseq(216,222),
     _b6_=union(cseq(192,214),_b5_),
     cupper=union(cseq(65,90),_b6_),
     clower=offset(32,cupper),
     _b7_=union(clower,cupper),
     calpha=caml_call3(Stdlib_list[22],cadd,_b8_,_b7_),
     cdigit=cseq(48,57),
     calnum=union(calpha,cdigit),
     cword=cadd(95,calnum);
    function equal$3(x1,x2)
     {var x1$0=x1,x2$0=x2;
      for(;;)
       {var switch$0=0;
        if(typeof x1$0 === "number")
         switch(x1$0)
          {case 0:
            if(typeof x2$0 === "number" && 0 === x2$0)switch$0 = 1;break;
           case 1:
            if(typeof x2$0 === "number" && 1 === x2$0)switch$0 = 1;break;
           case 2:
            if(typeof x2$0 === "number" && 2 === x2$0)switch$0 = 1;break;
           case 3:
            if(typeof x2$0 === "number" && 3 === x2$0)switch$0 = 1;break;
           case 4:
            if(typeof x2$0 === "number" && 4 === x2$0)switch$0 = 1;break;
           case 5:
            if(typeof x2$0 === "number" && 5 === x2$0)switch$0 = 1;break;
           case 6:
            if(typeof x2$0 === "number" && 6 === x2$0)switch$0 = 1;break;
           case 7:
            if(typeof x2$0 === "number" && 7 === x2$0)switch$0 = 1;break;
           case 8:
            if(typeof x2$0 === "number" && 8 === x2$0)switch$0 = 1;break;
           default:if(typeof x2$0 === "number" && 9 <= x2$0)switch$0 = 1}
        else
         switch(x1$0[0])
          {case 0:
            if(typeof x2$0 !== "number" && 0 === x2$0[0])
             {var s2=x2$0[1],s1=x1$0[1];return caml_equal(s1,s2)}
            break;
           case 1:
            if(typeof x2$0 !== "number" && 1 === x2$0[0])
             {var l2=x2$0[1],l1=x1$0[1];return eq_list(l1,l2)}
            break;
           case 2:
            if(typeof x2$0 !== "number" && 2 === x2$0[0])
             {var l2$0=x2$0[1],l1$0=x1$0[1];return eq_list(l1$0,l2$0)}
            break;
           case 3:
            if(typeof x2$0 !== "number" && 3 === x2$0[0])
             {var
               j2=x2$0[3],
               i2=x2$0[2],
               x2$1=x2$0[1],
               j1=x1$0[3],
               i1=x1$0[2],
               x1$1=x1$0[1],
               _fT_=i1 === i2?1:0;
              if(_fT_)
               {var _fU_=caml_equal(j1,j2);
                if(_fU_){var x1$0=x1$1,x2$0=x2$1;continue}
                var _fV_=_fU_}
              else
               var _fV_=_fT_;
              return _fV_}
            break;
           case 4:
            if(typeof x2$0 !== "number" && 4 === x2$0[0])
             {var
               x2$2=x2$0[2],
               sem2=x2$0[1],
               x1$2=x1$0[2],
               sem1=x1$0[1],
               _fW_=sem1 === sem2?1:0;
              if(_fW_){var x1$0=x1$2,x2$0=x2$2;continue}
              return _fW_}
            break;
           case 5:
            if(typeof x2$0 !== "number" && 5 === x2$0[0])
             {var
               x2$3=x2$0[2],
               k2=x2$0[1],
               x1$3=x1$0[2],
               k1=x1$0[1],
               _fX_=k1 === k2?1:0;
              if(_fX_){var x1$0=x1$3,x2$0=x2$3;continue}
              return _fX_}
            break;
           case 6:if(typeof x2$0 !== "number" && 6 === x2$0[0])return 0;break;
           case 7:
            if(typeof x2$0 !== "number" && 7 === x2$0[0])
             {var x2$4=x2$0[1],x1$4=x1$0[1],x1$0=x1$4,x2$0=x2$4;continue}
            break;
           case 8:
            if(typeof x2$0 !== "number" && 8 === x2$0[0])
             {var x2$5=x2$0[1],x1$5=x1$0[1],x1$0=x1$5,x2$0=x2$5;continue}
            break;
           case 9:
            if(typeof x2$0 !== "number" && 9 === x2$0[0])
             {var x2$6=x2$0[1],x1$6=x1$0[1],x1$0=x1$6,x2$0=x2$6;continue}
            break;
           case 10:
            if(typeof x2$0 !== "number" && 10 === x2$0[0])
             {var x2$7=x2$0[1],x1$7=x1$0[1],x1$0=x1$7,x2$0=x2$7;continue}
            break;
           case 11:
            if(typeof x2$0 !== "number" && 11 === x2$0[0])
             {var l2$1=x2$0[1],l1$1=x1$0[1];return eq_list(l1$1,l2$1)}
            break;
           case 12:
            if(typeof x2$0 !== "number" && 12 === x2$0[0])
             {var l2$2=x2$0[1],l1$2=x1$0[1];return eq_list(l1$2,l2$2)}
            break;
           case 13:
            if(typeof x2$0 !== "number" && 13 === x2$0[0])
             {var
               x2$8=x2$0[2],
               x2$9=x2$0[1],
               x1$8=x1$0[2],
               x1$9=x1$0[1],
               _fY_=equal$3(x1$9,x2$9);
              if(_fY_){var x1$0=x1$8,x2$0=x2$8;continue}
              return _fY_}
            break;
           default:
            if(typeof x2$0 !== "number" && 14 === x2$0[0])
             {var
               r2=x2$0[2],
               m2=x2$0[1],
               r1=x1$0[2],
               m1=x1$0[1],
               _fZ_=m1 === m2?1:0;
              if(_fZ_){var x1$0=r1,x2$0=r2;continue}
              return _fZ_}}
        return switch$0?1:0}}
    function eq_list(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             r2=l2$0[2],
             x2=l2$0[1],
             r1=l1$0[2],
             x1=l1$0[1],
             _fS_=equal$3(x1,x2);
            if(_fS_){var l1$0=r1,l2$0=r2;continue}
            return _fS_}}
        else
         if(! l2$0)return 1;
        return 0}}
    function sequence(l){if(l && ! l[2]){var x=l[1];return x}return [1,l]}
    function merge_sequences(param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var _fN_=param$0[1];
          if(typeof _fN_ !== "number")
           switch(_fN_[0])
            {case 1:
              var _fO_=_fN_[1];
              if(_fO_)
               {var
                 r$0=param$0[2],
                 y=_fO_[2],
                 x=_fO_[1],
                 r$1=merge_sequences(r$0);
                if(r$1)
                 {var _fP_=r$1[1],switch$0=0;
                  if(typeof _fP_ === "number" || ! (1 === _fP_[0]))
                   switch$0 = 1;
                  else
                   {var _fQ_=_fP_[1];
                    if(_fQ_)
                     {var r$2=r$1[2],y$0=_fQ_[2],x$0=_fQ_[1];
                      if(equal$3(x,x$0))
                       {var _fR_=[0,sequence(y$0),0];
                        return [0,[1,[0,x,[0,[2,[0,sequence(y),_fR_]],0]]],r$2]}}}}
                return [0,[1,[0,x,y]],r$1]}
              break;
             case 2:
              var
               r$3=param$0[2],
               l=_fN_[1],
               param$1=caml_call2(Stdlib[37],l,r$3),
               param$0=param$1;
              continue
             }
          var r=param$0[2];
          return [0,_fN_,merge_sequences(r)]}
        return 0}}
    function enforce_kind(ids,kind,k,cr)
     {return 332064784 === kind?332064784 === k?cr:seq$0(ids,k,cr,eps(ids)):cr}
    function trans_seq(ids,kind,ign_group,ign_case,greedy,pos,cache,c,param)
     {if(param)
       {var _fL_=param[2],_fM_=param[1];
        if(_fL_)
         {var
           match=
            translate(ids,kind,ign_group,ign_case,greedy,pos,cache,c,_fM_),
           kind$0=match[2],
           cr=match[1],
           cr$0=trans_seq(ids,kind,ign_group,ign_case,greedy,pos,cache,c,_fL_);
          return is_eps(cr$0)?cr:is_eps(cr)?cr$0:seq$0(ids,kind$0,cr,cr$0)}
        var
         match$0=
          translate(ids,kind,ign_group,ign_case,greedy,pos,cache,c,_fM_),
         kind$1=match$0[2],
         cr$1=match$0[1];
        return enforce_kind(ids,kind,kind$1,cr$1)}
      return eps(ids)}
    function translate(ids,kind,ign_group,ign_case,greedy,pos,cache,c,param)
     {var ign_group$0=ign_group,greedy$0=greedy,param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0)
         {case 0:return [0,after(ids,9),kind];
          case 1:return [0,before(ids,9),kind];
          case 2:
           var _fC_=before(ids,3);
           return [0,seq$0(ids,332064784,after(ids,5),_fC_),kind];
          case 3:
           var _fD_=before(ids,5);
           return [0,seq$0(ids,332064784,after(ids,3),_fD_),kind];
          case 4:
           var
            _fE_=before(ids,letter),
            _fF_=[0,seq$0(ids,332064784,after(ids,letter),_fE_),0],
            _fG_=before(ids,letter);
           return [0,
                   alt
                    (ids,[0,seq$0(ids,332064784,after(ids,letter),_fG_),_fF_]),
                   kind];
          case 5:return [0,after(ids,inexistant),kind];
          case 6:return [0,before(ids,inexistant),kind];
          case 7:return [0,before(ids,17),kind];
          case 8:return [0,after(ids,search_boundary),kind];
          default:return [0,before(ids,search_boundary),kind]}
       else
        switch(param$0[0])
         {case 0:
           var s=param$0[1];return [0,cst(ids,trans_set(cache,c,s)),kind];
          case 1:
           var l=param$0[1];
           return [0,
                   trans_seq
                    (ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,l),
                   kind];
          case 2:
           var l$0=param$0[1],merged_sequences=merge_sequences(l$0);
           if(merged_sequences && ! merged_sequences[2])
            {var
              r=merged_sequences[1],
              match=
               translate(ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r),
              kind$0=match[2],
              cr=match[1];
             return [0,enforce_kind(ids,kind,kind$0,cr),kind]}
           var
            _fH_=
             function(r)
              {var
                match=
                 translate
                  (ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r),
                kind$0=match[2],
                cr=match[1];
               return enforce_kind(ids,kind,kind$0,cr)};
           return [0,
                   alt(ids,caml_call2(Stdlib_list[17],_fH_,merged_sequences)),
                   kind];
          case 3:
           var
            j=param$0[3],
            i=param$0[2],
            r$0=param$0[1],
            match$0=
             translate(ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$0),
            kind$1=match$0[2],
            cr$0=match$0[1];
           if(j)
            var
             j$0=j[1],
             f=
              620821490 <= greedy$0
               ?function(rem)
                 {var _fJ_=[0,seq$0(ids,kind$1,rename(ids,cr$0),rem),0];
                  return alt(ids,[0,eps(ids),_fJ_])}
               :function(rem)
                 {var _fK_=[0,eps(ids),0];
                  return alt
                          (ids,[0,seq$0(ids,kind$1,rename(ids,cr$0),rem),_fK_])},
             rem=iter$0(j$0 - i | 0,f,eps(ids));
           else
            var rem=rep(ids,greedy$0,kind$1,cr$0);
           return [0,
                   iter$0
                    (i,
                     function(rem){return seq$0(ids,kind$1,rename(ids,cr$0),rem)},
                     rem),
                   kind];
          case 4:
           var
            r$1=param$0[2],
            kind$2=param$0[1],
            match$1=
             translate
              (ids,kind$2,ign_group$0,ign_case,greedy$0,pos,cache,c,r$1),
            kind$3=match$1[2],
            cr$1=match$1[1];
           return [0,enforce_kind(ids,kind$2,kind$3,cr$1),kind$2];
          case 5:
           var
            param$1=param$0[2],
            greedy$1=param$0[1],
            greedy$0=greedy$1,
            param$0=param$1;
           continue;
          case 6:
           var r$2=param$0[1];
           if(ign_group$0){var param$0=r$2;continue}
           var p=pos[1];
           pos[1] = pos[1] + 2 | 0;
           var
            match$2=
             translate(ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$2),
            kind$4=match$2[2],
            cr$2=match$2[1],
            _fI_=seq$0(ids,332064784,cr$2,mark(ids,p + 1 | 0));
           return [0,seq$0(ids,332064784,mark(ids,p),_fI_),kind$4];
          case 7:
           var param$2=param$0[1],ign_group$0=1,param$0=param$2;continue;
          case 8:
           var
            r$3=param$0[1],
            b=pos[1],
            match$3=
             translate(ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$3),
            kind$5=match$3[2],
            cr$3=match$3[1],
            e=pos[1] - 1 | 0;
           return e < b
                   ?[0,cr$3,kind$5]
                   :[0,seq$0(ids,332064784,erase(ids,b,e),cr$3),kind$5];
          case 14:
           var
            r$4=param$0[2],
            i$0=param$0[1],
            match$4=
             translate(ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$4),
            kind$6=match$4[2],
            cr$4=match$4[1];
           return [0,seq$0(ids,332064784,pmark(ids,i$0),cr$4),kind$6];
          default:throw [0,Assert_failure,_b__]}}
    function as_set(param)
     {if(typeof param !== "number" && 0 === param[0]){var s=param[1];return s}
      throw [0,Assert_failure,_b$_]}
    function handle_case(ign_case,r)
     {var ign_case$0=ign_case,r$0=r;
      for(;;)
       if(typeof r$0 === "number")
        return r$0;
       else
        switch(r$0[0])
         {case 0:
           var s=r$0[1];
           if(ign_case$0)
            var
             _fq_=offset(-32,inter(s,clower)),
             _fr_=union(s,union(offset(32,inter(s,cupper)),_fq_));
           else
            var _fr_=s;
           return [0,_fr_];
          case 1:
           var
            l=r$0[1],
            _fs_=function(_fB_){return handle_case(ign_case$0,_fB_)};
           return [1,caml_call2(Stdlib_list[17],_fs_,l)];
          case 2:
           var
            l$0=r$0[1],
            _ft_=function(_fA_){return handle_case(ign_case$0,_fA_)},
            l$1=caml_call2(Stdlib_list[17],_ft_,l$0);
           if(is_charset([2,l$1]))
            {var _fu_=function(s,r){return union(s,as_set(r))};
             return [0,caml_call3(Stdlib_list[21],_fu_,empty,l$1)]}
           return [2,l$1];
          case 3:
           var j=r$0[3],i=r$0[2],r$1=r$0[1];
           return [3,handle_case(ign_case$0,r$1),i,j];
          case 4:
           var r$2=r$0[2],k=r$0[1],r$3=handle_case(ign_case$0,r$2);
           return is_charset(r$3)?r$3:[4,k,r$3];
          case 5:
           var r$4=r$0[2],k$0=r$0[1],r$5=handle_case(ign_case$0,r$4);
           return is_charset(r$5)?r$5:[5,k$0,r$5];
          case 6:var r$6=r$0[1];return [6,handle_case(ign_case$0,r$6)];
          case 7:
           var r$7=r$0[1],r$8=handle_case(ign_case$0,r$7);
           return is_charset(r$8)?r$8:[7,r$8];
          case 8:
           var r$9=r$0[1],r$10=handle_case(ign_case$0,r$9);
           return is_charset(r$10)?r$10:[8,r$10];
          case 9:var r$11=r$0[1],ign_case$0=0,r$0=r$11;continue;
          case 10:var r$12=r$0[1],ign_case$0=1,r$0=r$12;continue;
          case 11:
           var
            l$2=r$0[1],
            _fv_=function(r){return handle_case(ign_case$0,r)},
            l$3=caml_call2(Stdlib_list[17],_fv_,l$2),
            _fw_=function(s,r){return inter(s,as_set(r))};
           return [0,caml_call3(Stdlib_list[21],_fw_,cany,l$3)];
          case 12:
           var
            l$4=r$0[1],
            _fx_=function(r){return handle_case(ign_case$0,r)},
            l$5=caml_call2(Stdlib_list[17],_fx_,l$4),
            _fy_=function(s,r){return union(s,as_set(r))};
           return [0,diff(cany,caml_call3(Stdlib_list[21],_fy_,empty,l$5))];
          case 13:
           var
            r$13=r$0[2],
            r$14=r$0[1],
            _fz_=diff(cany,as_set(handle_case(ign_case$0,r$13)));
           return [0,inter(as_set(handle_case(ign_case$0,r$14)),_fz_)];
          default:
           var r$15=r$0[2],i$0=r$0[1];
           return [14,i$0,handle_case(ign_case$0,r$15)]}}
    function anchored(param)
     {var param$0=param;
      for(;;)
       {var switch$0=0;
        if(typeof param$0 === "number")
         switch(param$0){case 5:case 8:return 1}
        else
         switch(param$0[0])
          {case 1:
            var l=param$0[1];return caml_call2(Stdlib_list[29],anchored,l);
           case 2:
            var l$0=param$0[1];
            return caml_call2(Stdlib_list[28],anchored,l$0);
           case 3:
            var i=param$0[2],r=param$0[1],_fp_=0 < i?1:0;
            if(_fp_){var param$0=r;continue}
            return _fp_;
           case 4:
           case 5:
           case 14:var param$1=param$0[2];switch$0 = 1;break;
           case 0:
           case 11:
           case 12:
           case 13:break;
           default:var param$1=param$0[1];switch$0 = 1}
        if(switch$0){var param$0=param$1;continue}
        return 0}}
    function str(s)
     {var l=[0,0],_fm_=caml_ml_string_length(s) - 1 | 0;
      if(! (_fm_ < 0))
       {var i=_fm_;
        for(;;)
         {var _fn_=l[1];
          l[1] = [0,[0,csingle(caml_string_get(s,i))],_fn_];
          var _fo_=i - 1 | 0;
          if(0 !== i){var i=_fo_;continue}
          break}}
      return [1,l[1]]}
    function char$0(c){return [0,csingle(c)]}
    function alt$0(l){if(l && ! l[2]){var r=l[1];return r}return [2,l]}
    function seq$1(l){if(l && ! l[2]){var r=l[1];return r}return [1,l]}
    var empty$2=alt$0(0),epsilon=seq$1(0);
    function repn(r,i,j)
     {if(i < 0)caml_call1(Stdlib[1],cst_Re_repn);
      var switch$0=0;
      if(j)
       {var j$0=j[1];
        if(j$0 < i){caml_call1(Stdlib[1],cst_Re_repn$0);switch$0 = 1}}
      return [3,r,i,j]}
    function rep$0(r){return repn(r,0,0)}
    function rep1(r){return repn(r,1,0)}
    function opt(r){return repn(r,0,_ca_)}
    var bol=0,eol=1,bow=2,eow=3;
    function word(r){return seq$1([0,bow,[0,r,[0,eow,0]]])}
    var not_boundary=4,bos=5,eos=6;
    function whole_string(r){return seq$1([0,bos,[0,r,[0,eos,0]]])}
    var leol=7,start$0=8,stop$0=9;
    function longest(r){return [4,-730718166,r]}
    function shortest(r){return [4,-1034406550,r]}
    function first$0(r){return [4,332064784,r]}
    function greedy(r){return [5,-904640576,r]}
    function non_greedy(r){return [5,620821490,r]}
    function group(r){return [6,r]}
    function no_group(r){return [7,r]}
    function nest(r){return [8,r]}
    function mark$0(r){var i=gen(0);return [0,i,[14,i,r]]}
    function set(str)
     {var s=[0,empty],_fj_=caml_ml_string_length(str) - 1 | 0,_fi_=0;
      if(! (_fj_ < 0))
       {var i=_fi_;
        for(;;)
         {var _fk_=s[1];
          s[1] = union(csingle(caml_string_get(str,i)),_fk_);
          var _fl_=i + 1 | 0;
          if(_fj_ !== i){var i=_fl_;continue}
          break}}
      return [0,s[1]]}
    function rg(c$0,c){return [0,cseq(c$0,c)]}
    function inter$0(l)
     {var r=[11,l];return is_charset(r)?r:caml_call1(Stdlib[1],cst_Re_inter)}
    function compl(l)
     {var r=[12,l];return is_charset(r)?r:caml_call1(Stdlib[1],cst_Re_compl)}
    function diff$0(r$0,r)
     {var r$1=[13,r$0,r];
      return is_charset(r$1)?r$1:caml_call1(Stdlib[1],cst_Re_diff)}
    var
     any=[0,cany],
     notnl=[0,diff(cany,csingle(10))],
     _cb_=[0,rg(248,255),0],
     _cc_=[0,rg(223,246),_cb_],
     _cd_=[0,char$0(181),_cc_],
     lower=alt$0([0,rg(97,122),_cd_]),
     _ce_=[0,rg(216,222),0],
     _cf_=[0,rg(192,214),_ce_],
     upper=alt$0([0,rg(65,90),_cf_]),
     _cg_=[0,char$0(186),0],
     alpha=alt$0([0,lower,[0,upper,[0,char$0(170),_cg_]]]),
     digit=rg(48,57),
     alnum=alt$0([0,alpha,[0,digit,0]]),
     wordc=alt$0([0,alnum,[0,char$0(95),0]]),
     ascii=rg(0,127),
     blank=set(cst$0),
     _ch_=[0,rg(127,159),0],
     cntrl=alt$0([0,rg(0,31),_ch_]),
     _ci_=[0,rg(160,255),0],
     graph=alt$0([0,rg(33,126),_ci_]),
     _cj_=[0,rg(160,255),0],
     print=alt$0([0,rg(32,126),_cj_]),
     _ck_=[0,char$0(247),0],
     _cl_=[0,char$0(215),_ck_],
     _cm_=[0,rg(187,191),_cl_],
     _cn_=[0,rg(182,185),_cm_],
     _co_=[0,rg(171,180),_cn_],
     _cp_=[0,rg(160,169),_co_],
     _cq_=[0,rg(123,126),_cp_],
     _cr_=[0,rg(91,96),_cq_],
     _cs_=[0,rg(58,64),_cr_],
     punct=alt$0([0,rg(33,47),_cs_]),
     _ct_=[0,rg(9,13),0],
     space=alt$0([0,char$0(32),_ct_]),
     _cu_=[0,rg(65,70),0],
     xdigit=alt$0([0,digit,[0,rg(97,102),_cu_]]);
    function case$0(r){return [9,r]}
    function no_case(r){return [10,r]}
    function compile(r$0)
     {var
       _fh_=
        anchored(r$0)?[6,r$0]:seq$1([0,shortest(rep$0(any)),[0,[6,r$0],0]]),
       regexp=handle_case(0,_fh_),
       c=make(0),
       lnl=[0,0];
      function colorize(regexp)
       {var regexp$0=regexp;
        for(;;)
         {if(typeof regexp$0 === "number")
           switch(regexp$0)
            {case 7:lnl[1] = 1;return 0;
             case 0:
             case 1:return split(csingle(10),c);
             case 2:
             case 3:
             case 4:return split(cword,c);
             default:return 0}
          else
           switch(regexp$0[0])
            {case 0:var s=regexp$0[1];return split(s,c);
             case 1:
              var l=regexp$0[1];return caml_call2(Stdlib_list[15],colorize,l);
             case 2:
              var l$0=regexp$0[1];
              return caml_call2(Stdlib_list[15],colorize,l$0);
             case 3:var regexp$1=regexp$0[1],regexp$0=regexp$1;continue;
             case 4:
             case 5:
             case 14:var regexp$2=regexp$0[2];break;
             case 6:
             case 7:
             case 8:var regexp$2=regexp$0[1];break;
             default:throw [0,Assert_failure,_b9_]}
          var regexp$0=regexp$2;
          continue}}
      colorize(regexp);
      var
       _fg_=lnl[1],
       match=flatten(c),
       ncolor=match[3],
       color_repr=match[2],
       colors=match[1],
       lnl$0=_fg_?ncolor:-1,
       ncolor$0=_fg_?ncolor + 1 | 0:ncolor,
       ids=create_ids(0),
       pos=[0,0],
       match$0=
        translate
         (ids,332064784,0,0,-904640576,pos,[0,CSetMap[1]],colors,regexp),
       kind=match$0[2],
       r=match$0[1],
       initial=enforce_kind(ids,332064784,kind,r),
       group_count=pos[1] / 2 | 0,
       _ff_=caml_call1(_b1_[3][1],97);
      return [0,
              initial,
              0,
              colors,
              color_repr,
              ncolor$0,
              lnl$0,
              create_working_area(0),
              _ff_,
              group_count]}
    function exec_internal(name,opt,_fb_,partial,groups,re,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(_fb_)var sth$0=_fb_[1],len=sth$0;else var len=-1;
      var _fc_=pos < 0?1:0;
      if(_fc_)
       var _fd_=_fc_;
      else
       var
        _fe_=len < -1?1:0,
        _fd_=_fe_ || (caml_ml_string_length(s) < (pos + len | 0)?1:0);
      if(_fd_)caml_call1(Stdlib[1],name);
      return match_str(groups,partial,re,s,pos,len)}
    function exec(pos,len,re,s)
     {var match=exec_internal(cst_Re_exec,pos,len,0,1,re,s);
      if(typeof match === "number")throw Stdlib[8];
      var substr=match[1];
      return substr}
    function exec_opt(pos,len,re,s)
     {var match=exec_internal(cst_Re_exec_opt,pos,len,0,1,re,s);
      if(typeof match === "number")return 0;
      var substr=match[1];
      return [0,substr]}
    function execp(pos,len,re,s)
     {var match=exec_internal(cst_Re_execp,pos,len,0,0,re,s);
      return typeof match === "number"?0:1}
    function exec_partial(pos,len,re,s)
     {var match=exec_internal(cst_Re_exec_partial,pos,len,1,0,re,s);
      return typeof match === "number"
              ?0 === match?-1062743954:939392865
              :782112175}
    function marked(g,p){return caml_call2(Set[3],p,g[3])}
    function mark_set(g){return g[3]}
    function all_seq(opt,len,re,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(pos < 0)caml_call1(Stdlib[1],cst_Re_all);
      if(len)
       {var
         l=len[1],
         _e9_=l < 0?1:0,
         _e__=_e9_ || (caml_ml_string_length(s) < (pos + l | 0)?1:0);
        if(_e__)caml_call1(Stdlib[1],cst_Re_all$0);
        var limit=pos + l | 0}
      else
       var limit=caml_ml_string_length(s);
      function aux(pos,param)
       {if(limit <= pos)return 0;
        var match=match_str(1,0,re,s,pos,limit - pos | 0);
        if(typeof match === "number")return 0;
        var
         substr=match[1],
         match$0=caml_call2(Group[2],substr,0),
         p2=match$0[2],
         p1=match$0[1],
         pos$0=p1 === p2?p2 + 1 | 0:p2;
        return [0,substr,function(_fa_){return aux(pos$0,_fa_)}]}
      return function(_e$_){return aux(pos,_e$_)}}
    function matches_seq(pos,len,re,s)
     {var _e7_=all_seq(pos,len,re,s);
      function _e8_(sub){return caml_call2(Group[1],sub,0)}
      return caml_call2(Stdlib_seq[3],_e8_,_e7_)}
    function split_full_seq(opt,len,re,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(pos < 0)caml_call1(Stdlib[1],cst_Re_split);
      if(len)
       {var
         l=len[1],
         _eW_=l < 0?1:0,
         _eX_=_eW_ || (caml_ml_string_length(s) < (pos + l | 0)?1:0);
        if(_eX_)caml_call1(Stdlib[1],cst_Re_split$0);
        var limit=pos + l | 0}
      else
       var limit=caml_ml_string_length(s);
      function aux(state,i,pos$0,param)
       {if(typeof state === "number")
         {if(limit <= pos$0)
           {if(i < limit)
             {var
               sub=caml_call3(Stdlib_string[4],s,i,limit - i | 0),
               _e0_=i + 1 | 0;
              return [0,
                      [0,936573133,sub],
                      function(_e6_){return aux(state,_e0_,pos$0,_e6_)}]}
            return 0}
          var match=match_str(1,0,re,s,pos$0,limit - pos$0 | 0);
          if(typeof match === "number")
           {if(0 === match)
             {if(i < limit)
               {var text=caml_call3(Stdlib_string[4],s,i,limit - i | 0);
                return [0,
                        [0,936573133,text],
                        function(_e5_){return aux(state,limit,pos$0,_e5_)}]}
              return 0}
            return 0}
          var
           substr=match[1],
           match$0=caml_call2(Group[2],substr,0),
           p2=match$0[2],
           p1=match$0[1],
           pos$1=p1 === p2?p2 + 1 | 0:p2;
          if(pos < p1)
           {var
             text$0=caml_call3(Stdlib_string[4],s,i,p1 - i | 0),
             state$0=[0,73271853,[0,-363573681,substr]];
            return [0,
                    [0,936573133,text$0],
                    function(_e4_){return aux(state$0,p2,pos$1,_e4_)}]}
          return [0,
                  [0,-363573681,substr],
                  function(_e3_){return aux(state,p2,pos$1,_e3_)}]}
        var x=state[2],_e1_=814535476;
        return [0,x,function(_e2_){return aux(_e1_,i,pos$0,_e2_)}]}
      var _eY_=814535476;
      return function(_eZ_){return aux(_eY_,pos,pos,_eZ_)}}
    function split_seq(pos,len,re,s)
     {var seq=split_full_seq(pos,len,re,s);
      function filter(seq,param)
       {var seq$0=seq;
        for(;;)
         {var match=caml_call1(seq$0,0);
          if(match)
           {var _eU_=match[1];
            if(936573133 <= _eU_[1])
             {var tl=match[2],s=_eU_[2];
              return [0,s,function(_eV_){return filter(tl,_eV_)}]}
            var seq$1=match[2],seq$0=seq$1;
            continue}
          return 0}}
      return function(_eT_){return filter(seq,_eT_)}}
    function list_of_seq(s)
     {var _eQ_=0;
      function _eR_(l,x){return [0,x,l]}
      var _eS_=caml_call3(Stdlib_seq[7],_eR_,_eQ_,s);
      return caml_call1(Stdlib_list[9],_eS_)}
    function all$0(pos,len,re,s){return list_of_seq(all_seq(pos,len,re,s))}
    function matches(pos,len,re,s)
     {return list_of_seq(matches_seq(pos,len,re,s))}
    function split_full(pos,len,re,s)
     {return list_of_seq(split_full_seq(pos,len,re,s))}
    function split$0(pos,len,re,s)
     {return list_of_seq(split_seq(pos,len,re,s))}
    function gen_of_seq(s)
     {var r=[0,s];
      return function(param)
       {var match=caml_call1(r[1],0);
        if(match){var tl=match[2],x=match[1];r[1] = tl;return [0,x]}
        return 0}}
    function split_gen(pos,len,re,s)
     {return gen_of_seq(split_seq(pos,len,re,s))}
    function split_full_gen(pos,len,re,s)
     {return gen_of_seq(split_full_seq(pos,len,re,s))}
    function all_gen(pos,len,re,s){return gen_of_seq(all_seq(pos,len,re,s))}
    function matches_gen(pos,len,re,s)
     {return gen_of_seq(matches_seq(pos,len,re,s))}
    function replace(opt,len,_eM_,re,f,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(_eM_)var sth$0=_eM_[1],all=sth$0;else var all=1;
      if(pos < 0)caml_call1(Stdlib[1],cst_Re_replace);
      if(len)
       {var
         l=len[1],
         _eN_=l < 0?1:0,
         _eO_=_eN_ || (caml_ml_string_length(s) < (pos + l | 0)?1:0);
        if(_eO_)caml_call1(Stdlib[1],cst_Re_replace$0);
        var limit=pos + l | 0}
      else
       var limit=caml_ml_string_length(s);
      var buf=caml_call1(Stdlib_buffer[1],caml_ml_string_length(s)),pos$0=pos;
      for(;;)
       {if(pos$0 < limit)
         {var match=match_str(1,0,re,s,pos$0,limit - pos$0 | 0);
          if(typeof match === "number")
           {if(0 === match)
             caml_call4(Stdlib_buffer[16],buf,s,pos$0,limit - pos$0 | 0)}
          else
           {var
             substr=match[1],
             match$0=caml_call2(Group[2],substr,0),
             p2=match$0[2],
             p1=match$0[1];
            caml_call4(Stdlib_buffer[16],buf,s,pos$0,p1 - pos$0 | 0);
            var replacing=caml_call1(f,substr);
            caml_call2(Stdlib_buffer[14],buf,replacing);
            if(all)
             {if(p1 === p2)
               {if(p2 < limit)
                 {var _eP_=caml_string_get(s,p2);
                  caml_call2(Stdlib_buffer[10],buf,_eP_)}
                var pos$1=p2 + 1 | 0}
              else
               var pos$1=p2;
              var pos$0=pos$1;
              continue}
            caml_call4(Stdlib_buffer[16],buf,s,p2,limit - p2 | 0)}}
        return caml_call1(Stdlib_buffer[2],buf)}}
    function replace_string(pos,len,all,re,by,s)
     {return replace(pos,len,all,re,function(param){return by},s)}
    function witness(t)
     {function witness(param)
       {var param$0=param;
        for(;;)
         {if(typeof param$0 === "number")
           return cst$1;
          else
           switch(param$0[0])
            {case 0:
              var
               c=param$0[1],
               _eG_=pick(c),
               _eH_=caml_call1(Stdlib_char[1],_eG_);
              return caml_call2(Stdlib_string[1],1,_eH_);
             case 1:
              var xs=param$0[1],_eI_=caml_call2(Stdlib_list[17],witness,xs);
              return caml_call2(Stdlib_string[7],cst$2,_eI_);
             case 2:
              var _eJ_=param$0[1];
              if(_eJ_){var param$1=_eJ_[1],param$0=param$1;continue}
              throw [0,Assert_failure,_cv_];
             case 3:
              var
               from=param$0[2],
               r=param$0[1],
               w=witness(r),
               b=
                caml_call1
                 (Stdlib_buffer[1],
                  runtime.caml_mul(caml_ml_string_length(w),from)),
               _eK_=1;
              if(! (from < 1))
               {var i=_eK_;
                for(;;)
                 {caml_call2(Stdlib_buffer[14],b,w);
                  var _eL_=i + 1 | 0;
                  if(from !== i){var i=_eL_;continue}
                  break}}
              return caml_call1(Stdlib_buffer[2],b);
             case 10:var param$3=param$0[1],param$0=param$3;continue;
             case 4:
             case 5:
             case 14:var param$2=param$0[2];break;
             case 11:
             case 12:
             case 13:throw [0,Assert_failure,_cw_];
             default:var param$2=param$0[1]}
          var param$0=param$2;
          continue}}
      return witness(handle_case(0,t))}
    var
     get$0=Group[1],
     get_ofs=Group[2],
     get_all=Group[5],
     get_all_ofs=Group[6],
     test$0=Group[7],
     Seq=[0,all_seq,matches_seq,split_seq,split_full_seq],
     Mark=[0,marked,Set,mark_set,equal$0,compare$1],
     include$0=
      [0,
       Group,
       compile,
       exec,
       exec_opt,
       execp,
       exec_partial,
       Mark,
       Seq,
       all$0,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split$0,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       replace,
       replace_string,
       str,
       char$0,
       alt$0,
       seq$1,
       empty$2,
       epsilon,
       rep$0,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start$0,
       stop$0,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first$0,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark$0,
       set,
       rg,
       inter$0,
       diff$0,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp$5,
       print_re,
       print_re,
       View,
       witness,
       get$0,
       get_ofs,
       get_all,
       get_all_ofs,
       test$0,
       marked,
       mark_set];
    caml_register_global(155,include$0,"Re__Core");
    var
     Parse_error=[248,cst_Re_Emacs_Parse_error,caml_fresh_oo_id(0)],
     Not_supported=[248,cst_Re_Emacs_Not_supported,caml_fresh_oo_id(0)];
    function re(opt$0,s)
     {if(opt$0)var sth=opt$0[1],case$0=sth;else var case$0=1;
      var i=[0,0],l=caml_ml_string_length(s);
      function eos$0(param){return i[1] === l?1:0}
      function test2(c$0,c)
       {var _eD_=(i[1] + 1 | 0) < l?1:0;
        if(_eD_)
         var
          _eE_=caml_string_get(s,i[1]) === c$0?1:0,
          _eF_=_eE_?caml_string_get(s,i[1] + 1 | 0) === c?1:0:_eE_;
        else
         var _eF_=_eD_;
        return _eF_}
      function accept(c)
       {var
         _eB_=1 - eos$0(0),
         _eC_=_eB_?caml_string_get(s,i[1]) === c?1:0:_eB_;
        if(_eC_)i[1]++;
        return _eC_}
      function accept2(c$0,c)
       {var r=test2(c$0,c);if(r)i[1] = i[1] + 2 | 0;return r}
      function get(param){var r=caml_string_get(s,i[1]);i[1]++;return r}
      function char$1(param){if(eos$0(0))throw Parse_error;return get(0)}
      function bracket(s)
       {var s$0=s;
        for(;;)
         {if(0 !== s$0 && accept(93))return s$0;
          var c=char$1(0);
          if(accept(45))
           {if(accept(93))
             {var _eA_=[0,char$0(45),s$0];return [0,char$0(c),_eA_]}
            var c$0=char$1(0),s$1=[0,rg(c,c$0),s$0],s$0=s$1;
            continue}
          var s$2=[0,char$0(c),s$0],s$0=s$2;
          continue}}
      function branch(param)
       {var left=0;
        for(;;)
         {if(! eos$0(0) && ! test2(92,124) && ! test2(92,41))
           {if(accept(46))
             var r=notnl;
            else
             if(accept(94))
              var r=bol;
             else
              if(accept(36))
               var r=eol;
              else
               if(accept(91))
                var r=accept(94)?compl(bracket(0)):alt$0(bracket(0));
               else
                if(accept(92))
                 if(accept(40))
                  {var r$0=regexp(0);
                   if(1 - accept2(92,41))throw Parse_error;
                   var r=[6,r$0]}
                 else
                  if(accept(96))
                   var r=bos;
                  else
                   if(accept(39))
                    var r=eos;
                   else
                    if(accept(61))
                     var r=start$0;
                    else
                     if(accept(98))
                      var r=alt$0([0,bow,[0,eow,0]]);
                     else
                      if(accept(66))
                       var r=not_boundary;
                      else
                       if(accept(60))
                        var r=bow;
                       else
                        if(accept(62))
                         var r=eow;
                        else
                         if(accept(119))
                          var r=alt$0([0,alnum,[0,char$0(95),0]]);
                         else
                          if(accept(87))
                           var r=compl([0,alnum,[0,char$0(95),0]]);
                          else
                           {if(eos$0(0))throw Parse_error;
                            var c=get(0),switch$0=0;
                            if(63 <= c)
                             {if(91 <= c)
                               {if(! (95 <= c))switch$0 = 1}
                              else
                               if(! (64 <= c))switch$0 = 1}
                            else
                             if(48 <= c)
                              {if(! (58 <= c))throw Not_supported}
                             else
                              if(36 <= c)
                               switch(c - 36 | 0)
                                {case 0:case 6:case 7:case 10:switch$0 = 1;break}
                            if(! switch$0)throw Parse_error;
                            var r=char$0(c)}
                else
                 {if(eos$0(0))throw Parse_error;
                  var c$0=get(0),switch$1=0;
                  if(44 <= c$0)
                   {if(63 === c$0)switch$1 = 1}
                  else
                   if(42 <= c$0)switch$1 = 1;
                  if(switch$1)throw Parse_error;
                  var r=char$0(c$0)}
            var
             _ez_=accept(42)?rep$0(r):accept(43)?rep1(r):accept(63)?opt(r):r,
             left$0=[0,_ez_,left],
             left=left$0;
            continue}
          return seq$1(caml_call1(Stdlib_list[9],left))}}
      function regexp(param)
       {var left=branch(0),left$0=left;
        for(;;)
         {if(accept2(92,124))
           {var left$1=alt$0([0,left$0,[0,branch(0),0]]),left$0=left$1;
            continue}
          return left$0}}
      var r=regexp(0);
      if(1 - eos$0(0))throw Parse_error;
      return case$0?r:[10,r]}
    function compile_pat(opt,s)
     {if(opt)var sth=opt[1],case$0=sth;else var case$0=1;
      return compile(re([0,case$0],s))}
    var Re_Emacs=[0,Parse_error,Not_supported,re,compile,compile_pat];
    caml_register_global(156,Re_Emacs,"Re__Emacs");
    function compile_regexp(s,c)
     {var
       re$0=re([0,1 - c],s),
       _ew_=[246,function(_ey_){return compile(re$0)}];
      return [0,
              re$0,
              [246,
               function(_ex_){return compile(seq$1([0,start$0,[0,re$0,0]]))}],
              _ew_]}
    var state=[0,0];
    function string_match(re,s,p)
     {try
       {var
         _er_=re[2],
         _es_=caml_obj_tag(_er_),
         _et_=
          250 === _es_
           ?_er_[1]
           :246 === _es_?caml_call1(CamlinternalLazy[2],_er_):_er_;
        state[1] = [0,exec([0,p],0,_et_,s)];
        var _eu_=1;
        return _eu_}
      catch(_ev_)
       {_ev_ = caml_wrap_exception(_ev_);
        if(_ev_ === Stdlib[8]){state[1] = 0;return 0}
        throw _ev_}}
    function string_partial_match(re,s,p)
     {var
       _eo_=re[2],
       _ep_=caml_obj_tag(_eo_),
       _eq_=
        250 === _ep_
         ?_eo_[1]
         :246 === _ep_?caml_call1(CamlinternalLazy[2],_eo_):_eo_,
       match=exec_partial([0,p],0,_eq_,s);
      return 782112175 === match?string_match(re,s,p):939392865 <= match?1:0}
    function search_forward(re,s,p)
     {try
       {var
         _ej_=re[3],
         _ek_=caml_obj_tag(_ej_),
         _el_=
          250 === _ek_
           ?_ej_[1]
           :246 === _ek_?caml_call1(CamlinternalLazy[2],_ej_):_ej_,
         res=exec([0,p],0,_el_,s);
        state[1] = [0,res];
        var _em_=caml_call2(Group[2],res,0)[1];
        return _em_}
      catch(_en_)
       {_en_ = caml_wrap_exception(_en_);
        if(_en_ === Stdlib[8]){state[1] = 0;throw Stdlib[8]}
        throw _en_}}
    function search_backward(re,s,p)
     {var p$0=p;
      for(;;)
       try
        {var
          _ef_=re[2],
          _eg_=caml_obj_tag(_ef_),
          _eh_=
           250 === _eg_
            ?_ef_[1]
            :246 === _eg_?caml_call1(CamlinternalLazy[2],_ef_):_ef_,
          res=exec([0,p$0],0,_eh_,s);
         state[1] = [0,res];
         return p$0}
       catch(_ei_)
        {_ei_ = caml_wrap_exception(_ei_);
         if(_ei_ === Stdlib[8])
          {state[1] = 0;
           if(0 === p$0)throw Stdlib[8];
           var p$1=p$0 - 1 | 0,p$0=p$1;
           continue}
         throw _ei_}}
    function valid_group(n)
     {var _eb_=0 <= n?1:0;
      if(_eb_)
       {var _ec_=n < 10?1:0;
        if(_ec_)
         {var _ed_=state[1];
          if(_ed_){var m=_ed_[1];return n < caml_call1(Group[8],m)?1:0}
          var _ee_=0}
        else
         var _ee_=_ec_}
      else
       var _ee_=_eb_;
      return _ee_}
    function offset_group(i)
     {var _ea_=state[1];
      if(_ea_){var m=_ea_[1];return caml_call2(Group[2],m,i)}
      throw Stdlib[8]}
    function group_len(i)
     {try
       {var match=offset_group(i),e=match[2],b=match[1],_d__=e - b | 0;
        return _d__}
      catch(_d$_)
       {_d$_ = caml_wrap_exception(_d$_);
        if(_d$_ === Stdlib[8])return 0;
        throw _d$_}}
    function replace$0(orig,repl,p,res,q,len)
     {var p$0=p,q$0=q;
      for(;;)
       {var _d7_=p$0 < len?1:0;
        if(_d7_)
         {var c=caml_string_get(repl,p$0);
          if(92 === c)
           {var c$0=caml_string_get(repl,p$0 + 1 | 0);
            if(58 <= c$0)
             {if(92 === c$0)
               {caml_bytes_set(res,q$0,92);
                var q$1=q$0 + 1 | 0,p$1=p$0 + 2 | 0,p$0=p$1,q$0=q$1;
                continue}}
            else
             if(48 <= c$0)
              {try
                {var
                  match=offset_group(c$0 - 48 | 0),
                  e=match[2],
                  b=match[1],
                  d$0=e - b | 0;
                 if(0 < d$0)caml_call5(Stdlib_string[6],orig,b,res,q$0,d$0);
                 var d=d$0}
               catch(_d9_)
                {_d9_ = caml_wrap_exception(_d9_);
                 if(_d9_ !== Stdlib[8])throw _d9_;
                 var d=0,_d8_=_d9_}
               var q$3=q$0 + d | 0,p$3=p$0 + 2 | 0,p$0=p$3,q$0=q$3;
               continue}
            caml_bytes_set(res,q$0,92);
            caml_bytes_set(res,q$0 + 1 | 0,c$0);
            var q$2=q$0 + 2 | 0,p$2=p$0 + 2 | 0,p$0=p$2,q$0=q$2;
            continue}
          caml_bytes_set(res,q$0,c);
          var q$4=q$0 + 1 | 0,p$4=p$0 + 1 | 0,p$0=p$4,q$0=q$4;
          continue}
        return _d7_}}
    function replacement_text(repl,orig)
     {var len=caml_ml_string_length(repl),p=0,q=0;
      for(;;)
       {if(p < len)
         {if(92 === caml_string_get(repl,p))
           {var p$0=p + 1 | 0;
            if(p$0 === len)
             caml_call1(Stdlib[2],cst_Str_replace_illegal_backsl);
            var c=caml_string_get(repl,p$0),switch$0=0;
            if(58 <= c)
             if(92 === c)var q$0=q + 1 | 0;else switch$0 = 1;
            else
             if(48 <= c)
              var q$0=q + group_len(c - 48 | 0) | 0;
             else
              switch$0 = 1;
            if(switch$0)var q$0=q + 2 | 0;
            var p$1=p$0 + 1 | 0,p=p$1,q=q$0;
            continue}
          var q$1=q + 1 | 0,p$2=p + 1 | 0,p=p$2,q=q$1;
          continue}
        var res=caml_create_bytes(q);
        replace$0(orig,repl,0,res,0,caml_ml_string_length(repl));
        return caml_call1(Stdlib_bytes[42],res)}}
    function quote$0(s)
     {var
       len=caml_ml_string_length(s),
       buf=caml_call1(Stdlib_buffer[1],2 * len | 0),
       _d3_=len - 1 | 0,
       _d2_=0;
      if(! (_d3_ < 0))
       {var i=_d2_;
        for(;;)
         {var c=caml_string_get(s,i),_d4_=c - 63 | 0,switch$0=0;
          if(31 < _d4_ >>> 0)
           {var _d5_=_d4_ + 27 | 0;
            if(! (10 < _d5_ >>> 0))
             switch(_d5_){case 0:case 6:case 7:case 10:switch$0 = 1;break}}
          else
           if(26 < (_d4_ - 1 | 0) >>> 0)switch$0 = 1;
          if(switch$0)
           {caml_call2(Stdlib_buffer[10],buf,92);
            caml_call2(Stdlib_buffer[10],buf,c)}
          else
           caml_call2(Stdlib_buffer[10],buf,c);
          var _d6_=i + 1 | 0;
          if(_d3_ !== i){var i=_d6_;continue}
          break}}
      return caml_call1(Stdlib_buffer[2],buf)}
    function string_before(s,n){return caml_call3(Stdlib_string[4],s,0,n)}
    function string_after(s,n)
     {return caml_call3(Stdlib_string[4],s,n,caml_ml_string_length(s) - n | 0)}
    function first_chars(s,n){return caml_call3(Stdlib_string[4],s,0,n)}
    function last_chars(s,n)
     {return caml_call3(Stdlib_string[4],s,caml_ml_string_length(s) - n | 0,n)}
    function regexp(e){return compile_regexp(e,0)}
    function regexp_case_fold(e){return compile_regexp(e,1)}
    function regexp_string(s){return compile_regexp(quote$0(s),0)}
    function regexp_string_case_fold(s){return compile_regexp(quote$0(s),1)}
    function group_beginning(n)
     {if(1 - valid_group(n))caml_call1(Stdlib[1],cst_Str_group_beginning);
      var pos=offset_group(n)[1];
      if(-1 === pos)throw Stdlib[8];
      return pos}
    function group_end(n)
     {if(1 - valid_group(n))caml_call1(Stdlib[1],cst_Str_group_end);
      var pos=offset_group(n)[2];
      if(-1 === pos)throw Stdlib[8];
      return pos}
    function matched_group(n,txt)
     {var match=offset_group(n),e=match[2],b=match[1];
      return caml_call3(Stdlib_string[4],txt,b,e - b | 0)}
    function replace_matched(repl,matched)
     {return replacement_text(repl,matched)}
    function match_beginning(param){return group_beginning(0)}
    function match_end(param){return group_end(0)}
    function matched_string(txt){return matched_group(0,txt)}
    function substitute_first(expr,repl_fun,text)
     {try
       {var
         pos=search_forward(expr,text,0),
         _dX_=[0,string_after(text,match_end(0)),0],
         _dY_=[0,caml_call1(repl_fun,text),_dX_],
         _dZ_=[0,string_before(text,pos),_dY_],
         _d0_=caml_call2(Stdlib_string[7],cst$3,_dZ_);
        return _d0_}
      catch(_d1_)
       {_d1_ = caml_wrap_exception(_d1_);
        if(_d1_ === Stdlib[8])return text;
        throw _d1_}}
    function global_substitute(expr,repl_fun,text)
     {function replace(accu,start,last_was_empty)
       {try
         {var startpos=last_was_empty?start + 1 | 0:start;
          if(caml_ml_string_length(text) < startpos)throw Stdlib[8];
          var
           pos=search_forward(expr,text,startpos),
           end_pos=match_end(0),
           repl_text=caml_call1(repl_fun,text),
           _dV_=
            replace
             ([0,
               repl_text,
               [0,
                caml_call3(Stdlib_string[4],text,start,pos - start | 0),
                accu]],
              end_pos,
              end_pos === pos?1:0);
          return _dV_}
        catch(_dW_)
         {_dW_ = caml_wrap_exception(_dW_);
          if(_dW_ === Stdlib[8])return [0,string_after(text,start),accu];
          throw _dW_}}
      var _dT_=replace(0,0,0),_dU_=caml_call1(Stdlib_list[9],_dT_);
      return caml_call2(Stdlib_string[7],cst$4,_dU_)}
    function global_replace(expr,repl,text)
     {return global_substitute
              (expr,function(_dS_){return replacement_text(repl,_dS_)},text)}
    function replace_first(expr,repl,text)
     {return substitute_first
              (expr,function(_dR_){return replacement_text(repl,_dR_)},text)}
    function search_forward_progress(re,s,p)
     {var pos=search_forward(re,s,p);
      if(p < match_end(0))return pos;
      if(p < caml_ml_string_length(s))return search_forward(re,s,p + 1 | 0);
      throw Stdlib[8]}
    function bounded_split(expr,text,num)
     {var start=string_match(expr,text,0)?match_end(0):0;
      function split(accu,start,n)
       {if(caml_ml_string_length(text) <= start)return accu;
        if(1 === n)return [0,string_after(text,start),accu];
        try
         {var
           pos=search_forward_progress(expr,text,start),
           _dO_=match_end(0),
           _dP_=
            split
             ([0,caml_call3(Stdlib_string[4],text,start,pos - start | 0),accu],
              _dO_,
              n - 1 | 0);
          return _dP_}
        catch(_dQ_)
         {_dQ_ = caml_wrap_exception(_dQ_);
          if(_dQ_ === Stdlib[8])return [0,string_after(text,start),accu];
          throw _dQ_}}
      var _dN_=split(0,start,num);
      return caml_call1(Stdlib_list[9],_dN_)}
    function split$1(expr,text){return bounded_split(expr,text,0)}
    function bounded_split_delim(expr,text,num)
     {function split(accu,start,n)
       {if(caml_ml_string_length(text) < start)return accu;
        if(1 === n)return [0,string_after(text,start),accu];
        try
         {var
           pos=search_forward_progress(expr,text,start),
           _dK_=match_end(0),
           _dL_=
            split
             ([0,caml_call3(Stdlib_string[4],text,start,pos - start | 0),accu],
              _dK_,
              n - 1 | 0);
          return _dL_}
        catch(_dM_)
         {_dM_ = caml_wrap_exception(_dM_);
          if(_dM_ === Stdlib[8])return [0,string_after(text,start),accu];
          throw _dM_}}
      if(runtime.caml_string_equal(text,cst$5))return 0;
      var _dJ_=split(0,0,num);
      return caml_call1(Stdlib_list[9],_dJ_)}
    function split_delim(expr,text){return bounded_split_delim(expr,text,0)}
    function bounded_full_split(expr,text,num)
     {function split(accu,start,n)
       {if(caml_ml_string_length(text) <= start)return accu;
        if(1 === n)return [0,[0,string_after(text,start)],accu];
        try
         {var
           pos=search_forward_progress(expr,text,start),
           s=matched_string(text);
          if(start < pos)
           var
            _dG_=match_end(0),
            _dH_=
             split
              ([0,
                [1,s],
                [0,
                 [0,caml_call3(Stdlib_string[4],text,start,pos - start | 0)],
                 accu]],
               _dG_,
               n - 1 | 0);
          else
           var _dH_=split([0,[1,s],accu],match_end(0),n - 1 | 0);
          return _dH_}
        catch(_dI_)
         {_dI_ = caml_wrap_exception(_dI_);
          if(_dI_ === Stdlib[8])return [0,[0,string_after(text,start)],accu];
          throw _dI_}}
      var _dF_=split(0,0,num);
      return caml_call1(Stdlib_list[9],_dF_)}
    function full_split(expr,text){return bounded_full_split(expr,text,0)}
    var
     Re_Str=
      [0,
       regexp,
       regexp_case_fold,
       quote$0,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_backward,
       string_partial_match,
       matched_string,
       match_beginning,
       match_end,
       matched_group,
       group_beginning,
       group_end,
       global_replace,
       replace_first,
       global_substitute,
       substitute_first,
       replace_matched,
       split$1,
       bounded_split,
       split_delim,
       bounded_split_delim,
       full_split,
       bounded_full_split,
       string_before,
       string_after,
       first_chars,
       last_chars];
    caml_register_global(158,Re_Str,"Re__Str");
    var Parse_error$0=[248,cst_Re_Glob_Parse_error,caml_fresh_oo_id(0)];
    function mul(l$0,l)
     {function _dC_(s)
       {function _dE_(s$0){return caml_call2(Stdlib[28],s,s$0)}
        return caml_call2(Stdlib_list[17],_dE_,l)}
      var _dD_=caml_call2(Stdlib_list[17],_dC_,l$0);
      return caml_call1(Stdlib_list[14],_dD_)}
    function explicit_period(t)
     {var _dy_=t[6];
      if(_dy_)
       {var _dz_=t[3];
        if(_dz_)var _dA_=_dz_;else var _dB_=t[4],_dA_=_dB_?t[5]:_dB_}
      else
       var _dA_=_dy_;
      return _dA_}
    function append(opt,t,piece)
     {if(opt)
       var sth=opt[1],am_at_start_of_component=sth;
      else
       var am_at_start_of_component=0;
      return [0,[0,piece,t[1]],t[2],0,am_at_start_of_component,t[5],t[6]]}
    function next(t)
     {var _dx_=t[2];
      if(_dx_)
       {var remaining=_dx_[2],piece=_dx_[1];
        return [0,[0,piece,[0,t[1],remaining,t[3],t[4],t[5],t[6]]]]}
      return 0}
    function one(explicit_slash,explicit_period)
     {var
       _dt_=0,
       _du_=explicit_period?[0,char$0(46),0]:0,
       _dv_=[0,_du_,_dt_],
       _dw_=explicit_slash?[0,char$0(47),0]:0;
      return compl(caml_call1(Stdlib_list[13],[0,_dw_,_dv_]))}
    function enclosed(enclosed)
     {if(0 === enclosed[0]){var c=enclosed[1];return char$0(c)}
      var high=enclosed[2],low=enclosed[1];
      return rg(low,high)}
    function enclosed_set(explicit_slash,explicit_period,kind,set)
     {var
       set$0=caml_call2(Stdlib_list[17],enclosed,set),
       enclosure=596216810 <= kind?alt$0(set$0):compl(set$0);
      return inter$0([0,enclosure,[0,one(explicit_slash,explicit_period),0]])}
    function exactly(state,c){return append([0,47 === c?1:0],state,char$0(c))}
    function glob(opt$0,_dh_,_dg_,_df_,s)
     {if(opt$0)var sth=opt$0[1],anchored=sth;else var anchored=0;
      if(_dh_)var sth$0=_dh_[1],pathname=sth$0;else var pathname=1;
      if(_dg_)var sth$1=_dg_[1],period=sth$1;else var period=1;
      if(_df_)var sth$2=_df_[1],expand_braces=sth$2;else var expand_braces=0;
      function to_re(s)
       {var i=[0,0],l=caml_ml_string_length(s);
        function eos(param){return i[1] === l?1:0}
        function read(c)
         {var _ds_=1 - eos(0),r=_ds_?caml_string_get(s,i[1]) === c?1:0:_ds_;
          if(r)i[1]++;
          return r}
        function char$0(param)
         {read(92);
          if(eos(0))throw Parse_error$0;
          var r=caml_string_get(s,i[1]);
          i[1]++;
          return r}
        function enclosed(param)
         {var s=0;
          for(;;)
           {if(0 !== s && read(93))return s;
            var c=char$0(0);
            if(read(45))
             {if(read(93))return [0,[0,c],[0,_cx_,s]];
              var c$0=char$0(0),s$0=[0,[1,c,c$0],s],s=s$0;
              continue}
            var s$1=[0,[0,c],s],s=s$1;
            continue}}
        var pieces=0;
        for(;;)
         {if(eos(0))
           {var
             glob=caml_call1(Stdlib_list[9],pieces),
             state=[0,0,glob,1,1,pathname,period],
             state$7=state;
            for(;;)
             {var match$0=next(state$7);
              if(match$0)
               {var
                 match$1=match$0[1],
                 state$8=match$1[2],
                 p=match$1[1],
                 explicit_slash$0=state$8[5],
                 explicit_period$1=explicit_period(state$8);
                if(typeof p === "number")
                 if(0 === p)
                  var
                   state$9=
                    append(0,state$8,one(explicit_slash$0,explicit_period$1));
                 else
                  {var
                    explicit_slash=state$8[5],
                    explicit_period$0=explicit_period(state$8);
                   if(explicit_period$0)
                    if(explicit_slash)
                     {var
                       _dl_=[0,rep$0(one(1,0)),0],
                       not_empty=seq$1([0,one(1,1),_dl_]),
                       maybe_empty=opt(not_empty),
                       enclosed_set$1=
                        function(not_empty)
                         {function enclosed_set$0(state,kind,set)
                           {var
                             _dr_=
                              [0,seq$1([0,not_empty,[0,enclosed_set(1,0,kind,set),0]]),0];
                            return append
                                    (0,state,alt$0([0,enclosed_set(1,1,kind,set),_dr_]))}
                          return enclosed_set$0},
                       enclosed_set$0=enclosed_set$1(not_empty),
                       state$0=state$8;
                      for(;;)
                       {var match=next(state$0);
                        if(match)
                         {var _dm_=match[1],_dn_=_dm_[1];
                          if(typeof _dn_ === "number")
                           {if(0 !== _dn_)
                             {var state$2=_dm_[2],state$0=state$2;continue}
                            var state$1=_dm_[2],_do_=append(0,state$1,not_empty)}
                          else
                           switch(_dn_[0])
                            {case 0:
                              var
                               state$3=_dm_[2],
                               c=_dn_[1],
                               not_empty$0=46 === c?not_empty:maybe_empty,
                               state$4=append(0,state$3,not_empty$0),
                               _do_=exactly(state$4,c);
                              break;
                             case 1:
                              var
                               state$5=_dm_[2],
                               enclosed$0=_dn_[1],
                               _do_=enclosed_set$0(state$5,596216810,enclosed$0);
                              break;
                             default:
                              var
                               state$6=_dm_[2],
                               enclosed$1=_dn_[1],
                               _do_=enclosed_set$0(state$6,-188280562,enclosed$1)}}
                        else
                         var _do_=append(0,state$0,maybe_empty);
                        var _dq_=_do_;
                        break}}
                    else
                     var
                      _dp_=[0,rep$0(one(0,0)),0],
                      _dq_=
                       append
                        (0,state$8,opt(seq$1([0,one(0,explicit_period$0),_dp_])));
                   else
                    var
                     _dq_=
                      append
                       (0,state$8,rep$0(one(explicit_slash,explicit_period$0)));
                   var state$9=_dq_}
                else
                 switch(p[0])
                  {case 0:var c$0=p[1],state$9=exactly(state$8,c$0);break;
                   case 1:
                    var
                     enclosed$2=p[1],
                     state$9=
                      append
                       (0,
                        state$8,
                        enclosed_set
                         (explicit_slash$0,explicit_period$1,596216810,enclosed$2));
                    break;
                   default:
                    var
                     enclosed$3=p[1],
                     state$9=
                      append
                       (0,
                        state$8,
                        enclosed_set
                         (explicit_slash$0,explicit_period$1,-188280562,enclosed$3))}
                var state$7=state$9;
                continue}
              var re=seq$1(caml_call1(Stdlib_list[9],state$7[1]));
              return anchored?whole_string(re):re}}
          if(read(42))
           var _dk_=1;
          else
           if(read(63))
            var _dk_=0;
           else
            if(read(91))
             {var switch$0=0;
              if(read(94) || read(33))
               switch$0 = 1;
              else
               var _dk_=[1,enclosed(0)];
              if(switch$0)var _dk_=[2,enclosed(0)]}
            else
             var _dk_=[0,char$0(0)];
          var pieces$0=[0,_dk_,pieces],pieces=pieces$0;
          continue}}
      if(expand_braces)
       {var
         l=caml_ml_string_length(s),
         expl=
          function(inner,s$0,i,acc,beg$0)
           {var s$1=s$0,i$0=i,acc$0=acc,beg$1=beg$0;
            for(;;)
             {if(l <= i$0)
               {if(inner)throw Parse_error$0;
                return [0,
                        mul
                         (beg$1,
                          [0,caml_call3(Stdlib_string[4],s,s$1,i$0 - s$1 | 0),0]),
                        i$0]}
              var match=caml_string_get(s,i$0);
              if(44 === match)
               {if(inner)
                 {var
                   _di_=
                    mul
                     (beg$1,
                      [0,caml_call3(Stdlib_string[4],s,s$1,i$0 - s$1 | 0),0]),
                   acc$1=caml_call2(Stdlib[37],_di_,acc$0),
                   i$1=i$0 + 1 | 0,
                   s$2=i$0 + 1 | 0,
                   s$1=s$2,
                   i$0=i$1,
                   acc$0=acc$1,
                   beg$1=beg;
                  continue}}
              else
               if(123 <= match)
                {if(! (126 <= match))
                  {var switcher=match - 123 | 0;
                   switch(switcher)
                    {case 0:
                      var
                       match$0=expl(1,i$0 + 1 | 0,i$0 + 1 | 0,0,_cy_),
                       i$3=match$0[2],
                       t=match$0[1],
                       beg$2=
                        mul
                         (beg$1,
                          mul
                           ([0,caml_call3(Stdlib_string[4],s,s$1,i$0 - s$1 | 0),0],t)),
                       s$1=i$3,
                       i$0=i$3,
                       beg$1=beg$2;
                      continue;
                     case 1:break;
                     default:
                      if(inner)
                       {var
                         _dj_=
                          mul
                           (beg$1,
                            [0,caml_call3(Stdlib_string[4],s,s$1,i$0 - s$1 | 0),0]);
                        return [0,caml_call2(Stdlib[37],_dj_,acc$0),i$0 + 1 | 0]}}}}
               else
                if(92 === match){var i$4=i$0 + 2 | 0,i$0=i$4;continue}
              var i$2=i$0 + 1 | 0,i$0=i$2;
              continue}},
         _dd_=expl(0,0,0,0,_cz_)[1],
         _de_=caml_call1(Stdlib_list[9],_dd_);
        return alt$0(caml_call2(Stdlib_list[17],to_re,_de_))}
      return to_re(s)}
    function glob$0(anchored,period,s){return glob(anchored,0,[0,period],0,s)}
    function globx(anchored,s){return glob(anchored,0,0,_cA_,s)}
    function globx$0(anchored,period,s)
     {return glob(anchored,0,[0,period],_cB_,s)}
    var Re_Glob=[0,Parse_error$0,glob,glob$0,globx,globx$0];
    caml_register_global(159,Re_Glob,"Re__Glob");
    var
     Parse_error$1=[248,cst_Re_Perl_Parse_error,caml_fresh_oo_id(0)],
     Not_supported$0=[248,cst_Re_Perl_Not_supported,caml_fresh_oo_id(0)];
    function posix_class_of_string(class$0)
     {var switch$0=runtime.caml_string_compare(class$0,cst_lower);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return lower;
        if(! caml_string_notequal(class$0,cst_print))return print;
        if(! caml_string_notequal(class$0,cst_punct))return punct;
        if(! caml_string_notequal(class$0,cst_space))return space;
        if(! caml_string_notequal(class$0,cst_upper))return upper;
        if(! caml_string_notequal(class$0,cst_word))return wordc;
        if(! caml_string_notequal(class$0,cst_xdigit))return xdigit}
      else
       {if(! caml_string_notequal(class$0,cst_alnum))return alnum;
        if(! caml_string_notequal(class$0,cst_ascii))return ascii;
        if(! caml_string_notequal(class$0,cst_blank))return blank;
        if(! caml_string_notequal(class$0,cst_cntrl))return cntrl;
        if(! caml_string_notequal(class$0,cst_digit))return digit;
        if(! caml_string_notequal(class$0,cst_graph))return graph}
      var _dc_=caml_call2(Stdlib[28],cst_Invalid_pcre_class,class$0);
      return caml_call1(Stdlib[1],_dc_)}
    function re$0(opt$0,s)
     {if(opt$0)var sth=opt$0[1],opts=sth;else var opts=0;
      var
       ungreedy=caml_call2(Stdlib_list[33],-243745063,opts),
       dotall=caml_call2(Stdlib_list[33],-424303016,opts),
       dollar_endonly=caml_call2(Stdlib_list[33],-712595228,opts),
       multiline=caml_call2(Stdlib_list[33],1071952589,opts),
       i=[0,0],
       l=caml_ml_string_length(s);
      function eos$0(param){return i[1] === l?1:0}
      function test(c)
       {var
         _da_=1 - eos$0(0),
         _db_=_da_?caml_string_get(s,i[1]) === c?1:0:_da_;
        return _db_}
      function accept(c){var r=test(c);if(r)i[1]++;return r}
      function accept_s(s$0)
       {var len=caml_ml_string_length(s$0);
        try
         {var _c6_=len - 1 | 0,_c5_=0;
          if(! (_c6_ < 0))
           {var j=_c5_;
            for(;;)
             {try
               {var _c8_=caml_string_get(s,i[1] + j | 0);
                if(caml_string_get(s$0,j) !== _c8_)throw Stdlib[3]}
              catch(_c$_){throw Stdlib[3]}
              var _c9_=j + 1 | 0;
              if(_c6_ !== j){var j=_c9_;continue}
              break}}
          i[1] = i[1] + len | 0;
          var _c7_=1;
          return _c7_}
        catch(_c__)
         {_c__ = caml_wrap_exception(_c__);
          if(_c__ === Stdlib[3])return 0;
          throw _c__}}
      function get(param){var r=caml_string_get(s,i[1]);i[1]++;return r}
      function unget(param){i[1] += -1;return 0}
      function greedy_mod(r)
       {var gr=accept(63),gr$0=ungreedy?1 - gr:gr;
        return gr$0?non_greedy(r):greedy(r)}
      function char$1(param)
       {if(eos$0(0))throw Parse_error$1;
        var c=get(0);
        if(91 === c)
         {if(accept(61))throw Not_supported$0;
          if(accept(58))
           {var compl$0=accept(94);
            try
             {var cls=caml_call2(Stdlib_list[34],accept_s,posix_class_strings)}
            catch(_c4_)
             {_c4_ = caml_wrap_exception(_c4_);
              if(_c4_ === Stdlib[8])throw Parse_error$1;
              throw _c4_}
            if(1 - accept_s(cst$6))throw Parse_error$1;
            var
             posix_class=posix_class_of_string(cls),
             re=compl$0?compl([0,posix_class,0]):posix_class;
            return [0,4150146,re]}
          if(accept(46))
           {if(eos$0(0))throw Parse_error$1;
            var c$0=get(0);
            if(1 - accept(46))throw Not_supported$0;
            if(1 - accept(93))throw Parse_error$1;
            return [0,748194550,c$0]}
          return [0,748194550,c]}
        if(92 === c)
         {if(eos$0(0))throw Parse_error$1;
          var c$1=get(0);
          if(58 <= c$1)
           {if(! (123 <= c$1))
             {var switcher=c$1 - 58 | 0;
              switch(switcher)
               {case 10:return [0,4150146,compl([0,digit,0])];
                case 25:return [0,4150146,compl([0,space,0])];
                case 29:return [0,4150146,compl([0,alnum,[0,char$0(95),0]])];
                case 40:return _cC_;
                case 42:return [0,4150146,digit];
                case 52:return _cD_;
                case 56:return _cE_;
                case 57:return [0,4150146,space];
                case 58:return _cF_;
                case 61:return [0,4150146,alt$0([0,alnum,[0,char$0(95),0]])];
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:break;
                default:throw Parse_error$1}}}
          else
           if(48 <= c$1)throw Not_supported$0;
          return [0,748194550,c$1]}
        return [0,748194550,c]}
      function bracket(s)
       {var s$0=s;
        for(;;)
         {if(0 !== s$0 && accept(93))return s$0;
          var match=char$1(0);
          if(748194550 <= match[1])
           {var c=match[2];
            if(accept(45))
             {if(accept(93))
               {var _c2_=[0,char$0(45),s$0];return [0,char$0(c),_c2_]}
              var match$0=char$1(0);
              if(748194550 <= match$0[1])
               {var c$0=match$0[2],s$1=[0,rg(c,c$0),s$0],s$0=s$1;continue}
              var
               st=match$0[2],
               _c3_=[0,char$0(45),[0,st,s$0]],
               s$2=[0,char$0(c),_c3_],
               s$0=s$2;
              continue}
            var s$3=[0,char$0(c),s$0],s$0=s$3;
            continue}
          var st$0=match[2],s$4=[0,st$0,s$0],s$0=s$4;
          continue}}
      function integer(param)
       {if(eos$0(0))return 0;
        var d=get(0),switcher=d - 48 | 0;
        if(9 < switcher >>> 0){unget(0);return 0}
        var i=d - 48 | 0,i$0=i;
        for(;;)
         {if(eos$0(0))return [0,i$0];
          var d$0=get(0),switcher$0=d$0 - 48 | 0;
          if(9 < switcher$0 >>> 0){unget(0);return [0,i$0]}
          var i$1=(10 * i$0 | 0) + (d$0 - 48 | 0) | 0;
          if(i$1 < i$0)throw Parse_error$1;
          var i$0=i$1;
          continue}}
      function branch(param)
       {var left=0;
        for(;;)
         {if(! eos$0(0) && ! test(124) && ! test(41))
           {if(accept(46))
             var r=dotall?any:notnl;
            else
             if(accept(40))
              if(accept(63))
               if(accept(58))
                {var r$0=regexp(0);
                 if(1 - accept(41))throw Parse_error$1;
                 var r=r$0}
               else
                {if(! accept(35))throw Parse_error$1;
                 for(;;)
                  {if(eos$0(0))throw Parse_error$1;
                   if(! accept(41)){i[1]++;continue}
                   var r=epsilon;
                   break}}
              else
               {var r$1=regexp(0);
                if(1 - accept(41))throw Parse_error$1;
                var r=[6,r$1]}
             else
              if(accept(94))
               var r=multiline?bol:bos;
              else
               if(accept(36))
                var r=multiline?eol:dollar_endonly?leol:eos;
               else
                if(accept(91))
                 var r=accept(94)?compl(bracket(0)):alt$0(bracket(0));
                else
                 if(accept(92))
                  {if(eos$0(0))throw Parse_error$1;
                   var c=get(0),switcher=c - 48 | 0,switch$0=0;
                   if(74 < switcher >>> 0)
                    switch$0 = 1;
                   else
                    switch(switcher)
                     {case 17:var r=bos;break;
                      case 18:var r=not_boundary;break;
                      case 20:var r=compl([0,digit,0]);break;
                      case 23:var r=start$0;break;
                      case 35:var r=compl([0,space,0]);break;
                      case 39:var r=compl([0,alnum,[0,char$0(95),0]]);break;
                      case 42:var r=leol;break;
                      case 50:var r=alt$0([0,bow,[0,eow,0]]);break;
                      case 52:var r=digit;break;
                      case 67:var r=space;break;
                      case 71:var r=alt$0([0,alnum,[0,char$0(95),0]]);break;
                      case 74:var r=eos;break;
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                      case 8:
                      case 9:throw Not_supported$0;
                      case 10:
                      case 11:
                      case 12:
                      case 13:
                      case 14:
                      case 15:
                      case 16:
                      case 43:
                      case 44:
                      case 45:
                      case 46:
                      case 47:
                      case 48:switch$0 = 1;break;
                      default:throw Parse_error$1}
                   if(switch$0)var r=char$0(c)}
                 else
                  {if(eos$0(0))throw Parse_error$1;
                   var c$0=get(0),switch$1=0;
                   if(64 <= c$0)
                    {if(92 !== c$0 && 123 !== c$0)switch$1 = 1}
                   else
                    if(44 <= c$0)
                     {if(! (63 <= c$0))switch$1 = 1}
                    else
                     if(! (42 <= c$0))switch$1 = 1;
                   if(! switch$1)throw Parse_error$1;
                   var r=char$0(c$0)}
            if(accept(42))
             var _c1_=greedy_mod(rep$0(r));
            else
             if(accept(43))
              var _c1_=greedy_mod(rep1(r));
             else
              if(accept(63))
               var _c1_=greedy_mod(opt(r));
              else
               if(accept(123))
                {var match=integer(0);
                 if(match)
                  {var i$0=match[1],j=accept(44)?integer(0):[0,i$0];
                   if(1 - accept(125))throw Parse_error$1;
                   if(j){var j$0=j[1];if(j$0 < i$0)throw Parse_error$1}
                   var _c1_=greedy_mod(repn(r,i$0,j))}
                 else
                  {unget(0);var _c1_=r}}
               else
                var _c1_=r;
            var left$0=[0,_c1_,left],left=left$0;
            continue}
          return seq$1(caml_call1(Stdlib_list[9],left))}}
      function regexp(param)
       {var left=branch(0),left$0=left;
        for(;;)
         {if(accept(124))
           {var left$1=alt$0([0,left$0,[0,branch(0),0]]),left$0=left$1;
            continue}
          return left$0}}
      var r=regexp(0);
      if(1 - eos$0(0))throw Parse_error$1;
      var
       r$0=
        caml_call2(Stdlib_list[33],616470068,opts)
         ?seq$1([0,start$0,[0,r,0]])
         :r,
       r$1=caml_call2(Stdlib_list[33],604571177,opts)?[10,r$0]:r$0;
      return r$1}
    function compile_pat$0(opt,s)
     {if(opt)var sth=opt[1],opts=sth;else var opts=0;
      return compile(re$0([0,opts],s))}
    var Re_Perl=[0,Parse_error$1,Not_supported$0,re$0,compile,compile_pat$0];
    caml_register_global(160,Re_Perl,"Re__Perl");
    function re$1(opt,pat)
     {if(opt)var sth=opt[1],flags=sth;else var flags=0;
      function _c0_(param)
       {return 601676297 === param
                ?604571177
                :613575188 <= param?616470068:1071952589}
      var opts=caml_call2(Stdlib_list[17],_c0_,flags);
      return re$0([0,opts],pat)}
    function regexp$0(flags,pat){return compile(re$1(flags,pat))}
    function extract(rex,s)
     {var _cZ_=exec(0,0,rex,s);return caml_call1(Group[5],_cZ_)}
    function exec$0(rex,pos,s){return exec(pos,0,rex,s)}
    function get_substring(s,i){return caml_call2(Group[1],s,i)}
    function get_substring_ofs(s,i){return caml_call2(Group[2],s,i)}
    function pmatch(rex,s){return execp(0,0,rex,s)}
    function substitute(rex,subst,str)
     {var b=caml_call1(Stdlib_buffer[1],1024),pos=0;
      for(;;)
       {if(caml_ml_string_length(str) <= pos)
         return caml_call1(Stdlib_buffer[2],b);
        if(execp([0,pos],0,rex,str))
         {var
           ss=exec([0,pos],0,rex,str),
           match=caml_call2(Group[2],ss,0),
           fin=match[2],
           start=match[1],
           pat=caml_call2(Group[1],ss,0);
          caml_call4(Stdlib_buffer[16],b,str,pos,start - pos | 0);
          var _cY_=caml_call1(subst,pat);
          caml_call2(Stdlib_buffer[14],b,_cY_);
          var pos=fin;
          continue}
        caml_call4
         (Stdlib_buffer[16],b,str,pos,caml_ml_string_length(str) - pos | 0);
        var pos$0=caml_ml_string_length(str),pos=pos$0;
        continue}}
    function split$2(rex,str)
     {var accu=0,pos=0;
      for(;;)
       {if(caml_ml_string_length(str) <= pos)
         return caml_call1(Stdlib_list[9],accu);
        if(execp([0,pos],0,rex,str))
         {var
           ss=exec([0,pos],0,rex,str),
           match=caml_call2(Group[2],ss,0),
           fin=match[2],
           start=match[1],
           s=caml_call3(Stdlib_string[4],str,pos,start - pos | 0),
           accu$0=[0,s,accu],
           accu=accu$0,
           pos=fin;
          continue}
        var
         s$0=
          caml_call3
           (Stdlib_string[4],str,pos,caml_ml_string_length(str) - pos | 0),
         pos$0=caml_ml_string_length(str),
         accu$1=[0,s$0,accu],
         accu=accu$1,
         pos=pos$0;
        continue}}
    function quote$1(s)
     {var
       len=caml_ml_string_length(s),
       s$0=caml_create_bytes(len << 1),
       pos=[0,0],
       _cU_=len - 1 | 0,
       _cT_=0;
      if(! (_cU_ < 0))
       {var i=_cT_;
        for(;;)
         {var c=runtime.caml_string_unsafe_get(s,i),switch$0=0;
          if(91 <= c)
           {var _cW_=c - 93 | 0;
            if(29 < _cW_ >>> 0)
             {if(! (32 <= _cW_))switch$0 = 1}
            else
             if(1 === _cW_)switch$0 = 1}
          else
           if(47 <= c)
            {if(63 === c)switch$0 = 1}
           else
            if(36 <= c)
             switch(c - 36 | 0)
              {case 1:case 2:case 3:case 8:case 9:break;default:switch$0 = 1}
          if(switch$0)
           {caml_bytes_unsafe_set(s$0,pos[1],92);
            pos[1]++;
            caml_bytes_unsafe_set(s$0,pos[1],c);
            pos[1]++}
          else
           {caml_bytes_unsafe_set(s$0,pos[1],c);pos[1]++}
          var _cX_=i + 1 | 0;
          if(_cU_ !== i){var i=_cX_;continue}
          break}}
      var _cV_=pos[1],r=caml_create_bytes(_cV_);
      runtime.caml_blit_bytes(s$0,0,r,0,_cV_);
      return caml_call1(Stdlib_bytes[42],r)}
    function full_split$0(opt,rex,s)
     {if(opt)var sth=opt[1],max=sth;else var max=0;
      if(0 === caml_ml_string_length(s))return 0;
      if(1 === max)return [0,[0,s],0];
      var results=split_full(0,0,rex,s);
      function _cN_(param)
       {if(936573133 <= param[1]){var s=param[2];return [0,[0,s],0]}
        var
         d=param[2],
         matches=caml_call1(Group[6],d),
         delim=caml_call2(Group[1],d,0),
         l=[0,0],
         _cP_=matches.length - 1 - 1 | 0,
         _cO_=1;
        if(! (_cP_ < 1))
         {var i=_cO_;
          for(;;)
           {var
             _cQ_=l[1],
             _cR_=
              caml_equal(caml_check_bound(matches,i)[1 + i],_cG_)
               ?0
               :[2,i,caml_call2(Group[1],d,i)];
            l[1] = [0,_cR_,_cQ_];
            var _cS_=i + 1 | 0;
            if(_cP_ !== i){var i=_cS_;continue}
            break}}
        return [0,[1,delim],caml_call1(Stdlib_list[9],l[1])]}
      var matches=caml_call2(Stdlib_list[17],_cN_,results);
      return caml_call1(Stdlib_list[13],matches)}
    var
     Re_Pcre=
      [0,
       re$1,
       regexp$0,
       extract,
       exec$0,
       get_substring,
       get_substring_ofs,
       pmatch,
       substitute,
       full_split$0,
       split$2,
       quote$1];
    caml_register_global(161,Re_Pcre,"Re__Pcre");
    var
     Parse_error$2=[248,cst_Re_Posix_Parse_error,caml_fresh_oo_id(0)],
     Not_supported$1=[248,cst_Re_Posix_Not_supported,caml_fresh_oo_id(0)];
    function re$2(opt$0,s)
     {if(opt$0)var sth=opt$0[1],opts=sth;else var opts=0;
      var
       newline=caml_call2(Stdlib_list[33],-638074828,opts),
       i=[0,0],
       l=caml_ml_string_length(s);
      function eos$0(param){return i[1] === l?1:0}
      function test(c)
       {var
         _cL_=1 - eos$0(0),
         _cM_=_cL_?caml_string_get(s,i[1]) === c?1:0:_cL_;
        return _cM_}
      function accept(c){var r=test(c);if(r)i[1]++;return r}
      function get(param){var r=caml_string_get(s,i[1]);i[1]++;return r}
      function unget(param){i[1] += -1;return 0}
      function char$1(param)
       {if(eos$0(0))throw Parse_error$2;
        var c=get(0);
        if(91 === c)
         {if(accept(61))throw Not_supported$1;
          if(accept(58))throw Not_supported$1;
          if(accept(46))
           {if(eos$0(0))throw Parse_error$2;
            var c$0=get(0);
            if(1 - accept(46))throw Not_supported$1;
            if(1 - accept(93))throw Parse_error$2;
            return c$0}
          return c}
        return c}
      function bracket(s)
       {var s$0=s;
        for(;;)
         {if(0 !== s$0 && accept(93))return s$0;
          var c=char$1(0);
          if(accept(45))
           {if(accept(93))
             {var _cK_=[0,char$0(45),s$0];return [0,char$0(c),_cK_]}
            var c$0=char$1(0),s$1=[0,rg(c,c$0),s$0],s$0=s$1;
            continue}
          var s$2=[0,char$0(c),s$0],s$0=s$2;
          continue}}
      function integer(param)
       {if(eos$0(0))return 0;
        var d=get(0),switcher=d - 48 | 0;
        if(9 < switcher >>> 0){unget(0);return 0}
        var i=d - 48 | 0,i$0=i;
        for(;;)
         {if(eos$0(0))return [0,i$0];
          var d$0=get(0),switcher$0=d$0 - 48 | 0;
          if(9 < switcher$0 >>> 0){unget(0);return [0,i$0]}
          var i$1=(10 * i$0 | 0) + (d$0 - 48 | 0) | 0;
          if(i$1 < i$0)throw Parse_error$2;
          var i$0=i$1;
          continue}}
      function branch(param)
       {var left=0;
        for(;;)
         {if(! eos$0(0) && ! test(124) && ! test(41))
           {if(accept(46))
             var r=newline?notnl:any;
            else
             if(accept(40))
              {var r$0=regexp(0);
               if(1 - accept(41))throw Parse_error$2;
               var r=[6,r$0]}
             else
              if(accept(94))
               var r=newline?bol:bos;
              else
               if(accept(36))
                var r=newline?eol:eos;
               else
                if(accept(91))
                 if(accept(94))
                  var _cI_=char$0(10),r=diff$0(compl(bracket(0)),_cI_);
                 else
                  var r=alt$0(bracket(0));
                else
                 if(accept(92))
                  {if(eos$0(0))throw Parse_error$2;
                   var c=get(0),switch$0=0;
                   if(91 <= c)
                    {var _cJ_=c - 93 | 0;
                     if(29 < _cJ_ >>> 0)
                      {if(! (32 <= _cJ_))switch$0 = 1}
                     else
                      if(1 === _cJ_)switch$0 = 1}
                   else
                    if(47 <= c)
                     {if(63 === c)switch$0 = 1}
                    else
                     if(36 <= c)
                      switch(c - 36 | 0)
                       {case 1:
                        case 2:
                        case 3:
                        case 8:
                        case 9:break;
                        default:switch$0 = 1}
                   if(! switch$0)throw Parse_error$2;
                   var r=char$0(c)}
                 else
                  {if(eos$0(0))throw Parse_error$2;
                   var c$0=get(0),switch$1=0;
                   if(64 <= c$0)
                    {if(92 !== c$0 && 123 !== c$0)switch$1 = 1}
                   else
                    if(44 <= c$0)
                     {if(! (63 <= c$0))switch$1 = 1}
                    else
                     if(! (42 <= c$0))switch$1 = 1;
                   if(! switch$1)throw Parse_error$2;
                   var r=char$0(c$0)}
            if(accept(42))
             var _cH_=rep$0([8,r]);
            else
             if(accept(43))
              var _cH_=rep1([8,r]);
             else
              if(accept(63))
               var _cH_=opt(r);
              else
               if(accept(123))
                {var match=integer(0);
                 if(match)
                  {var i=match[1],j=accept(44)?integer(0):[0,i];
                   if(1 - accept(125))throw Parse_error$2;
                   if(j){var j$0=j[1];if(j$0 < i)throw Parse_error$2}
                   var _cH_=repn([8,r],i,j)}
                 else
                  {unget(0);var _cH_=r}}
               else
                var _cH_=r;
            var left$0=[0,_cH_,left],left=left$0;
            continue}
          return seq$1(caml_call1(Stdlib_list[9],left))}}
      function regexp(param)
       {var left=branch(0),left$0=left;
        for(;;)
         {if(accept(124))
           {var left$1=alt$0([0,left$0,[0,branch(0),0]]),left$0=left$1;
            continue}
          return left$0}}
      var r=regexp(0);
      if(1 - eos$0(0))throw Parse_error$2;
      var
       r$0=caml_call2(Stdlib_list[33],886285209,opts)?[10,r]:r,
       r$1=caml_call2(Stdlib_list[33],853495711,opts)?[7,r$0]:r$0;
      return r$1}
    function compile$0(re){return compile(longest(re))}
    function compile_pat$1(opt,s)
     {if(opt)var sth=opt[1],opts=sth;else var opts=0;
      return compile$0(re$2([0,opts],s))}
    var
     Re_Posix=
      [0,Parse_error$2,Not_supported$1,re$2,compile$0,compile_pat$1];
    caml_register_global(162,Re_Posix,"Re__Posix");
    var
     Re$0=
      [0,
       Group,
       compile,
       exec,
       exec_opt,
       execp,
       exec_partial,
       Mark,
       Seq,
       all$0,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split$0,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       replace,
       replace_string,
       str,
       char$0,
       alt$0,
       seq$1,
       empty$2,
       epsilon,
       rep$0,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start$0,
       stop$0,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first$0,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark$0,
       set,
       rg,
       inter$0,
       diff$0,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp$5,
       print_re,
       print_re,
       View,
       witness,
       get$0,
       get_ofs,
       get_all,
       get_all_ofs,
       test$0,
       marked,
       mark_set];
    caml_register_global(163,Re$0,"Re");
    return}
  (function(){return this}()));


//# 1 "../../.js/tyxml.functor/tyxml_f.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call11(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
     {return f.length == 11
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Xml_stream_Malformed_strea=
      caml_string_of_jsbytes("Xml_stream.Malformed_stream"),
     cst_xmlns$1=caml_string_of_jsbytes("xmlns"),
     cst$30=caml_string_of_jsbytes(""),
     cst_xmlns$2=caml_string_of_jsbytes("xmlns"),
     cst$26=caml_string_of_jsbytes(""),
     cst$27=caml_string_of_jsbytes(" -->\n"),
     cst$28=caml_string_of_jsbytes("<!-- "),
     cst$29=caml_string_of_jsbytes("\n"),
     cst$12=caml_string_of_jsbytes(" "),
     cst$13=caml_string_of_jsbytes(" />"),
     cst$14=caml_string_of_jsbytes("<"),
     cst$15=caml_string_of_jsbytes(">"),
     cst$16=caml_string_of_jsbytes("><\/"),
     cst$17=caml_string_of_jsbytes("<"),
     cst$18=caml_string_of_jsbytes(">"),
     cst$19=caml_string_of_jsbytes("<\/"),
     cst$20=caml_string_of_jsbytes(">"),
     cst$21=caml_string_of_jsbytes("<"),
     cst$22=caml_string_of_jsbytes("-->"),
     cst$23=caml_string_of_jsbytes("<!--"),
     cst$24=caml_string_of_jsbytes(";"),
     cst$25=caml_string_of_jsbytes("&"),
     cst$11=caml_string_of_jsbytes(", "),
     cst$10=caml_string_of_jsbytes(" "),
     cst_xmlns=caml_string_of_jsbytes("xmlns"),
     cst_xmlns$0=caml_string_of_jsbytes("xmlns"),
     partial=[12,62,0],
     cst$9=caml_string_of_jsbytes(" "),
     cst_lt$0=caml_string_of_jsbytes("&lt;"),
     cst_gt$4=caml_string_of_jsbytes("&gt;"),
     cst_amp$0=caml_string_of_jsbytes("&amp;"),
     cst_quot$0=caml_string_of_jsbytes("&quot;"),
     cst_Infinity=caml_string_of_jsbytes("Infinity"),
     cst_Infinity$0=caml_string_of_jsbytes("-Infinity"),
     cst_NaN=caml_string_of_jsbytes("NaN"),
     cst$5=caml_string_of_jsbytes("--!>"),
     cst$6=caml_string_of_jsbytes("-->"),
     cst$7=caml_string_of_jsbytes("->"),
     cst$8=caml_string_of_jsbytes(">"),
     cst_gt$0=caml_string_of_jsbytes("&gt;"),
     cst_gt$1=caml_string_of_jsbytes("-&gt;"),
     cst_gt$2=caml_string_of_jsbytes("--&gt;"),
     cst_gt$3=caml_string_of_jsbytes("--!&gt;"),
     cst_1_0=caml_string_of_jsbytes("1.0"),
     cst_UTF_8=caml_string_of_jsbytes("UTF-8"),
     cst_64=caml_string_of_jsbytes("&#64;"),
     cst_lt=caml_string_of_jsbytes("&lt;"),
     cst_gt=caml_string_of_jsbytes("&gt;"),
     cst_amp=caml_string_of_jsbytes("&amp;"),
     cst_quot=caml_string_of_jsbytes("&quot;"),
     cst=caml_string_of_jsbytes("&#"),
     cst$0=caml_string_of_jsbytes(";"),
     cst$1=caml_string_of_jsbytes("--!>"),
     cst$2=caml_string_of_jsbytes("-->"),
     cst$3=caml_string_of_jsbytes("->"),
     cst$4=caml_string_of_jsbytes(">"),
     cst$38=caml_string_of_jsbytes(" "),
     cst$37=caml_string_of_jsbytes(""),
     partial$0=[12,32,[8,[0,0,3],0,0,[12,41,0]]],
     partial$1=[0,0,3],
     cst_none$1=caml_string_of_jsbytes("none"),
     cst_auto$2=caml_string_of_jsbytes("auto"),
     cst$36=caml_string_of_jsbytes("%"),
     cst_strokePaint=caml_string_of_jsbytes("strokePaint"),
     cst_sourceAlpha=caml_string_of_jsbytes("sourceAlpha"),
     cst_fillPaint=caml_string_of_jsbytes("fillPaint"),
     cst_sourceGraphic=caml_string_of_jsbytes("sourceGraphic"),
     cst_backgroundImage=caml_string_of_jsbytes("backgroundImage"),
     cst_backgroundAlpha=caml_string_of_jsbytes("backgroundAlpha"),
     cst_nochange=caml_string_of_jsbytes("nochange"),
     cst_alphabetic$1=caml_string_of_jsbytes("alphabetic"),
     cst_auto$1=caml_string_of_jsbytes("auto"),
     cst_hanging$1=caml_string_of_jsbytes("hanging"),
     cst_mathematical$1=caml_string_of_jsbytes("mathematical"),
     cst_inherit$1=caml_string_of_jsbytes("inherit"),
     cst_middle$1=caml_string_of_jsbytes("middle"),
     cst_central$0=caml_string_of_jsbytes("central"),
     cst_usescript=caml_string_of_jsbytes("usescript"),
     cst_ideographic$1=caml_string_of_jsbytes("ideographic"),
     cst_textbeforeedge=caml_string_of_jsbytes("textbeforeedge"),
     cst_resetsize=caml_string_of_jsbytes("resetsize"),
     cst_textafteredge=caml_string_of_jsbytes("textafteredge"),
     cst_stitch=caml_string_of_jsbytes("stitch"),
     cst_onRequest=caml_string_of_jsbytes("onRequest"),
     cst_repeat=caml_string_of_jsbytes("repeat"),
     cst_wrap=caml_string_of_jsbytes("wrap"),
     cst_remove=caml_string_of_jsbytes("remove"),
     cst_reflect=caml_string_of_jsbytes("reflect"),
     cst_noStitch=caml_string_of_jsbytes("noStitch"),
     cst$35=caml_string_of_jsbytes(""),
     cst_over=caml_string_of_jsbytes("over"),
     cst_none$0=caml_string_of_jsbytes("none"),
     cst_medial=caml_string_of_jsbytes("medial"),
     cst_never=caml_string_of_jsbytes("never"),
     cst_butt=caml_string_of_jsbytes("butt"),
     cst_auto$0=caml_string_of_jsbytes("auto"),
     cst_atop=caml_string_of_jsbytes("atop"),
     cst_arithmetic=caml_string_of_jsbytes("arithmetic"),
     cst_underline=caml_string_of_jsbytes("underline"),
     cst_gamma=caml_string_of_jsbytes("gamma"),
     cst_linear=caml_string_of_jsbytes("linear"),
     cst_overline=caml_string_of_jsbytes("overline"),
     cst_onLoad=caml_string_of_jsbytes("onLoad"),
     cst_turbulence=caml_string_of_jsbytes("turbulence"),
     cst_table=caml_string_of_jsbytes("table"),
     cst_geometricPrecision=caml_string_of_jsbytes("geometricPrecision"),
     cst_optimizeSpeed=caml_string_of_jsbytes("optimizeSpeed"),
     cst_miter=caml_string_of_jsbytes("miter"),
     cst_initial=caml_string_of_jsbytes("initial"),
     cst_start=caml_string_of_jsbytes("start"),
     cst_whenNotActive=caml_string_of_jsbytes("whenNotActive"),
     cst_identity=caml_string_of_jsbytes("identity"),
     cst_skewY=caml_string_of_jsbytes("skewY"),
     cst_skewX=caml_string_of_jsbytes("skewX"),
     cst_square=caml_string_of_jsbytes("square"),
     cst_scale$0=caml_string_of_jsbytes("scale"),
     cst_exact=caml_string_of_jsbytes("exact"),
     cst_perceptual=caml_string_of_jsbytes("perceptual"),
     cst_discrete=caml_string_of_jsbytes("discrete"),
     cst_erode=caml_string_of_jsbytes("erode"),
     cst_middle$0=caml_string_of_jsbytes("middle"),
     cst_round=caml_string_of_jsbytes("round"),
     cst_xor=caml_string_of_jsbytes("xor"),
     cst_XML=caml_string_of_jsbytes("XML"),
     cst_sum=caml_string_of_jsbytes("sum"),
     cst_pad=caml_string_of_jsbytes("pad"),
     cst_out=caml_string_of_jsbytes("out"),
     cst_new=caml_string_of_jsbytes("new"),
     cst_end=caml_string_of_jsbytes("end"),
     cst_CSS=caml_string_of_jsbytes("CSS"),
     cst_in$1=caml_string_of_jsbytes("in"),
     cst_v=caml_string_of_jsbytes("v"),
     cst_r$0=caml_string_of_jsbytes("r"),
     cst_h=caml_string_of_jsbytes("h"),
     cst_g$0=caml_string_of_jsbytes("g"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_a$0=caml_string_of_jsbytes("a"),
     cst_rotate$0=caml_string_of_jsbytes("rotate"),
     cst_disable=caml_string_of_jsbytes("disable"),
     cst_screen=caml_string_of_jsbytes("screen"),
     cst_absolute_colorimetric=caml_string_of_jsbytes("absolute_colorimetric"),
     cst_inherit$0=caml_string_of_jsbytes("inherit"),
     cst_always=caml_string_of_jsbytes("always"),
     cst_spacingAndGlyphs=caml_string_of_jsbytes("spacingAndGlyphs"),
     cst_replace=caml_string_of_jsbytes("replace"),
     cst_multiply=caml_string_of_jsbytes("multiply"),
     cst_spline=caml_string_of_jsbytes("spline"),
     cst_matrix=caml_string_of_jsbytes("matrix"),
     cst_saturation=caml_string_of_jsbytes("saturation"),
     cst_dilate=caml_string_of_jsbytes("dilate"),
     cst_translate=caml_string_of_jsbytes("translate"),
     cst_default=caml_string_of_jsbytes("default"),
     cst_lighten=caml_string_of_jsbytes("lighten"),
     cst_normal=caml_string_of_jsbytes("normal"),
     cst_freeze=caml_string_of_jsbytes("freeze"),
     cst_magnify=caml_string_of_jsbytes("magnify"),
     cst_hueRotate=caml_string_of_jsbytes("hueRotate"),
     cst_spacing$0=caml_string_of_jsbytes("spacing"),
     cst_fractalNoise=caml_string_of_jsbytes("fractalNoise"),
     cst_saturate=caml_string_of_jsbytes("saturate"),
     cst_userSpaceOnUse=caml_string_of_jsbytes("userSpaceOnUse"),
     cst_objectBoundingBox=caml_string_of_jsbytes("objectBoundingBox"),
     cst_darken=caml_string_of_jsbytes("darken"),
     cst_paced=caml_string_of_jsbytes("paced"),
     cst_isolated=caml_string_of_jsbytes("isolated"),
     cst_optimizeLegibility=caml_string_of_jsbytes("optimizeLegibility"),
     cst_luminanceToAlpha=caml_string_of_jsbytes("luminanceToAlpha"),
     cst_line_through=caml_string_of_jsbytes("line-through"),
     cst_other=caml_string_of_jsbytes("other"),
     cst_terminal=caml_string_of_jsbytes("terminal"),
     cst_blink=caml_string_of_jsbytes("blink"),
     cst_stroke_width$0=caml_string_of_jsbytes("stroke-width"),
     cst_stretch=caml_string_of_jsbytes("stretch"),
     cst_bevel=caml_string_of_jsbytes("bevel"),
     cst_duplicate=caml_string_of_jsbytes("duplicate"),
     cst_preserve=caml_string_of_jsbytes("preserve"),
     cst_relative_colorimetric=caml_string_of_jsbytes("relative_colorimetric"),
     cst_after_edge=caml_string_of_jsbytes("after-edge"),
     cst_alphabetic$0=caml_string_of_jsbytes("alphabetic"),
     cst_auto=caml_string_of_jsbytes("auto"),
     cst_hanging$0=caml_string_of_jsbytes("hanging"),
     cst_mathematical$0=caml_string_of_jsbytes("mathematical"),
     cst_inherit=caml_string_of_jsbytes("inherit"),
     cst_middle=caml_string_of_jsbytes("middle"),
     cst_baseline=caml_string_of_jsbytes("baseline"),
     cst_central=caml_string_of_jsbytes("central"),
     cst_ideographic$0=caml_string_of_jsbytes("ideographic"),
     cst_text_before_edge=caml_string_of_jsbytes("text-before-edge"),
     cst_before_edge=caml_string_of_jsbytes("before-edge"),
     cst_text_after_edge=caml_string_of_jsbytes("text-after-edge"),
     cst_http_www_w3_org_1999_xlink=
      caml_string_of_jsbytes("http://www.w3.org/1999/xlink"),
     cst_xmlns_xlink=caml_string_of_jsbytes("xmlns:xlink"),
     cst_http_www_w3_org_2000_svg=
      caml_string_of_jsbytes("http://www.w3.org/2000/svg"),
     cst_xmlns$3=caml_string_of_jsbytes("xmlns"),
     cst_svg$0=caml_string_of_jsbytes("svg"),
     cst_stroke_dasharray=caml_string_of_jsbytes("stroke-dasharray"),
     cst_stroke_linejoin=caml_string_of_jsbytes("stroke-linejoin"),
     cst_stroke_linecap=caml_string_of_jsbytes("stroke-linecap"),
     cst_dominant_baseline=caml_string_of_jsbytes("dominant-baseline"),
     cst_alignment_baseline=caml_string_of_jsbytes("alignment-baseline"),
     cst_arabic_form=caml_string_of_jsbytes("arabic-form"),
     cst_orientation=caml_string_of_jsbytes("orientation"),
     cst_accumulate=caml_string_of_jsbytes("accumulate"),
     cst_additive=caml_string_of_jsbytes("additive"),
     cst_calcMode=caml_string_of_jsbytes("calcMode"),
     cst_fill$0=caml_string_of_jsbytes("fill"),
     cst_restart=caml_string_of_jsbytes("restart"),
     cst_attributeType=caml_string_of_jsbytes("attributeType"),
     cst_xlink_actuate=caml_string_of_jsbytes("xlink:actuate"),
     cst_xlink_show=caml_string_of_jsbytes("xlink:show"),
     cst_type$2=caml_string_of_jsbytes("type"),
     cst_stitchTiles=caml_string_of_jsbytes("stitchTiles"),
     cst_operator$0=caml_string_of_jsbytes("operator"),
     cst_yChannelSelector=caml_string_of_jsbytes("yChannelSelector"),
     cst_xChannelSelector=caml_string_of_jsbytes("xChannelSelector"),
     cst_targetY$0=caml_string_of_jsbytes("targetY"),
     cst_operator=caml_string_of_jsbytes("operator"),
     cst_type$1=caml_string_of_jsbytes("type"),
     cst_type$0=caml_string_of_jsbytes("type"),
     cst_mode=caml_string_of_jsbytes("mode"),
     cst_in2=caml_string_of_jsbytes("in2"),
     cst_in$0=caml_string_of_jsbytes("in"),
     cst_primitiveUnits=caml_string_of_jsbytes("primitiveUnits"),
     cst_maskContentUnits=caml_string_of_jsbytes("maskContentUnits"),
     cst_maskUnits=caml_string_of_jsbytes("maskUnits"),
     cst_clipPathUnits=caml_string_of_jsbytes("clipPathUnits"),
     cst_patternTransform=caml_string_of_jsbytes("patternTransform"),
     cst_patternContentUnits=caml_string_of_jsbytes("patternContentUnits"),
     cst_patternUnits=caml_string_of_jsbytes("patternUnits"),
     cst_offset=caml_string_of_jsbytes("offset"),
     cst_spreadMethod=caml_string_of_jsbytes("spreadMethod"),
     cst_gradientUnits=caml_string_of_jsbytes("gradientUnits"),
     cst_rendering_intent=caml_string_of_jsbytes("rendering-intent"),
     cst_orient=caml_string_of_jsbytes("orient"),
     cst_markerUnits=caml_string_of_jsbytes("markerUnits"),
     cst_spacing=caml_string_of_jsbytes("spacing"),
     cst_method=caml_string_of_jsbytes("method"),
     cst_text_rendering=caml_string_of_jsbytes("text-rendering"),
     cst_text_decoration=caml_string_of_jsbytes("text-decoration"),
     cst_text_anchor=caml_string_of_jsbytes("text-anchor"),
     cst_lengthAdjust=caml_string_of_jsbytes("lengthAdjust"),
     cst_xml_space=caml_string_of_jsbytes("xml:space"),
     cst_data=caml_string_of_jsbytes("data-"),
     cst_zoomAndSpan=caml_string_of_jsbytes("zoomAndSpan"),
     cst_foreignObject=caml_string_of_jsbytes("foreignObject"),
     cst_metadata=caml_string_of_jsbytes("metadata"),
     content_type=caml_string_of_jsbytes("image/svg+xml"),
     version=caml_string_of_jsbytes("SVG 1.1"),
     standard=caml_string_of_jsbytes("http://www.w3.org/TR/svg11/"),
     namespace=caml_string_of_jsbytes("http://www.w3.org/2000/svg"),
     cst_svg=caml_string_of_jsbytes("svg"),
     cst_version=caml_string_of_jsbytes("version"),
     cst_baseProfile=caml_string_of_jsbytes("baseProfile"),
     cst_x=caml_string_of_jsbytes("x"),
     cst_y=caml_string_of_jsbytes("y"),
     cst_width=caml_string_of_jsbytes("width"),
     cst_height=caml_string_of_jsbytes("height"),
     cst_preserveAspectRatio=caml_string_of_jsbytes("preserveAspectRatio"),
     cst_contentScriptType=caml_string_of_jsbytes("contentScriptType"),
     cst_contentStyleType=caml_string_of_jsbytes("contentStyleType"),
     cst_href=caml_string_of_jsbytes("href"),
     cst_xlink_href=caml_string_of_jsbytes("xlink:href"),
     cst_requiredFeatures=caml_string_of_jsbytes("requiredFeatures"),
     cst_requiredExtension=caml_string_of_jsbytes("requiredExtension"),
     cst_systemLanguage=caml_string_of_jsbytes("systemLanguage"),
     cst_externalRessourcesRequired=
      caml_string_of_jsbytes("externalRessourcesRequired"),
     cst_id=caml_string_of_jsbytes("id"),
     cst_xml_base=caml_string_of_jsbytes("xml:base"),
     cst_xml_lang=caml_string_of_jsbytes("xml:lang"),
     cst_type=caml_string_of_jsbytes("type"),
     cst_media=caml_string_of_jsbytes("media"),
     cst_xlink_title=caml_string_of_jsbytes("xlink:title"),
     cst_class=caml_string_of_jsbytes("class"),
     cst_style=caml_string_of_jsbytes("style"),
     cst_transform=caml_string_of_jsbytes("transform"),
     cst_viewBox=caml_string_of_jsbytes("viewBox"),
     cst_d=caml_string_of_jsbytes("d"),
     cst_pathLength=caml_string_of_jsbytes("pathLength"),
     cst_rx=caml_string_of_jsbytes("rx"),
     cst_ry=caml_string_of_jsbytes("ry"),
     cst_cx=caml_string_of_jsbytes("cx"),
     cst_cy=caml_string_of_jsbytes("cy"),
     cst_r=caml_string_of_jsbytes("r"),
     cst_x1=caml_string_of_jsbytes("x1"),
     cst_y1=caml_string_of_jsbytes("y1"),
     cst_x2=caml_string_of_jsbytes("x2"),
     cst_y2=caml_string_of_jsbytes("y2"),
     cst_points=caml_string_of_jsbytes("points"),
     cst_x$0=caml_string_of_jsbytes("x"),
     cst_y$0=caml_string_of_jsbytes("y"),
     cst_dx=caml_string_of_jsbytes("dx"),
     cst_dy=caml_string_of_jsbytes("dy"),
     cst_dx$0=caml_string_of_jsbytes("dx"),
     cst_dy$0=caml_string_of_jsbytes("dy"),
     cst_textLength=caml_string_of_jsbytes("textLength"),
     cst_rotate=caml_string_of_jsbytes("rotate"),
     cst_startOffset=caml_string_of_jsbytes("startOffset"),
     cst_glyphRef=caml_string_of_jsbytes("glyphRef"),
     cst_format=caml_string_of_jsbytes("format"),
     cst_refX=caml_string_of_jsbytes("refX"),
     cst_refY=caml_string_of_jsbytes("refY"),
     cst_markerWidth=caml_string_of_jsbytes("markerWidth"),
     cst_markerHeight=caml_string_of_jsbytes("markerHeight"),
     cst_local=caml_string_of_jsbytes("local"),
     cst_gradientTransform=caml_string_of_jsbytes("gradientTransform"),
     cst_fx=caml_string_of_jsbytes("fx"),
     cst_fy=caml_string_of_jsbytes("fy"),
     cst_filterResUnits=caml_string_of_jsbytes("filterResUnits"),
     cst_result=caml_string_of_jsbytes("result"),
     cst_azimuth=caml_string_of_jsbytes("azimuth"),
     cst_elevation=caml_string_of_jsbytes("elevation"),
     cst_pointsAtX=caml_string_of_jsbytes("pointsAtX"),
     cst_pointsAtY=caml_string_of_jsbytes("pointsAtY"),
     cst_pointsAtZ=caml_string_of_jsbytes("pointsAtZ"),
     cst_specularExponent=caml_string_of_jsbytes("specularExponent"),
     cst_specularConstant=caml_string_of_jsbytes("specularConstant"),
     cst_limitingConeAngle=caml_string_of_jsbytes("limitingConeAngle"),
     cst_values=caml_string_of_jsbytes("values"),
     cst_tableValues=caml_string_of_jsbytes("tableValues"),
     cst_intercept=caml_string_of_jsbytes("intercept"),
     cst_amplitude=caml_string_of_jsbytes("amplitude"),
     cst_exponent=caml_string_of_jsbytes("exponent"),
     cst_offset$0=caml_string_of_jsbytes("offset"),
     cst_k1=caml_string_of_jsbytes("k1"),
     cst_k2=caml_string_of_jsbytes("k2"),
     cst_k3=caml_string_of_jsbytes("k3"),
     cst_k4=caml_string_of_jsbytes("k4"),
     cst_order=caml_string_of_jsbytes("order"),
     cst_kernelMatrix=caml_string_of_jsbytes("kernelMatrix"),
     cst_divisor=caml_string_of_jsbytes("divisor"),
     cst_bias=caml_string_of_jsbytes("bias"),
     cst_kernelUnitLength=caml_string_of_jsbytes("kernelUnitLength"),
     cst_targetX=caml_string_of_jsbytes("targetX"),
     cst_targetY=caml_string_of_jsbytes("targetY"),
     cst_preserveAlpha=caml_string_of_jsbytes("preserveAlpha"),
     cst_surfaceScale=caml_string_of_jsbytes("surfaceScale"),
     cst_diffuseConstant=caml_string_of_jsbytes("diffuseConstant"),
     cst_scale=caml_string_of_jsbytes("scale"),
     cst_stdDeviation=caml_string_of_jsbytes("stdDeviation"),
     cst_radius=caml_string_of_jsbytes("radius"),
     cst_baseFrequency=caml_string_of_jsbytes("baseFrequency"),
     cst_numOctaves=caml_string_of_jsbytes("numOctaves"),
     cst_seed=caml_string_of_jsbytes("seed"),
     cst_xlink_target=caml_string_of_jsbytes("xlink:target"),
     cst_viewTarget=caml_string_of_jsbytes("viewTarget"),
     cst_attributeName=caml_string_of_jsbytes("attributeName"),
     cst_begin=caml_string_of_jsbytes("begin"),
     cst_dur=caml_string_of_jsbytes("dur"),
     cst_min=caml_string_of_jsbytes("min"),
     cst_max=caml_string_of_jsbytes("max"),
     cst_repeatCount=caml_string_of_jsbytes("repeatCount"),
     cst_repeatDur=caml_string_of_jsbytes("repeatDur"),
     cst_fill=caml_string_of_jsbytes("fill"),
     cst_values$0=caml_string_of_jsbytes("values"),
     cst_keyTimes=caml_string_of_jsbytes("keyTimes"),
     cst_keySplines=caml_string_of_jsbytes("keySplines"),
     cst_from=caml_string_of_jsbytes("from"),
     cst_to=caml_string_of_jsbytes("to"),
     cst_by=caml_string_of_jsbytes("by"),
     cst_keyPoints=caml_string_of_jsbytes("keyPoints"),
     cst_path=caml_string_of_jsbytes("path"),
     cst_type$3=caml_string_of_jsbytes("type"),
     cst_horiz_origin_x=caml_string_of_jsbytes("horiz-origin-x"),
     cst_horiz_origin_y=caml_string_of_jsbytes("horiz-origin-y"),
     cst_horiz_adv_x=caml_string_of_jsbytes("horiz-adv-x"),
     cst_vert_origin_x=caml_string_of_jsbytes("vert-origin-x"),
     cst_vert_origin_y=caml_string_of_jsbytes("vert-origin-y"),
     cst_vert_adv_y=caml_string_of_jsbytes("vert-adv-y"),
     cst_unicode=caml_string_of_jsbytes("unicode"),
     cst_glyphname=caml_string_of_jsbytes("glyphname"),
     cst_lang=caml_string_of_jsbytes("lang"),
     cst_u1=caml_string_of_jsbytes("u1"),
     cst_u2=caml_string_of_jsbytes("u2"),
     cst_g1=caml_string_of_jsbytes("g1"),
     cst_g2=caml_string_of_jsbytes("g2"),
     cst_k=caml_string_of_jsbytes("k"),
     cst_font_family=caml_string_of_jsbytes("font-family"),
     cst_font_style=caml_string_of_jsbytes("font-style"),
     cst_font_variant=caml_string_of_jsbytes("font-variant"),
     cst_font_weight=caml_string_of_jsbytes("font-weight"),
     cst_font_stretch=caml_string_of_jsbytes("font-stretch"),
     cst_font_size=caml_string_of_jsbytes("font-size"),
     cst_unicode_range=caml_string_of_jsbytes("unicode-range"),
     cst_units_per_em=caml_string_of_jsbytes("units-per-em"),
     cst_stemv=caml_string_of_jsbytes("stemv"),
     cst_stemh=caml_string_of_jsbytes("stemh"),
     cst_slope=caml_string_of_jsbytes("slope"),
     cst_cap_height=caml_string_of_jsbytes("cap-height"),
     cst_x_height=caml_string_of_jsbytes("x-height"),
     cst_accent_height=caml_string_of_jsbytes("accent-height"),
     cst_ascent=caml_string_of_jsbytes("ascent"),
     cst_widths=caml_string_of_jsbytes("widths"),
     cst_bbox=caml_string_of_jsbytes("bbox"),
     cst_ideographic=caml_string_of_jsbytes("ideographic"),
     cst_alphabetic=caml_string_of_jsbytes("alphabetic"),
     cst_mathematical=caml_string_of_jsbytes("mathematical"),
     cst_hanging=caml_string_of_jsbytes("hanging"),
     cst_v_ideographic=caml_string_of_jsbytes("v-ideographic"),
     cst_v_alphabetic=caml_string_of_jsbytes("v-alphabetic"),
     cst_v_mathematical=caml_string_of_jsbytes("v-mathematical"),
     cst_v_hanging=caml_string_of_jsbytes("v-hanging"),
     cst_underline_position=caml_string_of_jsbytes("underline-position"),
     cst_underline_thickness=caml_string_of_jsbytes("underline-thickness"),
     cst_strikethrough_position=
      caml_string_of_jsbytes("strikethrough-position"),
     cst_strikethrough_thickness=
      caml_string_of_jsbytes("strikethrough-thickness"),
     cst_overline_position=caml_string_of_jsbytes("overline-position"),
     cst_overline_thickness=caml_string_of_jsbytes("overline-thickness"),
     cst_string=caml_string_of_jsbytes("string"),
     cst_name=caml_string_of_jsbytes("name"),
     cst_onabort=caml_string_of_jsbytes("onabort"),
     cst_onactivate=caml_string_of_jsbytes("onactivate"),
     cst_onbegin=caml_string_of_jsbytes("onbegin"),
     cst_onend=caml_string_of_jsbytes("onend"),
     cst_onerror=caml_string_of_jsbytes("onerror"),
     cst_onfocusin=caml_string_of_jsbytes("onfocusin"),
     cst_onfocusout=caml_string_of_jsbytes("onfocusout"),
     cst_onload=caml_string_of_jsbytes("onload"),
     cst_onrepeat=caml_string_of_jsbytes("onrepeat"),
     cst_onresize=caml_string_of_jsbytes("onresize"),
     cst_onscroll=caml_string_of_jsbytes("onscroll"),
     cst_onunload=caml_string_of_jsbytes("onunload"),
     cst_onzoom=caml_string_of_jsbytes("onzoom"),
     cst_onclick=caml_string_of_jsbytes("onclick"),
     cst_onmousedown=caml_string_of_jsbytes("onmousedown"),
     cst_onmouseup=caml_string_of_jsbytes("onmouseup"),
     cst_onmouseover=caml_string_of_jsbytes("onmouseover"),
     cst_onmouseout=caml_string_of_jsbytes("onmouseout"),
     cst_onmousemove=caml_string_of_jsbytes("onmousemove"),
     cst_ontouchstart=caml_string_of_jsbytes("ontouchstart"),
     cst_ontouchend=caml_string_of_jsbytes("ontouchend"),
     cst_ontouchmove=caml_string_of_jsbytes("ontouchmove"),
     cst_ontouchcancel=caml_string_of_jsbytes("ontouchcancel"),
     cst_stop_color=caml_string_of_jsbytes("stop-color"),
     cst_stop_opacity=caml_string_of_jsbytes("stop-opacity"),
     cst_stroke=caml_string_of_jsbytes("stroke"),
     cst_stroke_width=caml_string_of_jsbytes("stroke-width"),
     cst_stroke_miterlimit=caml_string_of_jsbytes("stroke-miterlimit"),
     cst_stroke_dashoffset=caml_string_of_jsbytes("stroke-dashoffset"),
     cst_stroke_opacity=caml_string_of_jsbytes("stroke-opacity"),
     cst_g=caml_string_of_jsbytes("g"),
     cst_defs=caml_string_of_jsbytes("defs"),
     cst_desc=caml_string_of_jsbytes("desc"),
     cst_title=caml_string_of_jsbytes("title"),
     cst_symbol=caml_string_of_jsbytes("symbol"),
     cst_use=caml_string_of_jsbytes("use"),
     cst_image=caml_string_of_jsbytes("image"),
     cst_switch=caml_string_of_jsbytes("switch"),
     cst_style$0=caml_string_of_jsbytes("style"),
     cst_path$0=caml_string_of_jsbytes("path"),
     cst_rect=caml_string_of_jsbytes("rect"),
     cst_circle=caml_string_of_jsbytes("circle"),
     cst_ellipse=caml_string_of_jsbytes("ellipse"),
     cst_line=caml_string_of_jsbytes("line"),
     cst_polyline=caml_string_of_jsbytes("polyline"),
     cst_polygon=caml_string_of_jsbytes("polygon"),
     cst_text=caml_string_of_jsbytes("text"),
     cst_tspan=caml_string_of_jsbytes("tspan"),
     cst_tref=caml_string_of_jsbytes("tref"),
     cst_textPath=caml_string_of_jsbytes("textPath"),
     cst_altGlyph=caml_string_of_jsbytes("altGlyph"),
     cst_altGlyphDef=caml_string_of_jsbytes("altGlyphDef"),
     cst_altGlyphItem=caml_string_of_jsbytes("altGlyphItem"),
     cst_glyphRef$0=caml_string_of_jsbytes("glyphRef"),
     cst_marker=caml_string_of_jsbytes("marker"),
     cst_color_profile=caml_string_of_jsbytes("color-profile"),
     cst_linearGradient=caml_string_of_jsbytes("linearGradient"),
     cst_radialGradient=caml_string_of_jsbytes("radialGradient"),
     cst_stop=caml_string_of_jsbytes("stop"),
     cst_pattern=caml_string_of_jsbytes("pattern"),
     cst_clipPath=caml_string_of_jsbytes("clipPath"),
     cst_filter=caml_string_of_jsbytes("filter"),
     cst_feDistantLight=caml_string_of_jsbytes("feDistantLight"),
     cst_fePointLight=caml_string_of_jsbytes("fePointLight"),
     cst_feSpotLight=caml_string_of_jsbytes("feSpotLight"),
     cst_feBlend=caml_string_of_jsbytes("feBlend"),
     cst_feColorMatrix=caml_string_of_jsbytes("feColorMatrix"),
     cst_feComponentTransfer=caml_string_of_jsbytes("feComponentTransfer"),
     cst_feFuncA=caml_string_of_jsbytes("feFuncA"),
     cst_feFuncG=caml_string_of_jsbytes("feFuncG"),
     cst_feFuncB=caml_string_of_jsbytes("feFuncB"),
     cst_feFuncR=caml_string_of_jsbytes("feFuncR"),
     cst_feComposite=caml_string_of_jsbytes("feComposite"),
     cst_feConvolveMatrix=caml_string_of_jsbytes("feConvolveMatrix"),
     cst_feDiffuseLighting=caml_string_of_jsbytes("feDiffuseLighting"),
     cst_feDisplacementMap=caml_string_of_jsbytes("feDisplacementMap"),
     cst_feFlood=caml_string_of_jsbytes("feFlood"),
     cst_feGaussianBlur=caml_string_of_jsbytes("feGaussianBlur"),
     cst_feImage=caml_string_of_jsbytes("feImage"),
     cst_feMerge=caml_string_of_jsbytes("feMerge"),
     cst_feMorphology=caml_string_of_jsbytes("feMorphology"),
     cst_feOffset=caml_string_of_jsbytes("feOffset"),
     cst_feSpecularLighting=caml_string_of_jsbytes("feSpecularLighting"),
     cst_feTile=caml_string_of_jsbytes("feTile"),
     cst_feTurbulence=caml_string_of_jsbytes("feTurbulence"),
     cst_cursor=caml_string_of_jsbytes("cursor"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_view=caml_string_of_jsbytes("view"),
     cst_script=caml_string_of_jsbytes("script"),
     cst_animate=caml_string_of_jsbytes("animate"),
     cst_set=caml_string_of_jsbytes("set"),
     cst_animateMotion=caml_string_of_jsbytes("animateMotion"),
     cst_mpath=caml_string_of_jsbytes("mpath"),
     cst_animateColor=caml_string_of_jsbytes("animateColor"),
     cst_animateTransform=caml_string_of_jsbytes("animateTransform"),
     cst_font=caml_string_of_jsbytes("font"),
     cst_glyph=caml_string_of_jsbytes("glyph"),
     cst_missing_glyph=caml_string_of_jsbytes("missing-glyph"),
     cst_hkern=caml_string_of_jsbytes("hkern"),
     cst_vkern=caml_string_of_jsbytes("vkern"),
     cst_font_face=caml_string_of_jsbytes("font-face"),
     cst_font_face_src=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_uri=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_uri$0=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_name=caml_string_of_jsbytes("font-face-name"),
     cst$34=caml_string_of_jsbytes(" "),
     cst_none=caml_string_of_jsbytes("none"),
     cst_currentColor=caml_string_of_jsbytes("currentColor"),
     cst$33=caml_string_of_jsbytes(" "),
     sep=caml_string_of_jsbytes(" "),
     cst_px=caml_string_of_jsbytes("px"),
     cst_pt=caml_string_of_jsbytes("pt"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst_in=caml_string_of_jsbytes("in"),
     cst_mm=caml_string_of_jsbytes("mm"),
     cst_ex=caml_string_of_jsbytes("ex"),
     cst_em=caml_string_of_jsbytes("em"),
     cst_cm=caml_string_of_jsbytes("cm"),
     cst$32=caml_string_of_jsbytes("%"),
     cst_grad=caml_string_of_jsbytes("grad"),
     cst_deg=caml_string_of_jsbytes("deg"),
     cst_rad=caml_string_of_jsbytes("rad"),
     cst$31=caml_string_of_jsbytes(""),
     cst$46=caml_string_of_jsbytes(", "),
     cst$45=caml_string_of_jsbytes(" "),
     cst$44=caml_string_of_jsbytes(", "),
     cst$43=caml_string_of_jsbytes(","),
     cst$42=caml_string_of_jsbytes(" "),
     cst$41=caml_string_of_jsbytes(" "),
     cst_any$1=caml_string_of_jsbytes("any"),
     cst_any$0=caml_string_of_jsbytes("any"),
     cst$40=caml_string_of_jsbytes(""),
     cst_on=caml_string_of_jsbytes("on"),
     cst_off=caml_string_of_jsbytes("off"),
     cst_week=caml_string_of_jsbytes("week"),
     cst_time$0=caml_string_of_jsbytes("time"),
     cst_text$0=caml_string_of_jsbytes("text"),
     cst_file=caml_string_of_jsbytes("file"),
     cst_date=caml_string_of_jsbytes("date"),
     cst_datetime_local=caml_string_of_jsbytes("datetime-local"),
     cst_password=caml_string_of_jsbytes("password"),
     cst_month=caml_string_of_jsbytes("month"),
     cst_search$1=caml_string_of_jsbytes("search"),
     cst_button$0=caml_string_of_jsbytes("button"),
     cst_checkbox$0=caml_string_of_jsbytes("checkbox"),
     cst_email$0=caml_string_of_jsbytes("email"),
     cst_hidden$1=caml_string_of_jsbytes("hidden"),
     cst_url$0=caml_string_of_jsbytes("url"),
     cst_tel$0=caml_string_of_jsbytes("tel"),
     cst_reset=caml_string_of_jsbytes("reset"),
     cst_range=caml_string_of_jsbytes("range"),
     cst_radio$0=caml_string_of_jsbytes("radio"),
     cst_readonly$1=caml_string_of_jsbytes("readonly"),
     cst_color=caml_string_of_jsbytes("color"),
     cst_number=caml_string_of_jsbytes("number"),
     cst_image$0=caml_string_of_jsbytes("image"),
     cst_submit=caml_string_of_jsbytes("submit"),
     cst_datetime$0=caml_string_of_jsbytes("datetime"),
     cst_external$0=caml_string_of_jsbytes("external"),
     cst_0=caml_string_of_jsbytes("0"),
     cst_formnovalidate$0=caml_string_of_jsbytes("formnovalidate"),
     cst_audio$0=caml_string_of_jsbytes("audio"),
     cst_async$0=caml_string_of_jsbytes("async"),
     cst_toolbar=caml_string_of_jsbytes("toolbar"),
     cst_soft=caml_string_of_jsbytes("soft"),
     cst_rows$0=caml_string_of_jsbytes("rows"),
     cst_rect$0=caml_string_of_jsbytes("rect"),
     cst_prev$0=caml_string_of_jsbytes("prev"),
     cst_POST=caml_string_of_jsbytes("POST"),
     cst_poly=caml_string_of_jsbytes("poly"),
     cst_open$0=caml_string_of_jsbytes("open"),
     cst_none$2=caml_string_of_jsbytes("none"),
     cst_next$0=caml_string_of_jsbytes("next"),
     cst_loop$0=caml_string_of_jsbytes("loop"),
     cst_left=caml_string_of_jsbytes("left"),
     cst_last$0=caml_string_of_jsbytes("last"),
     cst_kana=caml_string_of_jsbytes("kana"),
     cst_icon$1=caml_string_of_jsbytes("icon"),
     cst_help$0=caml_string_of_jsbytes("help"),
     cst_hard=caml_string_of_jsbytes("hard"),
     cst_cols$0=caml_string_of_jsbytes("cols"),
     cst_char$0=caml_string_of_jsbytes("char"),
     cst_auto$3=caml_string_of_jsbytes("auto"),
     cst_noreferrer$0=caml_string_of_jsbytes("noreferrer"),
     cst_author$0=caml_string_of_jsbytes("author"),
     cst_muted$0=caml_string_of_jsbytes("muted"),
     cst_autoplay$0=caml_string_of_jsbytes("autoplay"),
     cst_anonymous=caml_string_of_jsbytes("anonymous"),
     cst_metadata$0=caml_string_of_jsbytes("metadata"),
     cst_license$0=caml_string_of_jsbytes("license"),
     cst_search$0=caml_string_of_jsbytes("search"),
     cst_first$0=caml_string_of_jsbytes("first"),
     cst_novalidate$0=caml_string_of_jsbytes("novalidate"),
     cst_controls$0=caml_string_of_jsbytes("controls"),
     cst_bookmark$0=caml_string_of_jsbytes("bookmark"),
     cst_required$0=caml_string_of_jsbytes("required"),
     cst_selected$0=caml_string_of_jsbytes("selected"),
     cst_circle$0=caml_string_of_jsbytes("circle"),
     cst_rowgroup=caml_string_of_jsbytes("rowgroup"),
     cst_checkbox=caml_string_of_jsbytes("checkbox"),
     cst_katakana=caml_string_of_jsbytes("katakana"),
     cst_email=caml_string_of_jsbytes("email"),
     cst_latin=caml_string_of_jsbytes("latin"),
     cst_hidden$0=caml_string_of_jsbytes("hidden"),
     cst_yes=caml_string_of_jsbytes("yes"),
     cst_url=caml_string_of_jsbytes("url"),
     cst_tel=caml_string_of_jsbytes("tel"),
     cst_tag$0=caml_string_of_jsbytes("tag"),
     cst_rtl=caml_string_of_jsbytes("rtl"),
     cst_row=caml_string_of_jsbytes("row"),
     cst_1=caml_string_of_jsbytes("1"),
     cst_ltr=caml_string_of_jsbytes("ltr"),
     cst_GET=caml_string_of_jsbytes("GET"),
     cst_col$0=caml_string_of_jsbytes("col"),
     cst_any=caml_string_of_jsbytes("any"),
     cst_all$0=caml_string_of_jsbytes("all"),
     cst_up$0=caml_string_of_jsbytes("up"),
     cst_no=caml_string_of_jsbytes("no"),
     cst_right=caml_string_of_jsbytes("right"),
     cst_scoped$0=caml_string_of_jsbytes("scoped"),
     cst_numeric=caml_string_of_jsbytes("numeric"),
     cst_pingback$0=caml_string_of_jsbytes("pingback"),
     cst_radio=caml_string_of_jsbytes("radio"),
     cst_pubdate$0=caml_string_of_jsbytes("pubdate"),
     cst_multiple$0=caml_string_of_jsbytes("multiple"),
     cst_latin_name=caml_string_of_jsbytes("latin-name"),
     cst_autofocus$0=caml_string_of_jsbytes("autofocus"),
     cst_nofollow$0=caml_string_of_jsbytes("nofollow"),
     cst_defer$0=caml_string_of_jsbytes("defer"),
     cst_full_width_latin=caml_string_of_jsbytes("full-width-latin"),
     cst_default$0=caml_string_of_jsbytes("default"),
     cst_context=caml_string_of_jsbytes("context"),
     cst_verbatim=caml_string_of_jsbytes("verbatim"),
     cst_checked$0=caml_string_of_jsbytes("checked"),
     cst_stylesheet$0=caml_string_of_jsbytes("stylesheet"),
     cst_reserved$0=caml_string_of_jsbytes("reserved"),
     cst_alternate$0=caml_string_of_jsbytes("alternate"),
     cst_http_www_w3_org_1999_xhtml=
      caml_string_of_jsbytes("http://www.w3.org/1999/xhtml"),
     cst_disabled$0=caml_string_of_jsbytes("disabled"),
     cst_ismap$0=caml_string_of_jsbytes("ismap"),
     cst_use_credentials=caml_string_of_jsbytes("use-credentials"),
     cst_index$0=caml_string_of_jsbytes("index"),
     cst_justify=caml_string_of_jsbytes("justify"),
     cst_groups=caml_string_of_jsbytes("groups"),
     cst_command$0=caml_string_of_jsbytes("command"),
     cst_sidebar$0=caml_string_of_jsbytes("sidebar"),
     cst_latin_prose=caml_string_of_jsbytes("latin-prose"),
     cst_readonly$0=caml_string_of_jsbytes("readonly"),
     cst_colgroup$0=caml_string_of_jsbytes("colgroup"),
     cst_archives$0=caml_string_of_jsbytes("archives"),
     cst_seamless$0=caml_string_of_jsbytes("seamless"),
     cst_preserve$0=caml_string_of_jsbytes("preserve"),
     cst_prefetch$0=caml_string_of_jsbytes("prefetch"),
     cst_same_origin=caml_string_of_jsbytes("same-origin"),
     cst_origin_when_cross_origin=
      caml_string_of_jsbytes("origin-when-cross-origin"),
     cst_no_referrer_when_downgrade=
      caml_string_of_jsbytes("no-referrer-when-downgrade"),
     cst_no_referrer=caml_string_of_jsbytes("no-referrer"),
     cst_unsafe_url=caml_string_of_jsbytes("unsafe-url"),
     cst$39=caml_string_of_jsbytes(""),
     cst_origin=caml_string_of_jsbytes("origin"),
     cst_strict_origin=caml_string_of_jsbytes("strict-origin"),
     cst_strict_origin_when_cross_o=
      caml_string_of_jsbytes("strict-origin-when-cross-origin"),
     cst_projection=caml_string_of_jsbytes("projection"),
     cst_aural=caml_string_of_jsbytes("aural"),
     cst_handheld=caml_string_of_jsbytes("handheld"),
     cst_embossed=caml_string_of_jsbytes("embossed"),
     cst_tty=caml_string_of_jsbytes("tty"),
     cst_all=caml_string_of_jsbytes("all"),
     cst_tv=caml_string_of_jsbytes("tv"),
     cst_screen$0=caml_string_of_jsbytes("screen"),
     cst_speech=caml_string_of_jsbytes("speech"),
     cst_print=caml_string_of_jsbytes("print"),
     cst_braille=caml_string_of_jsbytes("braille"),
     cst_external=caml_string_of_jsbytes("external"),
     cst_canonical=caml_string_of_jsbytes("canonical"),
     cst_prev=caml_string_of_jsbytes("prev"),
     cst_next=caml_string_of_jsbytes("next"),
     cst_last=caml_string_of_jsbytes("last"),
     cst_icon$0=caml_string_of_jsbytes("icon"),
     cst_help=caml_string_of_jsbytes("help"),
     cst_noreferrer=caml_string_of_jsbytes("noreferrer"),
     cst_author=caml_string_of_jsbytes("author"),
     cst_license=caml_string_of_jsbytes("license"),
     cst_search=caml_string_of_jsbytes("search"),
     cst_noopener=caml_string_of_jsbytes("noopener"),
     cst_first=caml_string_of_jsbytes("first"),
     cst_bookmark=caml_string_of_jsbytes("bookmark"),
     cst_tag=caml_string_of_jsbytes("tag"),
     cst_up=caml_string_of_jsbytes("up"),
     cst_pingback=caml_string_of_jsbytes("pingback"),
     cst_nofollow=caml_string_of_jsbytes("nofollow"),
     cst_stylesheet=caml_string_of_jsbytes("stylesheet"),
     cst_alternate=caml_string_of_jsbytes("alternate"),
     cst_index=caml_string_of_jsbytes("index"),
     cst_sidebar=caml_string_of_jsbytes("sidebar"),
     cst_archives=caml_string_of_jsbytes("archives"),
     cst_prefetch=caml_string_of_jsbytes("prefetch"),
     cst_allow_same_origin=caml_string_of_jsbytes("allow-same-origin"),
     cst_allow_popups=caml_string_of_jsbytes("allow-popups"),
     cst_allow_forms=caml_string_of_jsbytes("allow-forms"),
     cst_allow_pointer_lock=caml_string_of_jsbytes("allow-pointer-lock"),
     cst_allow_script=caml_string_of_jsbytes("allow-script"),
     cst_allow_top_navigation=caml_string_of_jsbytes("allow-top-navigation"),
     cst_link=caml_string_of_jsbytes("link"),
     cst_style$2=caml_string_of_jsbytes("style"),
     cst_img=caml_string_of_jsbytes("img"),
     cst_object=caml_string_of_jsbytes("object"),
     cst_table$0=caml_string_of_jsbytes("table"),
     cst_figure=caml_string_of_jsbytes("figure"),
     cst_optgroup=caml_string_of_jsbytes("optgroup"),
     cst_fieldset=caml_string_of_jsbytes("fieldset"),
     cst_details=caml_string_of_jsbytes("details"),
     cst_datalist=caml_string_of_jsbytes("datalist"),
     cst_menu=caml_string_of_jsbytes("menu"),
     cst_command=caml_string_of_jsbytes("command"),
     cst_area=caml_string_of_jsbytes("area"),
     cst_coords=caml_string_of_jsbytes("coords"),
     cst_shape=caml_string_of_jsbytes("shape"),
     cst_bdo=caml_string_of_jsbytes("bdo"),
     cst_nbsp=caml_string_of_jsbytes("nbsp"),
     cst_html$0=caml_string_of_jsbytes("html"),
     cst_aria=caml_string_of_jsbytes("aria-"),
     cst_scrolling=caml_string_of_jsbytes("scrolling"),
     cst_frameborder=caml_string_of_jsbytes("frameborder"),
     cst_char=caml_string_of_jsbytes("char"),
     cst_rules=caml_string_of_jsbytes("rules"),
     cst_scope=caml_string_of_jsbytes("scope"),
     cst_align=caml_string_of_jsbytes("align"),
     cst_type$8=caml_string_of_jsbytes("type"),
     cst_type$7=caml_string_of_jsbytes("type"),
     cst_type$6=caml_string_of_jsbytes("type"),
     cst_type$5=caml_string_of_jsbytes("type"),
     cst_wrap$0=caml_string_of_jsbytes("wrap"),
     cst_step=caml_string_of_jsbytes("step"),
     cst_sizes=caml_string_of_jsbytes("sizes"),
     cst_spellcheck=caml_string_of_jsbytes("spellcheck"),
     cst_sandbox=caml_string_of_jsbytes("sandbox"),
     cst_preload=caml_string_of_jsbytes("preload"),
     cst_inputmode=caml_string_of_jsbytes("inputmode"),
     cst_draggable=caml_string_of_jsbytes("draggable"),
     cst_dir=caml_string_of_jsbytes("dir"),
     cst_contenteditable=caml_string_of_jsbytes("contenteditable"),
     cst_crossorigin=caml_string_of_jsbytes("crossorigin"),
     cst_autocomplete=caml_string_of_jsbytes("autocomplete"),
     cst_referrerpolicy=caml_string_of_jsbytes("referrerpolicy"),
     cst_method$0=caml_string_of_jsbytes("method"),
     cst_width$0=caml_string_of_jsbytes("width"),
     cst_height$0=caml_string_of_jsbytes("height"),
     cst_download=caml_string_of_jsbytes("download"),
     cst_accesskey=caml_string_of_jsbytes("accesskey"),
     cst_xml_space$0=caml_string_of_jsbytes("xml:space"),
     cst_xmlns$4=caml_string_of_jsbytes("xmlns"),
     cst_data$0=caml_string_of_jsbytes("data-"),
     content_type$0=caml_string_of_jsbytes("text/html"),
     alternative_content_types=
      [0,
       caml_string_of_jsbytes("application/xhtml+xml"),
       [0,
        caml_string_of_jsbytes("application/xml"),
        [0,caml_string_of_jsbytes("text/xml"),0]]],
     version$0=caml_string_of_jsbytes("HTML5-draft"),
     standard$0=caml_string_of_jsbytes("http://www.w3.org/TR/html5/"),
     namespace$0=caml_string_of_jsbytes("http://www.w3.org/1999/xhtml"),
     cst_html=caml_string_of_jsbytes("html"),
     emptytags=
      caml_list_of_js_array
       ([caml_string_of_jsbytes("area"),
         caml_string_of_jsbytes("base"),
         caml_string_of_jsbytes("br"),
         caml_string_of_jsbytes("col"),
         caml_string_of_jsbytes("command"),
         caml_string_of_jsbytes("embed"),
         caml_string_of_jsbytes("hr"),
         caml_string_of_jsbytes("img"),
         caml_string_of_jsbytes("input"),
         caml_string_of_jsbytes("keygen"),
         caml_string_of_jsbytes("link"),
         caml_string_of_jsbytes("meta"),
         caml_string_of_jsbytes("param"),
         caml_string_of_jsbytes("source"),
         caml_string_of_jsbytes("wbr")]),
     cst_class$0=caml_string_of_jsbytes("class"),
     cst_id$0=caml_string_of_jsbytes("id"),
     cst_title$0=caml_string_of_jsbytes("title"),
     cst_xml_lang$0=caml_string_of_jsbytes("xml:lang"),
     cst_lang$0=caml_string_of_jsbytes("lang"),
     cst_style$1=caml_string_of_jsbytes("style"),
     cst_property=caml_string_of_jsbytes("property"),
     cst_onabort$0=caml_string_of_jsbytes("onabort"),
     cst_onafterprint=caml_string_of_jsbytes("onafterprint"),
     cst_onbeforeprint=caml_string_of_jsbytes("onbeforeprint"),
     cst_onbeforeunload=caml_string_of_jsbytes("onbeforeunload"),
     cst_onblur=caml_string_of_jsbytes("onblur"),
     cst_oncanplay=caml_string_of_jsbytes("oncanplay"),
     cst_oncanplaythrough=caml_string_of_jsbytes("oncanplaythrough"),
     cst_onchange=caml_string_of_jsbytes("onchange"),
     cst_ondurationchange=caml_string_of_jsbytes("ondurationchange"),
     cst_onemptied=caml_string_of_jsbytes("onemptied"),
     cst_onended=caml_string_of_jsbytes("onended"),
     cst_onerror$0=caml_string_of_jsbytes("onerror"),
     cst_onfocus=caml_string_of_jsbytes("onfocus"),
     cst_onformchange=caml_string_of_jsbytes("onformchange"),
     cst_onforminput=caml_string_of_jsbytes("onforminput"),
     cst_onhashchange=caml_string_of_jsbytes("onhashchange"),
     cst_oninput=caml_string_of_jsbytes("oninput"),
     cst_oninvalid=caml_string_of_jsbytes("oninvalid"),
     cst_onoffline=caml_string_of_jsbytes("onoffline"),
     cst_ononline=caml_string_of_jsbytes("ononline"),
     cst_onpause=caml_string_of_jsbytes("onpause"),
     cst_onplay=caml_string_of_jsbytes("onplay"),
     cst_onplaying=caml_string_of_jsbytes("onplaying"),
     cst_onpagehide=caml_string_of_jsbytes("onpagehide"),
     cst_onpageshow=caml_string_of_jsbytes("onpageshow"),
     cst_onpopstate=caml_string_of_jsbytes("onpopstate"),
     cst_onprogress=caml_string_of_jsbytes("onprogress"),
     cst_onratechange=caml_string_of_jsbytes("onratechange"),
     cst_onreadystatechange=caml_string_of_jsbytes("onreadystatechange"),
     cst_onredo=caml_string_of_jsbytes("onredo"),
     cst_onresize$0=caml_string_of_jsbytes("onresize"),
     cst_onscroll$0=caml_string_of_jsbytes("onscroll"),
     cst_onseeked=caml_string_of_jsbytes("onseeked"),
     cst_onseeking=caml_string_of_jsbytes("onseeking"),
     cst_onselect=caml_string_of_jsbytes("onselect"),
     cst_onshow=caml_string_of_jsbytes("onshow"),
     cst_onstalled=caml_string_of_jsbytes("onstalled"),
     cst_onstorage=caml_string_of_jsbytes("onstorage"),
     cst_onsubmit=caml_string_of_jsbytes("onsubmit"),
     cst_onsuspend=caml_string_of_jsbytes("onsuspend"),
     cst_ontimeupdate=caml_string_of_jsbytes("ontimeupdate"),
     cst_onundo=caml_string_of_jsbytes("onundo"),
     cst_onunload$0=caml_string_of_jsbytes("onunload"),
     cst_onvolumechange=caml_string_of_jsbytes("onvolumechange"),
     cst_onwaiting=caml_string_of_jsbytes("onwaiting"),
     cst_onload$0=caml_string_of_jsbytes("onload"),
     cst_onloadeddata=caml_string_of_jsbytes("onloadeddata"),
     cst_onloadedmetadata=caml_string_of_jsbytes("onloadedmetadata"),
     cst_onloadstart=caml_string_of_jsbytes("onloadstart"),
     cst_onmessage=caml_string_of_jsbytes("onmessage"),
     cst_onmousewheel=caml_string_of_jsbytes("onmousewheel"),
     cst_onclick$0=caml_string_of_jsbytes("onclick"),
     cst_oncontextmenu=caml_string_of_jsbytes("oncontextmenu"),
     cst_ondblclick=caml_string_of_jsbytes("ondblclick"),
     cst_ondrag=caml_string_of_jsbytes("ondrag"),
     cst_ondragend=caml_string_of_jsbytes("ondragend"),
     cst_ondragenter=caml_string_of_jsbytes("ondragenter"),
     cst_ondragleave=caml_string_of_jsbytes("ondragleave"),
     cst_ondragover=caml_string_of_jsbytes("ondragover"),
     cst_ondragstart=caml_string_of_jsbytes("ondragstart"),
     cst_ondrop=caml_string_of_jsbytes("ondrop"),
     cst_onmousedown$0=caml_string_of_jsbytes("onmousedown"),
     cst_onmouseup$0=caml_string_of_jsbytes("onmouseup"),
     cst_onmouseover$0=caml_string_of_jsbytes("onmouseover"),
     cst_onmousemove$0=caml_string_of_jsbytes("onmousemove"),
     cst_onmouseout$0=caml_string_of_jsbytes("onmouseout"),
     cst_ontouchstart$0=caml_string_of_jsbytes("ontouchstart"),
     cst_ontouchend$0=caml_string_of_jsbytes("ontouchend"),
     cst_ontouchmove$0=caml_string_of_jsbytes("ontouchmove"),
     cst_ontouchcancel$0=caml_string_of_jsbytes("ontouchcancel"),
     cst_onkeypress=caml_string_of_jsbytes("onkeypress"),
     cst_onkeydown=caml_string_of_jsbytes("onkeydown"),
     cst_onkeyup=caml_string_of_jsbytes("onkeyup"),
     cst_version$0=caml_string_of_jsbytes("version"),
     cst_manifest=caml_string_of_jsbytes("manifest"),
     cst_cite=caml_string_of_jsbytes("cite"),
     cst_charset=caml_string_of_jsbytes("charset"),
     cst_accept_charset=caml_string_of_jsbytes("accept-charset"),
     cst_accept=caml_string_of_jsbytes("accept"),
     cst_href$0=caml_string_of_jsbytes("href"),
     cst_hreflang=caml_string_of_jsbytes("hreflang"),
     cst_rel=caml_string_of_jsbytes("rel"),
     cst_tabindex=caml_string_of_jsbytes("tabindex"),
     cst_type$4=caml_string_of_jsbytes("type"),
     cst_alt=caml_string_of_jsbytes("alt"),
     cst_src=caml_string_of_jsbytes("src"),
     cst_for=caml_string_of_jsbytes("for"),
     cst_for$0=caml_string_of_jsbytes("for"),
     cst_selected=caml_string_of_jsbytes("selected"),
     cst_value=caml_string_of_jsbytes("value"),
     cst_value$0=caml_string_of_jsbytes("value"),
     cst_value$1=caml_string_of_jsbytes("value"),
     cst_value$2=caml_string_of_jsbytes("value"),
     cst_action=caml_string_of_jsbytes("action"),
     cst_enctype=caml_string_of_jsbytes("enctype"),
     cst_checked=caml_string_of_jsbytes("checked"),
     cst_disabled=caml_string_of_jsbytes("disabled"),
     cst_readonly=caml_string_of_jsbytes("readonly"),
     cst_maxlength=caml_string_of_jsbytes("maxlength"),
     cst_minlength=caml_string_of_jsbytes("minlength"),
     cst_name$0=caml_string_of_jsbytes("name"),
     cst_allowfullscreen=caml_string_of_jsbytes("allowfullscreen"),
     cst_allowpaymentrequest=caml_string_of_jsbytes("allowpaymentrequest"),
     cst_async=caml_string_of_jsbytes("async"),
     cst_autofocus=caml_string_of_jsbytes("autofocus"),
     cst_autoplay=caml_string_of_jsbytes("autoplay"),
     cst_muted=caml_string_of_jsbytes("muted"),
     cst_integrity=caml_string_of_jsbytes("integrity"),
     cst_mediagroup=caml_string_of_jsbytes("mediagroup"),
     cst_challenge=caml_string_of_jsbytes("challenge"),
     cst_contextmenu=caml_string_of_jsbytes("contextmenu"),
     cst_controls=caml_string_of_jsbytes("controls"),
     cst_form=caml_string_of_jsbytes("form"),
     cst_formaction=caml_string_of_jsbytes("formaction"),
     cst_formenctype=caml_string_of_jsbytes("formenctype"),
     cst_formnovalidate=caml_string_of_jsbytes("formnovalidate"),
     cst_formtarget=caml_string_of_jsbytes("formtarget"),
     cst_hidden=caml_string_of_jsbytes("hidden"),
     cst_high=caml_string_of_jsbytes("high"),
     cst_icon=caml_string_of_jsbytes("icon"),
     cst_ismap=caml_string_of_jsbytes("ismap"),
     cst_keytype=caml_string_of_jsbytes("keytype"),
     cst_list=caml_string_of_jsbytes("list"),
     cst_loop=caml_string_of_jsbytes("loop"),
     cst_low=caml_string_of_jsbytes("low"),
     cst_max$0=caml_string_of_jsbytes("max"),
     cst_max$1=caml_string_of_jsbytes("max"),
     cst_min$0=caml_string_of_jsbytes("min"),
     cst_min$1=caml_string_of_jsbytes("min"),
     cst_novalidate=caml_string_of_jsbytes("novalidate"),
     cst_open=caml_string_of_jsbytes("open"),
     cst_optimum=caml_string_of_jsbytes("optimum"),
     cst_pattern$0=caml_string_of_jsbytes("pattern"),
     cst_placeholder=caml_string_of_jsbytes("placeholder"),
     cst_poster=caml_string_of_jsbytes("poster"),
     cst_pubdate=caml_string_of_jsbytes("pubdate"),
     cst_radiogroup=caml_string_of_jsbytes("radiogroup"),
     cst_required=caml_string_of_jsbytes("required"),
     cst_reserved=caml_string_of_jsbytes("reserved"),
     cst_scoped=caml_string_of_jsbytes("scoped"),
     cst_seamless=caml_string_of_jsbytes("seamless"),
     cst_span=caml_string_of_jsbytes("span"),
     cst_xml_lang$1=caml_string_of_jsbytes("xml:lang"),
     cst_srcset=caml_string_of_jsbytes("srcset"),
     cst_sizes$0=caml_string_of_jsbytes("sizes"),
     cst_start$0=caml_string_of_jsbytes("start"),
     cst_size=caml_string_of_jsbytes("size"),
     cst_multiple=caml_string_of_jsbytes("multiple"),
     cst_cols=caml_string_of_jsbytes("cols"),
     cst_rows=caml_string_of_jsbytes("rows"),
     cst_summary=caml_string_of_jsbytes("summary"),
     cst_axis=caml_string_of_jsbytes("axis"),
     cst_colspan=caml_string_of_jsbytes("colspan"),
     cst_headers=caml_string_of_jsbytes("headers"),
     cst_rowspan=caml_string_of_jsbytes("rowspan"),
     cst_border=caml_string_of_jsbytes("border"),
     cst_data$1=caml_string_of_jsbytes("data"),
     cst_codetype=caml_string_of_jsbytes("codetype"),
     cst_marginheight=caml_string_of_jsbytes("marginheight"),
     cst_marginwidth=caml_string_of_jsbytes("marginwidth"),
     cst_target=caml_string_of_jsbytes("target"),
     cst_content=caml_string_of_jsbytes("content"),
     cst_http_equiv=caml_string_of_jsbytes("http-equiv"),
     cst_media$0=caml_string_of_jsbytes("media"),
     cst_role=caml_string_of_jsbytes("role"),
     cst_body=caml_string_of_jsbytes("body"),
     cst_head=caml_string_of_jsbytes("head"),
     cst_title$1=caml_string_of_jsbytes("title"),
     cst_footer=caml_string_of_jsbytes("footer"),
     cst_header=caml_string_of_jsbytes("header"),
     cst_section=caml_string_of_jsbytes("section"),
     cst_nav=caml_string_of_jsbytes("nav"),
     cst_h1=caml_string_of_jsbytes("h1"),
     cst_h2=caml_string_of_jsbytes("h2"),
     cst_h3=caml_string_of_jsbytes("h3"),
     cst_h4=caml_string_of_jsbytes("h4"),
     cst_h5=caml_string_of_jsbytes("h5"),
     cst_h6=caml_string_of_jsbytes("h6"),
     cst_hgroup=caml_string_of_jsbytes("hgroup"),
     cst_address=caml_string_of_jsbytes("address"),
     cst_blockquote=caml_string_of_jsbytes("blockquote"),
     cst_div=caml_string_of_jsbytes("div"),
     cst_p=caml_string_of_jsbytes("p"),
     cst_pre=caml_string_of_jsbytes("pre"),
     cst_abbr=caml_string_of_jsbytes("abbr"),
     cst_br=caml_string_of_jsbytes("br"),
     cst_cite$0=caml_string_of_jsbytes("cite"),
     cst_code=caml_string_of_jsbytes("code"),
     cst_dfn=caml_string_of_jsbytes("dfn"),
     cst_em$0=caml_string_of_jsbytes("em"),
     cst_kbd=caml_string_of_jsbytes("kbd"),
     cst_q=caml_string_of_jsbytes("q"),
     cst_samp=caml_string_of_jsbytes("samp"),
     cst_span$0=caml_string_of_jsbytes("span"),
     cst_strong=caml_string_of_jsbytes("strong"),
     cst_time=caml_string_of_jsbytes("time"),
     cst_var=caml_string_of_jsbytes("var"),
     cst_a$1=caml_string_of_jsbytes("a"),
     cst_dl=caml_string_of_jsbytes("dl"),
     cst_ol=caml_string_of_jsbytes("ol"),
     cst_ul=caml_string_of_jsbytes("ul"),
     cst_dd=caml_string_of_jsbytes("dd"),
     cst_dt=caml_string_of_jsbytes("dt"),
     cst_li=caml_string_of_jsbytes("li"),
     cst_hr=caml_string_of_jsbytes("hr"),
     cst_b$0=caml_string_of_jsbytes("b"),
     cst_i=caml_string_of_jsbytes("i"),
     cst_u=caml_string_of_jsbytes("u"),
     cst_small=caml_string_of_jsbytes("small"),
     cst_sub=caml_string_of_jsbytes("sub"),
     cst_sup=caml_string_of_jsbytes("sup"),
     cst_mark=caml_string_of_jsbytes("mark"),
     cst_rp=caml_string_of_jsbytes("rp"),
     cst_rt=caml_string_of_jsbytes("rt"),
     cst_ruby=caml_string_of_jsbytes("ruby"),
     cst_wbr=caml_string_of_jsbytes("wbr"),
     cst_datetime=caml_string_of_jsbytes("datetime"),
     cst_usemap=caml_string_of_jsbytes("usemap"),
     cst_defer=caml_string_of_jsbytes("defer"),
     cst_label=caml_string_of_jsbytes("label"),
     cst_map=caml_string_of_jsbytes("map"),
     cst_del=caml_string_of_jsbytes("del"),
     cst_ins=caml_string_of_jsbytes("ins"),
     cst_script$0=caml_string_of_jsbytes("script"),
     cst_noscript=caml_string_of_jsbytes("noscript"),
     cst_template=caml_string_of_jsbytes("template"),
     cst_article=caml_string_of_jsbytes("article"),
     cst_aside=caml_string_of_jsbytes("aside"),
     cst_main=caml_string_of_jsbytes("main"),
     cst_audio=caml_string_of_jsbytes("audio"),
     cst_video=caml_string_of_jsbytes("video"),
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_embed=caml_string_of_jsbytes("embed"),
     cst_source=caml_string_of_jsbytes("source"),
     cst_meter=caml_string_of_jsbytes("meter"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_form$0=caml_string_of_jsbytes("form"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_keygen=caml_string_of_jsbytes("keygen"),
     cst_label$0=caml_string_of_jsbytes("label"),
     cst_option=caml_string_of_jsbytes("option"),
     cst_select=caml_string_of_jsbytes("select"),
     cst_textarea=caml_string_of_jsbytes("textarea"),
     cst_button=caml_string_of_jsbytes("button"),
     cst_progress=caml_string_of_jsbytes("progress"),
     cst_legend=caml_string_of_jsbytes("legend"),
     cst_summary$0=caml_string_of_jsbytes("summary"),
     cst_figcaption=caml_string_of_jsbytes("figcaption"),
     cst_caption=caml_string_of_jsbytes("caption"),
     cst_td=caml_string_of_jsbytes("td"),
     cst_th=caml_string_of_jsbytes("th"),
     cst_tr=caml_string_of_jsbytes("tr"),
     cst_colgroup=caml_string_of_jsbytes("colgroup"),
     cst_col=caml_string_of_jsbytes("col"),
     cst_thead=caml_string_of_jsbytes("thead"),
     cst_tbody=caml_string_of_jsbytes("tbody"),
     cst_tfoot=caml_string_of_jsbytes("tfoot"),
     cst_iframe=caml_string_of_jsbytes("iframe"),
     cst_param=caml_string_of_jsbytes("param"),
     cst_meta=caml_string_of_jsbytes("meta"),
     cst_base=caml_string_of_jsbytes("base"),
     Stdlib=global_data.Stdlib,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_seq=global_data.Stdlib__seq,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_format=global_data.Stdlib__format,
     Stdlib_set=global_data.Stdlib__set,
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Uutf=global_data.Uutf,
     Re=global_data.Re,
     _L_=[0,[2,0,[12,61,[2,0,0]]],caml_string_of_jsbytes("%s=%s")],
     _H_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _I_=[0,[12,34,[4,0,0,0,[12,34,0]]],caml_string_of_jsbytes('"%d"')],
     _J_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _K_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _F_=
      [0,
       [2,0,[17,[0,caml_string_of_jsbytes("@,"),0,0],0]],
       caml_string_of_jsbytes("%s@,")],
     _G_=
      [0,
       [11,
        caml_string_of_jsbytes("<!-- "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" -->"),
          [17,[0,caml_string_of_jsbytes("@,"),0,0],0]]]],
       caml_string_of_jsbytes("<!-- %s -->@,")],
     _C_=
      [0,
       [12,
        60,
        [16,
         [15,
          [12,
           62,
           [16,
            [15,[16,[16,[11,caml_string_of_jsbytes("<\/"),[2,0,partial]]]]]]]]]],
       caml_string_of_jsbytes("<%t%a>%t%a%t%t<\/%s>")],
     _D_=
      [0,
       [11,
        caml_string_of_jsbytes("<!--"),
        [2,0,[11,caml_string_of_jsbytes("-->"),0]]],
       caml_string_of_jsbytes("<!--%s-->")],
     _E_=[0,[12,38,[2,0,[12,59,0]]],caml_string_of_jsbytes("&%s;")],
     _A_=
      [0,
       [12,60,[15,[11,caml_string_of_jsbytes("/>"),0]]],
       caml_string_of_jsbytes("<%a/>")],
     _B_=
      [0,
       [12,
        60,
        [15,[12,62,[16,[11,caml_string_of_jsbytes("<\/"),[2,0,[12,62,0]]]]]]],
       caml_string_of_jsbytes("<%a>%t<\/%s>")],
     _z_=[0,[2,0,[15,[16,0]]],caml_string_of_jsbytes("%s%a%t")],
     _y_=[0,[16,[2,0,[12,61,[15,0]]]],caml_string_of_jsbytes("%t%s=%a")],
     _u_=[0,[12,34,[15,[12,34,0]]],caml_string_of_jsbytes('"%a"')],
     _v_=[0,[12,34,[4,0,0,0,[12,34,0]]],caml_string_of_jsbytes('"%d"')],
     _w_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _x_=[0,[12,34,[15,[12,34,0]]],caml_string_of_jsbytes('"%a"')],
     _t_=[0,[12,44,[16,0]],caml_string_of_jsbytes(",%t")],
     _s_=
      [0,
       [18,[1,[0,0,caml_string_of_jsbytes("")]],[15,[17,0,0]]],
       caml_string_of_jsbytes("@[%a@]")],
     _r_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _n_=[0,[4,0,0,0,[12,101,[4,0,0,0,0]]],caml_string_of_jsbytes("%de%d")],
     _o_=[0,[8,[0,0,3],0,[0,12],0],caml_string_of_jsbytes("%.12g")],
     _p_=[0,[8,[0,0,3],0,[0,15],0],caml_string_of_jsbytes("%.15g")],
     _q_=[0,[8,[0,0,3],0,[0,18],0],caml_string_of_jsbytes("%.18g")],
     _m_=[0,1],
     _c_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _d_=
      [0,
       [11,caml_string_of_jsbytes(" PUBLIC "),[15,0]],
       caml_string_of_jsbytes(" PUBLIC %a")],
     _e_=
      [0,
       [11,caml_string_of_jsbytes("<!DOCTYPE "),[2,0,[15,[12,62,0]]]],
       caml_string_of_jsbytes("<!DOCTYPE %s%a>")],
     _b_=
      [0,
       [11,
        caml_string_of_jsbytes('<?xml version="'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('" encoding="'),
          [2,0,[11,caml_string_of_jsbytes('"?>\\n'),0]]]]],
       caml_string_of_jsbytes('<?xml version="%s" encoding="%s"?>\\n')],
     _X_=
      [0,
       [11,caml_string_of_jsbytes("skewY("),[2,0,[12,41,0]]],
       caml_string_of_jsbytes("skewY(%s)")],
     _Y_=
      [0,
       [11,caml_string_of_jsbytes("skewX("),[2,0,[12,41,0]]],
       caml_string_of_jsbytes("skewX(%s)")],
     _Z_=
      [0,
       [11,caml_string_of_jsbytes("scale("),[2,0,[12,41,0]]],
       caml_string_of_jsbytes("scale(%s)")],
     ___=
      [0,
       [8,[0,0,3],0,0,[12,32,[8,[0,0,3],0,0,0]]],
       caml_string_of_jsbytes("%g %g")],
     _$_=
      [0,
       [11,caml_string_of_jsbytes("rotate("),[2,0,[12,32,[2,0,[12,41,0]]]]],
       caml_string_of_jsbytes("rotate(%s %s)")],
     _aa_=
      [0,
       [11,
        caml_string_of_jsbytes("matrix("),
        [8,
         [0,0,3],
         0,
         0,
         [12,
          32,
          [8,
           [0,0,3],
           0,
           0,
           [12,
            32,
            [8,
             [0,0,3],
             0,
             0,
             [12,32,[8,[0,0,3],0,0,[12,32,[8,partial$1,0,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes("matrix(%g %g %g %g %g %g)")],
     _ab_=
      [0,
       [11,caml_string_of_jsbytes("translate("),[2,0,[12,41,0]]],
       caml_string_of_jsbytes("translate(%s)")],
     _U_=
      [0,
       [8,[0,0,3],0,0,[11,caml_string_of_jsbytes(", "),[8,[0,0,3],0,0,0]]],
       caml_string_of_jsbytes("%g, %g")],
     _V_=[0,[8,[0,0,3],0,0,0],caml_string_of_jsbytes("%g")],
     _T_=
      [0,
       [2,0,[12,32,[2,0,[12,32,[2,0,[12,32,[2,0,0]]]]]]],
       caml_string_of_jsbytes("%s %s %s %s")],
     _S_=
      [0,
       [8,[0,0,3],0,0,[11,caml_string_of_jsbytes(", "),[8,[0,0,3],0,0,0]]],
       caml_string_of_jsbytes("%g, %g")],
     _W_=[0,caml_string_of_jsbytes("; ")],
     _R_=
      [0,
       caml_string_of_jsbytes("-//W3C//DTD SVG 1.1//EN"),
       [0,
        caml_string_of_jsbytes
         ("http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"),
        0]],
     _Q_=[0,[8,[0,0,3],0,0,[2,0,0]],caml_string_of_jsbytes("%g%s")],
     _P_=
      [0,
       [11,caml_string_of_jsbytes("url("),[2,0,[12,41,0]]],
       caml_string_of_jsbytes("url(%s)")],
     _ag_=[0,[2,0,[12,32,[2,0,[12,120,0]]]],caml_string_of_jsbytes("%s %sx")],
     _af_=[0,[2,0,[12,32,[2,0,[12,119,0]]]],caml_string_of_jsbytes("%s %sw")],
     _ae_=[0,[4,0,0,0,[12,120,[4,0,0,0,0]]],caml_string_of_jsbytes("%dx%d")];
    function fmap(f){return f}
    function nil(param){return 0}
    function singleton(x){return [0,x,0]}
    function cons(x,xs){return [0,x,xs]}
    function append(x,y){return caml_call2(Stdlib[37],x,y)}
    var
     map=Stdlib_list[17],
     Xml_wrap=
      [0,[0,function(_nk_){return _nk_},fmap,nil,singleton,cons,append,map]];
    caml_register_global(1084,Xml_wrap,"Xml_wrap");
    var
     Malformed_stream=
      [248,cst_Xml_stream_Malformed_strea,runtime.caml_fresh_oo_id(0)];
    function _a_(Xml)
     {function of_list(l)
       {var _nh_=caml_call1(Xml[1][3],0);
        function _ni_(a,b)
         {var _nj_=caml_call1(Xml[1][1],a);
          return caml_call2(Xml[1][5],_nj_,b)}
        return caml_call3(Stdlib_list[22],_ni_,l,_nh_)}
      function mk(children,seq)
       {var children$0=children,seq$0=seq;
        for(;;)
         {var match=caml_call1(seq$0,0);
          if(match)
           {var _m$_=match[1];
            if(typeof _m$_ === "number")
             {var rest=match[2];
              return [0,of_list(caml_call1(Stdlib_list[9],children$0)),rest]}
            var _na_=_m$_[1];
            if(856096383 === _na_)
             {var
               q=match[2],
               _nb_=_m$_[2],
               attrs=_nb_[2],
               match$0=_nb_[1],
               name=match$0[2],
               f=
                function(param)
                 {var
                   v=param[2],
                   match=param[1],
                   name=match[2],
                   _ng_=caml_call1(Xml[1][1],v);
                  return caml_call2(Xml[6],name,_ng_)},
               a=caml_call2(Stdlib_list[17],f,attrs),
               match$1=mk(0,q),
               rest$0=match$1[2],
               sub_children=match$1[1],
               children$1=
                [0,caml_call3(Xml[21],[0,a],name,sub_children),children$0],
               children$0=children$1,
               seq$0=rest$0;
              continue}
            if(936573133 <= _na_)
             {var
               q$0=match[2],
               s=_m$_[2],
               _nc_=
                function(x)
                 {var _nf_=caml_call1(Xml[1][1],x);
                  return caml_call1(Xml[17],_nf_)},
               _nd_=caml_call2(Stdlib_list[17],_nc_,s),
               children$2=caml_call2(Stdlib[37],_nd_,children$0),
               children$0=children$2,
               seq$0=q$0;
              continue}
            var
             q$1=match[2],
             s$0=_m$_[2],
             children$3=[0,caml_call1(Xml[16],s$0),children$0],
             children$0=children$3,
             seq$0=q$1;
            continue}
          var _ne_=Stdlib_seq[1];
          return [0,of_list(caml_call1(Stdlib_list[9],children$0)),_ne_]}}
      function of_seq(seq)
       {var
         match=mk(0,seq),
         rest=match[2],
         l=match[1],
         match$0=caml_call1(rest,0);
        if(match$0)throw Malformed_stream;
        return l}
      return [0,of_seq]}
    var Xml_stream=[0,Malformed_stream,_a_];
    caml_register_global(1086,Xml_stream,"Xml_stream");
    function add_unsafe_char(b,c)
     {if(34 === c)return caml_call2(Stdlib_buffer[14],b,cst_quot);
      if(60 <= c)
       {if(! (63 <= c))
         {var switcher=c - 60 | 0;
          switch(switcher)
           {case 0:return caml_call2(Stdlib_buffer[14],b,cst_lt);
            case 1:break;
            default:return caml_call2(Stdlib_buffer[14],b,cst_gt)}}}
      else
       if(38 === c)return caml_call2(Stdlib_buffer[14],b,cst_amp);
      var _m4_=c <= 8?1:0;
      if(_m4_)
       var _m5_=_m4_;
      else
       {var _m6_=11 === c?1:0;
        if(_m6_)
         var _m5_=_m6_;
        else
         {var _m7_=12 === c?1:0;
          if(_m7_)
           var _m5_=_m7_;
          else
           var
            _m8_=14 <= c?1:0,
            _m9_=_m8_?c <= 31?1:0:_m8_,
            _m5_=_m9_ || (127 === c?1:0)}}
      if(_m5_)
       {caml_call2(Stdlib_buffer[14],b,cst);
        var _m__=caml_call1(Stdlib[33],c);
        caml_call2(Stdlib_buffer[14],b,_m__);
        return caml_call2(Stdlib_buffer[14],b,cst$0)}
      return caml_call2(Stdlib_buffer[10],b,c)}
    function encode_unsafe_char(s)
     {var b=caml_call1(Stdlib_buffer[1],caml_ml_string_length(s));
      function _m2_(_m3_){return add_unsafe_char(b,_m3_)}
      caml_call2(Stdlib_string[8],_m2_,s);
      return caml_call1(Stdlib_buffer[2],b)}
    function encode_unsafe_char_and_at(s)
     {var b=caml_call1(Stdlib_buffer[1],caml_ml_string_length(s));
      function f(c)
       {return 64 === c
                ?caml_call2(Stdlib_buffer[14],b,cst_64)
                :add_unsafe_char(b,c)}
      caml_call2(Stdlib_string[8],f,s);
      return caml_call1(Stdlib_buffer[2],b)}
    function compose_decl(opt,_m1_,param)
     {if(opt)var sth=opt[1],version=sth;else var version=cst_1_0;
      if(_m1_)var sth$0=_m1_[1],encoding=sth$0;else var encoding=cst_UTF_8;
      return caml_call3(Stdlib_format[126],_b_,version,encoding)}
    function compose_doctype(dt,args)
     {function pp_args(fmt,l)
       {if(l)
         {var
           _mZ_=function(fmt){return caml_call2(Stdlib_format[123],fmt,_c_)},
           _m0_=caml_call2(Stdlib_format[119],[0,Stdlib_format[25]],_mZ_);
          return caml_call4(Stdlib_format[123],fmt,_d_,_m0_,l)}
        return 0}
      return caml_call4(Stdlib_format[127],_e_,dt,pp_args,args)}
    var
     _f_=[0,caml_call1(Re[23],cst$1),0],
     _g_=[0,caml_call1(Re[23],cst$2),_f_],
     _h_=[0,caml_call1(Re[23],cst$3),0],
     _i_=[0,caml_call1(Re[26],[0,Re[37],_h_]),_g_],
     _j_=[0,caml_call1(Re[23],cst$4),0],
     _k_=[0,caml_call1(Re[26],[0,Re[37],_j_]),_i_],
     _l_=caml_call1(Re[25],_k_),
     re_end_comment=caml_call1(Re[2],_l_);
    function pp_number(fmt,v)
     {if(v == Stdlib[22])
       return caml_call2(Stdlib_format[13],fmt,cst_Infinity);
      if(v == Stdlib[23])
       return caml_call2(Stdlib_format[13],fmt,cst_Infinity$0);
      if(v != v)return caml_call2(Stdlib_format[13],fmt,cst_NaN);
      var n=v | 0;
      if(n == v)
       {var n$0=n,i=0;
        for(;;)
         {if(0 !== n$0 && 0 === (n$0 % 10 | 0))
           {var i$0=i + 1 | 0,n$1=n$0 / 10 | 0,n$0=n$1,i=i$0;continue}
          return 2 < i
                  ?caml_call4(Stdlib_format[123],fmt,_n_,n$0,i)
                  :caml_call2(Stdlib_format[17],fmt,n)}}
      var s1=caml_call2(Stdlib_printf[4],_o_,v);
      if(v == caml_float_of_string(s1))
       return caml_call2(Stdlib_format[13],fmt,s1);
      var s2=caml_call2(Stdlib_printf[4],_p_,v);
      return v == caml_float_of_string(s2)
              ?caml_call2(Stdlib_format[13],fmt,s2)
              :caml_call3(Stdlib_format[123],fmt,_q_,v)}
    function string_of_number(v)
     {return caml_call3(Stdlib_format[127],_r_,pp_number,v)}
    function normalize(src)
     {var
       warn=[0,0],
       buffer=caml_call1(Stdlib_buffer[1],caml_ml_string_length(src)),
       _mV_=0;
      function _mW_(param,_mY_,d)
       {if(852405675 <= d[1])
         {var code=d[2];return caml_call2(Uutf[23][1],buffer,code)}
        caml_call2(Uutf[23][1],buffer,Uutf[2]);
        warn[1] = 1;
        return 0}
      caml_call5(Uutf[22][2],0,0,_mW_,_mV_,src);
      var _mX_=warn[1];
      return [0,caml_call1(Stdlib_buffer[2],buffer),_mX_]}
    function normalize_html(src)
     {var l=caml_ml_string_length(src),i=0;
      for(;;)
       {var _mP_=i < l?1:0;
        if(_mP_)
         {var match=runtime.caml_string_get(src,i),switch$0=0;
          if(35 <= match)
           {if(61 <= match)
             {if(62 === match)switch$0 = 1;else if(127 <= match)switch$0 = 2}
            else
             if(38 === match || 60 <= match)switch$0 = 1}
          else
           if(11 <= match)
            {if(32 <= match)
              {if(34 <= match)switch$0 = 1}
             else
              if(13 !== match)switch$0 = 2}
           else
            if(! (9 <= match))switch$0 = 2;
          switch(switch$0)
           {case 2:var _mQ_=1;break;
            case 1:var _mQ_=1;break;
            default:var i$0=i + 1 | 0,i=i$0;continue}}
        else
         var _mQ_=_mP_;
        if(_mQ_)
         {var
           warn=[0,0],
           buffer=caml_call1(Stdlib_buffer[1],caml_ml_string_length(src)),
           _mR_=0,
           _mS_=
            function(param,_mU_,d)
             {if(852405675 <= d[1])
               {var u=d[2],code=caml_call1(Stdlib_uchar[10],u);
                if(34 === code)
                 return caml_call2(Stdlib_buffer[14],buffer,cst_quot$0);
                if(60 <= code)
                 {if(! (63 <= code))
                   {var switcher=code - 60 | 0;
                    switch(switcher)
                     {case 0:
                       return caml_call2(Stdlib_buffer[14],buffer,cst_lt$0);
                      case 1:break;
                      default:return caml_call2(Stdlib_buffer[14],buffer,cst_gt$4)}}}
                else
                 if(38 === code)
                  return caml_call2(Stdlib_buffer[14],buffer,cst_amp$0);
                var switch$0=0;
                if(! (31 < code) && 9 !== code && 10 !== code && 13 !== code)
                 switch$0 = 1;
                var switch$1=0;
                if(! switch$0)
                 {var switch$2=0;
                  if(127 <= code && ! (159 < code))switch$2 = 1;
                  if
                   (!
                    switch$2
                    &&
                    65534
                    !==
                    (code & 65535)
                    &&
                    65535
                    !==
                    (code & 65535))
                   {var u$0=u;switch$1 = 1}}
                if(! switch$1){warn[1] = 1;var u$0=Uutf[2]}
                return caml_call2(Uutf[23][1],buffer,u$0)}
              caml_call2(Uutf[23][1],buffer,Uutf[2]);
              warn[1] = 1;
              return 0};
          caml_call5(Uutf[22][2],0,0,_mS_,_mR_,src);
          var _mT_=warn[1];
          return [0,caml_call1(Stdlib_buffer[2],buffer),_mT_]}
        return [0,src,0]}}
    function pp_noop(fmt,param){return 0}
    function Make_fmt(Xml,_lY_)
     {function open_box(indent,fmt)
       {return indent?caml_call2(Stdlib_format[1],fmt,0):0}
      function close_box(indent,fmt)
       {return indent?caml_call2(Stdlib_format[3],fmt,0):0}
      function sp(indent,fmt)
       {return indent
                ?caml_call2(Stdlib_format[25],fmt,0)
                :caml_call2(Stdlib_format[13],fmt,cst$9)}
      function cut(indent,fmt)
       {return indent?caml_call2(Stdlib_format[27],fmt,0):0}
      var S=caml_call1(Stdlib_set[1],[0,Stdlib_string[33]]),_lZ_=_lY_[1];
      if(_lZ_)
       var
        _l0_=S[1],
        _l1_=function(s,x){return caml_call2(S[4],x,s)},
        set=caml_call3(Stdlib_list[21],_l1_,_l0_,_lZ_),
        is_emptytag=function(x){return caml_call2(S[3],x,set)};
      else
       var is_emptytag=function(param){return 0};
      function pp_encode(encode,indent,fmt,s)
       {var s$0=caml_call1(encode,s);
        return indent
                ?caml_call4(Stdlib_format[123],fmt,_s_,Stdlib_format[120],s$0)
                :caml_call2(Stdlib_format[13],fmt,s$0)}
      function pp_sep(indent,param)
       {return 0 === param
                ?function(fmt,param){return sp(indent,fmt)}
                :function(fmt,param)
                  {function _mN_(_mO_){return sp(indent,_mO_)}
                   return caml_call3(Stdlib_format[123],fmt,_t_,_mN_)}}
      function pp_attrib_value(encode,indent,fmt,a)
       {var match=caml_call1(Xml[26],a);
        switch(match[0])
         {case 0:
           var f=match[1];
           return caml_call4(Stdlib_format[123],fmt,_u_,pp_number,f);
          case 1:
           var i=match[1];return caml_call3(Stdlib_format[123],fmt,_v_,i);
          case 2:
           var s=match[1],_mH_=caml_call1(encode,s);
           return caml_call3(Stdlib_format[123],fmt,_w_,_mH_);
          default:
           var
            slist=match[2],
            sep=match[1],
            _mI_=
             function(_mL_,_mM_){return pp_encode(encode,indent,_mL_,_mM_)},
            _mJ_=[0,pp_sep(indent,sep)],
            _mK_=caml_call2(Stdlib_format[119],_mJ_,_mI_);
           return caml_call4(Stdlib_format[123],fmt,_x_,_mK_,slist)}}
      function pp_attrib(encode,indent,fmt,a)
       {function _mB_(_mF_,_mG_)
         {return pp_attrib_value(encode,indent,_mF_,_mG_)}
        var _mC_=caml_call1(Xml[25],a);
        function _mD_(_mE_){return sp(indent,_mE_)}
        return caml_call6(Stdlib_format[123],fmt,_y_,_mD_,_mC_,_mB_,a)}
      function pp_attribs(encode,indent)
       {function _my_(_mz_,_mA_){return pp_attrib(encode,indent,_mz_,_mA_)}
        return caml_call2(Stdlib_format[119],[0,pp_noop],_my_)}
      function pp_tag_and_attribs(encode,indent,fmt,param)
       {var attrs=param[2],tag=param[1];
        open_box(indent,fmt);
        function _mv_(_mx_){return cut(indent,_mx_)}
        var _mw_=pp_attribs(encode,indent);
        caml_call6(Stdlib_format[123],fmt,_z_,tag,_mw_,attrs,_mv_);
        return close_box(indent,fmt)}
      function pp_closedtag(encode,indent,fmt,tag,attrs)
       {if(is_emptytag(tag))
         {var
           _ml_=[0,tag,attrs],
           _mm_=
            function(_mt_,_mu_)
             {return pp_tag_and_attribs(encode,indent,_mt_,_mu_)};
          return caml_call4(Stdlib_format[123],fmt,_A_,_mm_,_ml_)}
        open_box(indent,fmt);
        function _mn_(_ms_){return cut(indent,_ms_)}
        var _mo_=[0,tag,attrs];
        function _mp_(_mq_,_mr_)
         {return pp_tag_and_attribs(encode,indent,_mq_,_mr_)}
        caml_call6(Stdlib_format[123],fmt,_B_,_mp_,_mo_,_mn_,tag);
        return close_box(indent,fmt)}
      function pp_elts(encode,indent)
       {function _mh_(_mj_,_mk_){return pp_elt(encode,indent,_mj_,_mk_)}
        var _mi_=[0,function(fmt,param){return cut(indent,fmt)}];
        return caml_call2(Stdlib_format[119],_mi_,_mh_)}
      function pp_tag(encode,indent,fmt,tag,attrs,children)
       {if(children)
         {open_box(indent,fmt);
          var
           _l6_=function(_mg_){return cut(indent,_mg_)},
           _l7_=function(_mf_){return close_box(indent,_mf_)},
           _l8_=pp_elts(encode,indent),
           _l9_=function(_me_){return cut(indent,_me_)},
           _l__=[0,tag,attrs],
           _l$_=
            function(_mc_,_md_)
             {return pp_tag_and_attribs(encode,indent,_mc_,_md_)},
           _ma_=function(_mb_){return open_box(indent,_mb_)};
          caml_call11
           (Stdlib_format[123],
            fmt,
            _C_,
            _ma_,
            _l$_,
            _l__,
            _l9_,
            _l8_,
            children,
            _l7_,
            _l6_,
            tag);
          return close_box(indent,fmt)}
        return pp_closedtag(encode,indent,fmt,tag,attrs)}
      function pp_elt(encode,indent,fmt,elt)
       {var match=caml_call1(Xml[27],elt);
        if(typeof match === "number")
         return 0;
        else
         switch(match[0])
          {case 0:
            var
             texte=match[1],
             f=
              function(g)
               {var s=caml_call2(Re[1][1],g,0);
                return caml_string_notequal(s,cst$5)
                        ?caml_string_notequal(s,cst$6)
                          ?caml_string_notequal(s,cst$7)
                            ?caml_string_notequal(s,cst$8)?s:cst_gt$0
                            :cst_gt$1
                          :cst_gt$2
                        :cst_gt$3},
             _l5_=caml_call6(Re[21],0,0,_m_,re_end_comment,f,texte);
            return caml_call3(Stdlib_format[123],fmt,_D_,_l5_);
           case 1:
            var texte$0=match[1];
            return caml_call2(Stdlib_format[13],fmt,texte$0);
           case 2:
            var texte$1=match[1];return pp_encode(encode,indent,fmt,texte$1);
           case 3:
            var e=match[1];return caml_call3(Stdlib_format[123],fmt,_E_,e);
           case 4:
            var xh_attrs=match[2],name=match[1];
            return pp_closedtag(encode,indent,fmt,name,xh_attrs);
           default:
            var xh_taglist=match[3],xh_attrs$0=match[2],name$0=match[1];
            return pp_tag(encode,indent,fmt,name$0,xh_attrs$0,xh_taglist)}}
      function pp(opt,_l2_,param)
       {if(opt)var sth=opt[1],encode=sth;else var encode=encode_unsafe_char;
        if(_l2_)var sth$0=_l2_[1],indent=sth$0;else var indent=0;
        return function(_l3_,_l4_){return pp_elt(encode,indent,_l3_,_l4_)}}
      return [0,
              open_box,
              close_box,
              sp,
              cut,
              S,
              is_emptytag,
              pp_encode,
              pp_sep,
              pp_attrib_value,
              pp_attrib,
              pp_attribs,
              pp_tag_and_attribs,
              pp_closedtag,
              pp_tag,
              pp_elt,
              pp_elts,
              pp]}
    function Make(Xml,I,O)
     {var symbol=O[2];
      function separator_to_string(param){return 0 === param?cst$10:cst$11}
      function attrib_value_to_string(encode,a)
       {var match=caml_call1(Xml[26],a);
        switch(match[0])
         {case 0:
           var f=match[1],_lU_=string_of_number(f);
           return caml_call2(Stdlib_printf[4],_H_,_lU_);
          case 1:var i=match[1];return caml_call2(Stdlib_printf[4],_I_,i);
          case 2:
           var s=match[1],_lV_=caml_call1(encode,s);
           return caml_call2(Stdlib_printf[4],_J_,_lV_);
          default:
           var
            slist=match[2],
            sep=match[1],
            _lW_=separator_to_string(sep),
            _lX_=caml_call1(encode,caml_call2(Stdlib_string[7],_lW_,slist));
           return caml_call2(Stdlib_printf[4],_K_,_lX_)}}
      function attrib_to_string(encode,a)
       {var _lS_=attrib_value_to_string(encode,a),_lT_=caml_call1(Xml[25],a);
        return caml_call3(Stdlib_printf[4],_L_,_lT_,_lS_)}
      function xh_print_attrs(encode,attrs)
       {if(attrs)
         {var
           queue=attrs[2],
           attr=attrs[1],
           _lP_=xh_print_attrs(encode,queue),
           _lQ_=attrib_to_string(encode,attr),
           _lR_=caml_call2(Stdlib[28],cst$12,_lQ_);
          return caml_call2(symbol,caml_call1(O[3],_lR_),_lP_)}
        return O[1]}
      function xh_print_closedtag(encode,tag,attrs)
       {if(0 !== I[1] && ! caml_call2(Stdlib_list[32],tag,I[1]))
         {var
           _lK_=caml_call2(Stdlib[28],tag,cst$15),
           _lL_=caml_call2(Stdlib[28],cst$16,_lK_),
           _lM_=caml_call1(O[3],_lL_),
           _lN_=xh_print_attrs(encode,attrs),
           _lO_=caml_call2(Stdlib[28],cst$17,tag);
          return caml_call2
                  (symbol,caml_call2(symbol,caml_call1(O[3],_lO_),_lN_),_lM_)}
        var
         _lH_=caml_call1(O[3],cst$13),
         _lI_=xh_print_attrs(encode,attrs),
         _lJ_=caml_call2(Stdlib[28],cst$14,tag);
        return caml_call2
                (symbol,caml_call2(symbol,caml_call1(O[3],_lJ_),_lI_),_lH_)}
      function xh_print_taglist(encode,taglist)
       {var taglist$0=taglist;
        for(;;)
         {if(taglist$0)
           {var
             queue=taglist$0[2],
             elt=taglist$0[1],
             match=caml_call1(Xml[27],elt);
            if(typeof match === "number")
             {var taglist$0=queue;continue}
            else
             switch(match[0])
              {case 0:
                var
                 texte=match[1],
                 _lx_=xh_print_taglist(encode,queue),
                 _ly_=caml_call1(encode,texte),
                 _lz_=caml_call2(Stdlib[28],_ly_,cst$22),
                 _lA_=caml_call2(Stdlib[28],cst$23,_lz_);
                return caml_call2(symbol,caml_call1(O[3],_lA_),_lx_);
               case 1:
                var texte$0=match[1],_lB_=xh_print_taglist(encode,queue);
                return caml_call2(symbol,caml_call1(O[3],texte$0),_lB_);
               case 2:
                var
                 texte$1=match[1],
                 _lC_=xh_print_taglist(encode,queue),
                 _lD_=caml_call1(encode,texte$1);
                return caml_call2(symbol,caml_call1(O[3],_lD_),_lC_);
               case 3:
                var
                 e=match[1],
                 _lE_=xh_print_taglist(encode,queue),
                 _lF_=caml_call2(Stdlib[28],e,cst$24),
                 _lG_=caml_call2(Stdlib[28],cst$25,_lF_);
                return caml_call2(symbol,caml_call1(O[3],_lG_),_lE_);
               case 4:
                var xh_attrs=match[2],name=match[1];
                return print_nodes(encode,name,xh_attrs,0,queue);
               default:
                var xh_taglist=match[3],xh_attrs$0=match[2],name$0=match[1];
                return print_nodes(encode,name$0,xh_attrs$0,xh_taglist,queue)}}
          return O[1]}}
      function print_nodes(encode,name,xh_attrs,xh_taglist,queue)
       {var _lw_=xh_print_taglist(encode,queue);
        return caml_call2
                (symbol,xh_print_tag(encode,name,xh_attrs,xh_taglist),_lw_)}
      function xh_print_tag(encode,tag,attrs,taglist)
       {if(0 === taglist)return xh_print_closedtag(encode,tag,attrs);
        var
         _lp_=caml_call2(Stdlib[28],tag,cst$18),
         _lq_=caml_call2(Stdlib[28],cst$19,_lp_),
         _lr_=caml_call1(O[3],_lq_),
         _ls_=xh_print_taglist(encode,taglist),
         _lt_=caml_call1(O[3],cst$20),
         _lu_=xh_print_attrs(encode,attrs),
         _lv_=caml_call2(Stdlib[28],cst$21,tag);
        return caml_call2
                (symbol,
                 caml_call2
                  (symbol,
                   caml_call2
                    (symbol,caml_call2(symbol,caml_call1(O[3],_lv_),_lu_),_lt_),
                   _ls_),
                 _lr_)}
      function print_list(opt,foret)
       {if(opt)var sth=opt[1],encode=sth;else var encode=encode_unsafe_char;
        var _lo_=xh_print_taglist(encode,foret);
        return caml_call1(O[4],_lo_)}
      return [0,
              symbol,
              separator_to_string,
              attrib_value_to_string,
              attrib_to_string,
              xh_print_attrs,
              xh_print_closedtag,
              xh_print_tag,
              print_nodes,
              xh_print_taglist,
              print_list]}
    function Make_typed(Xml,Typed_xml,O)
     {var P=Make(Xml,[0,Typed_xml[1][7]],O),symbol=O[2];
      function print_list(opt,foret)
       {if(opt)var sth=opt[1],encode=sth;else var encode=encode_unsafe_char;
        var
         _lm_=caml_call2(Stdlib_list[17],Typed_xml[2],foret),
         _ln_=caml_call2(P[9],encode,_lm_);
        return caml_call1(O[4],_ln_)}
      function print(opt,_lf_,doc)
       {if(opt)var sth=opt[1],encode=sth;else var encode=encode_unsafe_char;
        if(_lf_)var sth$0=_lf_[1],advert=sth$0;else var advert=cst$30;
        var
         doc$0=caml_call1(Typed_xml[3],doc),
         match=caml_call1(Xml[27],doc$0),
         switch$0=0;
        if(typeof match !== "number" && 5 === match[0])
         {var
           c=match[3],
           a=match[2],
           n=match[1],
           _ll_=
            function(a)
             {return caml_string_equal(caml_call1(Xml[25],a),cst_xmlns$1)},
           a$0=
            caml_call2(Stdlib_list[29],_ll_,a)
             ?a
             :[0,caml_call2(Xml[6],cst_xmlns$2,Typed_xml[1][5]),a],
           doc$1=caml_call3(Xml[21],[0,a$0],n,c);
          switch$0 = 1}
        if(! switch$0)var doc$1=doc$0;
        var _lg_=caml_call2(P[9],encode,[0,doc$1,0]);
        if(caml_string_notequal(advert,cst$26))
         var
          _lh_=caml_call2(Stdlib[28],advert,cst$27),
          _li_=caml_call2(Stdlib[28],cst$28,_lh_);
        else
         var _li_=cst$29;
        var
         _lj_=caml_call1(O[3],_li_),
         _lk_=
          caml_call2
           (symbol,
            caml_call2(symbol,caml_call1(O[3],Typed_xml[1][6]),_lj_),
            _lg_);
        return caml_call1(O[4],_lk_)}
      return [0,P,symbol,print_list,print]}
    function Simple_output(M)
     {function empty(param){return 0}
      function concat(f1,f2,param){caml_call1(f1,0);return caml_call1(f2,0)}
      function put(s,param){return caml_call1(M[1],s)}
      function make(f){return caml_call1(f,0)}
      return [0,empty,concat,put,make]}
    function Make_simple(Xml,I)
     {function print_list(output)
       {return Make(Xml,I,Simple_output([0,output]))[10]}
      return [0,print_list]}
    function Make_typed_simple(Xml,Typed_xml)
     {function print_list(output)
       {return Make_typed(Xml,Typed_xml,Simple_output([0,output]))[3]}
      function print(output)
       {return Make_typed(Xml,Typed_xml,Simple_output([0,output]))[4]}
      return [0,print_list,print]}
    function _M_(_ld_,_lc_,_lb_)
     {var _le_=Make_typed(_ld_,_lc_,_lb_);return [0,_le_[3],_le_[4]]}
    function _N_(_la_,_k$_,_k__){return [0,Make(_la_,_k$_,_k__)[10]]}
    function _O_(_k9_,_k8_){return [0,Make_fmt(_k9_,_k8_)[17]]}
    var
     Xml_print=
      [0,
       encode_unsafe_char,
       encode_unsafe_char_and_at,
       [0,normalize,normalize_html],
       compose_decl,
       compose_doctype,
       string_of_number,
       pp_number,
       function(Xml,Typed_xml)
        {var P=Make_fmt(Xml,[0,Typed_xml[1][7]]);
         function pp_elt(opt,_k6_,param,fmt,foret)
          {if(opt)
            var sth=opt[1],encode=sth;
           else
            var encode=encode_unsafe_char;
           if(_k6_)var sth$0=_k6_[1],indent=sth$0;else var indent=0;
           var _k7_=caml_call1(Typed_xml[2],foret);
           return caml_call4(P[15],encode,indent,fmt,_k7_)}
         function pp(opt,_k4_,advert,param,fmt,doc$0)
          {if(opt)
            var sth=opt[1],encode=sth;
           else
            var encode=encode_unsafe_char;
           if(_k4_)var sth$0=_k4_[1],indent=sth$0;else var indent=0;
           caml_call2(Stdlib_format[7],fmt,0);
           caml_call3(Stdlib_format[123],fmt,_F_,Typed_xml[1][6]);
           if(advert)
            {var s=advert[1];caml_call3(Stdlib_format[123],fmt,_G_,s)}
           var
            doc=caml_call1(Typed_xml[3],doc$0),
            match=caml_call1(Xml[27],doc),
            switch$0=0;
           if(typeof match !== "number" && 5 === match[0])
            {var
              c=match[3],
              a=match[2],
              n=match[1],
              _k3_=
               function(a)
                {return caml_string_equal(caml_call1(Xml[25],a),cst_xmlns)},
              a$0=
               caml_call2(Stdlib_list[29],_k3_,a)
                ?a
                :[0,caml_call2(Xml[6],cst_xmlns$0,Typed_xml[1][5]),a],
              _k5_=caml_call3(Xml[21],[0,a$0],n,c);
             switch$0 = 1}
           if(! switch$0)var _k5_=doc;
           caml_call4(P[15],encode,indent,fmt,_k5_);
           return caml_call2(Stdlib_format[3],fmt,0)}
         return [0,pp_elt,pp]},
       _O_,
       _N_,
       _M_,
       Make_simple,
       Make_typed_simple];
    caml_register_global(1095,Xml_print,"Xml_print");
    var
     Xml_iter=
      [0,
       function(Xml)
        {function amap1(f,n)
          {var match=caml_call1(Xml[27],n);
           if(typeof match !== "number")
            switch(match[0])
             {case 4:
               var
                attribs=match[2],
                name=match[1],
                _k1_=[0,caml_call2(f,name,attribs)];
               return caml_call2(Xml[20],_k1_,name);
              case 5:
               var
                elts=match[3],
                attribs$0=match[2],
                name$0=match[1],
                _k2_=[0,caml_call2(f,name$0,attribs$0)];
               return caml_call3(Xml[21],_k2_,name$0,elts)
              }
           return n}
         function amap(f,n)
          {var match=caml_call1(Xml[27],n);
           if(typeof match !== "number")
            switch(match[0])
             {case 4:
               var
                attribs=match[2],
                name=match[1],
                _kW_=[0,caml_call2(f,name,attribs)];
               return caml_call2(Xml[20],_kW_,name);
              case 5:
               var
                elts=match[3],
                attribs$0=match[2],
                name$0=match[1],
                _kX_=function(_k0_){return amap(f,_k0_)},
                _kY_=caml_call2(Stdlib_list[17],_kX_,elts),
                _kZ_=[0,caml_call2(f,name$0,attribs$0)];
               return caml_call3(Xml[21],_kZ_,name$0,_kY_)
              }
           return n}
         function add_float_attrib(name,value,param)
          {if(param)
            {var tail=param[2],head=param[1];
             return caml_string_equal(caml_call1(Xml[25],head),name)
                     ?[0,caml_call2(Xml[4],name,value),tail]
                     :[0,head,add_float_attrib(name,value,tail)]}
           return [0,caml_call2(Xml[4],name,value),0]}
         function map_float_attrib(is_attrib,f,l)
          {function aux(head)
            {var match=caml_call1(Xml[26],head);
             if(0 === match[0])
              {var value=match[1];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {var _kU_=caml_call1(f,value),_kV_=caml_call1(Xml[25],head);
                 return caml_call2(Xml[4],_kV_,_kU_)}}
             return head}
           return caml_call2(Stdlib_list[17],aux,l)}
         function add_int_attrib(name,value,param)
          {if(param)
            {var tail=param[2],head=param[1];
             return caml_string_equal(caml_call1(Xml[25],head),name)
                     ?[0,caml_call2(Xml[5],name,value),tail]
                     :[0,head,add_int_attrib(name,value,tail)]}
           return [0,caml_call2(Xml[5],name,value),0]}
         function rm_attrib(is_attrib,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var tail=param$0[2],head=param$0[1];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {var param$0=tail;continue}
               return [0,head,rm_attrib(is_attrib,tail)]}
             return 0}}
         function map_int_attrib(is_attrib,f,l)
          {function aux(head)
            {var match=caml_call1(Xml[26],head);
             if(1 === match[0])
              {var value=match[1];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {var _kS_=caml_call1(f,value),_kT_=caml_call1(Xml[25],head);
                 return caml_call2(Xml[5],_kT_,_kS_)}}
             return head}
           return caml_call2(Stdlib_list[17],aux,l)}
         function add_string_attrib(name,value,param)
          {if(param)
            {var tail=param[2],head=param[1];
             return caml_string_equal(caml_call1(Xml[25],head),name)
                     ?[0,caml_call2(Xml[6],name,value),tail]
                     :[0,head,add_string_attrib(name,value,tail)]}
           return [0,caml_call2(Xml[6],name,value),0]}
         function map_string_attrib(is_attrib,f,l)
          {function aux(head)
            {var match=caml_call1(Xml[26],head);
             if(2 === match[0])
              {var value=match[1];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {var _kQ_=caml_call1(f,value),_kR_=caml_call1(Xml[25],head);
                 return caml_call2(Xml[6],_kR_,_kQ_)}}
             return head}
           return caml_call2(Stdlib_list[17],aux,l)}
         function add_space_sep_attrib(name,value,param)
          {if(param)
            {var tail=param[2],head=param[1],match=caml_call1(Xml[26],head);
             if(3 === match[0] && 0 === match[1])
              {var values=match[2];
               if(caml_string_equal(caml_call1(Xml[25],head),name))
                return [0,caml_call2(Xml[7],name,[0,value,values]),tail]}
             return caml_string_equal(caml_call1(Xml[25],head),name)
                     ?[0,caml_call2(Xml[7],name,[0,value,0]),tail]
                     :[0,head,add_space_sep_attrib(name,value,tail)]}
           return [0,caml_call2(Xml[7],name,[0,value,0]),0]}
         function add_comma_sep_attrib(name,value,param)
          {if(param)
            {var tail=param[2],head=param[1],match=caml_call1(Xml[26],head);
             if(3 === match[0] && 0 !== match[1])
              {var values=match[2];
               if(caml_string_equal(caml_call1(Xml[25],head),name))
                return [0,caml_call2(Xml[8],name,[0,value,values]),tail]}
             return caml_string_equal(caml_call1(Xml[25],head),name)
                     ?[0,caml_call2(Xml[8],name,[0,value,0]),tail]
                     :[0,head,add_comma_sep_attrib(name,value,tail)]}
           return [0,caml_call2(Xml[8],name,[0,value,0]),0]}
         function rm_attrib_from_list(is_attrib,is_value,param)
          {if(param)
            {var tail=param[2],head=param[1],match=caml_call1(Xml[26],head);
             if(3 === match[0])
              {var values=match[2],sep=match[1];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {var
                  _kN_=function(v){return 1 - caml_call1(is_value,v)},
                  values$0=caml_call2(Stdlib_list[36],_kN_,values);
                 if(values$0)
                  {if(0 === sep)
                    {var _kO_=caml_call1(Xml[25],head);
                     return [0,caml_call2(Xml[7],_kO_,values$0),tail]}
                   var _kP_=caml_call1(Xml[25],head);
                   return [0,caml_call2(Xml[8],_kP_,values$0),tail]}
                 return tail}}
             return [0,head,rm_attrib_from_list(is_attrib,is_value,tail)]}
           return 0}
         function map_string_attrib_in_list(is_attrib,f,l)
          {function aux(head)
            {var match=caml_call1(Xml[26],head);
             if(3 === match[0])
              {var values=match[2],sep=match[1];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {if(0 === sep)
                  {var
                    _kJ_=caml_call2(Stdlib_list[17],f,values),
                    _kK_=caml_call1(Xml[25],head);
                   return caml_call2(Xml[7],_kK_,_kJ_)}
                 var
                  _kL_=caml_call2(Stdlib_list[17],f,values),
                  _kM_=caml_call1(Xml[25],head);
                 return caml_call2(Xml[8],_kM_,_kL_)}}
             return head}
           return caml_call2(Stdlib_list[17],aux,l)}
         function fold
          (of_empty,
           of_comment,
           of_txt,
           of_encodedpcdata,
           of_entity,
           of_leaf,
           of_node,
           n)
          {var match=caml_call1(Xml[27],n);
           if(typeof match === "number")
            return caml_call1(of_empty,0);
           else
            switch(match[0])
             {case 0:var s=match[1];return caml_call1(of_comment,s);
              case 1:var s$0=match[1];return caml_call1(of_encodedpcdata,s$0);
              case 2:var s$1=match[1];return caml_call1(of_txt,s$1);
              case 3:var s$2=match[1];return caml_call1(of_entity,s$2);
              case 4:
               var attribs=match[2],name=match[1];
               return caml_call2(of_leaf,name,attribs);
              default:
               var
                elts=match[3],
                attribs$0=match[2],
                name$0=match[1],
                _kH_=
                 function(_kI_)
                  {return fold
                           (of_empty,
                            of_comment,
                            of_txt,
                            of_encodedpcdata,
                            of_entity,
                            of_leaf,
                            of_node,
                            _kI_)};
               return caml_call3
                       (of_node,
                        name$0,
                        attribs$0,
                        caml_call2(Stdlib_list[17],_kH_,elts))}}
         function all_entities(elt)
          {function f(param){return 0}
           function _kG_(ename,attribs,elts)
            {return caml_call1(Stdlib_list[14],elts)}
           return fold(f,f,f,f,f,function(ename,attribs){return 0},_kG_,elt)}
         function flatmap(f,l)
          {var _kF_=caml_call2(Stdlib_list[17],f,l);
           return caml_call1(Stdlib_list[13],_kF_)}
         function translate
          (root_leaf,root_node,sub_leaf,sub_node,update_state,state,n)
          {function translate(state,n)
            {var match=caml_call1(Xml[27],n);
             if(typeof match !== "number")
              switch(match[0])
               {case 4:
                 var attribs=match[2],name=match[1];
                 return caml_call3(sub_leaf,state,name,attribs);
                case 5:
                 var
                  elts=match[3],
                  attribs$0=match[2],
                  name$0=match[1],
                  _kD_=caml_call3(update_state,name$0,attribs$0,state);
                 return caml_call4
                         (sub_node,
                          state,
                          name$0,
                          attribs$0,
                          flatmap(function(_kE_){return translate(_kD_,_kE_)},elts))
                }
             return [0,n,0]}
           var match=caml_call1(Xml[27],n);
           if(typeof match !== "number")
            switch(match[0])
             {case 4:
               var attribs=match[2],name=match[1];
               return caml_call2(root_leaf,name,attribs);
              case 5:
               var elts=match[3],attribs$0=match[2],name$0=match[1];
               return caml_call3
                       (root_node,
                        name$0,
                        attribs$0,
                        flatmap(function(_kC_){return translate(state,_kC_)},elts))
              }
           return n}
         return [0,
                 amap,
                 amap1,
                 rm_attrib,
                 rm_attrib_from_list,
                 map_int_attrib,
                 map_float_attrib,
                 map_string_attrib,
                 map_string_attrib_in_list,
                 add_int_attrib,
                 add_float_attrib,
                 add_string_attrib,
                 add_comma_sep_attrib,
                 add_space_sep_attrib,
                 fold,
                 all_entities,
                 translate]}];
    caml_register_global(1096,Xml_iter,"Xml_iter");
    function string_of_iri(x){return caml_call2(Stdlib_printf[4],_P_,x)}
    function to_string(f,param)
     {var unit=param[2],n=param[1];
      if(unit)
       var unit$0=unit[1],_kB_=caml_call1(f,unit$0);
      else
       var _kB_=cst$31;
      return caml_call3(Stdlib_printf[4],_Q_,n,_kB_)}
    function angle_names(param)
     {return 4099509 === param?cst_rad:793050094 <= param?cst_grad:cst_deg}
    function string_of_angle(a){return to_string(angle_names,a)}
    function length_names(param)
     {return 16389 <= param
              ?17280 === param
                ?cst_mm
                :17956 <= param
                  ?17960 <= param?cst_px:cst_pt
                  :17939 <= param?cst_pc:cst_in
              :15496 <= param
                ?15507 <= param?cst_ex:cst_em
                :15050 <= param?cst_cm:cst$32}
    function string_of_length(a){return to_string(length_names,a)}
    function list(opt,f,l)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cst$33;
      var _kA_=caml_call2(Stdlib_list[17],f,l);
      return caml_call2(Stdlib_string[7],sep,_kA_)}
    function string_of_paint_whitout_icc(param)
     {if(typeof param === "number")
       return 870530776 <= param?cst_none:cst_currentColor;
      var match=param[2],icc=match[2],c=match[1];
      if(icc)
       {var x=icc[1],_kz_=caml_call2(Stdlib[28],sep,x);
        return caml_call2(Stdlib[28],c,_kz_)}
      return c}
    function string_of_paint(c)
     {if(typeof c !== "number" && 3652393 <= c[1])
       {var _kt_=c[2],_ku_=_kt_[2],_kv_=_kt_[1];
        if(_ku_)
         {var
           b=_ku_[1],
           _kw_=string_of_paint_whitout_icc(b),
           _kx_=caml_call2(Stdlib[28],cst$34,_kw_),
           _ky_=string_of_iri(_kv_);
          return caml_call2(Stdlib[28],_ky_,_kx_)}
        return string_of_iri(_kv_)}
      return string_of_paint_whitout_icc(c)}
    function Make_with_wrapped_functions(Xml,C)
     {var
       doctype=compose_doctype(cst_svg,_R_),
       Info=[0,content_type,0,0,version,standard,namespace,doctype],
       _fk_=Xml[2],
       _fl_=Xml[3];
      function tot(x){return x}
      function totl(x){return x}
      function toelt(x){return x}
      function toeltl(x){return x}
      function to_attrib(x){return x}
      function nullary(tag,a,param)
       {var _ks_=caml_call1(Xml[1][3],0);
        return caml_call3(Xml[21],a,tag,_ks_)}
      function unary(tag,a,elt)
       {var _kr_=caml_call1(Xml[1][4],elt);
        return caml_call3(Xml[21],a,tag,_kr_)}
      function star(tag,a,elts){return caml_call3(Xml[21],a,tag,elts)}
      function to_xmlattribs(x){return x}
      var _fm_=Xml[4],_fn_=Xml[6],_fo_=C[10],_fp_=C[10],_fq_=C[11];
      function user_attrib(f,name,v)
       {var _kq_=caml_call2(Xml[1][2],f,v);
        return caml_call2(Xml[6],name,_kq_)}
      var _fr_=Xml[6];
      function metadata(a,children)
       {return caml_call3(Xml[21],a,cst_metadata,children)}
      function foreignObject(a,children)
       {return caml_call3(Xml[21],a,cst_foreignObject,children)}
      function pcdata(s){return caml_call1(Xml[17],s)}
      var
       a_version=caml_call1(_fn_,cst_version),
       a_baseProfile=caml_call1(_fn_,cst_baseProfile);
      function a_x(_kp_){return user_attrib(_fo_,cst_x,_kp_)}
      function a_y(_ko_){return user_attrib(_fo_,cst_y,_ko_)}
      function a_width(_kn_){return user_attrib(_fp_,cst_width,_kn_)}
      function a_height(_km_){return user_attrib(_fp_,cst_height,_km_)}
      var
       a_preserveAspectRatio=caml_call1(_fn_,cst_preserveAspectRatio),
       a_contentScriptType=caml_call1(_fn_,cst_contentScriptType),
       a_contentStyleType=caml_call1(_fn_,cst_contentStyleType);
      function a_zoomAndPan(x){return user_attrib(C[4],cst_zoomAndSpan,x)}
      var
       a_href=caml_call1(_fn_,cst_href),
       a_xlink_href=caml_call1(_fn_,cst_xlink_href),
       a_requiredFeatures=caml_call1(Xml[7],cst_requiredFeatures),
       a_requiredExtensions=caml_call1(Xml[7],cst_requiredExtension),
       a_systemLanguage=caml_call1(Xml[8],cst_systemLanguage),
       _fs_=C[3];
      function a_externalRessourcesRequired(_kl_)
       {return user_attrib(_fs_,cst_externalRessourcesRequired,_kl_)}
      var a_id=caml_call1(_fn_,cst_id);
      function a_user_data(name)
       {return caml_call1(_fn_,caml_call2(Stdlib[28],cst_data,name))}
      var
       a_xml_base=caml_call1(_fn_,cst_xml_base),
       a_xml_lang=caml_call1(_fn_,cst_xml_lang);
      function a_xml_space(x){return user_attrib(C[4],cst_xml_space,x)}
      var
       a_type=caml_call1(_fn_,cst_type),
       a_media=caml_call1(Xml[8],cst_media),
       a_xlink_title=caml_call1(_fn_,cst_xlink_title),
       a_class=caml_call1(Xml[7],cst_class),
       a_style=caml_call1(_fn_,cst_style),
       _ft_=C[21];
      function a_transform(_kk_){return user_attrib(_ft_,cst_transform,_kk_)}
      var _fu_=C[7];
      function a_viewBox(_kj_){return user_attrib(_fu_,cst_viewBox,_kj_)}
      var
       a_d=caml_call1(_fn_,cst_d),
       a_pathLength=caml_call1(_fm_,cst_pathLength);
      function a_rx(_ki_){return user_attrib(_fp_,cst_rx,_ki_)}
      function a_ry(_kh_){return user_attrib(_fp_,cst_ry,_kh_)}
      function a_cx(_kg_){return user_attrib(_fp_,cst_cx,_kg_)}
      function a_cy(_kf_){return user_attrib(_fp_,cst_cy,_kf_)}
      function a_r(_ke_){return user_attrib(_fp_,cst_r,_ke_)}
      function a_x1(_kd_){return user_attrib(_fo_,cst_x1,_kd_)}
      function a_y1(_kc_){return user_attrib(_fo_,cst_y1,_kc_)}
      function a_x2(_kb_){return user_attrib(_fo_,cst_x2,_kb_)}
      function a_y2(_ka_){return user_attrib(_fo_,cst_y2,_ka_)}
      var _fv_=C[5];
      function a_points(_j$_){return user_attrib(_fv_,cst_points,_j$_)}
      function a_x_list(_j__){return user_attrib(_fq_,cst_x$0,_j__)}
      function a_y_list(_j9_){return user_attrib(_fq_,cst_y$0,_j9_)}
      var _fw_=C[12];
      function a_dx(_j8_){return user_attrib(_fw_,cst_dx,_j8_)}
      var _fx_=C[12];
      function a_dy(_j7_){return user_attrib(_fx_,cst_dy,_j7_)}
      function a_dx_list(_j6_){return user_attrib(_fq_,cst_dx$0,_j6_)}
      function a_dy_list(_j5_){return user_attrib(_fq_,cst_dy$0,_j5_)}
      function a_lengthAdjust(x){return user_attrib(C[4],cst_lengthAdjust,x)}
      function a_textLength(_j4_)
       {return user_attrib(_fp_,cst_textLength,_j4_)}
      function a_text_anchor(x){return user_attrib(C[4],cst_text_anchor,x)}
      function a_text_decoration(x)
       {return user_attrib(C[4],cst_text_decoration,x)}
      function a_text_rendering(x)
       {return user_attrib(C[4],cst_text_rendering,x)}
      var _fy_=C[14];
      function a_rotate(_j3_){return user_attrib(_fy_,cst_rotate,_j3_)}
      function a_startOffset(_j2_)
       {return user_attrib(_fp_,cst_startOffset,_j2_)}
      function a_method(x){return user_attrib(C[4],cst_method,x)}
      function a_spacing(x){return user_attrib(C[4],cst_spacing,x)}
      var
       a_glyphRef=caml_call1(_fn_,cst_glyphRef),
       a_format=caml_call1(_fn_,cst_format);
      function a_markerUnits(x){return user_attrib(C[4],cst_markerUnits,x)}
      function a_refX(_j1_){return user_attrib(_fo_,cst_refX,_j1_)}
      function a_refY(_j0_){return user_attrib(_fo_,cst_refY,_j0_)}
      function a_markerWidth(_jZ_)
       {return user_attrib(_fp_,cst_markerWidth,_jZ_)}
      function a_markerHeight(_jY_)
       {return user_attrib(_fp_,cst_markerHeight,_jY_)}
      function a_orient(x){return user_attrib(C[17],cst_orient,x)}
      var a_local=caml_call1(_fn_,cst_local);
      function a_rendering_intent(x)
       {return user_attrib(C[4],cst_rendering_intent,x)}
      function a_gradientUnits(x)
       {return user_attrib(C[4],cst_gradientUnits,x)}
      var _fz_=C[21];
      function a_gradientTransform(_jX_)
       {return user_attrib(_fz_,cst_gradientTransform,_jX_)}
      function a_spreadMethod(x){return user_attrib(C[4],cst_spreadMethod,x)}
      function a_fx(_jW_){return user_attrib(_fo_,cst_fx,_jW_)}
      function a_fy(_jV_){return user_attrib(_fo_,cst_fy,_jV_)}
      function a_offset(x){return user_attrib(C[16],cst_offset,x)}
      function a_patternUnits(x){return user_attrib(C[4],cst_patternUnits,x)}
      function a_patternContentUnits(x)
       {return user_attrib(C[4],cst_patternContentUnits,x)}
      function a_patternTransform(x)
       {return user_attrib(C[21],cst_patternTransform,x)}
      function a_clipPathUnits(x)
       {return user_attrib(C[4],cst_clipPathUnits,x)}
      function a_maskUnits(x){return user_attrib(C[4],cst_maskUnits,x)}
      function a_maskContentUnits(x)
       {return user_attrib(C[4],cst_maskContentUnits,x)}
      function a_primitiveUnits(x)
       {return user_attrib(C[4],cst_primitiveUnits,x)}
      var _fA_=C[13];
      function a_filterRes(_jU_)
       {return user_attrib(_fA_,cst_filterResUnits,_jU_)}
      var a_result=caml_call1(_fn_,cst_result);
      function a_in(x){return user_attrib(C[8],cst_in$0,x)}
      function a_in2(x){return user_attrib(C[8],cst_in2,x)}
      var
       a_azimuth=caml_call1(_fm_,cst_azimuth),
       a_elevation=caml_call1(_fm_,cst_elevation),
       a_pointsAtX=caml_call1(_fm_,cst_pointsAtX),
       a_pointsAtY=caml_call1(_fm_,cst_pointsAtY),
       a_pointsAtZ=caml_call1(_fm_,cst_pointsAtZ),
       a_specularExponent=caml_call1(_fm_,cst_specularExponent),
       a_specularConstant=caml_call1(_fm_,cst_specularConstant),
       a_limitingConeAngle=caml_call1(_fm_,cst_limitingConeAngle);
      function a_mode(x){return user_attrib(C[4],cst_mode,x)}
      function a_feColorMatrix_type(x){return user_attrib(C[4],cst_type$0,x)}
      var _fB_=C[14];
      function a_values(_jT_){return user_attrib(_fB_,cst_values,_jT_)}
      function a_transfer_type(x){return user_attrib(C[4],cst_type$1,x)}
      var _fC_=C[14];
      function a_tableValues(_jS_)
       {return user_attrib(_fC_,cst_tableValues,_jS_)}
      var _fD_=C[12];
      function a_intercept(_jR_){return user_attrib(_fD_,cst_intercept,_jR_)}
      var _fE_=C[12];
      function a_amplitude(_jQ_){return user_attrib(_fE_,cst_amplitude,_jQ_)}
      var _fF_=C[12];
      function a_exponent(_jP_){return user_attrib(_fF_,cst_exponent,_jP_)}
      var _fG_=C[12];
      function a_transfer_offset(_jO_)
       {return user_attrib(_fG_,cst_offset$0,_jO_)}
      function a_feComposite_operator(x)
       {return user_attrib(C[4],cst_operator,x)}
      var _fH_=C[12];
      function a_k1(_jN_){return user_attrib(_fH_,cst_k1,_jN_)}
      var _fI_=C[12];
      function a_k2(_jM_){return user_attrib(_fI_,cst_k2,_jM_)}
      var _fJ_=C[12];
      function a_k3(_jL_){return user_attrib(_fJ_,cst_k3,_jL_)}
      var _fK_=C[12];
      function a_k4(_jK_){return user_attrib(_fK_,cst_k4,_jK_)}
      var _fL_=C[13];
      function a_order(_jJ_){return user_attrib(_fL_,cst_order,_jJ_)}
      var _fM_=C[14];
      function a_kernelMatrix(_jI_)
       {return user_attrib(_fM_,cst_kernelMatrix,_jI_)}
      var _fN_=C[12];
      function a_divisor(_jH_){return user_attrib(_fN_,cst_divisor,_jH_)}
      var _fO_=C[12];
      function a_bias(_jG_){return user_attrib(_fO_,cst_bias,_jG_)}
      var _fP_=C[13];
      function a_kernelUnitLength(_jF_)
       {return user_attrib(_fP_,cst_kernelUnitLength,_jF_)}
      var _fQ_=C[9];
      function a_targetX(_jE_){return user_attrib(_fQ_,cst_targetX,_jE_)}
      var _fR_=C[9];
      function a_targetY(_jD_){return user_attrib(_fR_,cst_targetY,_jD_)}
      function a_edgeMode(x){return user_attrib(C[4],cst_targetY$0,x)}
      var _fS_=C[3];
      function a_preserveAlpha(_jC_)
       {return user_attrib(_fS_,cst_preserveAlpha,_jC_)}
      var _fT_=C[12];
      function a_surfaceScale(_jB_)
       {return user_attrib(_fT_,cst_surfaceScale,_jB_)}
      var _fU_=C[12];
      function a_diffuseConstant(_jA_)
       {return user_attrib(_fU_,cst_diffuseConstant,_jA_)}
      var _fV_=C[12];
      function a_scale(_jz_){return user_attrib(_fV_,cst_scale,_jz_)}
      function a_xChannelSelector(x)
       {return user_attrib(C[4],cst_xChannelSelector,x)}
      function a_yChannelSelector(x)
       {return user_attrib(C[4],cst_yChannelSelector,x)}
      var _fW_=C[13];
      function a_stdDeviation(_jy_)
       {return user_attrib(_fW_,cst_stdDeviation,_jy_)}
      function a_feMorphology_operator(x)
       {return user_attrib(C[4],cst_operator$0,x)}
      var _fX_=C[13];
      function a_radius(_jx_){return user_attrib(_fX_,cst_radius,_jx_)}
      var _fY_=C[13];
      function a_baseFrenquency(_jw_)
       {return user_attrib(_fY_,cst_baseFrequency,_jw_)}
      var _fZ_=C[9];
      function a_numOctaves(_jv_)
       {return user_attrib(_fZ_,cst_numOctaves,_jv_)}
      var _f0_=C[12];
      function a_seed(_ju_){return user_attrib(_f0_,cst_seed,_ju_)}
      function a_stitchTiles(x){return user_attrib(C[4],cst_stitchTiles,x)}
      function a_feTurbulence_type(x){return user_attrib(C[4],cst_type$2,x)}
      function a_xlink_show(x){return user_attrib(C[4],cst_xlink_show,x)}
      function a_xlink_actuate(x)
       {return user_attrib(C[4],cst_xlink_actuate,x)}
      var
       a_target=caml_call1(_fn_,cst_xlink_target),
       a_viewTarget=caml_call1(_fn_,cst_viewTarget),
       a_attributeName=caml_call1(_fn_,cst_attributeName);
      function a_attributeType(x)
       {return user_attrib(C[4],cst_attributeType,x)}
      var
       a_begin=caml_call1(_fn_,cst_begin),
       a_dur=caml_call1(_fn_,cst_dur),
       a_min=caml_call1(_fn_,cst_min),
       a_max=caml_call1(_fn_,cst_max);
      function a_restart(x){return user_attrib(C[4],cst_restart,x)}
      var
       a_repeatCount=caml_call1(_fn_,cst_repeatCount),
       a_repeatDur=caml_call1(_fn_,cst_repeatDur),
       _f1_=C[18];
      function a_fill(_jt_){return user_attrib(_f1_,cst_fill,_jt_)}
      function a_animation_fill(x){return user_attrib(C[4],cst_fill$0,x)}
      function a_calcMode(x){return user_attrib(C[4],cst_calcMode,x)}
      var
       a_animation_values=caml_call1(Xml[8],cst_values$0),
       a_keyTimes=caml_call1(Xml[8],cst_keyTimes),
       a_keySplines=caml_call1(Xml[8],cst_keySplines),
       a_from=caml_call1(_fn_,cst_from),
       a_to=caml_call1(_fn_,cst_to),
       a_by=caml_call1(_fn_,cst_by);
      function a_additive(x){return user_attrib(C[4],cst_additive,x)}
      function a_accumulate(x){return user_attrib(C[4],cst_accumulate,x)}
      var _f2_=C[15];
      function a_keyPoints(_js_){return user_attrib(_f2_,cst_keyPoints,_js_)}
      var a_path=caml_call1(_fn_,cst_path),_f3_=C[4];
      function a_animateTransform_type(_jr_)
       {return user_attrib(_f3_,cst_type$3,_jr_)}
      var _f4_=C[12];
      function a_horiz_origin_x(_jq_)
       {return user_attrib(_f4_,cst_horiz_origin_x,_jq_)}
      var _f5_=C[12];
      function a_horiz_origin_y(_jp_)
       {return user_attrib(_f5_,cst_horiz_origin_y,_jp_)}
      var _f6_=C[12];
      function a_horiz_adv_x(_jo_)
       {return user_attrib(_f6_,cst_horiz_adv_x,_jo_)}
      var _f7_=C[12];
      function a_vert_origin_x(_jn_)
       {return user_attrib(_f7_,cst_vert_origin_x,_jn_)}
      var _f8_=C[12];
      function a_vert_origin_y(_jm_)
       {return user_attrib(_f8_,cst_vert_origin_y,_jm_)}
      var _f9_=C[12];
      function a_vert_adv_y(_jl_)
       {return user_attrib(_f9_,cst_vert_adv_y,_jl_)}
      var
       a_unicode=caml_call1(_fn_,cst_unicode),
       a_glyph_name=caml_call1(_fn_,cst_glyphname);
      function a_orientation(x){return user_attrib(C[4],cst_orientation,x)}
      function a_arabic_form(x){return user_attrib(C[4],cst_arabic_form,x)}
      var
       a_lang=caml_call1(_fn_,cst_lang),
       a_u1=caml_call1(_fn_,cst_u1),
       a_u2=caml_call1(_fn_,cst_u2),
       a_g1=caml_call1(_fn_,cst_g1),
       a_g2=caml_call1(_fn_,cst_g2),
       a_k=caml_call1(_fn_,cst_k),
       a_font_family=caml_call1(_fn_,cst_font_family),
       a_font_style=caml_call1(_fn_,cst_font_style),
       a_font_variant=caml_call1(_fn_,cst_font_variant),
       a_font_weight=caml_call1(_fn_,cst_font_weight),
       a_font_stretch=caml_call1(_fn_,cst_font_stretch),
       a_font_size=caml_call1(_fn_,cst_font_size),
       a_unicode_range=caml_call1(_fn_,cst_unicode_range),
       a_units_per_em=caml_call1(_fn_,cst_units_per_em),
       _f__=C[12];
      function a_stemv(_jk_){return user_attrib(_f__,cst_stemv,_jk_)}
      var _f$_=C[12];
      function a_stemh(_jj_){return user_attrib(_f$_,cst_stemh,_jj_)}
      var _ga_=C[12];
      function a_slope(_ji_){return user_attrib(_ga_,cst_slope,_ji_)}
      var _gb_=C[12];
      function a_cap_height(_jh_)
       {return user_attrib(_gb_,cst_cap_height,_jh_)}
      var _gc_=C[12];
      function a_x_height(_jg_){return user_attrib(_gc_,cst_x_height,_jg_)}
      var _gd_=C[12];
      function a_accent_height(_jf_)
       {return user_attrib(_gd_,cst_accent_height,_jf_)}
      var _ge_=C[12];
      function a_ascent(_je_){return user_attrib(_ge_,cst_ascent,_je_)}
      var
       a_widths=caml_call1(_fn_,cst_widths),
       a_bbox=caml_call1(_fn_,cst_bbox),
       _gf_=C[12];
      function a_ideographic(_jd_)
       {return user_attrib(_gf_,cst_ideographic,_jd_)}
      var _gg_=C[12];
      function a_alphabetic(_jc_)
       {return user_attrib(_gg_,cst_alphabetic,_jc_)}
      var _gh_=C[12];
      function a_mathematical(_jb_)
       {return user_attrib(_gh_,cst_mathematical,_jb_)}
      var _gi_=C[12];
      function a_hanging(_ja_){return user_attrib(_gi_,cst_hanging,_ja_)}
      var _gj_=C[12];
      function a_videographic(_i$_)
       {return user_attrib(_gj_,cst_v_ideographic,_i$_)}
      var _gk_=C[12];
      function a_v_alphabetic(_i__)
       {return user_attrib(_gk_,cst_v_alphabetic,_i__)}
      var _gl_=C[12];
      function a_v_mathematical(_i9_)
       {return user_attrib(_gl_,cst_v_mathematical,_i9_)}
      var _gm_=C[12];
      function a_v_hanging(_i8_){return user_attrib(_gm_,cst_v_hanging,_i8_)}
      var _gn_=C[12];
      function a_underline_position(_i7_)
       {return user_attrib(_gn_,cst_underline_position,_i7_)}
      var _go_=C[12];
      function a_underline_thickness(_i6_)
       {return user_attrib(_go_,cst_underline_thickness,_i6_)}
      var _gp_=C[12];
      function a_strikethrough_position(_i5_)
       {return user_attrib(_gp_,cst_strikethrough_position,_i5_)}
      var _gq_=C[12];
      function a_strikethrough_thickness(_i4_)
       {return user_attrib(_gq_,cst_strikethrough_thickness,_i4_)}
      var _gr_=C[12];
      function a_overline_position(_i3_)
       {return user_attrib(_gr_,cst_overline_position,_i3_)}
      var _gs_=C[12];
      function a_overline_thickness(_i2_)
       {return user_attrib(_gs_,cst_overline_thickness,_i2_)}
      var
       a_string=caml_call1(_fn_,cst_string),
       a_name=caml_call1(_fn_,cst_name);
      function a_alignment_baseline(x)
       {return user_attrib(C[2],cst_alignment_baseline,x)}
      function a_dominant_baseline(x)
       {return user_attrib(C[6],cst_dominant_baseline,x)}
      var
       a_onabort=caml_call1(Xml[9],cst_onabort),
       a_onactivate=caml_call1(Xml[9],cst_onactivate),
       a_onbegin=caml_call1(Xml[9],cst_onbegin),
       a_onend=caml_call1(Xml[9],cst_onend),
       a_onerror=caml_call1(Xml[9],cst_onerror),
       a_onfocusin=caml_call1(Xml[9],cst_onfocusin),
       a_onfocusout=caml_call1(Xml[9],cst_onfocusout),
       a_onload=caml_call1(Xml[9],cst_onload),
       a_onrepeat=caml_call1(Xml[9],cst_onrepeat),
       a_onresize=caml_call1(Xml[9],cst_onresize),
       a_onscroll=caml_call1(Xml[9],cst_onscroll),
       a_onunload=caml_call1(Xml[9],cst_onunload),
       a_onzoom=caml_call1(Xml[9],cst_onzoom),
       a_onclick=caml_call1(Xml[10],cst_onclick),
       a_onmousedown=caml_call1(Xml[10],cst_onmousedown),
       a_onmouseup=caml_call1(Xml[10],cst_onmouseup),
       a_onmouseover=caml_call1(Xml[10],cst_onmouseover),
       a_onmouseout=caml_call1(Xml[10],cst_onmouseout),
       a_onmousemove=caml_call1(Xml[10],cst_onmousemove),
       a_ontouchstart=caml_call1(Xml[12],cst_ontouchstart),
       a_ontouchend=caml_call1(Xml[12],cst_ontouchend),
       a_ontouchmove=caml_call1(Xml[12],cst_ontouchmove),
       a_ontouchcancel=caml_call1(Xml[12],cst_ontouchcancel),
       a_stop_color=caml_call1(_fr_,cst_stop_color),
       _gt_=C[12];
      function a_stop_opacity(_i1_)
       {return user_attrib(_gt_,cst_stop_opacity,_i1_)}
      var _gu_=C[18];
      function a_stroke(_i0_){return user_attrib(_gu_,cst_stroke,_i0_)}
      var _gv_=C[10];
      function a_stroke_width(_iZ_)
       {return user_attrib(_gv_,cst_stroke_width,_iZ_)}
      function a_stroke_linecap(x)
       {return user_attrib(C[4],cst_stroke_linecap,x)}
      function a_stroke_linejoin(x)
       {return user_attrib(C[4],cst_stroke_linejoin,x)}
      var _gw_=C[12];
      function a_stroke_miterlimit(_iY_)
       {return user_attrib(_gw_,cst_stroke_miterlimit,_iY_)}
      function a_stroke_dasharray(x)
       {return user_attrib(C[19],cst_stroke_dasharray,x)}
      var _gx_=C[10];
      function a_stroke_dashoffset(_iX_)
       {return user_attrib(_gx_,cst_stroke_dashoffset,_iX_)}
      var _gy_=C[12];
      function a_stroke_opacity(_iW_)
       {return user_attrib(_gy_,cst_stroke_opacity,_iW_)}
      function svg(opt,children)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var
         _iV_=
          [0,
           caml_call2
            (_fn_,
             cst_xmlns_xlink,
             caml_call1(Xml[1][1],cst_http_www_w3_org_1999_xlink)),
           a],
         attribs=
          [0,
           caml_call2
            (_fn_,
             cst_xmlns$3,
             caml_call1(Xml[1][1],cst_http_www_w3_org_2000_svg)),
           _iV_];
        return star(cst_svg$0,[0,attribs],children)}
      function g(_iT_,_iU_){return star(cst_g,_iT_,_iU_)}
      function defs(_iR_,_iS_){return star(cst_defs,_iR_,_iS_)}
      function desc(_iP_,_iQ_){return unary(cst_desc,_iP_,_iQ_)}
      function title(_iN_,_iO_){return unary(cst_title,_iN_,_iO_)}
      function symbol(_iL_,_iM_){return star(cst_symbol,_iL_,_iM_)}
      function use(_iJ_,_iK_){return star(cst_use,_iJ_,_iK_)}
      function image(_iH_,_iI_){return star(cst_image,_iH_,_iI_)}
      function switch$0(_iF_,_iG_){return star(cst_switch,_iF_,_iG_)}
      function style(_iD_,_iE_){return unary(cst_style$0,_iD_,_iE_)}
      function path(_iB_,_iC_){return star(cst_path$0,_iB_,_iC_)}
      function rect(_iz_,_iA_){return star(cst_rect,_iz_,_iA_)}
      function circle(_ix_,_iy_){return star(cst_circle,_ix_,_iy_)}
      function ellipse(_iv_,_iw_){return star(cst_ellipse,_iv_,_iw_)}
      function line(_it_,_iu_){return star(cst_line,_it_,_iu_)}
      function polyline(_ir_,_is_){return star(cst_polyline,_ir_,_is_)}
      function polygon(_ip_,_iq_){return star(cst_polygon,_ip_,_iq_)}
      function text(_in_,_io_){return star(cst_text,_in_,_io_)}
      function tspan(_il_,_im_){return star(cst_tspan,_il_,_im_)}
      function tref(_ij_,_ik_){return star(cst_tref,_ij_,_ik_)}
      function textPath(_ih_,_ii_){return star(cst_textPath,_ih_,_ii_)}
      function altGlyph(_if_,_ig_){return unary(cst_altGlyph,_if_,_ig_)}
      function altGlyphDef(_id_,_ie_){return unary(cst_altGlyphDef,_id_,_ie_)}
      function altGlyphItem(_ib_,_ic_)
       {return star(cst_altGlyphItem,_ib_,_ic_)}
      function glyphRef(_h$_,_ia_){return nullary(cst_glyphRef$0,_h$_,_ia_)}
      function marker(_h9_,_h__){return star(cst_marker,_h9_,_h__)}
      function color_profile(_h7_,_h8_)
       {return star(cst_color_profile,_h7_,_h8_)}
      function linearGradient(_h5_,_h6_)
       {return star(cst_linearGradient,_h5_,_h6_)}
      function radialGradient(_h3_,_h4_)
       {return star(cst_radialGradient,_h3_,_h4_)}
      function stop(_h1_,_h2_){return star(cst_stop,_h1_,_h2_)}
      function pattern(_hZ_,_h0_){return star(cst_pattern,_hZ_,_h0_)}
      function clipPath(_hX_,_hY_){return star(cst_clipPath,_hX_,_hY_)}
      function filter(_hV_,_hW_){return star(cst_filter,_hV_,_hW_)}
      function feDistantLight(_hT_,_hU_)
       {return star(cst_feDistantLight,_hT_,_hU_)}
      function fePointLight(_hR_,_hS_)
       {return star(cst_fePointLight,_hR_,_hS_)}
      function feSpotLight(_hP_,_hQ_){return star(cst_feSpotLight,_hP_,_hQ_)}
      function feBlend(_hN_,_hO_){return star(cst_feBlend,_hN_,_hO_)}
      function feColorMatrix(_hL_,_hM_)
       {return star(cst_feColorMatrix,_hL_,_hM_)}
      function feComponentTransfer(_hJ_,_hK_)
       {return star(cst_feComponentTransfer,_hJ_,_hK_)}
      function feFuncA(_hH_,_hI_){return star(cst_feFuncA,_hH_,_hI_)}
      function feFuncG(_hF_,_hG_){return star(cst_feFuncG,_hF_,_hG_)}
      function feFuncB(_hD_,_hE_){return star(cst_feFuncB,_hD_,_hE_)}
      function feFuncR(_hB_,_hC_){return star(cst_feFuncR,_hB_,_hC_)}
      function feComposite(_hz_,_hA_){return star(cst_feComposite,_hz_,_hA_)}
      function feConvolveMatrix(_hx_,_hy_)
       {return star(cst_feConvolveMatrix,_hx_,_hy_)}
      function feDiffuseLighting(_hv_,_hw_)
       {return star(cst_feDiffuseLighting,_hv_,_hw_)}
      function feDisplacementMap(_ht_,_hu_)
       {return star(cst_feDisplacementMap,_ht_,_hu_)}
      function feFlood(_hr_,_hs_){return star(cst_feFlood,_hr_,_hs_)}
      function feGaussianBlur(_hp_,_hq_)
       {return star(cst_feGaussianBlur,_hp_,_hq_)}
      function feImage(_hn_,_ho_){return star(cst_feImage,_hn_,_ho_)}
      function feMerge(_hl_,_hm_){return star(cst_feMerge,_hl_,_hm_)}
      function feMorphology(_hj_,_hk_)
       {return star(cst_feMorphology,_hj_,_hk_)}
      function feOffset(_hh_,_hi_){return star(cst_feOffset,_hh_,_hi_)}
      function feSpecularLighting(_hf_,_hg_)
       {return star(cst_feSpecularLighting,_hf_,_hg_)}
      function feTile(_hd_,_he_){return star(cst_feTile,_hd_,_he_)}
      function feTurbulence(_hb_,_hc_)
       {return star(cst_feTurbulence,_hb_,_hc_)}
      function cursor(_g$_,_ha_){return star(cst_cursor,_g$_,_ha_)}
      function a(_g9_,_g__){return star(cst_a,_g9_,_g__)}
      function view(_g7_,_g8_){return star(cst_view,_g7_,_g8_)}
      function script(_g5_,_g6_){return unary(cst_script,_g5_,_g6_)}
      function animation(_g3_,_g4_){return star(cst_animate,_g3_,_g4_)}
      function set(_g1_,_g2_){return star(cst_set,_g1_,_g2_)}
      function animateMotion(_gZ_,_g0_)
       {return star(cst_animateMotion,_gZ_,_g0_)}
      function mpath(_gX_,_gY_){return star(cst_mpath,_gX_,_gY_)}
      function animateColor(_gV_,_gW_)
       {return star(cst_animateColor,_gV_,_gW_)}
      function animateTransform(_gT_,_gU_)
       {return star(cst_animateTransform,_gT_,_gU_)}
      function font(_gR_,_gS_){return star(cst_font,_gR_,_gS_)}
      function glyph(_gP_,_gQ_){return star(cst_glyph,_gP_,_gQ_)}
      function missing_glyph(_gN_,_gO_)
       {return star(cst_missing_glyph,_gN_,_gO_)}
      function hkern(_gL_,_gM_){return nullary(cst_hkern,_gL_,_gM_)}
      function vkern(_gJ_,_gK_){return nullary(cst_vkern,_gJ_,_gK_)}
      function font_face(_gH_,_gI_){return nullary(cst_font_face,_gH_,_gI_)}
      function font_face_src(_gF_,_gG_)
       {return star(cst_font_face_src,_gF_,_gG_)}
      function font_face_uri(_gD_,_gE_)
       {return star(cst_font_face_uri,_gD_,_gE_)}
      function font_face_format(_gB_,_gC_)
       {return nullary(cst_font_face_uri$0,_gB_,_gC_)}
      function font_face_name(_gz_,_gA_)
       {return nullary(cst_font_face_name,_gz_,_gA_)}
      function doc_toelt(x){return x}
      var I=_a_(Xml);
      function of_seq(s){return caml_call1(I[1],s)}
      function data(s){return caml_call1(Xml[18],s)}
      function leaf(tag,a,param){return caml_call2(Xml[20],a,tag)}
      function node(tag,a,elts){return caml_call3(Xml[21],a,tag,elts)}
      function coerce_elt(x){return x}
      var float_attrib=Xml[4],int_attrib=Xml[5],string_attrib=Xml[6];
      function uri_attrib(a,s){return caml_call2(Xml[13],a,s)}
      var
       space_sep_attrib=Xml[7],
       comma_sep_attrib=Xml[8],
       Unsafe=
        [0,
         data,
         leaf,
         node,
         coerce_elt,
         float_attrib,
         int_attrib,
         string_attrib,
         uri_attrib,
         space_sep_attrib,
         comma_sep_attrib];
      return [0,
              Xml,
              Info,
              _fk_,
              _fl_,
              tot,
              totl,
              toelt,
              toeltl,
              to_attrib,
              nullary,
              unary,
              star,
              to_xmlattribs,
              _fm_,
              _fn_,
              _fo_,
              _fp_,
              _fq_,
              user_attrib,
              _fm_,
              _fr_,
              metadata,
              foreignObject,
              pcdata,
              pcdata,
              a_version,
              a_baseProfile,
              a_x,
              a_y,
              a_width,
              a_height,
              a_preserveAspectRatio,
              a_contentScriptType,
              a_contentStyleType,
              a_zoomAndPan,
              a_href,
              a_xlink_href,
              a_requiredFeatures,
              a_requiredExtensions,
              a_systemLanguage,
              a_externalRessourcesRequired,
              a_id,
              a_user_data,
              a_xml_base,
              a_xml_lang,
              a_xml_space,
              a_type,
              a_media,
              a_xlink_title,
              a_class,
              a_style,
              a_transform,
              a_viewBox,
              a_d,
              a_pathLength,
              a_rx,
              a_ry,
              a_cx,
              a_cy,
              a_r,
              a_x1,
              a_y1,
              a_x2,
              a_y2,
              a_points,
              a_x_list,
              a_y_list,
              a_dx,
              a_dy,
              a_dx_list,
              a_dy_list,
              a_lengthAdjust,
              a_textLength,
              a_text_anchor,
              a_text_decoration,
              a_text_rendering,
              a_rotate,
              a_startOffset,
              a_method,
              a_spacing,
              a_glyphRef,
              a_format,
              a_markerUnits,
              a_refX,
              a_refY,
              a_markerWidth,
              a_markerHeight,
              a_orient,
              a_local,
              a_rendering_intent,
              a_gradientUnits,
              a_gradientTransform,
              a_spreadMethod,
              a_fx,
              a_fy,
              a_offset,
              a_patternUnits,
              a_patternContentUnits,
              a_patternTransform,
              a_clipPathUnits,
              a_maskUnits,
              a_maskContentUnits,
              a_primitiveUnits,
              a_filterRes,
              a_result,
              a_in,
              a_in2,
              a_azimuth,
              a_elevation,
              a_pointsAtX,
              a_pointsAtY,
              a_pointsAtZ,
              a_specularExponent,
              a_specularConstant,
              a_limitingConeAngle,
              a_mode,
              a_feColorMatrix_type,
              a_values,
              a_transfer_type,
              a_tableValues,
              a_intercept,
              a_amplitude,
              a_exponent,
              a_transfer_offset,
              a_feComposite_operator,
              a_k1,
              a_k2,
              a_k3,
              a_k4,
              a_order,
              a_kernelMatrix,
              a_divisor,
              a_bias,
              a_kernelUnitLength,
              a_targetX,
              a_targetY,
              a_edgeMode,
              a_preserveAlpha,
              a_surfaceScale,
              a_diffuseConstant,
              a_scale,
              a_xChannelSelector,
              a_yChannelSelector,
              a_stdDeviation,
              a_feMorphology_operator,
              a_radius,
              a_baseFrenquency,
              a_numOctaves,
              a_seed,
              a_stitchTiles,
              a_feTurbulence_type,
              a_xlink_show,
              a_xlink_actuate,
              a_target,
              a_viewTarget,
              a_attributeName,
              a_attributeType,
              a_begin,
              a_dur,
              a_min,
              a_max,
              a_restart,
              a_repeatCount,
              a_repeatDur,
              a_fill,
              a_animation_fill,
              a_calcMode,
              a_animation_values,
              a_keyTimes,
              a_keySplines,
              a_from,
              a_to,
              a_by,
              a_additive,
              a_accumulate,
              a_keyPoints,
              a_path,
              a_animateTransform_type,
              a_horiz_origin_x,
              a_horiz_origin_y,
              a_horiz_adv_x,
              a_vert_origin_x,
              a_vert_origin_y,
              a_vert_adv_y,
              a_unicode,
              a_glyph_name,
              a_orientation,
              a_arabic_form,
              a_lang,
              a_u1,
              a_u2,
              a_g1,
              a_g2,
              a_k,
              a_font_family,
              a_font_style,
              a_font_variant,
              a_font_weight,
              a_font_stretch,
              a_font_size,
              a_unicode_range,
              a_units_per_em,
              a_stemv,
              a_stemh,
              a_slope,
              a_cap_height,
              a_x_height,
              a_accent_height,
              a_ascent,
              a_widths,
              a_bbox,
              a_ideographic,
              a_alphabetic,
              a_mathematical,
              a_hanging,
              a_videographic,
              a_v_alphabetic,
              a_v_mathematical,
              a_v_hanging,
              a_underline_position,
              a_underline_thickness,
              a_strikethrough_position,
              a_strikethrough_thickness,
              a_overline_position,
              a_overline_thickness,
              a_string,
              a_name,
              a_alignment_baseline,
              a_dominant_baseline,
              a_onabort,
              a_onactivate,
              a_onbegin,
              a_onend,
              a_onerror,
              a_onfocusin,
              a_onfocusout,
              a_onload,
              a_onrepeat,
              a_onresize,
              a_onscroll,
              a_onunload,
              a_onzoom,
              a_onclick,
              a_onmousedown,
              a_onmouseup,
              a_onmouseover,
              a_onmouseout,
              a_onmousemove,
              a_ontouchstart,
              a_ontouchend,
              a_ontouchmove,
              a_ontouchcancel,
              a_stop_color,
              a_stop_opacity,
              a_stroke,
              a_stroke_width,
              a_stroke_linecap,
              a_stroke_linejoin,
              a_stroke_miterlimit,
              a_stroke_dasharray,
              a_stroke_dashoffset,
              a_stroke_opacity,
              svg,
              g,
              defs,
              desc,
              title,
              symbol,
              use,
              image,
              switch$0,
              style,
              path,
              rect,
              circle,
              ellipse,
              line,
              polyline,
              polygon,
              text,
              tspan,
              tref,
              textPath,
              altGlyph,
              altGlyphDef,
              altGlyphItem,
              glyphRef,
              marker,
              color_profile,
              linearGradient,
              radialGradient,
              stop,
              pattern,
              clipPath,
              filter,
              feDistantLight,
              fePointLight,
              feSpotLight,
              feBlend,
              feColorMatrix,
              feComponentTransfer,
              feFuncA,
              feFuncG,
              feFuncB,
              feFuncR,
              feComposite,
              feConvolveMatrix,
              feDiffuseLighting,
              feDisplacementMap,
              feFlood,
              feGaussianBlur,
              feImage,
              feMerge,
              feMorphology,
              feOffset,
              feSpecularLighting,
              feTile,
              feTurbulence,
              cursor,
              a,
              view,
              script,
              animation,
              set,
              animateMotion,
              mpath,
              animateColor,
              animateTransform,
              font,
              glyph,
              missing_glyph,
              hkern,
              vkern,
              font_face,
              font_face_src,
              font_face_uri,
              font_face_format,
              font_face_name,
              doc_toelt,
              I,
              of_seq,
              Unsafe]}
    function Wrapped_functions(Xml)
     {function string_of_alignment_baseline(param)
       {return -72987685 <= param
                ?354434192 <= param
                  ?881373037 <= param
                    ?1018879136 <= param?cst_after_edge:cst_alphabetic$0
                    :726666127 <= param?cst_auto:cst_hanging$0
                  :15943541 === param
                    ?cst_middle
                    :218255880 <= param?cst_mathematical$0:cst_inherit
                :-840627829 <= param
                  ?-415175851 <= param
                    ?-354838363 <= param?cst_baseline:cst_central
                    :-693588957 <= param?cst_ideographic$0:cst_text_before_edge
                  :-863864035 <= param?cst_before_edge:cst_text_after_edge}
      function string_of_big_variant(param)
       {return 3350435 <= param
                ?476616093 <= param
                  ?744337004 <= param
                    ?914009117 <= param
                      ?970483178 <= param
                        ?1040349136 <= param
                          ?1071251601 <= param?cst_stitch:cst_onRequest
                          :990972795 <= param?cst_repeat:cst_wrap
                        :958206052 <= param?cst_remove:cst_reflect
                      :870530776 <= param
                        ?884917925 <= param
                          ?889668530 <= param?cst_noStitch:cst$35
                          :881966452 <= param?cst_over:cst_none$0
                        :861714216 <= param?cst_medial:cst_never
                    :568588039 <= param
                      ?716799946 <= param
                        ?726666127 <= param
                          ?737755699 <= param?cst_butt:cst_auto$0
                          :726615284 <= param?cst_atop:cst_arithmetic
                        :698610924 <= param?cst_underline:cst_gamma
                      :512807795 <= param
                        ?518168424 <= param
                          ?557106693 <= param?cst_linear:cst_overline
                          :517347077 <= param?cst_onLoad:cst_turbulence
                        :504440814 <= param?cst_table:cst_geometricPrecision
                  :163178525 <= param
                    ?316735838 <= param
                      ?389604418 <= param
                        ?463106021 <= param
                          ?466749770 <= param?cst_optimizeSpeed:cst_miter
                          :418396260 <= param?cst_initial:cst_start
                        :384893183 <= param?cst_whenNotActive:cst_identity
                      :201080426 <= param
                        ?289998318 <= param
                          ?289998319 <= param?cst_skewY:cst_skewX
                          :226915517 <= param?cst_square:cst_scale$0
                        :172069535 <= param?cst_exact:cst_perceptual
                    :4393399 <= param
                      ?9660462 <= param
                        ?106228547 <= param
                          ?118574553 <= param?cst_discrete:cst_erode
                          :15943541 <= param?cst_middle$0:cst_round
                        :4401019 <= param?cst_xor:cst_XML
                      :3901504 <= param
                        ?4000051 <= param
                          ?4153707 <= param?cst_sum:cst_pad
                          :3954798 <= param?cst_out:cst_new
                        :3455931 <= param?cst_end:cst_CSS
                :-453122489 <= param
                  ?-72987685 <= param
                    ?66 <= param
                      ?72 <= param
                        ?86 <= param
                          ?16389 <= param?cst_in$1:cst_v
                          :82 <= param?cst_r$0:cst_h
                        :71 <= param?cst_g$0:cst_b
                      :-68046964 <= param
                        ?-4932997 <= param
                          ?65 <= param?cst_a$0:cst_rotate$0
                          :-22441528 <= param?cst_disable:cst_screen
                        :-72678338 <= param?cst_absolute_colorimetric:cst_inherit$0
                    :-262362527 <= param
                      ?-197222844 <= param
                        ?-115006565 <= param
                          ?-76840209 <= param?cst_always:cst_spacingAndGlyphs
                          :-126259180 <= param?cst_replace:cst_multiply
                        :-197983439 <= param?cst_spline:cst_matrix
                      :-384499551 <= param
                        ?-318472885 <= param
                          ?-313337870 <= param?cst_saturation:cst_dilate
                          :-346900690 <= param?cst_translate:cst_default
                        :-415993185 <= param?cst_lighten:cst_normal
                  :-839430911 <= param
                    ?-672592881 <= param
                      ?-552838301 <= param
                        ?-505547199 <= param
                          ?-474415497 <= param?cst_freeze:cst_magnify
                          :-543144685 <= param?cst_hueRotate:cst_spacing$0
                        :-621842423 <= param?cst_fractalNoise:cst_saturate
                      :-797470191 <= param
                        ?-699926424 <= param
                          ?-689066995 <= param
                            ?cst_userSpaceOnUse
                            :cst_objectBoundingBox
                          :-707876225 <= param?cst_darken:cst_paced
                        :-824137927 <= param?cst_isolated:cst_optimizeLegibility
                    :-951087346 <= param
                      ?-912466532 <= param
                        ?-851306022 <= param
                          ?-851300629 <= param?cst_luminanceToAlpha:cst_line_through
                          :-912009552 <= param?cst_other:cst_terminal
                        :-937074372 <= param?cst_blink:cst_stroke_width$0
                      :-1044642615 === param
                        ?cst_relative_colorimetric
                        :-1014056864 <= param
                          ?-1012636187 <= param?cst_stretch:cst_bevel
                          :-1024851605 <= param?cst_duplicate:cst_preserve}
      var _eX_=Stdlib[30];
      function _eY_(param)
       {var b=param[2],a=param[1];return caml_call3(Stdlib_printf[4],_S_,a,b)}
      var _eZ_=0;
      function string_of_coords(_fj_){return list(_eZ_,_eY_,_fj_)}
      function string_of_dominant_baseline(param)
       {return -72987685 <= param
                ?354434192 <= param
                  ?881373037 <= param
                    ?945233102 <= param?cst_nochange:cst_alphabetic$1
                    :726666127 <= param?cst_auto$1:cst_hanging$1
                  :15943541 === param
                    ?cst_middle$1
                    :218255880 <= param?cst_mathematical$1:cst_inherit$1
                :-840627829 <= param
                  ?-504734109 <= param
                    ?-415175851 <= param?cst_central$0:cst_usescript
                    :-693588957 <= param?cst_ideographic$1:cst_textbeforeedge
                  :-880506735 <= param?cst_resetsize:cst_textafteredge}
      function string_of_in_value(param)
       {if(typeof param === "number")
         return 198492909 <= param
                 ?885982307 <= param
                   ?976982182 <= param?cst_strokePaint:cst_sourceAlpha
                   :768130555 <= param?cst_fillPaint:cst_sourceGraphic
                 :-522189715 <= param?cst_backgroundImage:cst_backgroundAlpha;
        var svg=param[2];
        return svg}
      var _e0_=Stdlib[33],_e1_=0;
      function string_of_lengths(_fi_)
       {return list(_e1_,string_of_length,_fi_)}
      function string_of_percentage(x)
       {var _fh_=string_of_number(x);
        return caml_call2(Stdlib[28],_fh_,cst$36)}
      function string_of_fourfloats(param)
       {var
         d=param[4],
         c=param[3],
         b=param[2],
         a=param[1],
         _fd_=string_of_number(d),
         _fe_=string_of_number(c),
         _ff_=string_of_number(b),
         _fg_=string_of_number(a);
        return caml_call5(Stdlib_printf[4],_T_,_fg_,_ff_,_fe_,_fd_)}
      function string_of_number_optional_numb(param)
       {var _fb_=param[2],_fc_=param[1];
        if(_fb_){var y=_fb_[1];return caml_call3(Stdlib_printf[4],_U_,_fc_,y)}
        return caml_call2(Stdlib_printf[4],_V_,_fc_)}
      var _e2_=0;
      function string_of_numbers(_fa_)
       {return list(_e2_,string_of_number,_fa_)}
      function string_of_numbers_semicolon(_e$_)
       {return list(_W_,string_of_number,_e$_)}
      function string_of_offset(param)
       {if(-488794310 <= param[1])
         {var x=param[2];return string_of_percentage(x)}
        var x$0=param[2];
        return string_of_number(x$0)}
      function string_of_orient(param)
       {if(param){var svg=param[1];return string_of_angle(svg)}
        return cst_auto$2}
      function string_of_strokedasharray(l)
       {return l?list(0,string_of_length,l):cst_none$1}
      function string_of_transform(param)
       {var _e4_=param[1];
        if(-4932997 <= _e4_)
         {if(289998318 <= _e4_)
           {if(289998319 <= _e4_)
             {var angle=param[2],_e5_=string_of_angle(angle);
              return caml_call2(Stdlib_printf[4],_X_,_e5_)}
            var angle$0=param[2],_e6_=string_of_angle(angle$0);
            return caml_call2(Stdlib_printf[4],_Y_,_e6_)}
          if(201080426 <= _e4_)
           {var x=param[2],_e7_=string_of_number_optional_numb(x);
            return caml_call2(Stdlib_printf[4],_Z_,_e7_)}
          var match=param[2],x$0=match[2],angle$1=match[1];
          if(x$0)
           var
            match$0=x$0[1],
            y=match$0[2],
            x$1=match$0[1],
            _e8_=caml_call3(Stdlib_printf[4],___,x$1,y);
          else
           var _e8_=cst$37;
          var _e9_=string_of_angle(angle$1);
          return caml_call3(Stdlib_printf[4],_$_,_e9_,_e8_)}
        if(-262362527 <= _e4_)
         {var
           match$1=param[2],
           f=match$1[6],
           e=match$1[5],
           d=match$1[4],
           c=match$1[3],
           b=match$1[2],
           a=match$1[1];
          return caml_call7(Stdlib_printf[4],_aa_,a,b,c,d,e,f)}
        var x$2=param[2],_e__=string_of_number_optional_numb(x$2);
        return caml_call2(Stdlib_printf[4],_ab_,_e__)}
      function string_of_transforms(l)
       {var _e3_=caml_call2(Stdlib_list[17],string_of_transform,l);
        return caml_call2(Stdlib_string[7],cst$38,_e3_)}
      return [0,
              Xml,
              string_of_alignment_baseline,
              string_of_big_variant,
              _eX_,
              string_of_coords,
              string_of_dominant_baseline,
              string_of_in_value,
              _e0_,
              string_of_length,
              string_of_lengths,
              string_of_number,
              string_of_percentage,
              string_of_fourfloats,
              string_of_number_optional_numb,
              string_of_numbers,
              string_of_numbers_semicolon,
              string_of_offset,
              string_of_orient,
              string_of_paint,
              string_of_strokedasharray,
              string_of_transform,
              string_of_transforms]}
    function _ac_(_eT_,_eS_)
     {var
       _eU_=Make_with_wrapped_functions(_eT_,_eS_),
       _eV_=_eU_[342],
       _eW_=_eU_[2];
      return [0,
              _eU_[1],
              [0,_eW_[1],_eW_[2],_eW_[4],_eW_[5],_eW_[6],_eW_[7],_eW_[3]],
              _eU_[3],
              _eU_[4],
              _eU_[26],
              _eU_[27],
              _eU_[28],
              _eU_[29],
              _eU_[30],
              _eU_[31],
              _eU_[32],
              _eU_[33],
              _eU_[34],
              _eU_[35],
              _eU_[36],
              _eU_[37],
              _eU_[38],
              _eU_[39],
              _eU_[40],
              _eU_[41],
              _eU_[42],
              _eU_[43],
              _eU_[44],
              _eU_[45],
              _eU_[46],
              _eU_[47],
              _eU_[48],
              _eU_[49],
              _eU_[50],
              _eU_[51],
              _eU_[52],
              _eU_[53],
              _eU_[54],
              _eU_[55],
              _eU_[56],
              _eU_[57],
              _eU_[58],
              _eU_[59],
              _eU_[60],
              _eU_[61],
              _eU_[62],
              _eU_[63],
              _eU_[64],
              _eU_[65],
              _eU_[66],
              _eU_[67],
              _eU_[68],
              _eU_[69],
              _eU_[70],
              _eU_[71],
              _eU_[72],
              _eU_[73],
              _eU_[74],
              _eU_[75],
              _eU_[76],
              _eU_[77],
              _eU_[78],
              _eU_[79],
              _eU_[80],
              _eU_[81],
              _eU_[82],
              _eU_[83],
              _eU_[84],
              _eU_[85],
              _eU_[86],
              _eU_[87],
              _eU_[88],
              _eU_[89],
              _eU_[90],
              _eU_[91],
              _eU_[92],
              _eU_[93],
              _eU_[94],
              _eU_[95],
              _eU_[96],
              _eU_[97],
              _eU_[98],
              _eU_[99],
              _eU_[100],
              _eU_[101],
              _eU_[102],
              _eU_[103],
              _eU_[104],
              _eU_[105],
              _eU_[106],
              _eU_[107],
              _eU_[108],
              _eU_[109],
              _eU_[110],
              _eU_[111],
              _eU_[112],
              _eU_[113],
              _eU_[114],
              _eU_[115],
              _eU_[116],
              _eU_[117],
              _eU_[118],
              _eU_[119],
              _eU_[120],
              _eU_[121],
              _eU_[122],
              _eU_[123],
              _eU_[124],
              _eU_[125],
              _eU_[126],
              _eU_[127],
              _eU_[128],
              _eU_[129],
              _eU_[130],
              _eU_[131],
              _eU_[132],
              _eU_[133],
              _eU_[134],
              _eU_[135],
              _eU_[136],
              _eU_[137],
              _eU_[138],
              _eU_[139],
              _eU_[140],
              _eU_[141],
              _eU_[142],
              _eU_[143],
              _eU_[144],
              _eU_[145],
              _eU_[146],
              _eU_[147],
              _eU_[148],
              _eU_[149],
              _eU_[150],
              _eU_[151],
              _eU_[152],
              _eU_[153],
              _eU_[154],
              _eU_[155],
              _eU_[156],
              _eU_[157],
              _eU_[158],
              _eU_[159],
              _eU_[160],
              _eU_[161],
              _eU_[162],
              _eU_[163],
              _eU_[164],
              _eU_[165],
              _eU_[166],
              _eU_[167],
              _eU_[168],
              _eU_[169],
              _eU_[170],
              _eU_[171],
              _eU_[172],
              _eU_[173],
              _eU_[174],
              _eU_[175],
              _eU_[176],
              _eU_[177],
              _eU_[178],
              _eU_[179],
              _eU_[180],
              _eU_[181],
              _eU_[182],
              _eU_[183],
              _eU_[184],
              _eU_[185],
              _eU_[186],
              _eU_[187],
              _eU_[188],
              _eU_[189],
              _eU_[190],
              _eU_[191],
              _eU_[192],
              _eU_[193],
              _eU_[194],
              _eU_[195],
              _eU_[196],
              _eU_[197],
              _eU_[198],
              _eU_[199],
              _eU_[200],
              _eU_[201],
              _eU_[202],
              _eU_[203],
              _eU_[204],
              _eU_[205],
              _eU_[206],
              _eU_[207],
              _eU_[208],
              _eU_[209],
              _eU_[210],
              _eU_[211],
              _eU_[212],
              _eU_[213],
              _eU_[214],
              _eU_[215],
              _eU_[216],
              _eU_[217],
              _eU_[218],
              _eU_[219],
              _eU_[220],
              _eU_[221],
              _eU_[222],
              _eU_[223],
              _eU_[224],
              _eU_[225],
              _eU_[226],
              _eU_[227],
              _eU_[228],
              _eU_[229],
              _eU_[253],
              _eU_[254],
              _eU_[255],
              _eU_[256],
              _eU_[257],
              _eU_[258],
              _eU_[259],
              _eU_[260],
              _eU_[261],
              _eU_[262],
              _eU_[230],
              _eU_[231],
              _eU_[232],
              _eU_[233],
              _eU_[234],
              _eU_[235],
              _eU_[236],
              _eU_[237],
              _eU_[238],
              _eU_[239],
              _eU_[240],
              _eU_[241],
              _eU_[242],
              _eU_[243],
              _eU_[244],
              _eU_[245],
              _eU_[246],
              _eU_[247],
              _eU_[248],
              _eU_[249],
              _eU_[250],
              _eU_[251],
              _eU_[252],
              _eU_[24],
              _eU_[263],
              _eU_[264],
              _eU_[265],
              _eU_[266],
              _eU_[267],
              _eU_[268],
              _eU_[269],
              _eU_[270],
              _eU_[271],
              _eU_[272],
              _eU_[273],
              _eU_[274],
              _eU_[275],
              _eU_[276],
              _eU_[277],
              _eU_[278],
              _eU_[279],
              _eU_[280],
              _eU_[281],
              _eU_[282],
              _eU_[283],
              _eU_[284],
              _eU_[285],
              _eU_[286],
              _eU_[287],
              _eU_[288],
              _eU_[289],
              _eU_[290],
              _eU_[291],
              _eU_[292],
              _eU_[293],
              _eU_[294],
              _eU_[295],
              _eU_[296],
              _eU_[297],
              _eU_[298],
              _eU_[299],
              _eU_[300],
              _eU_[301],
              _eU_[302],
              _eU_[303],
              _eU_[304],
              _eU_[305],
              _eU_[306],
              _eU_[307],
              _eU_[308],
              _eU_[309],
              _eU_[310],
              _eU_[311],
              _eU_[312],
              _eU_[313],
              _eU_[314],
              _eU_[315],
              _eU_[316],
              _eU_[317],
              _eU_[318],
              _eU_[319],
              _eU_[320],
              _eU_[321],
              _eU_[322],
              _eU_[323],
              _eU_[324],
              _eU_[325],
              _eU_[326],
              _eU_[327],
              _eU_[328],
              _eU_[329],
              _eU_[330],
              _eU_[331],
              _eU_[332],
              _eU_[333],
              _eU_[334],
              _eU_[335],
              _eU_[336],
              _eU_[337],
              _eU_[338],
              _eU_[22],
              _eU_[23],
              _eU_[25],
              _eU_[341],
              _eU_[5],
              _eU_[6],
              _eU_[7],
              _eU_[8],
              _eU_[339],
              _eU_[13],
              _eU_[9],
              [0,
               _eV_[1],
               _eV_[3],
               _eV_[2],
               _eV_[4],
               _eV_[7],
               _eV_[5],
               _eV_[6],
               _eV_[8],
               _eV_[9],
               _eV_[10]]]}
    function _ad_(_eQ_)
     {var _eR_=Wrapped_functions(_eQ_);
      return [0,
              _eR_[1],
              _eR_[2],
              _eR_[4],
              _eR_[3],
              _eR_[5],
              _eR_[6],
              _eR_[13],
              _eR_[7],
              _eR_[8],
              _eR_[9],
              _eR_[10],
              _eR_[11],
              _eR_[14],
              _eR_[15],
              _eR_[16],
              _eR_[17],
              _eR_[18],
              _eR_[19],
              _eR_[20],
              _eR_[21],
              _eR_[22]]}
    var
     Svg_f=
      [0,
       function(_eM_)
        {var
          _eL_=Wrapped_functions(_eM_),
          _eP_=
           Make_with_wrapped_functions
            (_eM_,
             [0,
              _eL_[1],
              _eL_[2],
              _eL_[4],
              _eL_[3],
              _eL_[5],
              _eL_[6],
              _eL_[13],
              _eL_[7],
              _eL_[8],
              _eL_[9],
              _eL_[10],
              _eL_[11],
              _eL_[14],
              _eL_[15],
              _eL_[16],
              _eL_[17],
              _eL_[18],
              _eL_[19],
              _eL_[20],
              _eL_[21],
              _eL_[22]]),
          _eN_=_eP_[342],
          _eO_=_eP_[2];
         return [0,
                 _eP_[1],
                 [0,_eO_[1],_eO_[2],_eO_[4],_eO_[5],_eO_[6],_eO_[7],_eO_[3]],
                 _eP_[3],
                 _eP_[4],
                 _eP_[26],
                 _eP_[27],
                 _eP_[28],
                 _eP_[29],
                 _eP_[30],
                 _eP_[31],
                 _eP_[32],
                 _eP_[33],
                 _eP_[34],
                 _eP_[35],
                 _eP_[36],
                 _eP_[37],
                 _eP_[38],
                 _eP_[39],
                 _eP_[40],
                 _eP_[41],
                 _eP_[42],
                 _eP_[43],
                 _eP_[44],
                 _eP_[45],
                 _eP_[46],
                 _eP_[47],
                 _eP_[48],
                 _eP_[49],
                 _eP_[50],
                 _eP_[51],
                 _eP_[52],
                 _eP_[53],
                 _eP_[54],
                 _eP_[55],
                 _eP_[56],
                 _eP_[57],
                 _eP_[58],
                 _eP_[59],
                 _eP_[60],
                 _eP_[61],
                 _eP_[62],
                 _eP_[63],
                 _eP_[64],
                 _eP_[65],
                 _eP_[66],
                 _eP_[67],
                 _eP_[68],
                 _eP_[69],
                 _eP_[70],
                 _eP_[71],
                 _eP_[72],
                 _eP_[73],
                 _eP_[74],
                 _eP_[75],
                 _eP_[76],
                 _eP_[77],
                 _eP_[78],
                 _eP_[79],
                 _eP_[80],
                 _eP_[81],
                 _eP_[82],
                 _eP_[83],
                 _eP_[84],
                 _eP_[85],
                 _eP_[86],
                 _eP_[87],
                 _eP_[88],
                 _eP_[89],
                 _eP_[90],
                 _eP_[91],
                 _eP_[92],
                 _eP_[93],
                 _eP_[94],
                 _eP_[95],
                 _eP_[96],
                 _eP_[97],
                 _eP_[98],
                 _eP_[99],
                 _eP_[100],
                 _eP_[101],
                 _eP_[102],
                 _eP_[103],
                 _eP_[104],
                 _eP_[105],
                 _eP_[106],
                 _eP_[107],
                 _eP_[108],
                 _eP_[109],
                 _eP_[110],
                 _eP_[111],
                 _eP_[112],
                 _eP_[113],
                 _eP_[114],
                 _eP_[115],
                 _eP_[116],
                 _eP_[117],
                 _eP_[118],
                 _eP_[119],
                 _eP_[120],
                 _eP_[121],
                 _eP_[122],
                 _eP_[123],
                 _eP_[124],
                 _eP_[125],
                 _eP_[126],
                 _eP_[127],
                 _eP_[128],
                 _eP_[129],
                 _eP_[130],
                 _eP_[131],
                 _eP_[132],
                 _eP_[133],
                 _eP_[134],
                 _eP_[135],
                 _eP_[136],
                 _eP_[137],
                 _eP_[138],
                 _eP_[139],
                 _eP_[140],
                 _eP_[141],
                 _eP_[142],
                 _eP_[143],
                 _eP_[144],
                 _eP_[145],
                 _eP_[146],
                 _eP_[147],
                 _eP_[148],
                 _eP_[149],
                 _eP_[150],
                 _eP_[151],
                 _eP_[152],
                 _eP_[153],
                 _eP_[154],
                 _eP_[155],
                 _eP_[156],
                 _eP_[157],
                 _eP_[158],
                 _eP_[159],
                 _eP_[160],
                 _eP_[161],
                 _eP_[162],
                 _eP_[163],
                 _eP_[164],
                 _eP_[165],
                 _eP_[166],
                 _eP_[167],
                 _eP_[168],
                 _eP_[169],
                 _eP_[170],
                 _eP_[171],
                 _eP_[172],
                 _eP_[173],
                 _eP_[174],
                 _eP_[175],
                 _eP_[176],
                 _eP_[177],
                 _eP_[178],
                 _eP_[179],
                 _eP_[180],
                 _eP_[181],
                 _eP_[182],
                 _eP_[183],
                 _eP_[184],
                 _eP_[185],
                 _eP_[186],
                 _eP_[187],
                 _eP_[188],
                 _eP_[189],
                 _eP_[190],
                 _eP_[191],
                 _eP_[192],
                 _eP_[193],
                 _eP_[194],
                 _eP_[195],
                 _eP_[196],
                 _eP_[197],
                 _eP_[198],
                 _eP_[199],
                 _eP_[200],
                 _eP_[201],
                 _eP_[202],
                 _eP_[203],
                 _eP_[204],
                 _eP_[205],
                 _eP_[206],
                 _eP_[207],
                 _eP_[208],
                 _eP_[209],
                 _eP_[210],
                 _eP_[211],
                 _eP_[212],
                 _eP_[213],
                 _eP_[214],
                 _eP_[215],
                 _eP_[216],
                 _eP_[217],
                 _eP_[218],
                 _eP_[219],
                 _eP_[220],
                 _eP_[221],
                 _eP_[222],
                 _eP_[223],
                 _eP_[224],
                 _eP_[225],
                 _eP_[226],
                 _eP_[227],
                 _eP_[228],
                 _eP_[229],
                 _eP_[253],
                 _eP_[254],
                 _eP_[255],
                 _eP_[256],
                 _eP_[257],
                 _eP_[258],
                 _eP_[259],
                 _eP_[260],
                 _eP_[261],
                 _eP_[262],
                 _eP_[230],
                 _eP_[231],
                 _eP_[232],
                 _eP_[233],
                 _eP_[234],
                 _eP_[235],
                 _eP_[236],
                 _eP_[237],
                 _eP_[238],
                 _eP_[239],
                 _eP_[240],
                 _eP_[241],
                 _eP_[242],
                 _eP_[243],
                 _eP_[244],
                 _eP_[245],
                 _eP_[246],
                 _eP_[247],
                 _eP_[248],
                 _eP_[249],
                 _eP_[250],
                 _eP_[251],
                 _eP_[252],
                 _eP_[24],
                 _eP_[263],
                 _eP_[264],
                 _eP_[265],
                 _eP_[266],
                 _eP_[267],
                 _eP_[268],
                 _eP_[269],
                 _eP_[270],
                 _eP_[271],
                 _eP_[272],
                 _eP_[273],
                 _eP_[274],
                 _eP_[275],
                 _eP_[276],
                 _eP_[277],
                 _eP_[278],
                 _eP_[279],
                 _eP_[280],
                 _eP_[281],
                 _eP_[282],
                 _eP_[283],
                 _eP_[284],
                 _eP_[285],
                 _eP_[286],
                 _eP_[287],
                 _eP_[288],
                 _eP_[289],
                 _eP_[290],
                 _eP_[291],
                 _eP_[292],
                 _eP_[293],
                 _eP_[294],
                 _eP_[295],
                 _eP_[296],
                 _eP_[297],
                 _eP_[298],
                 _eP_[299],
                 _eP_[300],
                 _eP_[301],
                 _eP_[302],
                 _eP_[303],
                 _eP_[304],
                 _eP_[305],
                 _eP_[306],
                 _eP_[307],
                 _eP_[308],
                 _eP_[309],
                 _eP_[310],
                 _eP_[311],
                 _eP_[312],
                 _eP_[313],
                 _eP_[314],
                 _eP_[315],
                 _eP_[316],
                 _eP_[317],
                 _eP_[318],
                 _eP_[319],
                 _eP_[320],
                 _eP_[321],
                 _eP_[322],
                 _eP_[323],
                 _eP_[324],
                 _eP_[325],
                 _eP_[326],
                 _eP_[327],
                 _eP_[328],
                 _eP_[329],
                 _eP_[330],
                 _eP_[331],
                 _eP_[332],
                 _eP_[333],
                 _eP_[334],
                 _eP_[335],
                 _eP_[336],
                 _eP_[337],
                 _eP_[338],
                 _eP_[22],
                 _eP_[23],
                 _eP_[25],
                 _eP_[341],
                 _eP_[5],
                 _eP_[6],
                 _eP_[7],
                 _eP_[8],
                 _eP_[339],
                 _eP_[13],
                 _eP_[9],
                 [0,
                  _eN_[1],
                  _eN_[3],
                  _eN_[2],
                  _eN_[4],
                  _eN_[7],
                  _eN_[5],
                  _eN_[6],
                  _eN_[8],
                  _eN_[9],
                  _eN_[10]]]},
       _ad_,
       _ac_];
    caml_register_global(1097,Svg_f,"Svg_f");
    function Make_with_wrapped_functions$0(Xml,C,Svg)
     {var
       doctype=compose_doctype(cst_html,0),
       Info=
        [0,
         content_type$0,
         alternative_content_types,
         version$0,
         standard$0,
         namespace$0,
         doctype,
         emptytags],
       _aH_=Xml[2],
       _aI_=Xml[3];
      function to_xmlattribs(x){return x}
      function to_attrib(x){return x}
      var _aJ_=Xml[4],_aK_=Xml[5],_aL_=Xml[6];
      function uri_attrib(a,s){return caml_call2(Xml[13],a,s)}
      var _aM_=Xml[7],_aN_=Xml[8];
      function user_attrib(f,name,v)
       {var _eK_=caml_call2(Xml[1][2],f,v);
        return caml_call2(Xml[6],name,_eK_)}
      var _aO_=C[3];
      function bool_attrib(_eI_,_eJ_){return user_attrib(_aO_,_eI_,_eJ_)}
      function constant_attrib(a,param)
       {return caml_call2(_aL_,a,caml_call1(Xml[1][1],a))}
      function linktypes_attrib(name,x){return user_attrib(C[8],name,x)}
      function mediadesc_attrib(name,x){return user_attrib(C[9],name,x)}
      function srcset_attrib(name,x){return user_attrib(C[14],name,x)}
      var a_class=caml_call1(_aM_,cst_class$0),a_id=caml_call1(_aL_,cst_id$0);
      function a_user_data(name)
       {return caml_call1(_aL_,caml_call2(Stdlib[28],cst_data$0,name))}
      var
       a_title=caml_call1(_aL_,cst_title$0),
       a_xml_lang=caml_call1(_aL_,cst_xml_lang$0),
       a_lang=caml_call1(_aL_,cst_lang$0),
       a_style=caml_call1(_aL_,cst_style$1),
       a_property=caml_call1(_aL_,cst_property),
       a_onabort=caml_call1(Xml[9],cst_onabort$0),
       a_onafterprint=caml_call1(Xml[9],cst_onafterprint),
       a_onbeforeprint=caml_call1(Xml[9],cst_onbeforeprint),
       a_onbeforeunload=caml_call1(Xml[9],cst_onbeforeunload),
       a_onblur=caml_call1(Xml[9],cst_onblur),
       a_oncanplay=caml_call1(Xml[9],cst_oncanplay),
       a_oncanplaythrough=caml_call1(Xml[9],cst_oncanplaythrough),
       a_onchange=caml_call1(Xml[9],cst_onchange),
       a_ondurationchange=caml_call1(Xml[9],cst_ondurationchange),
       a_onemptied=caml_call1(Xml[9],cst_onemptied),
       a_onended=caml_call1(Xml[9],cst_onended),
       a_onerror=caml_call1(Xml[9],cst_onerror$0),
       a_onfocus=caml_call1(Xml[9],cst_onfocus),
       a_onformchange=caml_call1(Xml[9],cst_onformchange),
       a_onforminput=caml_call1(Xml[9],cst_onforminput),
       a_onhashchange=caml_call1(Xml[9],cst_onhashchange),
       a_oninput=caml_call1(Xml[9],cst_oninput),
       a_oninvalid=caml_call1(Xml[9],cst_oninvalid),
       a_onoffline=caml_call1(Xml[9],cst_onoffline),
       a_ononline=caml_call1(Xml[9],cst_ononline),
       a_onpause=caml_call1(Xml[9],cst_onpause),
       a_onplay=caml_call1(Xml[9],cst_onplay),
       a_onplaying=caml_call1(Xml[9],cst_onplaying),
       a_onpagehide=caml_call1(Xml[9],cst_onpagehide),
       a_onpageshow=caml_call1(Xml[9],cst_onpageshow),
       a_onpopstate=caml_call1(Xml[9],cst_onpopstate),
       a_onprogress=caml_call1(Xml[9],cst_onprogress),
       a_onratechange=caml_call1(Xml[9],cst_onratechange),
       a_onreadystatechange=caml_call1(Xml[9],cst_onreadystatechange),
       a_onredo=caml_call1(Xml[9],cst_onredo),
       a_onresize=caml_call1(Xml[9],cst_onresize$0),
       a_onscroll=caml_call1(Xml[9],cst_onscroll$0),
       a_onseeked=caml_call1(Xml[9],cst_onseeked),
       a_onseeking=caml_call1(Xml[9],cst_onseeking),
       a_onselect=caml_call1(Xml[9],cst_onselect),
       a_onshow=caml_call1(Xml[9],cst_onshow),
       a_onstalled=caml_call1(Xml[9],cst_onstalled),
       a_onstorage=caml_call1(Xml[9],cst_onstorage),
       a_onsubmit=caml_call1(Xml[9],cst_onsubmit),
       a_onsuspend=caml_call1(Xml[9],cst_onsuspend),
       a_ontimeupdate=caml_call1(Xml[9],cst_ontimeupdate),
       a_onundo=caml_call1(Xml[9],cst_onundo),
       a_onunload=caml_call1(Xml[9],cst_onunload$0),
       a_onvolumechange=caml_call1(Xml[9],cst_onvolumechange),
       a_onwaiting=caml_call1(Xml[9],cst_onwaiting),
       a_onload=caml_call1(Xml[9],cst_onload$0),
       a_onloadeddata=caml_call1(Xml[9],cst_onloadeddata),
       a_onloadedmetadata=caml_call1(Xml[9],cst_onloadedmetadata),
       a_onloadstart=caml_call1(Xml[9],cst_onloadstart),
       a_onmessage=caml_call1(Xml[9],cst_onmessage),
       a_onmousewheel=caml_call1(Xml[9],cst_onmousewheel),
       a_onclick=caml_call1(Xml[10],cst_onclick$0),
       a_oncontextmenu=caml_call1(Xml[10],cst_oncontextmenu),
       a_ondblclick=caml_call1(Xml[10],cst_ondblclick),
       a_ondrag=caml_call1(Xml[10],cst_ondrag),
       a_ondragend=caml_call1(Xml[10],cst_ondragend),
       a_ondragenter=caml_call1(Xml[10],cst_ondragenter),
       a_ondragleave=caml_call1(Xml[10],cst_ondragleave),
       a_ondragover=caml_call1(Xml[10],cst_ondragover),
       a_ondragstart=caml_call1(Xml[10],cst_ondragstart),
       a_ondrop=caml_call1(Xml[10],cst_ondrop),
       a_onmousedown=caml_call1(Xml[10],cst_onmousedown$0),
       a_onmouseup=caml_call1(Xml[10],cst_onmouseup$0),
       a_onmouseover=caml_call1(Xml[10],cst_onmouseover$0),
       a_onmousemove=caml_call1(Xml[10],cst_onmousemove$0),
       a_onmouseout=caml_call1(Xml[10],cst_onmouseout$0),
       a_ontouchstart=caml_call1(Xml[12],cst_ontouchstart$0),
       a_ontouchend=caml_call1(Xml[12],cst_ontouchend$0),
       a_ontouchmove=caml_call1(Xml[12],cst_ontouchmove$0),
       a_ontouchcancel=caml_call1(Xml[12],cst_ontouchcancel$0),
       a_onkeypress=caml_call1(Xml[11],cst_onkeypress),
       a_onkeydown=caml_call1(Xml[11],cst_onkeydown),
       a_onkeyup=caml_call1(Xml[11],cst_onkeyup),
       a_version=caml_call1(_aL_,cst_version$0);
      function a_xmlns(x){return user_attrib(C[2],cst_xmlns$4,x)}
      function a_manifest(_eH_){return uri_attrib(cst_manifest,_eH_)}
      function a_cite(_eG_){return uri_attrib(cst_cite,_eG_)}
      function a_xml_space(x){return user_attrib(C[2],cst_xml_space$0,x)}
      function a_accesskey(c){return user_attrib(C[5],cst_accesskey,c)}
      var
       a_charset=caml_call1(_aL_,cst_charset),
       a_accept_charset=caml_call1(_aM_,cst_accept_charset),
       a_accept=caml_call1(_aN_,cst_accept);
      function a_href(_eF_){return uri_attrib(cst_href$0,_eF_)}
      var a_hreflang=caml_call1(_aL_,cst_hreflang);
      function a_download(file){return user_attrib(C[16],cst_download,file)}
      function a_rel(_eE_){return linktypes_attrib(cst_rel,_eE_)}
      var
       a_tabindex=caml_call1(_aK_,cst_tabindex),
       a_mime_type=caml_call1(_aL_,cst_type$4),
       a_alt=caml_call1(_aL_,cst_alt);
      function a_height(p){return caml_call2(_aK_,cst_height$0,p)}
      function a_src(_eD_){return uri_attrib(cst_src,_eD_)}
      function a_width(p){return caml_call2(_aK_,cst_width$0,p)}
      var
       a_for=caml_call1(_aL_,cst_for),
       a_for_list=caml_call1(_aM_,cst_for$0);
      function a_selected(_eC_){return constant_attrib(cst_selected,_eC_)}
      var
       a_text_value=caml_call1(_aL_,cst_value),
       a_int_value=caml_call1(_aK_,cst_value$0),
       a_value=caml_call1(_aL_,cst_value$1),
       a_float_value=caml_call1(_aJ_,cst_value$2);
      function a_action(_eB_){return uri_attrib(cst_action,_eB_)}
      function a_formmethod(x){return user_attrib(C[2],cst_method$0,x)}
      var a_enctype=caml_call1(_aL_,cst_enctype);
      function a_checked(_eA_){return constant_attrib(cst_checked,_eA_)}
      function a_disabled(_ez_){return constant_attrib(cst_disabled,_ez_)}
      function a_readonly(_ey_){return constant_attrib(cst_readonly,_ey_)}
      var
       a_maxlength=caml_call1(_aK_,cst_maxlength),
       a_minlength=caml_call1(_aK_,cst_minlength),
       a_name=caml_call1(_aL_,cst_name$0);
      function a_allowfullscreen(_ex_)
       {return constant_attrib(cst_allowfullscreen,_ex_)}
      function a_allowpaymentrequest(_ew_)
       {return constant_attrib(cst_allowpaymentrequest,_ew_)}
      function a_referrerpolicy(x)
       {return user_attrib(C[10],cst_referrerpolicy,x)}
      function a_autocomplete(x){return user_attrib(C[4],cst_autocomplete,x)}
      function a_async(_ev_){return constant_attrib(cst_async,_ev_)}
      function a_autofocus(_eu_){return constant_attrib(cst_autofocus,_eu_)}
      function a_autoplay(_et_){return constant_attrib(cst_autoplay,_et_)}
      function a_muted(_es_){return constant_attrib(cst_muted,_es_)}
      function a_crossorigin(x){return user_attrib(C[2],cst_crossorigin,x)}
      var
       a_integrity=caml_call1(_aL_,cst_integrity),
       a_mediagroup=caml_call1(_aL_,cst_mediagroup),
       a_challenge=caml_call1(_aL_,cst_challenge);
      function a_contenteditable(ce)
       {return bool_attrib(cst_contenteditable,ce)}
      var a_contextmenu=caml_call1(_aL_,cst_contextmenu);
      function a_controls(_er_){return constant_attrib(cst_controls,_er_)}
      function a_dir(x){return user_attrib(C[2],cst_dir,x)}
      function a_draggable(d){return bool_attrib(cst_draggable,d)}
      var a_form=caml_call1(_aL_,cst_form);
      function a_formaction(_eq_){return uri_attrib(cst_formaction,_eq_)}
      var a_formenctype=caml_call1(_aL_,cst_formenctype);
      function a_formnovalidate(_ep_)
       {return constant_attrib(cst_formnovalidate,_ep_)}
      var a_formtarget=caml_call1(_aL_,cst_formtarget);
      function a_hidden(_eo_){return constant_attrib(cst_hidden,_eo_)}
      var a_high=caml_call1(_aJ_,cst_high);
      function a_icon(_en_){return uri_attrib(cst_icon,_en_)}
      function a_ismap(_em_){return constant_attrib(cst_ismap,_em_)}
      var
       a_keytype=caml_call1(_aL_,cst_keytype),
       a_list=caml_call1(_aL_,cst_list);
      function a_loop(_el_){return constant_attrib(cst_loop,_el_)}
      var
       a_low=caml_call1(_aJ_,cst_low),
       a_max=caml_call1(_aJ_,cst_max$0),
       _aP_=C[7];
      function a_input_max(_ek_){return user_attrib(_aP_,cst_max$1,_ek_)}
      var a_min=caml_call1(_aJ_,cst_min$0),_aQ_=C[7];
      function a_input_min(_ej_){return user_attrib(_aQ_,cst_min$1,_ej_)}
      function a_inputmode(x){return user_attrib(C[2],cst_inputmode,x)}
      function a_novalidate(_ei_){return constant_attrib(cst_novalidate,_ei_)}
      function a_open(_eh_){return constant_attrib(cst_open,_eh_)}
      var
       a_optimum=caml_call1(_aJ_,cst_optimum),
       a_pattern=caml_call1(_aL_,cst_pattern$0),
       a_placeholder=caml_call1(_aL_,cst_placeholder);
      function a_poster(_eg_){return uri_attrib(cst_poster,_eg_)}
      function a_preload(x){return user_attrib(C[2],cst_preload,x)}
      function a_pubdate(_ef_){return constant_attrib(cst_pubdate,_ef_)}
      var a_radiogroup=caml_call1(_aL_,cst_radiogroup);
      function a_required(_ee_){return constant_attrib(cst_required,_ee_)}
      function a_reversed(_ed_){return constant_attrib(cst_reserved,_ed_)}
      function a_sandbox(x){return user_attrib(C[12],cst_sandbox,x)}
      function a_spellcheck(sc){return bool_attrib(cst_spellcheck,sc)}
      function a_scoped(_ec_){return constant_attrib(cst_scoped,_ec_)}
      function a_seamless(_eb_){return constant_attrib(cst_seamless,_eb_)}
      function a_sizes(sizes){return user_attrib(C[13],cst_sizes,sizes)}
      var
       a_span=caml_call1(_aK_,cst_span),
       a_srclang=caml_call1(_aL_,cst_xml_lang$1);
      function a_srcset(_ea_){return srcset_attrib(cst_srcset,_ea_)}
      var
       a_img_sizes=caml_call1(_aN_,cst_sizes$0),
       a_start=caml_call1(_aK_,cst_start$0);
      function a_step(step){return user_attrib(C[15],cst_step,step)}
      function a_wrap(x){return user_attrib(C[2],cst_wrap$0,x)}
      var a_size=caml_call1(_aK_,cst_size);
      function a_input_type(it){return user_attrib(C[6],cst_type$5,it)}
      function a_menu_type(x){return user_attrib(C[2],cst_type$6,x)}
      function a_command_type(x){return user_attrib(C[2],cst_type$7,x)}
      function a_button_type(bt){return user_attrib(C[6],cst_type$8,bt)}
      function a_multiple(_d$_){return constant_attrib(cst_multiple,_d$_)}
      var
       a_cols=caml_call1(_aK_,cst_cols),
       a_rows=caml_call1(_aK_,cst_rows),
       a_summary=caml_call1(_aL_,cst_summary);
      function a_align(x){return user_attrib(C[2],cst_align,x)}
      var
       a_axis=caml_call1(_aL_,cst_axis),
       a_colspan=caml_call1(_aK_,cst_colspan),
       a_headers=caml_call1(_aM_,cst_headers),
       a_rowspan=caml_call1(_aK_,cst_rowspan);
      function a_scope(x){return user_attrib(C[2],cst_scope,x)}
      var a_border=caml_call1(_aK_,cst_border);
      function a_rules(x){return user_attrib(C[2],cst_rules,x)}
      function a_char(c){return user_attrib(C[5],cst_char,c)}
      function a_data(_d__){return uri_attrib(cst_data$1,_d__)}
      var a_codetype=caml_call1(_aL_,cst_codetype);
      function a_frameborder(x){return user_attrib(C[2],cst_frameborder,x)}
      var
       a_marginheight=caml_call1(_aK_,cst_marginheight),
       a_marginwidth=caml_call1(_aK_,cst_marginwidth);
      function a_scrolling(x){return user_attrib(C[2],cst_scrolling,x)}
      var
       a_target=caml_call1(_aL_,cst_target),
       a_content=caml_call1(_aL_,cst_content),
       a_http_equiv=caml_call1(_aL_,cst_http_equiv);
      function a_media(_d9_){return mediadesc_attrib(cst_media$0,_d9_)}
      var a_role=caml_call1(_aM_,cst_role);
      function a_aria(name)
       {return caml_call1(_aM_,caml_call2(Stdlib[28],cst_aria,name))}
      function terminal(tag,a,param){return caml_call2(Xml[20],a,tag)}
      function unary(tag,a,elt)
       {var _d8_=caml_call1(Xml[1][4],elt);
        return caml_call3(Xml[21],a,tag,_d8_)}
      function star(tag,a,elts){return caml_call3(Xml[21],a,tag,elts)}
      function plus(tag,a,elt,elts)
       {var _d7_=caml_call2(Xml[1][5],elt,elts);
        return caml_call3(Xml[21],a,tag,_d7_)}
      function option_cons(opt,elts)
       {if(opt){var x=opt[1];return caml_call2(Xml[1][5],x,elts)}return elts}
      function body(_d5_,_d6_){return star(cst_body,_d5_,_d6_)}
      function head(_d2_,_d3_,_d4_){return plus(cst_head,_d2_,_d3_,_d4_)}
      function title(_d0_,_d1_){return unary(cst_title$1,_d0_,_d1_)}
      function html(a,head,body)
       {var
         _dZ_=caml_call1(Xml[1][4],body),
         content=caml_call2(Xml[1][5],head,_dZ_);
        return caml_call3(Xml[21],a,cst_html$0,content)}
      function footer(_dX_,_dY_){return star(cst_footer,_dX_,_dY_)}
      function header(_dV_,_dW_){return star(cst_header,_dV_,_dW_)}
      function section(_dT_,_dU_){return star(cst_section,_dT_,_dU_)}
      function nav(_dR_,_dS_){return star(cst_nav,_dR_,_dS_)}
      function pcdata(s){return caml_call1(Xml[17],s)}
      var _aR_=Xml[19];
      function space(param){return caml_call1(_aR_,cst_nbsp)}
      var _aS_=Xml[22],_aT_=Xml[23],_aU_=Xml[24];
      function h1(_dP_,_dQ_){return star(cst_h1,_dP_,_dQ_)}
      function h2(_dN_,_dO_){return star(cst_h2,_dN_,_dO_)}
      function h3(_dL_,_dM_){return star(cst_h3,_dL_,_dM_)}
      function h4(_dJ_,_dK_){return star(cst_h4,_dJ_,_dK_)}
      function h5(_dH_,_dI_){return star(cst_h5,_dH_,_dI_)}
      function h6(_dF_,_dG_){return star(cst_h6,_dF_,_dG_)}
      function hgroup(_dD_,_dE_){return star(cst_hgroup,_dD_,_dE_)}
      function address(_dB_,_dC_){return star(cst_address,_dB_,_dC_)}
      function blockquote(_dz_,_dA_){return star(cst_blockquote,_dz_,_dA_)}
      function div(_dx_,_dy_){return star(cst_div,_dx_,_dy_)}
      function p(_dv_,_dw_){return star(cst_p,_dv_,_dw_)}
      function pre(_dt_,_du_){return star(cst_pre,_dt_,_du_)}
      function abbr(_dr_,_ds_){return star(cst_abbr,_dr_,_ds_)}
      function br(_dp_,_dq_){return terminal(cst_br,_dp_,_dq_)}
      function cite(_dn_,_do_){return star(cst_cite$0,_dn_,_do_)}
      function code(_dl_,_dm_){return star(cst_code,_dl_,_dm_)}
      function dfn(_dj_,_dk_){return star(cst_dfn,_dj_,_dk_)}
      function em(_dh_,_di_){return star(cst_em$0,_dh_,_di_)}
      function kbd(_df_,_dg_){return star(cst_kbd,_df_,_dg_)}
      function q(_dd_,_de_){return star(cst_q,_dd_,_de_)}
      function samp(_db_,_dc_){return star(cst_samp,_db_,_dc_)}
      function span(_c$_,_da_){return star(cst_span$0,_c$_,_da_)}
      function strong(_c9_,_c__){return star(cst_strong,_c9_,_c__)}
      function time(_c7_,_c8_){return star(cst_time,_c7_,_c8_)}
      function var$0(_c5_,_c6_){return star(cst_var,_c5_,_c6_)}
      function a(_c3_,_c4_){return star(cst_a$1,_c3_,_c4_)}
      function dl(_c1_,_c2_){return star(cst_dl,_c1_,_c2_)}
      function ol(_cZ_,_c0_){return star(cst_ol,_cZ_,_c0_)}
      function ul(_cX_,_cY_){return star(cst_ul,_cX_,_cY_)}
      function dd(_cV_,_cW_){return star(cst_dd,_cV_,_cW_)}
      function dt(_cT_,_cU_){return star(cst_dt,_cT_,_cU_)}
      function li(_cR_,_cS_){return star(cst_li,_cR_,_cS_)}
      function hr(_cP_,_cQ_){return terminal(cst_hr,_cP_,_cQ_)}
      function b(_cN_,_cO_){return star(cst_b$0,_cN_,_cO_)}
      function i(_cL_,_cM_){return star(cst_i,_cL_,_cM_)}
      function u(_cJ_,_cK_){return star(cst_u,_cJ_,_cK_)}
      function small(_cH_,_cI_){return star(cst_small,_cH_,_cI_)}
      function sub(_cF_,_cG_){return star(cst_sub,_cF_,_cG_)}
      function sup(_cD_,_cE_){return star(cst_sup,_cD_,_cE_)}
      function mark(_cB_,_cC_){return star(cst_mark,_cB_,_cC_)}
      function rp(_cz_,_cA_){return star(cst_rp,_cz_,_cA_)}
      function rt(_cx_,_cy_){return star(cst_rt,_cx_,_cy_)}
      function ruby(_cv_,_cw_){return star(cst_ruby,_cv_,_cw_)}
      function wbr(_ct_,_cu_){return terminal(cst_wbr,_ct_,_cu_)}
      function bdo(dir,opt,elts)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _cs_=[0,[0,a_dir(dir),a]];
        return caml_call3(Xml[21],_cs_,cst_bdo,elts)}
      var a_datetime=caml_call1(_aL_,cst_datetime);
      function a_shape(x){return user_attrib(C[2],cst_shape,x)}
      function a_coords(coords){return user_attrib(C[11],cst_coords,coords)}
      var a_usemap=caml_call1(_aL_,cst_usemap);
      function a_defer(_cr_){return constant_attrib(cst_defer,_cr_)}
      var a_label=caml_call1(_aL_,cst_label);
      function area(alt,opt,param)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _cq_=[0,[0,caml_call1(a_alt,alt),a]];
        return caml_call2(Xml[20],_cq_,cst_area)}
      function map(_co_,_cp_){return star(cst_map,_co_,_cp_)}
      function del(_cm_,_cn_){return star(cst_del,_cm_,_cn_)}
      function ins(_ck_,_cl_){return star(cst_ins,_ck_,_cl_)}
      function script(_ci_,_cj_){return unary(cst_script$0,_ci_,_cj_)}
      function noscript(_cg_,_ch_){return star(cst_noscript,_cg_,_ch_)}
      function template(_ce_,_cf_){return star(cst_template,_ce_,_cf_)}
      function article(_cc_,_cd_){return star(cst_article,_cc_,_cd_)}
      function aside(_ca_,_cb_){return star(cst_aside,_ca_,_cb_)}
      function main(_b__,_b$_){return star(cst_main,_b__,_b$_)}
      function video_audio(name,src,srcs,opt,elts)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        if(src)var uri=src[1],a$0=[0,a_src(uri),a];else var a$0=a;
        if(srcs)
         {var srcs$0=srcs[1],_b9_=caml_call2(Xml[1][6],srcs$0,elts);
          return caml_call3(Xml[21],[0,a$0],name,_b9_)}
        return caml_call3(Xml[21],[0,a$0],name,elts)}
      function audio(_b5_,_b6_,_b7_,_b8_)
       {return video_audio(cst_audio,_b5_,_b6_,_b7_,_b8_)}
      function video(_b1_,_b2_,_b3_,_b4_)
       {return video_audio(cst_video,_b1_,_b2_,_b3_,_b4_)}
      function canvas(_bZ_,_b0_){return star(cst_canvas,_bZ_,_b0_)}
      function command(label,opt,param)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _bY_=[0,[0,caml_call1(a_label,label),a]];
        return caml_call2(Xml[20],_bY_,cst_command)}
      function menu(children,a,param)
       {if(children)
         var match=children[1],l=match[2],children$0=l;
        else
         var children$0=caml_call1(Xml[1][3],0);
        return caml_call3(Xml[21],a,cst_menu,children$0)}
      function embed(_bW_,_bX_){return terminal(cst_embed,_bW_,_bX_)}
      function source(_bU_,_bV_){return terminal(cst_source,_bU_,_bV_)}
      function meter(_bS_,_bT_){return star(cst_meter,_bS_,_bT_)}
      function output_elt(_bQ_,_bR_){return star(cst_output,_bQ_,_bR_)}
      function form(_bO_,_bP_){return star(cst_form$0,_bO_,_bP_)}
      function svg(opt,children)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _bN_=caml_call2(Svg[242],[0,a],children);
        return caml_call1(Svg[324],_bN_)}
      function input(_bL_,_bM_){return terminal(cst_input,_bL_,_bM_)}
      function keygen(_bJ_,_bK_){return terminal(cst_keygen,_bJ_,_bK_)}
      function label(_bH_,_bI_){return star(cst_label$0,_bH_,_bI_)}
      function option(_bF_,_bG_){return unary(cst_option,_bF_,_bG_)}
      function select(_bD_,_bE_){return star(cst_select,_bD_,_bE_)}
      function textarea(_bB_,_bC_){return unary(cst_textarea,_bB_,_bC_)}
      function button(_bz_,_bA_){return star(cst_button,_bz_,_bA_)}
      function datalist(children,a,param)
       {if(children)
         var match=children[1],x=match[2],children$0=x;
        else
         var children$0=caml_call1(Xml[1][3],0);
        return caml_call3(Xml[21],a,cst_datalist,children$0)}
      function progress(_bx_,_by_){return star(cst_progress,_bx_,_by_)}
      function legend(_bv_,_bw_){return star(cst_legend,_bv_,_bw_)}
      function details(summary,a,children)
       {return plus(cst_details,a,summary,children)}
      function summary(_bt_,_bu_){return star(cst_summary$0,_bt_,_bu_)}
      function fieldset(legend,a,elts)
       {var _bs_=option_cons(legend,elts);
        return caml_call3(Xml[21],a,cst_fieldset,_bs_)}
      function optgroup(label,opt,elts)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _br_=[0,[0,caml_call1(a_label,label),a]];
        return caml_call3(Xml[21],_br_,cst_optgroup,elts)}
      function figcaption(_bp_,_bq_){return star(cst_figcaption,_bp_,_bq_)}
      function figure(figcaption,a,elts)
       {if(figcaption)
         {var _bm_=figcaption[1];
          if(437082891 <= _bm_[1])
           var
            c=_bm_[2],
            _bn_=caml_call1(Xml[1][4],c),
            _bo_=caml_call2(Xml[1][6],elts,_bn_);
          else
           var c$0=_bm_[2],_bo_=caml_call2(Xml[1][5],c$0,elts);
          var content=_bo_}
        else
         var content=elts;
        return caml_call3(Xml[21],a,cst_figure,content)}
      function caption(_bk_,_bl_){return star(cst_caption,_bk_,_bl_)}
      function table(caption,columns,thead,tfoot,a,elts)
       {var content=option_cons(thead,option_cons(tfoot,elts));
        if(columns)
         var
          columns$0=columns[1],
          content$0=caml_call2(Xml[1][6],columns$0,content);
        else
         var content$0=content;
        var content$1=option_cons(caption,content$0);
        return caml_call3(Xml[21],a,cst_table$0,content$1)}
      function td(_bi_,_bj_){return star(cst_td,_bi_,_bj_)}
      function th(_bg_,_bh_){return star(cst_th,_bg_,_bh_)}
      function tr(_be_,_bf_){return star(cst_tr,_be_,_bf_)}
      function colgroup(_bc_,_bd_){return star(cst_colgroup,_bc_,_bd_)}
      function col(_ba_,_bb_){return terminal(cst_col,_ba_,_bb_)}
      function thead(_a__,_a$_){return star(cst_thead,_a__,_a$_)}
      function tbody(_a8_,_a9_){return star(cst_tbody,_a8_,_a9_)}
      function tfoot(_a6_,_a7_){return star(cst_tfoot,_a6_,_a7_)}
      function iframe(_a4_,_a5_){return star(cst_iframe,_a4_,_a5_)}
      function object(params,opt,elts)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        if(params)
         var e=params[1],elts$0=caml_call2(Xml[1][6],e,elts);
        else
         var elts$0=elts;
        return caml_call3(Xml[21],[0,a],cst_object,elts$0)}
      function param(_a2_,_a3_){return terminal(cst_param,_a2_,_a3_)}
      function img(src,alt,opt,param)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _a1_=[0,caml_call1(a_alt,alt),a],a$0=[0,a_src(src),_a1_];
        return caml_call2(Xml[20],[0,a$0],cst_img)}
      function meta(_aZ_,_a0_){return terminal(cst_meta,_aZ_,_a0_)}
      function style(opt,elts)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        return caml_call3(Xml[21],[0,a],cst_style$2,elts)}
      function link(rel,href,opt,param)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _aX_=[0,a_href(href),a],_aY_=[0,[0,a_rel(rel),_aX_]];
        return caml_call2(Xml[20],_aY_,cst_link)}
      function base(_aV_,_aW_){return terminal(cst_base,_aV_,_aW_)}
      function tot(x){return x}
      function totl(x){return x}
      function toelt(x){return x}
      function toeltl(x){return x}
      function doc_toelt(x){return x}
      var I=_a_(Xml);
      function of_seq(s){return caml_call1(I[1],s)}
      function data(s){return caml_call1(Xml[18],s)}
      function leaf(tag,a,param){return caml_call2(Xml[20],a,tag)}
      function node(tag,a,elts){return caml_call3(Xml[21],a,tag,elts)}
      function coerce_elt(x){return x}
      var float_attrib=Xml[4],int_attrib=Xml[5],string_attrib=Xml[6];
      function uri_attrib$0(a,s){return caml_call2(Xml[13],a,s)}
      var
       space_sep_attrib=Xml[7],
       comma_sep_attrib=Xml[8],
       Unsafe=
        [0,
         data,
         leaf,
         node,
         coerce_elt,
         float_attrib,
         int_attrib,
         string_attrib,
         uri_attrib$0,
         space_sep_attrib,
         comma_sep_attrib];
      return [0,
              Xml,
              Info,
              _aH_,
              _aI_,
              to_xmlattribs,
              to_attrib,
              _aJ_,
              _aK_,
              _aL_,
              uri_attrib,
              _aM_,
              _aN_,
              user_attrib,
              bool_attrib,
              constant_attrib,
              linktypes_attrib,
              mediadesc_attrib,
              srcset_attrib,
              a_class,
              a_id,
              a_user_data,
              a_title,
              a_xml_lang,
              a_lang,
              a_style,
              a_property,
              a_onabort,
              a_onafterprint,
              a_onbeforeprint,
              a_onbeforeunload,
              a_onblur,
              a_oncanplay,
              a_oncanplaythrough,
              a_onchange,
              a_ondurationchange,
              a_onemptied,
              a_onended,
              a_onerror,
              a_onfocus,
              a_onformchange,
              a_onforminput,
              a_onhashchange,
              a_oninput,
              a_oninvalid,
              a_onoffline,
              a_ononline,
              a_onpause,
              a_onplay,
              a_onplaying,
              a_onpagehide,
              a_onpageshow,
              a_onpopstate,
              a_onprogress,
              a_onratechange,
              a_onreadystatechange,
              a_onredo,
              a_onresize,
              a_onscroll,
              a_onseeked,
              a_onseeking,
              a_onselect,
              a_onshow,
              a_onstalled,
              a_onstorage,
              a_onsubmit,
              a_onsuspend,
              a_ontimeupdate,
              a_onundo,
              a_onunload,
              a_onvolumechange,
              a_onwaiting,
              a_onload,
              a_onloadeddata,
              a_onloadedmetadata,
              a_onloadstart,
              a_onmessage,
              a_onmousewheel,
              a_onclick,
              a_oncontextmenu,
              a_ondblclick,
              a_ondrag,
              a_ondragend,
              a_ondragenter,
              a_ondragleave,
              a_ondragover,
              a_ondragstart,
              a_ondrop,
              a_onmousedown,
              a_onmouseup,
              a_onmouseover,
              a_onmousemove,
              a_onmouseout,
              a_ontouchstart,
              a_ontouchend,
              a_ontouchmove,
              a_ontouchcancel,
              a_onkeypress,
              a_onkeydown,
              a_onkeyup,
              a_version,
              a_xmlns,
              a_manifest,
              a_cite,
              a_xml_space,
              a_accesskey,
              a_charset,
              a_accept_charset,
              a_accept,
              a_href,
              a_hreflang,
              a_download,
              a_rel,
              a_tabindex,
              a_mime_type,
              a_alt,
              a_height,
              a_src,
              a_width,
              a_for,
              a_for,
              a_for_list,
              a_for_list,
              a_selected,
              a_text_value,
              a_int_value,
              a_value,
              a_float_value,
              a_action,
              a_formmethod,
              a_formmethod,
              a_enctype,
              a_checked,
              a_disabled,
              a_readonly,
              a_maxlength,
              a_minlength,
              a_name,
              a_allowfullscreen,
              a_allowpaymentrequest,
              a_referrerpolicy,
              a_autocomplete,
              a_async,
              a_autofocus,
              a_autoplay,
              a_muted,
              a_crossorigin,
              a_integrity,
              a_mediagroup,
              a_challenge,
              a_contenteditable,
              a_contextmenu,
              a_controls,
              a_dir,
              a_draggable,
              a_form,
              a_formaction,
              a_formenctype,
              a_formnovalidate,
              a_formtarget,
              a_hidden,
              a_high,
              a_icon,
              a_ismap,
              a_keytype,
              a_list,
              a_loop,
              a_low,
              a_max,
              a_input_max,
              a_min,
              a_input_min,
              a_inputmode,
              a_novalidate,
              a_open,
              a_optimum,
              a_pattern,
              a_placeholder,
              a_poster,
              a_preload,
              a_pubdate,
              a_radiogroup,
              a_required,
              a_reversed,
              a_sandbox,
              a_spellcheck,
              a_scoped,
              a_seamless,
              a_sizes,
              a_span,
              a_srclang,
              a_srcset,
              a_img_sizes,
              a_start,
              a_step,
              a_wrap,
              a_size,
              a_input_type,
              a_menu_type,
              a_command_type,
              a_button_type,
              a_multiple,
              a_cols,
              a_rows,
              a_summary,
              a_align,
              a_axis,
              a_colspan,
              a_headers,
              a_rowspan,
              a_scope,
              a_border,
              a_rules,
              a_char,
              a_data,
              a_codetype,
              a_frameborder,
              a_marginheight,
              a_marginwidth,
              a_scrolling,
              a_target,
              a_content,
              a_http_equiv,
              a_media,
              a_role,
              a_aria,
              terminal,
              unary,
              star,
              plus,
              option_cons,
              body,
              head,
              title,
              html,
              footer,
              header,
              section,
              nav,
              pcdata,
              pcdata,
              _aR_,
              space,
              _aS_,
              _aT_,
              _aU_,
              h1,
              h2,
              h3,
              h4,
              h5,
              h6,
              hgroup,
              address,
              blockquote,
              div,
              p,
              pre,
              abbr,
              br,
              cite,
              code,
              dfn,
              em,
              kbd,
              q,
              samp,
              span,
              strong,
              time,
              var$0,
              a,
              dl,
              ol,
              ul,
              dd,
              dt,
              li,
              hr,
              b,
              i,
              u,
              small,
              sub,
              sup,
              mark,
              rp,
              rt,
              ruby,
              wbr,
              bdo,
              a_datetime,
              a_shape,
              a_coords,
              a_usemap,
              a_defer,
              a_label,
              area,
              map,
              del,
              ins,
              script,
              noscript,
              template,
              article,
              aside,
              main,
              video_audio,
              audio,
              video,
              canvas,
              command,
              menu,
              embed,
              source,
              meter,
              output_elt,
              form,
              svg,
              input,
              keygen,
              label,
              option,
              select,
              textarea,
              button,
              datalist,
              progress,
              legend,
              details,
              summary,
              fieldset,
              optgroup,
              figcaption,
              figure,
              caption,
              table,
              table,
              td,
              th,
              tr,
              colgroup,
              col,
              thead,
              tbody,
              tfoot,
              iframe,
              object,
              param,
              img,
              meta,
              style,
              link,
              base,
              tot,
              totl,
              toelt,
              toeltl,
              doc_toelt,
              I,
              of_seq,
              Unsafe]}
    function Wrapped_functions$0(Xml)
     {function string_of_sandbox_token(param)
       {return -177579325 <= param
                ?642066717 <= param
                  ?961985737 <= param?cst_allow_same_origin:cst_allow_popups
                  :-141440231 <= param?cst_allow_forms:cst_allow_pointer_lock
                :-237921695 <= param?cst_allow_script:cst_allow_top_navigation}
      function string_of_linktype(param)
       {if(typeof param === "number")
         return 381789656 <= param
                 ?814486425 <= param
                   ?870035731 <= param
                     ?1021867988 <= param
                       ?1026883179 <= param?cst_external:cst_canonical
                       :892857107 <= param?cst_prev:cst_next
                     :847656566 <= param?cst_last:cst_icon$0
                   :395967329 <= param
                     ?693914176 <= param
                       ?803495649 <= param?cst_help:cst_noreferrer
                       :672161451 <= param?cst_author:cst_license
                     :395056008 <= param?cst_search:cst_noopener
                 :-289155950 <= param
                   ?19067 <= param
                     ?212027606 <= param
                       ?332064784 <= param?cst_first:cst_bookmark
                       :4198970 <= param?cst_tag:cst_up
                     :-123098695 <= param?cst_pingback:cst_nofollow
                   :-837966724 <= param
                     ?-687429350 <= param
                       ?-543567890 <= param?cst_stylesheet:cst_alternate
                       :-784200974 <= param?cst_index:cst_sidebar
                     :-954191215 <= param?cst_archives:cst_prefetch;
        var s=param[2];
        return s}
      function string_of_mediadesc_token(param)
       {if(typeof param === "number")
         return 3256577 <= param
                 ?67844052 <= param
                   ?985170249 <= param
                     ?993823919 <= param?cst_projection:cst_aural
                     :741408196 <= param?cst_handheld:cst_embossed
                   :4203225 <= param?cst_tty:cst_all
                 :-321929715 === param
                   ?cst_braille
                   :-68046964 <= param
                     ?18850 <= param?cst_tv:cst_screen$0
                     :-275811774 <= param?cst_speech:cst_print;
        var s=param[2];
        return s}
      function string_of_referrerpolicy(param)
       {return 128179133 <= param
                ?516162486 === param
                  ?cst_unsafe_url
                  :880519217 <= param
                    ?1065162943 <= param
                      ?cst_same_origin
                      :cst_origin_when_cross_origin
                    :808133042 <= param
                      ?cst_no_referrer_when_downgrade
                      :cst_no_referrer
                :-6975994 <= param
                  ?50834029 <= param?cst$39:cst_origin
                  :-512964804 <= param
                    ?cst_strict_origin
                    :cst_strict_origin_when_cross_o}
      function string_of_big_variant(param)
       {if(typeof param === "number")
         return 4252495 <= param
                 ?748194550 <= param
                   ?892709484 <= param
                     ?936387931 <= param
                       ?984475830 <= param
                         ?1003109192 <= param
                           ?1026883179 <= param?cst_external$0:cst_0
                           :995986491 <= param?cst_formnovalidate$0:cst_audio$0
                         :963342108 <= param?cst_async$0:cst_toolbar
                       :892857107 <= param
                         ?914891065 <= param
                           ?925976842 <= param?cst_soft:cst_rows$0
                           :914389316 <= param?cst_rect$0:cst_prev$0
                         :892711040 <= param?cst_POST:cst_poly
                     :847656566 <= param
                       ?848351876 <= param
                         ?870530776 <= param
                           ?881668074 <= param?cst_open$0:cst_none$2
                           :870035731 <= param?cst_next$0:cst_loop$0
                         :847852583 <= param?cst_left:cst_last$0
                       :803298059 <= param
                         ?814486425 <= param
                           ?836565865 <= param?cst_kana:cst_icon$1
                           :803495649 <= param?cst_help$0:cst_hard
                         :748545107 <= param?cst_cols$0:cst_char$0
                   :292438678 <= param
                     ?434500685 <= param
                       ?596180811 <= param
                         ?693914176 <= param
                           ?726666127 <= param?cst_auto$3:cst_noreferrer$0
                           :672161451 <= param?cst_author$0:cst_muted$0
                         :475573507 <= param?cst_autoplay$0:cst_anonymous
                       :332064784 <= param
                         ?395967329 <= param
                           ?432776079 <= param?cst_metadata$0:cst_license$0
                           :395056008 <= param?cst_search$0:cst_first$0
                         :306241015 <= param?cst_novalidate$0:cst_controls$0
                     :111644259 <= param
                       ?178382384 <= param
                         ?202657151 <= param
                           ?212027606 <= param?cst_bookmark$0:cst_required$0
                           :186574459 <= param?cst_selected$0:cst_circle$0
                         :140750597 <= param?cst_rowgroup:cst_checkbox
                       :19559306 <= param
                         ?50085628 <= param
                           ?95509868 <= param?cst_katakana:cst_email
                           :48900580 <= param?cst_latin:cst_hidden$0
                         :4448519 <= param?cst_yes:cst_url
                 :-369291781 <= param
                   ?17505 <= param
                     ?3805386 <= param
                       ?4102650 <= param
                         ?4198970 <= param
                           ?4199867 <= param?cst_tel:cst_tag$0
                           :4103754 <= param?cst_rtl:cst_row
                         :3953222 <= param?cst_1:cst_ltr
                       :3256577 <= param
                         ?3356704 <= param
                           ?3553398 <= param?cst_GET:cst_col$0
                           :3257036 <= param?cst_any:cst_all$0
                         :19067 <= param?cst_up$0:cst_no
                     :-165772469 <= param
                       ?-123098695 <= param
                         ?-100768656 <= param
                           ?-57574468 <= param?cst_right:cst_scoped$0
                           :-116258131 <= param?cst_numeric:cst_pingback$0
                         :-146439973 <= param?cst_radio:cst_pubdate$0
                       :-289155950 <= param
                         ?-200275514 <= param
                           ?-197222864 <= param?cst_multiple$0:cst_latin_name
                           :-247853591 <= param?cst_autofocus$0:cst_nofollow$0
                         :-363872942 <= param?cst_defer$0:cst_full_width_latin
                   :-784200974 <= param
                     ?-613973726 <= param
                       ?-529147129 <= param
                         ?-423051825 <= param
                           ?-384499551 <= param?cst_default$0:cst_context
                           :-514572330 <= param?cst_verbatim:cst_checked$0
                         :-543567890 <= param?cst_stylesheet$0:cst_reserved$0
                       :-728306478 <= param
                         ?-707104822 <= param
                           ?-687429350 <= param
                             ?cst_alternate$0
                             :cst_http_www_w3_org_1999_xhtml
                           :-709493348 <= param?cst_disabled$0:cst_ismap$0
                         :-773209244 <= param?cst_use_credentials:cst_index$0
                     :-883155966 <= param
                       ?-837966724 <= param
                         ?-792946572 <= param
                           ?-788068560 <= param?cst_justify:cst_groups
                           :-826369749 <= param?cst_command$0:cst_sidebar$0
                         :-872161756 <= param?cst_latin_prose:cst_readonly$0
                       :-1000861353 === param
                         ?cst_prefetch$0
                         :-954191215 <= param
                           ?-931002593 <= param?cst_colgroup$0:cst_archives$0
                           :-967956361 <= param?cst_seamless$0:cst_preserve$0;
        var s=param[2];
        return s}
      function string_of_input_type(param)
       {return 50085628 <= param
                ?612668487 <= param
                  ?781515420 <= param
                    ?936769581 <= param
                      ?969837588 <= param?cst_week:cst_time$0
                      :936573133 <= param?cst_text$0:cst_file
                    :758940238 <= param?cst_date:cst_datetime_local
                  :242538002 <= param
                    ?529348384 <= param
                      ?578936635 <= param?cst_password:cst_month
                      :395056008 <= param?cst_search$1:cst_button$0
                    :111644259 <= param?cst_checkbox$0:cst_email$0
                :-146439973 <= param
                  ?-101336657 <= param
                    ?4252495 <= param
                      ?19559306 <= param?cst_hidden$1:cst_url$0
                      :4199867 <= param?cst_tel$0:cst_reset
                    :-145943139 <= param?cst_range:cst_radio$0
                  :-795439301 <= param
                    ?-578166461 <= param
                      ?-528289822 <= param?cst_readonly$1:cst_color
                      :-703661335 <= param?cst_number:cst_image$0
                    :-828715976 <= param?cst_submit:cst_datetime$0}
      function string_of_number_or_datetime(param)
       {if(-703661335 <= param[1])
         {var n=param[2];return caml_call1(Stdlib[33],n)}
        var t=param[2];
        return t}
      var
       string_of_character=caml_call1(Stdlib_string[1],1),
       string_of_number$0=Stdlib[33],
       string_of_bool=Stdlib[30];
      function onoff_of_bool(param){return 0 === param?cst_off:cst_on}
      function unoption_string(param)
       {if(param){var x=param[1];return x}return cst$40}
      function string_of_step(param)
       {if(param){var x=param[1];return string_of_number(x)}return cst_any$0}
      function string_of_sizes(param)
       {if(param)
         {var
           l=param[1],
           _aF_=
            function(param)
             {var y=param[2],x=param[1];
              return caml_call3(Stdlib_printf[4],_ae_,x,y)},
           _aG_=caml_call2(Stdlib_list[17],_aF_,l);
          return caml_call2(Stdlib_string[7],cst$41,_aG_)}
        return cst_any$1}
      function string_of_sandbox(l)
       {var _aE_=caml_call2(Stdlib_list[17],string_of_sandbox_token,l);
        return caml_call2(Stdlib_string[7],cst$42,_aE_)}
      function string_of_numbers(l)
       {var _aD_=caml_call2(Stdlib_list[17],string_of_number$0,l);
        return caml_call2(Stdlib_string[7],cst$43,_aD_)}
      function string_of_mediadesc(l)
       {var _aC_=caml_call2(Stdlib_list[17],string_of_mediadesc_token,l);
        return caml_call2(Stdlib_string[7],cst$44,_aC_)}
      function string_of_linktypes(l)
       {var _aB_=caml_call2(Stdlib_list[17],string_of_linktype,l);
        return caml_call2(Stdlib_string[7],cst$45,_aB_)}
      function string_of_srcset(l)
       {function f(param)
         {var _aw_=param[1];
          if(-738802218 === _aw_)
           {var
             match=param[2],
             v=match[2],
             url=match[1],
             _ax_=caml_call1(string_of_number$0,v),
             _ay_=caml_call1(Xml[2],url);
            return caml_call3(Stdlib_printf[4],_af_,_ay_,_ax_)}
          if(4252495 <= _aw_)
           {var url$0=param[2];return caml_call1(Xml[2],url$0)}
          var
           match$0=param[2],
           v$0=match$0[2],
           url$1=match$0[1],
           _az_=string_of_number(v$0),
           _aA_=caml_call1(Xml[2],url$1);
          return caml_call3(Stdlib_printf[4],_ag_,_aA_,_az_)}
        var _av_=caml_call2(Stdlib_list[17],f,l);
        return caml_call2(Stdlib_string[7],cst$46,_av_)}
      return [0,
              Xml,
              string_of_sandbox_token,
              string_of_linktype,
              string_of_mediadesc_token,
              string_of_referrerpolicy,
              string_of_big_variant,
              string_of_input_type,
              string_of_number_or_datetime,
              string_of_character,
              string_of_number$0,
              string_of_bool,
              onoff_of_bool,
              unoption_string,
              string_of_step,
              string_of_sizes,
              string_of_sandbox,
              string_of_numbers,
              string_of_mediadesc,
              string_of_linktypes,
              string_of_srcset]}
    function _ah_(_as_,_ar_,_aq_)
     {var _at_=Make_with_wrapped_functions$0(_as_,_ar_,_aq_),_au_=_at_[361];
      return [0,
              _at_[1],
              _at_[2],
              _at_[3],
              _at_[4],
              _at_[19],
              _at_[21],
              _at_[20],
              _at_[22],
              _at_[23],
              _at_[24],
              _at_[27],
              _at_[28],
              _at_[29],
              _at_[30],
              _at_[31],
              _at_[32],
              _at_[33],
              _at_[34],
              _at_[35],
              _at_[36],
              _at_[37],
              _at_[38],
              _at_[39],
              _at_[40],
              _at_[41],
              _at_[42],
              _at_[43],
              _at_[44],
              _at_[77],
              _at_[45],
              _at_[46],
              _at_[47],
              _at_[48],
              _at_[49],
              _at_[50],
              _at_[51],
              _at_[52],
              _at_[53],
              _at_[54],
              _at_[55],
              _at_[56],
              _at_[57],
              _at_[58],
              _at_[59],
              _at_[60],
              _at_[61],
              _at_[62],
              _at_[63],
              _at_[64],
              _at_[65],
              _at_[66],
              _at_[67],
              _at_[68],
              _at_[69],
              _at_[70],
              _at_[71],
              _at_[72],
              _at_[73],
              _at_[74],
              _at_[75],
              _at_[76],
              _at_[78],
              _at_[79],
              _at_[80],
              _at_[81],
              _at_[82],
              _at_[83],
              _at_[84],
              _at_[85],
              _at_[86],
              _at_[87],
              _at_[88],
              _at_[89],
              _at_[90],
              _at_[91],
              _at_[92],
              _at_[93],
              _at_[94],
              _at_[95],
              _at_[96],
              _at_[97],
              _at_[98],
              _at_[99],
              _at_[138],
              _at_[139],
              _at_[141],
              _at_[142],
              _at_[143],
              _at_[144],
              _at_[145],
              _at_[146],
              _at_[147],
              _at_[148],
              _at_[149],
              _at_[150],
              _at_[151],
              _at_[152],
              _at_[153],
              _at_[154],
              _at_[155],
              _at_[156],
              _at_[157],
              _at_[158],
              _at_[159],
              _at_[160],
              _at_[161],
              _at_[162],
              _at_[163],
              _at_[164],
              _at_[165],
              _at_[166],
              _at_[167],
              _at_[168],
              _at_[169],
              _at_[170],
              _at_[171],
              _at_[172],
              _at_[173],
              _at_[174],
              _at_[175],
              _at_[176],
              _at_[177],
              _at_[178],
              _at_[179],
              _at_[180],
              _at_[181],
              _at_[140],
              _at_[182],
              _at_[183],
              _at_[184],
              _at_[185],
              _at_[186],
              _at_[187],
              _at_[188],
              _at_[189],
              _at_[190],
              _at_[191],
              _at_[192],
              _at_[193],
              _at_[194],
              _at_[195],
              _at_[100],
              _at_[101],
              _at_[102],
              _at_[103],
              _at_[104],
              _at_[105],
              _at_[106],
              _at_[107],
              _at_[108],
              _at_[109],
              _at_[110],
              _at_[111],
              _at_[112],
              _at_[113],
              _at_[114],
              _at_[291],
              _at_[128],
              _at_[132],
              _at_[202],
              _at_[131],
              _at_[119],
              _at_[120],
              _at_[121],
              _at_[122],
              _at_[135],
              _at_[136],
              _at_[129],
              _at_[130],
              _at_[201],
              _at_[137],
              _at_[203],
              _at_[123],
              _at_[196],
              _at_[117],
              _at_[197],
              _at_[124],
              _at_[125],
              _at_[126],
              _at_[127],
              _at_[133],
              _at_[134],
              _at_[200],
              _at_[199],
              _at_[198],
              _at_[296],
              _at_[205],
              _at_[206],
              _at_[207],
              _at_[208],
              _at_[209],
              _at_[210],
              _at_[204],
              _at_[211],
              _at_[212],
              _at_[213],
              _at_[115],
              _at_[116],
              _at_[118],
              _at_[292],
              _at_[293],
              _at_[294],
              _at_[214],
              _at_[215],
              _at_[216],
              _at_[217],
              _at_[218],
              _at_[219],
              _at_[220],
              _at_[221],
              _at_[222],
              _at_[295],
              _at_[223],
              _at_[25],
              _at_[26],
              _at_[224],
              _at_[225],
              _at_[239],
              _at_[234],
              _at_[232],
              _at_[353],
              _at_[233],
              _at_[231],
              _at_[318],
              _at_[235],
              _at_[236],
              _at_[237],
              _at_[238],
              _at_[246],
              _at_[247],
              _at_[248],
              _at_[249],
              _at_[250],
              _at_[251],
              _at_[252],
              _at_[253],
              _at_[304],
              _at_[305],
              _at_[306],
              _at_[256],
              _at_[257],
              _at_[254],
              _at_[255],
              _at_[272],
              _at_[273],
              _at_[274],
              _at_[275],
              _at_[276],
              _at_[277],
              _at_[333],
              _at_[334],
              _at_[278],
              _at_[279],
              _at_[280],
              _at_[281],
              _at_[282],
              _at_[283],
              _at_[284],
              _at_[285],
              _at_[289],
              _at_[290],
              _at_[258],
              _at_[259],
              _at_[260],
              _at_[261],
              _at_[262],
              _at_[263],
              _at_[264],
              _at_[265],
              _at_[266],
              _at_[267],
              _at_[268],
              _at_[269],
              _at_[270],
              _at_[271],
              _at_[299],
              _at_[300],
              _at_[349],
              _at_[346],
              _at_[347],
              _at_[348],
              _at_[313],
              _at_[308],
              _at_[309],
              _at_[310],
              _at_[314],
              _at_[297],
              _at_[298],
              _at_[335],
              _at_[337],
              _at_[336],
              _at_[341],
              _at_[342],
              _at_[343],
              _at_[344],
              _at_[345],
              _at_[338],
              _at_[339],
              _at_[340],
              _at_[317],
              _at_[331],
              _at_[328],
              _at_[321],
              _at_[319],
              _at_[325],
              _at_[323],
              _at_[326],
              _at_[332],
              _at_[322],
              _at_[324],
              _at_[320],
              _at_[327],
              _at_[315],
              _at_[316],
              _at_[241],
              _at_[242],
              _at_[243],
              _at_[244],
              _at_[245],
              _at_[329],
              _at_[330],
              _at_[311],
              _at_[312],
              _at_[301],
              _at_[302],
              _at_[303],
              _at_[350],
              _at_[351],
              _at_[352],
              _at_[287],
              _at_[286],
              _at_[288],
              _at_[240],
              _at_[360],
              _at_[354],
              _at_[355],
              _at_[356],
              _at_[357],
              _at_[358],
              _at_[5],
              _at_[6],
              [0,
               _au_[1],
               _au_[3],
               _au_[2],
               _au_[4],
               _au_[7],
               _au_[5],
               _au_[6],
               _au_[8],
               _au_[9],
               _au_[10]]]}
    function _ai_(_ao_)
     {var _ap_=Wrapped_functions$0(_ao_);
      return [0,
              _ap_[1],
              _ap_[6],
              _ap_[11],
              _ap_[12],
              _ap_[9],
              _ap_[7],
              _ap_[8],
              _ap_[19],
              _ap_[18],
              _ap_[5],
              _ap_[17],
              _ap_[16],
              _ap_[15],
              _ap_[20],
              _ap_[14],
              _ap_[13]]}
    var
     Html_f=
      [0,
       function(_al_,_ak_)
        {var
          _aj_=Wrapped_functions$0(_al_),
          _an_=
           Make_with_wrapped_functions$0
            (_al_,
             [0,
              _aj_[1],
              _aj_[6],
              _aj_[11],
              _aj_[12],
              _aj_[9],
              _aj_[7],
              _aj_[8],
              _aj_[19],
              _aj_[18],
              _aj_[5],
              _aj_[17],
              _aj_[16],
              _aj_[15],
              _aj_[20],
              _aj_[14],
              _aj_[13]],
             _ak_),
          _am_=_an_[361];
         return [0,
                 _an_[1],
                 _an_[2],
                 _an_[3],
                 _an_[4],
                 _an_[19],
                 _an_[21],
                 _an_[20],
                 _an_[22],
                 _an_[23],
                 _an_[24],
                 _an_[27],
                 _an_[28],
                 _an_[29],
                 _an_[30],
                 _an_[31],
                 _an_[32],
                 _an_[33],
                 _an_[34],
                 _an_[35],
                 _an_[36],
                 _an_[37],
                 _an_[38],
                 _an_[39],
                 _an_[40],
                 _an_[41],
                 _an_[42],
                 _an_[43],
                 _an_[44],
                 _an_[77],
                 _an_[45],
                 _an_[46],
                 _an_[47],
                 _an_[48],
                 _an_[49],
                 _an_[50],
                 _an_[51],
                 _an_[52],
                 _an_[53],
                 _an_[54],
                 _an_[55],
                 _an_[56],
                 _an_[57],
                 _an_[58],
                 _an_[59],
                 _an_[60],
                 _an_[61],
                 _an_[62],
                 _an_[63],
                 _an_[64],
                 _an_[65],
                 _an_[66],
                 _an_[67],
                 _an_[68],
                 _an_[69],
                 _an_[70],
                 _an_[71],
                 _an_[72],
                 _an_[73],
                 _an_[74],
                 _an_[75],
                 _an_[76],
                 _an_[78],
                 _an_[79],
                 _an_[80],
                 _an_[81],
                 _an_[82],
                 _an_[83],
                 _an_[84],
                 _an_[85],
                 _an_[86],
                 _an_[87],
                 _an_[88],
                 _an_[89],
                 _an_[90],
                 _an_[91],
                 _an_[92],
                 _an_[93],
                 _an_[94],
                 _an_[95],
                 _an_[96],
                 _an_[97],
                 _an_[98],
                 _an_[99],
                 _an_[138],
                 _an_[139],
                 _an_[141],
                 _an_[142],
                 _an_[143],
                 _an_[144],
                 _an_[145],
                 _an_[146],
                 _an_[147],
                 _an_[148],
                 _an_[149],
                 _an_[150],
                 _an_[151],
                 _an_[152],
                 _an_[153],
                 _an_[154],
                 _an_[155],
                 _an_[156],
                 _an_[157],
                 _an_[158],
                 _an_[159],
                 _an_[160],
                 _an_[161],
                 _an_[162],
                 _an_[163],
                 _an_[164],
                 _an_[165],
                 _an_[166],
                 _an_[167],
                 _an_[168],
                 _an_[169],
                 _an_[170],
                 _an_[171],
                 _an_[172],
                 _an_[173],
                 _an_[174],
                 _an_[175],
                 _an_[176],
                 _an_[177],
                 _an_[178],
                 _an_[179],
                 _an_[180],
                 _an_[181],
                 _an_[140],
                 _an_[182],
                 _an_[183],
                 _an_[184],
                 _an_[185],
                 _an_[186],
                 _an_[187],
                 _an_[188],
                 _an_[189],
                 _an_[190],
                 _an_[191],
                 _an_[192],
                 _an_[193],
                 _an_[194],
                 _an_[195],
                 _an_[100],
                 _an_[101],
                 _an_[102],
                 _an_[103],
                 _an_[104],
                 _an_[105],
                 _an_[106],
                 _an_[107],
                 _an_[108],
                 _an_[109],
                 _an_[110],
                 _an_[111],
                 _an_[112],
                 _an_[113],
                 _an_[114],
                 _an_[291],
                 _an_[128],
                 _an_[132],
                 _an_[202],
                 _an_[131],
                 _an_[119],
                 _an_[120],
                 _an_[121],
                 _an_[122],
                 _an_[135],
                 _an_[136],
                 _an_[129],
                 _an_[130],
                 _an_[201],
                 _an_[137],
                 _an_[203],
                 _an_[123],
                 _an_[196],
                 _an_[117],
                 _an_[197],
                 _an_[124],
                 _an_[125],
                 _an_[126],
                 _an_[127],
                 _an_[133],
                 _an_[134],
                 _an_[200],
                 _an_[199],
                 _an_[198],
                 _an_[296],
                 _an_[205],
                 _an_[206],
                 _an_[207],
                 _an_[208],
                 _an_[209],
                 _an_[210],
                 _an_[204],
                 _an_[211],
                 _an_[212],
                 _an_[213],
                 _an_[115],
                 _an_[116],
                 _an_[118],
                 _an_[292],
                 _an_[293],
                 _an_[294],
                 _an_[214],
                 _an_[215],
                 _an_[216],
                 _an_[217],
                 _an_[218],
                 _an_[219],
                 _an_[220],
                 _an_[221],
                 _an_[222],
                 _an_[295],
                 _an_[223],
                 _an_[25],
                 _an_[26],
                 _an_[224],
                 _an_[225],
                 _an_[239],
                 _an_[234],
                 _an_[232],
                 _an_[353],
                 _an_[233],
                 _an_[231],
                 _an_[318],
                 _an_[235],
                 _an_[236],
                 _an_[237],
                 _an_[238],
                 _an_[246],
                 _an_[247],
                 _an_[248],
                 _an_[249],
                 _an_[250],
                 _an_[251],
                 _an_[252],
                 _an_[253],
                 _an_[304],
                 _an_[305],
                 _an_[306],
                 _an_[256],
                 _an_[257],
                 _an_[254],
                 _an_[255],
                 _an_[272],
                 _an_[273],
                 _an_[274],
                 _an_[275],
                 _an_[276],
                 _an_[277],
                 _an_[333],
                 _an_[334],
                 _an_[278],
                 _an_[279],
                 _an_[280],
                 _an_[281],
                 _an_[282],
                 _an_[283],
                 _an_[284],
                 _an_[285],
                 _an_[289],
                 _an_[290],
                 _an_[258],
                 _an_[259],
                 _an_[260],
                 _an_[261],
                 _an_[262],
                 _an_[263],
                 _an_[264],
                 _an_[265],
                 _an_[266],
                 _an_[267],
                 _an_[268],
                 _an_[269],
                 _an_[270],
                 _an_[271],
                 _an_[299],
                 _an_[300],
                 _an_[349],
                 _an_[346],
                 _an_[347],
                 _an_[348],
                 _an_[313],
                 _an_[308],
                 _an_[309],
                 _an_[310],
                 _an_[314],
                 _an_[297],
                 _an_[298],
                 _an_[335],
                 _an_[337],
                 _an_[336],
                 _an_[341],
                 _an_[342],
                 _an_[343],
                 _an_[344],
                 _an_[345],
                 _an_[338],
                 _an_[339],
                 _an_[340],
                 _an_[317],
                 _an_[331],
                 _an_[328],
                 _an_[321],
                 _an_[319],
                 _an_[325],
                 _an_[323],
                 _an_[326],
                 _an_[332],
                 _an_[322],
                 _an_[324],
                 _an_[320],
                 _an_[327],
                 _an_[315],
                 _an_[316],
                 _an_[241],
                 _an_[242],
                 _an_[243],
                 _an_[244],
                 _an_[245],
                 _an_[329],
                 _an_[330],
                 _an_[311],
                 _an_[312],
                 _an_[301],
                 _an_[302],
                 _an_[303],
                 _an_[350],
                 _an_[351],
                 _an_[352],
                 _an_[287],
                 _an_[286],
                 _an_[288],
                 _an_[240],
                 _an_[360],
                 _an_[354],
                 _an_[355],
                 _an_[356],
                 _an_[357],
                 _an_[358],
                 _an_[5],
                 _an_[6],
                 [0,
                  _am_[1],
                  _am_[3],
                  _am_[2],
                  _am_[4],
                  _am_[7],
                  _am_[5],
                  _am_[6],
                  _am_[8],
                  _am_[9],
                  _am_[10]]]},
       _ai_,
       _ah_];
    caml_register_global(1098,Html_f,"Html_f");
    return}
  (function(){return this}()));


//# 1 "../../.js/tyxml/tyxml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_register_global=runtime.caml_register_global,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_string_of_jsbytes(""),
     cst=caml_string_of_jsbytes(""),
     cst$1=caml_string_of_jsbytes(""),
     cst_CDATA=caml_string_of_jsbytes("<![CDATA["),
     cst$2=caml_string_of_jsbytes("//"),
     cst_CDATA$0=caml_string_of_jsbytes("//<![CDATA["),
     cst$3=caml_string_of_jsbytes("/*  */"),
     cst_CDATA$1=caml_string_of_jsbytes("/* <![CDATA[ */"),
     Stdlib_format=global_data.Stdlib__format,
     Re=global_data.Re,
     Stdlib_printf=global_data.Stdlib__printf,
     Xml_wrap=global_data.Xml_wrap,
     Xml_print=global_data.Xml_print,
     Xml_iter=global_data.Xml_iter,
     Xml_stream=global_data.Xml_stream,
     Svg_f=global_data.Svg_f,
     Html_f=global_data.Html_f,
     _b_=[0,1],
     _c_=
      [0,
       [12,10,[2,0,[12,10,[2,0,[12,10,[2,0,[12,10,0]]]]]]],
       caml_string_of_jsbytes("\n%s\n%s\n%s\n")];
    function uri_of_string(s){return s}
    function string_of_uri(s){return s}
    function acontent(param){var a=param[2];return a}
    function aname(param){var name=param[1];return name}
    function float_attrib(name,value){return [0,name,[0,value]]}
    function int_attrib(name,value){return [0,name,[1,value]]}
    function string_attrib(name,value){return [0,name,[2,value]]}
    function space_sep_attrib(name,values){return [0,name,[3,0,values]]}
    function comma_sep_attrib(name,values){return [0,name,[3,1,values]]}
    function event_handler_attrib(name,value){return [0,name,[2,value]]}
    function mouse_event_handler_attrib(name,value){return [0,name,[2,value]]}
    function keyboard_event_handler_attrib(name,value)
     {return [0,name,[2,value]]}
    function touch_event_handler_attrib(name,value){return [0,name,[2,value]]}
    function uri_attrib(name,value){return [0,name,[2,value]]}
    function uris_attrib(name,values){return [0,name,[3,0,values]]}
    function content(elt){return elt}
    function empty(param){return 0}
    function comment(c){return [0,c]}
    function pcdata(d){return [2,d]}
    function encodedpcdata(d){return [1,d]}
    function entity(e){return [3,e]}
    var _a_=caml_call1(Re[23],cst),re_end_cdata=caml_call1(Re[2],_a_);
    function encoded_cdata(s1,s2,s)
     {var _j5_=caml_call6(Re[22],0,0,_b_,re_end_cdata,cst$0,s);
      return [1,caml_call4(Stdlib_printf[4],_c_,s1,_j5_,s2)]}
    function cdata(_j4_){return encoded_cdata(cst_CDATA,cst$1,_j4_)}
    function cdata_script(_j3_){return encoded_cdata(cst_CDATA$0,cst$2,_j3_)}
    function cdata_style(_j2_){return encoded_cdata(cst_CDATA$1,cst$3,_j2_)}
    function leaf(opt,name)
     {if(opt)var sth=opt[1],a=sth;else var a=0;return [4,name,a]}
    function node(opt,name,children)
     {if(opt)var sth=opt[1],a=sth;else var a=0;return [5,name,a,children]}
    var
     print_list=
      caml_call1
        (caml_call1
          (Xml_print[12],
           [0,
            Xml_wrap[1],
            string_of_uri,
            uri_of_string,
            float_attrib,
            int_attrib,
            string_attrib,
            space_sep_attrib,
            comma_sep_attrib,
            event_handler_attrib,
            mouse_event_handler_attrib,
            keyboard_event_handler_attrib,
            touch_event_handler_attrib,
            uri_attrib,
            uris_attrib,
            empty,
            comment,
            pcdata,
            encodedpcdata,
            entity,
            leaf,
            node,
            cdata,
            cdata_script,
            cdata_style,
            aname,
            acontent,
            content]),
         [0,0])
       [1],
     include=
      caml_call1
       (Xml_iter[1],
        [0,
         Xml_wrap[1],
         string_of_uri,
         uri_of_string,
         float_attrib,
         int_attrib,
         string_attrib,
         space_sep_attrib,
         comma_sep_attrib,
         event_handler_attrib,
         mouse_event_handler_attrib,
         keyboard_event_handler_attrib,
         touch_event_handler_attrib,
         uri_attrib,
         uris_attrib,
         empty,
         comment,
         pcdata,
         encodedpcdata,
         entity,
         leaf,
         node,
         cdata,
         cdata_script,
         cdata_style,
         aname,
         acontent,
         content]),
     amap=include[1],
     amap1=include[2],
     rm_attrib=include[3],
     rm_attrib_from_list=include[4],
     map_int_attrib=include[5],
     map_string_attrib=include[7],
     map_string_attrib_in_list=include[8],
     add_int_attrib=include[9],
     add_string_attrib=include[11],
     add_comma_sep_attrib=include[12],
     add_space_sep_attrib=include[13],
     fold=include[14],
     all_entities=include[15],
     translate=include[16],
     pp=
      caml_call1
        (caml_call1
          (Xml_print[9],
           [0,
            Xml_wrap[1],
            string_of_uri,
            uri_of_string,
            float_attrib,
            int_attrib,
            string_attrib,
            space_sep_attrib,
            comma_sep_attrib,
            event_handler_attrib,
            mouse_event_handler_attrib,
            keyboard_event_handler_attrib,
            touch_event_handler_attrib,
            uri_attrib,
            uris_attrib,
            empty,
            comment,
            pcdata,
            encodedpcdata,
            entity,
            leaf,
            node,
            cdata,
            cdata_script,
            cdata_style,
            aname,
            acontent,
            content]),
         [0,0])
       [1],
     include$0=
      caml_call1
       (Xml_stream[2],
        [0,
         Xml_wrap[1],
         string_of_uri,
         uri_of_string,
         float_attrib,
         int_attrib,
         string_attrib,
         space_sep_attrib,
         comma_sep_attrib,
         event_handler_attrib,
         mouse_event_handler_attrib,
         keyboard_event_handler_attrib,
         touch_event_handler_attrib,
         uri_attrib,
         uris_attrib,
         empty,
         comment,
         pcdata,
         encodedpcdata,
         entity,
         leaf,
         node,
         cdata,
         cdata_script,
         cdata_style]),
     of_seq=include$0[1];
    function print(fmt,x)
     {return caml_call3
              (print_list,caml_call1(Stdlib_format[13],fmt),0,[0,x,0])}
    var
     _d_=Xml_wrap[1],
     Tyxml_xml=
      [0,
       _d_,
       string_of_uri,
       uri_of_string,
       float_attrib,
       int_attrib,
       string_attrib,
       space_sep_attrib,
       comma_sep_attrib,
       event_handler_attrib,
       mouse_event_handler_attrib,
       keyboard_event_handler_attrib,
       touch_event_handler_attrib,
       uri_attrib,
       uris_attrib,
       empty,
       comment,
       pcdata,
       encodedpcdata,
       entity,
       leaf,
       node,
       cdata,
       cdata_script,
       cdata_style,
       aname,
       acontent,
       content,
       pp,
       of_seq,
       amap,
       amap1,
       rm_attrib,
       rm_attrib_from_list,
       map_int_attrib,
       map_string_attrib,
       map_string_attrib_in_list,
       add_int_attrib,
       add_string_attrib,
       add_comma_sep_attrib,
       add_space_sep_attrib,
       fold,
       all_entities,
       translate,
       print_list,
       print];
    caml_register_global(17,Tyxml_xml,"Tyxml_xml");
    var
     M=
      caml_call1
       (Svg_f[1],
        [0,
         _d_,
         string_of_uri,
         uri_of_string,
         float_attrib,
         int_attrib,
         string_attrib,
         space_sep_attrib,
         comma_sep_attrib,
         event_handler_attrib,
         mouse_event_handler_attrib,
         keyboard_event_handler_attrib,
         touch_event_handler_attrib,
         uri_attrib,
         uris_attrib,
         empty,
         comment,
         pcdata,
         encodedpcdata,
         entity,
         leaf,
         node,
         cdata,
         cdata_script,
         cdata_style]),
     _e_=[0,M[2],M[325],M[327]],
     include$1=
      caml_call1
       (caml_call1
         (Xml_print[8],
          [0,
           _d_,
           string_of_uri,
           uri_of_string,
           float_attrib,
           int_attrib,
           string_attrib,
           space_sep_attrib,
           comma_sep_attrib,
           event_handler_attrib,
           mouse_event_handler_attrib,
           keyboard_event_handler_attrib,
           touch_event_handler_attrib,
           uri_attrib,
           uris_attrib,
           empty,
           comment,
           pcdata,
           encodedpcdata,
           entity,
           leaf,
           node,
           cdata,
           cdata_script,
           cdata_style,
           aname,
           acontent,
           content]),
        _e_),
     _f_=[0,M[2],M[325],M[327]],
     Make_printer=
      caml_call1
       (caml_call1
         (Xml_print[11],
          [0,
           _d_,
           string_of_uri,
           uri_of_string,
           float_attrib,
           int_attrib,
           string_attrib,
           space_sep_attrib,
           comma_sep_attrib,
           event_handler_attrib,
           mouse_event_handler_attrib,
           keyboard_event_handler_attrib,
           touch_event_handler_attrib,
           uri_attrib,
           uris_attrib,
           empty,
           comment,
           pcdata,
           encodedpcdata,
           entity,
           leaf,
           node,
           cdata,
           cdata_script,
           cdata_style,
           aname,
           acontent,
           content]),
        _f_),
     _h_=M[2],
     _i_=M[3],
     _j_=M[4],
     _k_=M[5],
     _l_=M[6],
     _m_=M[7],
     _n_=M[8],
     _o_=M[9],
     _p_=M[10],
     _q_=M[11],
     _r_=M[12],
     _s_=M[13],
     _t_=M[14],
     _u_=M[15],
     _v_=M[16],
     _w_=M[17],
     _x_=M[18],
     _y_=M[19],
     _z_=M[20],
     _A_=M[21],
     _B_=M[22],
     _C_=M[23],
     _D_=M[24],
     _E_=M[25],
     _F_=M[26],
     _G_=M[27],
     _H_=M[28],
     _I_=M[29],
     _J_=M[30],
     _K_=M[31],
     _L_=M[32],
     _M_=M[33],
     _N_=M[34],
     _O_=M[35],
     _P_=M[36],
     _Q_=M[37],
     _R_=M[38],
     _S_=M[39],
     _T_=M[40],
     _U_=M[41],
     _V_=M[42],
     _W_=M[43],
     _X_=M[44],
     _Y_=M[45],
     _Z_=M[46],
     ___=M[47],
     _$_=M[48],
     _aa_=M[49],
     _ab_=M[50],
     _ac_=M[51],
     _ad_=M[52],
     _ae_=M[53],
     _af_=M[54],
     _ag_=M[55],
     _ah_=M[56],
     _ai_=M[57],
     _aj_=M[58],
     _ak_=M[59],
     _al_=M[60],
     _am_=M[61],
     _an_=M[62],
     _ao_=M[63],
     _ap_=M[64],
     _aq_=M[65],
     _ar_=M[66],
     _as_=M[67],
     _at_=M[68],
     _au_=M[69],
     _av_=M[70],
     _aw_=M[71],
     _ax_=M[72],
     _ay_=M[73],
     _az_=M[74],
     _aA_=M[75],
     _aB_=M[76],
     _aC_=M[77],
     _aD_=M[78],
     _aE_=M[79],
     _aF_=M[80],
     _aG_=M[81],
     _aH_=M[82],
     _aI_=M[83],
     _aJ_=M[84],
     _aK_=M[85],
     _aL_=M[86],
     _aM_=M[87],
     _aN_=M[88],
     _aO_=M[89],
     _aP_=M[90],
     _aQ_=M[91],
     _aR_=M[92],
     _aS_=M[93],
     _aT_=M[94],
     _aU_=M[95],
     _aV_=M[96],
     _aW_=M[97],
     _aX_=M[98],
     _aY_=M[99],
     _aZ_=M[100],
     _a0_=M[101],
     _a1_=M[102],
     _a2_=M[103],
     _a3_=M[104],
     _a4_=M[105],
     _a5_=M[106],
     _a6_=M[107],
     _a7_=M[108],
     _a8_=M[109],
     _a9_=M[110],
     _a__=M[111],
     _a$_=M[112],
     _ba_=M[113],
     _bb_=M[114],
     _bc_=M[115],
     _bd_=M[116],
     _be_=M[117],
     _bf_=M[118],
     _bg_=M[119],
     _bh_=M[120],
     _bi_=M[121],
     _bj_=M[122],
     _bk_=M[123],
     _bl_=M[124],
     _bm_=M[125],
     _bn_=M[126],
     _bo_=M[127],
     _bp_=M[128],
     _bq_=M[129],
     _br_=M[130],
     _bs_=M[131],
     _bt_=M[132],
     _bu_=M[133],
     _bv_=M[134],
     _bw_=M[135],
     _bx_=M[136],
     _by_=M[137],
     _bz_=M[138],
     _bA_=M[139],
     _bB_=M[140],
     _bC_=M[141],
     _bD_=M[142],
     _bE_=M[143],
     _bF_=M[144],
     _bG_=M[145],
     _bH_=M[146],
     _bI_=M[147],
     _bJ_=M[148],
     _bK_=M[149],
     _bL_=M[150],
     _bM_=M[151],
     _bN_=M[152],
     _bO_=M[153],
     _bP_=M[154],
     _bQ_=M[155],
     _bR_=M[156],
     _bS_=M[157],
     _bT_=M[158],
     _bU_=M[159],
     _bV_=M[160],
     _bW_=M[161],
     _bX_=M[162],
     _bY_=M[163],
     _bZ_=M[164],
     _b0_=M[165],
     _b1_=M[166],
     _b2_=M[167],
     _b3_=M[168],
     _b4_=M[169],
     _b5_=M[170],
     _b6_=M[171],
     _b7_=M[172],
     _b8_=M[173],
     _b9_=M[174],
     _b__=M[175],
     _b$_=M[176],
     _ca_=M[177],
     _cb_=M[178],
     _cc_=M[179],
     _cd_=M[180],
     _ce_=M[181],
     _cf_=M[182],
     _cg_=M[183],
     _ch_=M[184],
     _ci_=M[185],
     _cj_=M[186],
     _ck_=M[187],
     _cl_=M[188],
     _cm_=M[189],
     _cn_=M[190],
     _co_=M[191],
     _cp_=M[192],
     _cq_=M[193],
     _cr_=M[194],
     _cs_=M[195],
     _ct_=M[196],
     _cu_=M[197],
     _cv_=M[198],
     _cw_=M[199],
     _cx_=M[200],
     _cy_=M[201],
     _cz_=M[202],
     _cA_=M[203],
     _cB_=M[204],
     _cC_=M[205],
     _cD_=M[206],
     _cE_=M[207],
     _cF_=M[208],
     _cG_=M[209],
     _cH_=M[210],
     _cI_=M[211],
     _cJ_=M[212],
     _cK_=M[213],
     _cL_=M[214],
     _cM_=M[215],
     _cN_=M[216],
     _cO_=M[217],
     _cP_=M[218],
     _cQ_=M[219],
     _cR_=M[220],
     _cS_=M[221],
     _cT_=M[222],
     _cU_=M[223],
     _cV_=M[224],
     _cW_=M[225],
     _cX_=M[226],
     _cY_=M[227],
     _cZ_=M[228],
     _c0_=M[229],
     _c1_=M[230],
     _c2_=M[231],
     _c3_=M[232],
     _c4_=M[233],
     _c5_=M[234],
     _c6_=M[235],
     _c7_=M[236],
     _c8_=M[237],
     _c9_=M[238],
     _c__=M[239],
     _c$_=M[240],
     _da_=M[241],
     _db_=M[242],
     _dc_=M[243],
     _dd_=M[244],
     _de_=M[245],
     _df_=M[246],
     _dg_=M[247],
     _dh_=M[248],
     _di_=M[249],
     _dj_=M[250],
     _dk_=M[251],
     _dl_=M[252],
     _dm_=M[253],
     _dn_=M[254],
     _do_=M[255],
     _dp_=M[256],
     _dq_=M[257],
     _dr_=M[258],
     _ds_=M[259],
     _dt_=M[260],
     _du_=M[261],
     _dv_=M[262],
     _dw_=M[263],
     _dx_=M[264],
     _dy_=M[265],
     _dz_=M[266],
     _dA_=M[267],
     _dB_=M[268],
     _dC_=M[269],
     _dD_=M[270],
     _dE_=M[271],
     _dF_=M[272],
     _dG_=M[273],
     _dH_=M[274],
     _dI_=M[275],
     _dJ_=M[276],
     _dK_=M[277],
     _dL_=M[278],
     _dM_=M[279],
     _dN_=M[280],
     _dO_=M[281],
     _dP_=M[282],
     _dQ_=M[283],
     _dR_=M[284],
     _dS_=M[285],
     _dT_=M[286],
     _dU_=M[287],
     _dV_=M[288],
     _dW_=M[289],
     _dX_=M[290],
     _dY_=M[291],
     _dZ_=M[292],
     _d0_=M[293],
     _d1_=M[294],
     _d2_=M[295],
     _d3_=M[296],
     _d4_=M[297],
     _d5_=M[298],
     _d6_=M[299],
     _d7_=M[300],
     _d8_=M[301],
     _d9_=M[302],
     _d__=M[303],
     _d$_=M[304],
     _ea_=M[305],
     _eb_=M[306],
     _ec_=M[307],
     _ed_=M[308],
     _ee_=M[309],
     _ef_=M[310],
     _eg_=M[311],
     _eh_=M[312],
     _ei_=M[313],
     _ej_=M[314],
     _ek_=M[315],
     _el_=M[316],
     _em_=M[317],
     _en_=M[318],
     _eo_=M[319],
     _ep_=M[320],
     _eq_=M[321],
     _er_=M[322],
     _es_=M[323],
     _et_=M[324],
     _eu_=M[325],
     _ev_=M[326],
     _ew_=M[327],
     _ex_=M[328],
     _ey_=M[329],
     _ez_=M[330],
     _eA_=include$1[1],
     _eB_=include$1[2],
     _g_=M[1],
     pp$0=caml_call4(_eB_,0,0,0,0),
     pp_elt=caml_call3(_eA_,0,0,0),
     Tyxml_svg=
      [0,
       _g_,
       _h_,
       _i_,
       _j_,
       _k_,
       _l_,
       _m_,
       _n_,
       _o_,
       _p_,
       _q_,
       _r_,
       _s_,
       _t_,
       _u_,
       _v_,
       _w_,
       _x_,
       _y_,
       _z_,
       _A_,
       _B_,
       _C_,
       _D_,
       _E_,
       _F_,
       _G_,
       _H_,
       _I_,
       _J_,
       _K_,
       _L_,
       _M_,
       _N_,
       _O_,
       _P_,
       _Q_,
       _R_,
       _S_,
       _T_,
       _U_,
       _V_,
       _W_,
       _X_,
       _Y_,
       _Z_,
       ___,
       _$_,
       _aa_,
       _ab_,
       _ac_,
       _ad_,
       _ae_,
       _af_,
       _ag_,
       _ah_,
       _ai_,
       _aj_,
       _ak_,
       _al_,
       _am_,
       _an_,
       _ao_,
       _ap_,
       _aq_,
       _ar_,
       _as_,
       _at_,
       _au_,
       _av_,
       _aw_,
       _ax_,
       _ay_,
       _az_,
       _aA_,
       _aB_,
       _aC_,
       _aD_,
       _aE_,
       _aF_,
       _aG_,
       _aH_,
       _aI_,
       _aJ_,
       _aK_,
       _aL_,
       _aM_,
       _aN_,
       _aO_,
       _aP_,
       _aQ_,
       _aR_,
       _aS_,
       _aT_,
       _aU_,
       _aV_,
       _aW_,
       _aX_,
       _aY_,
       _aZ_,
       _a0_,
       _a1_,
       _a2_,
       _a3_,
       _a4_,
       _a5_,
       _a6_,
       _a7_,
       _a8_,
       _a9_,
       _a__,
       _a$_,
       _ba_,
       _bb_,
       _bc_,
       _bd_,
       _be_,
       _bf_,
       _bg_,
       _bh_,
       _bi_,
       _bj_,
       _bk_,
       _bl_,
       _bm_,
       _bn_,
       _bo_,
       _bp_,
       _bq_,
       _br_,
       _bs_,
       _bt_,
       _bu_,
       _bv_,
       _bw_,
       _bx_,
       _by_,
       _bz_,
       _bA_,
       _bB_,
       _bC_,
       _bD_,
       _bE_,
       _bF_,
       _bG_,
       _bH_,
       _bI_,
       _bJ_,
       _bK_,
       _bL_,
       _bM_,
       _bN_,
       _bO_,
       _bP_,
       _bQ_,
       _bR_,
       _bS_,
       _bT_,
       _bU_,
       _bV_,
       _bW_,
       _bX_,
       _bY_,
       _bZ_,
       _b0_,
       _b1_,
       _b2_,
       _b3_,
       _b4_,
       _b5_,
       _b6_,
       _b7_,
       _b8_,
       _b9_,
       _b__,
       _b$_,
       _ca_,
       _cb_,
       _cc_,
       _cd_,
       _ce_,
       _cf_,
       _cg_,
       _ch_,
       _ci_,
       _cj_,
       _ck_,
       _cl_,
       _cm_,
       _cn_,
       _co_,
       _cp_,
       _cq_,
       _cr_,
       _cs_,
       _ct_,
       _cu_,
       _cv_,
       _cw_,
       _cx_,
       _cy_,
       _cz_,
       _cA_,
       _cB_,
       _cC_,
       _cD_,
       _cE_,
       _cF_,
       _cG_,
       _cH_,
       _cI_,
       _cJ_,
       _cK_,
       _cL_,
       _cM_,
       _cN_,
       _cO_,
       _cP_,
       _cQ_,
       _cR_,
       _cS_,
       _cT_,
       _cU_,
       _cV_,
       _cW_,
       _cX_,
       _cY_,
       _cZ_,
       _c0_,
       _c1_,
       _c2_,
       _c3_,
       _c4_,
       _c5_,
       _c6_,
       _c7_,
       _c8_,
       _c9_,
       _c__,
       _c$_,
       _da_,
       _db_,
       _dc_,
       _dd_,
       _de_,
       _df_,
       _dg_,
       _dh_,
       _di_,
       _dj_,
       _dk_,
       _dl_,
       _dm_,
       _dn_,
       _do_,
       _dp_,
       _dq_,
       _dr_,
       _ds_,
       _dt_,
       _du_,
       _dv_,
       _dw_,
       _dx_,
       _dy_,
       _dz_,
       _dA_,
       _dB_,
       _dC_,
       _dD_,
       _dE_,
       _dF_,
       _dG_,
       _dH_,
       _dI_,
       _dJ_,
       _dK_,
       _dL_,
       _dM_,
       _dN_,
       _dO_,
       _dP_,
       _dQ_,
       _dR_,
       _dS_,
       _dT_,
       _dU_,
       _dV_,
       _dW_,
       _dX_,
       _dY_,
       _dZ_,
       _d0_,
       _d1_,
       _d2_,
       _d3_,
       _d4_,
       _d5_,
       _d6_,
       _d7_,
       _d8_,
       _d9_,
       _d__,
       _d$_,
       _ea_,
       _eb_,
       _ec_,
       _ed_,
       _ee_,
       _ef_,
       _eg_,
       _eh_,
       _ei_,
       _ej_,
       _ek_,
       _el_,
       _em_,
       _en_,
       _eo_,
       _ep_,
       _eq_,
       _er_,
       _es_,
       _et_,
       _eu_,
       _ev_,
       _ew_,
       _ex_,
       _ey_,
       _ez_,
       _eB_,
       _eA_,
       Make_printer,
       pp$0,
       pp_elt];
    caml_register_global(19,Tyxml_svg,"Tyxml_svg");
    var
     M$0=
      caml_call1
       (caml_call1
         (Html_f[1],
          [0,
           _d_,
           string_of_uri,
           uri_of_string,
           float_attrib,
           int_attrib,
           string_attrib,
           space_sep_attrib,
           comma_sep_attrib,
           event_handler_attrib,
           mouse_event_handler_attrib,
           keyboard_event_handler_attrib,
           touch_event_handler_attrib,
           uri_attrib,
           uris_attrib,
           empty,
           comment,
           pcdata,
           encodedpcdata,
           entity,
           leaf,
           node,
           cdata,
           cdata_script,
           cdata_style]),
        [0,
         _h_,
         _i_,
         _j_,
         _k_,
         _l_,
         _m_,
         _n_,
         _o_,
         _p_,
         _q_,
         _r_,
         _s_,
         _t_,
         _u_,
         _v_,
         _w_,
         _x_,
         _y_,
         _z_,
         _A_,
         _B_,
         _C_,
         _D_,
         _E_,
         _F_,
         _G_,
         _H_,
         _I_,
         _J_,
         _K_,
         _L_,
         _M_,
         _N_,
         _O_,
         _P_,
         _Q_,
         _R_,
         _S_,
         _T_,
         _U_,
         _V_,
         _W_,
         _X_,
         _Y_,
         _Z_,
         ___,
         _$_,
         _aa_,
         _ab_,
         _ac_,
         _ad_,
         _ae_,
         _af_,
         _ag_,
         _ah_,
         _ai_,
         _aj_,
         _ak_,
         _al_,
         _am_,
         _an_,
         _ao_,
         _ap_,
         _aq_,
         _ar_,
         _as_,
         _at_,
         _au_,
         _av_,
         _aw_,
         _ax_,
         _ay_,
         _az_,
         _aA_,
         _aB_,
         _aC_,
         _aD_,
         _aE_,
         _aF_,
         _aG_,
         _aH_,
         _aI_,
         _aJ_,
         _aK_,
         _aL_,
         _aM_,
         _aN_,
         _aO_,
         _aP_,
         _aQ_,
         _aR_,
         _aS_,
         _aT_,
         _aU_,
         _aV_,
         _aW_,
         _aX_,
         _aY_,
         _aZ_,
         _a0_,
         _a1_,
         _a2_,
         _a3_,
         _a4_,
         _a5_,
         _a6_,
         _a7_,
         _a8_,
         _a9_,
         _a__,
         _a$_,
         _ba_,
         _bb_,
         _bc_,
         _bd_,
         _be_,
         _bf_,
         _bg_,
         _bh_,
         _bi_,
         _bj_,
         _bk_,
         _bl_,
         _bm_,
         _bn_,
         _bo_,
         _bp_,
         _bq_,
         _br_,
         _bs_,
         _bt_,
         _bu_,
         _bv_,
         _bw_,
         _bx_,
         _by_,
         _bz_,
         _bA_,
         _bB_,
         _bC_,
         _bD_,
         _bE_,
         _bF_,
         _bG_,
         _bH_,
         _bI_,
         _bJ_,
         _bK_,
         _bL_,
         _bM_,
         _bN_,
         _bO_,
         _bP_,
         _bQ_,
         _bR_,
         _bS_,
         _bT_,
         _bU_,
         _bV_,
         _bW_,
         _bX_,
         _bY_,
         _bZ_,
         _b0_,
         _b1_,
         _b2_,
         _b3_,
         _b4_,
         _b5_,
         _b6_,
         _b7_,
         _b8_,
         _b9_,
         _b__,
         _b$_,
         _ca_,
         _cb_,
         _cc_,
         _cd_,
         _ce_,
         _cf_,
         _cg_,
         _ch_,
         _ci_,
         _cj_,
         _ck_,
         _cl_,
         _cm_,
         _cn_,
         _co_,
         _cp_,
         _cq_,
         _cr_,
         _cs_,
         _ct_,
         _cu_,
         _cv_,
         _cw_,
         _cx_,
         _cy_,
         _cz_,
         _cA_,
         _cB_,
         _cC_,
         _cD_,
         _cE_,
         _cF_,
         _cG_,
         _cH_,
         _cI_,
         _cJ_,
         _cK_,
         _cL_,
         _cM_,
         _cN_,
         _cO_,
         _cP_,
         _cQ_,
         _cR_,
         _cS_,
         _cT_,
         _cU_,
         _cV_,
         _cW_,
         _cX_,
         _cY_,
         _cZ_,
         _c0_,
         _c1_,
         _c2_,
         _c3_,
         _c4_,
         _c5_,
         _c6_,
         _c7_,
         _c8_,
         _c9_,
         _c__,
         _c$_,
         _da_,
         _db_,
         _dc_,
         _dd_,
         _de_,
         _df_,
         _dg_,
         _dh_,
         _di_,
         _dj_,
         _dk_,
         _dl_,
         _dm_,
         _dn_,
         _do_,
         _dp_,
         _dq_,
         _dr_,
         _ds_,
         _dt_,
         _du_,
         _dv_,
         _dw_,
         _dx_,
         _dy_,
         _dz_,
         _dA_,
         _dB_,
         _dC_,
         _dD_,
         _dE_,
         _dF_,
         _dG_,
         _dH_,
         _dI_,
         _dJ_,
         _dK_,
         _dL_,
         _dM_,
         _dN_,
         _dO_,
         _dP_,
         _dQ_,
         _dR_,
         _dS_,
         _dT_,
         _dU_,
         _dV_,
         _dW_,
         _dX_,
         _dY_,
         _dZ_,
         _d0_,
         _d1_,
         _d2_,
         _d3_,
         _d4_,
         _d5_,
         _d6_,
         _d7_,
         _d8_,
         _d9_,
         _d__,
         _d$_,
         _ea_,
         _eb_,
         _ec_,
         _ed_,
         _ee_,
         _ef_,
         _eg_,
         _eh_,
         _ei_,
         _ej_,
         _ek_,
         _el_,
         _em_,
         _en_,
         _eo_,
         _ep_,
         _eq_,
         _er_,
         _es_,
         _et_,
         _eu_,
         _ev_,
         _ew_,
         _ex_,
         _ey_,
         _ez_]),
     _eC_=[0,M$0[2],M$0[337],M$0[339]],
     include$2=
      caml_call1
       (caml_call1
         (Xml_print[8],
          [0,
           _d_,
           string_of_uri,
           uri_of_string,
           float_attrib,
           int_attrib,
           string_attrib,
           space_sep_attrib,
           comma_sep_attrib,
           event_handler_attrib,
           mouse_event_handler_attrib,
           keyboard_event_handler_attrib,
           touch_event_handler_attrib,
           uri_attrib,
           uris_attrib,
           empty,
           comment,
           pcdata,
           encodedpcdata,
           entity,
           leaf,
           node,
           cdata,
           cdata_script,
           cdata_style,
           aname,
           acontent,
           content]),
        _eC_),
     _eD_=[0,M$0[2],M$0[337],M$0[339]],
     Make_printer$0=
      caml_call1
       (caml_call1
         (Xml_print[11],
          [0,
           _d_,
           string_of_uri,
           uri_of_string,
           float_attrib,
           int_attrib,
           string_attrib,
           space_sep_attrib,
           comma_sep_attrib,
           event_handler_attrib,
           mouse_event_handler_attrib,
           keyboard_event_handler_attrib,
           touch_event_handler_attrib,
           uri_attrib,
           uris_attrib,
           empty,
           comment,
           pcdata,
           encodedpcdata,
           entity,
           leaf,
           node,
           cdata,
           cdata_script,
           cdata_style,
           aname,
           acontent,
           content]),
        _eD_),
     _j0_=include$2[1],
     _j1_=include$2[2],
     _eE_=M$0[1],
     _eF_=M$0[2],
     _eG_=M$0[3],
     _eH_=M$0[4],
     _eI_=M$0[5],
     _eJ_=M$0[6],
     _eK_=M$0[7],
     _eL_=M$0[8],
     _eM_=M$0[9],
     _eN_=M$0[10],
     _eO_=M$0[11],
     _eP_=M$0[12],
     _eQ_=M$0[13],
     _eR_=M$0[14],
     _eS_=M$0[15],
     _eT_=M$0[16],
     _eU_=M$0[17],
     _eV_=M$0[18],
     _eW_=M$0[19],
     _eX_=M$0[20],
     _eY_=M$0[21],
     _eZ_=M$0[22],
     _e0_=M$0[23],
     _e1_=M$0[24],
     _e2_=M$0[25],
     _e3_=M$0[26],
     _e4_=M$0[27],
     _e5_=M$0[28],
     _e6_=M$0[29],
     _e7_=M$0[30],
     _e8_=M$0[31],
     _e9_=M$0[32],
     _e__=M$0[33],
     _e$_=M$0[34],
     _fa_=M$0[35],
     _fb_=M$0[36],
     _fc_=M$0[37],
     _fd_=M$0[38],
     _fe_=M$0[39],
     _ff_=M$0[40],
     _fg_=M$0[41],
     _fh_=M$0[42],
     _fi_=M$0[43],
     _fj_=M$0[44],
     _fk_=M$0[45],
     _fl_=M$0[46],
     _fm_=M$0[47],
     _fn_=M$0[48],
     _fo_=M$0[49],
     _fp_=M$0[50],
     _fq_=M$0[51],
     _fr_=M$0[52],
     _fs_=M$0[53],
     _ft_=M$0[54],
     _fu_=M$0[55],
     _fv_=M$0[56],
     _fw_=M$0[57],
     _fx_=M$0[58],
     _fy_=M$0[59],
     _fz_=M$0[60],
     _fA_=M$0[61],
     _fB_=M$0[62],
     _fC_=M$0[63],
     _fD_=M$0[64],
     _fE_=M$0[65],
     _fF_=M$0[66],
     _fG_=M$0[67],
     _fH_=M$0[68],
     _fI_=M$0[69],
     _fJ_=M$0[70],
     _fK_=M$0[71],
     _fL_=M$0[72],
     _fM_=M$0[73],
     _fN_=M$0[74],
     _fO_=M$0[75],
     _fP_=M$0[76],
     _fQ_=M$0[77],
     _fR_=M$0[78],
     _fS_=M$0[79],
     _fT_=M$0[80],
     _fU_=M$0[81],
     _fV_=M$0[82],
     _fW_=M$0[83],
     _fX_=M$0[84],
     _fY_=M$0[85],
     _fZ_=M$0[86],
     _f0_=M$0[87],
     _f1_=M$0[88],
     _f2_=M$0[89],
     _f3_=M$0[90],
     _f4_=M$0[91],
     _f5_=M$0[92],
     _f6_=M$0[93],
     _f7_=M$0[94],
     _f8_=M$0[95],
     _f9_=M$0[96],
     _f__=M$0[97],
     _f$_=M$0[98],
     _ga_=M$0[99],
     _gb_=M$0[100],
     _gc_=M$0[101],
     _gd_=M$0[102],
     _ge_=M$0[103],
     _gf_=M$0[104],
     _gg_=M$0[105],
     _gh_=M$0[106],
     _gi_=M$0[107],
     _gj_=M$0[108],
     _gk_=M$0[109],
     _gl_=M$0[110],
     _gm_=M$0[111],
     _gn_=M$0[112],
     _go_=M$0[113],
     _gp_=M$0[114],
     _gq_=M$0[115],
     _gr_=M$0[116],
     _gs_=M$0[117],
     _gt_=M$0[118],
     _gu_=M$0[119],
     _gv_=M$0[120],
     _gw_=M$0[121],
     _gx_=M$0[122],
     _gy_=M$0[123],
     _gz_=M$0[124],
     _gA_=M$0[125],
     _gB_=M$0[126],
     _gC_=M$0[127],
     _gD_=M$0[128],
     _gE_=M$0[129],
     _gF_=M$0[130],
     _gG_=M$0[131],
     _gH_=M$0[132],
     _gI_=M$0[133],
     _gJ_=M$0[134],
     _gK_=M$0[135],
     _gL_=M$0[136],
     _gM_=M$0[137],
     _gN_=M$0[138],
     _gO_=M$0[139],
     _gP_=M$0[140],
     _gQ_=M$0[141],
     _gR_=M$0[142],
     _gS_=M$0[143],
     _gT_=M$0[144],
     _gU_=M$0[145],
     _gV_=M$0[146],
     _gW_=M$0[147],
     _gX_=M$0[148],
     _gY_=M$0[149],
     _gZ_=M$0[150],
     _g0_=M$0[151],
     _g1_=M$0[152],
     _g2_=M$0[153],
     _g3_=M$0[154],
     _g4_=M$0[155],
     _g5_=M$0[156],
     _g6_=M$0[157],
     _g7_=M$0[158],
     _g8_=M$0[159],
     _g9_=M$0[160],
     _g__=M$0[161],
     _g$_=M$0[162],
     _ha_=M$0[163],
     _hb_=M$0[164],
     _hc_=M$0[165],
     _hd_=M$0[166],
     _he_=M$0[167],
     _hf_=M$0[168],
     _hg_=M$0[169],
     _hh_=M$0[170],
     _hi_=M$0[171],
     _hj_=M$0[172],
     _hk_=M$0[173],
     _hl_=M$0[174],
     _hm_=M$0[175],
     _hn_=M$0[176],
     _ho_=M$0[177],
     _hp_=M$0[178],
     _hq_=M$0[179],
     _hr_=M$0[180],
     _hs_=M$0[181],
     _ht_=M$0[182],
     _hu_=M$0[183],
     _hv_=M$0[184],
     _hw_=M$0[185],
     _hx_=M$0[186],
     _hy_=M$0[187],
     _hz_=M$0[188],
     _hA_=M$0[189],
     _hB_=M$0[190],
     _hC_=M$0[191],
     _hD_=M$0[192],
     _hE_=M$0[193],
     _hF_=M$0[194],
     _hG_=M$0[195],
     _hH_=M$0[196],
     _hI_=M$0[197],
     _hJ_=M$0[198],
     _hK_=M$0[199],
     _hL_=M$0[200],
     _hM_=M$0[201],
     _hN_=M$0[202],
     _hO_=M$0[203],
     _hP_=M$0[204],
     _hQ_=M$0[205],
     _hR_=M$0[206],
     _hS_=M$0[207],
     _hT_=M$0[208],
     _hU_=M$0[209],
     _hV_=M$0[210],
     _hW_=M$0[211],
     _hX_=M$0[212],
     _hY_=M$0[213],
     _hZ_=M$0[214],
     _h0_=M$0[215],
     _h1_=M$0[216],
     _h2_=M$0[217],
     _h3_=M$0[218],
     _h4_=M$0[219],
     _h5_=M$0[220],
     _h6_=M$0[221],
     _h7_=M$0[222],
     _h8_=M$0[223],
     _h9_=M$0[224],
     _h__=M$0[225],
     _h$_=M$0[226],
     _ia_=M$0[227],
     _ib_=M$0[228],
     _ic_=M$0[229],
     _id_=M$0[230],
     _ie_=M$0[231],
     _if_=M$0[232],
     _ig_=M$0[233],
     _ih_=M$0[234],
     _ii_=M$0[235],
     _ij_=M$0[236],
     _ik_=M$0[237],
     _il_=M$0[238],
     _im_=M$0[239],
     _in_=M$0[240],
     _io_=M$0[241],
     _ip_=M$0[242],
     _iq_=M$0[243],
     _ir_=M$0[244],
     _is_=M$0[245],
     _it_=M$0[246],
     _iu_=M$0[247],
     _iv_=M$0[248],
     _iw_=M$0[249],
     _ix_=M$0[250],
     _iy_=M$0[251],
     _iz_=M$0[252],
     _iA_=M$0[253],
     _iB_=M$0[254],
     _iC_=M$0[255],
     _iD_=M$0[256],
     _iE_=M$0[257],
     _iF_=M$0[258],
     _iG_=M$0[259],
     _iH_=M$0[260],
     _iI_=M$0[261],
     _iJ_=M$0[262],
     _iK_=M$0[263],
     _iL_=M$0[264],
     _iM_=M$0[265],
     _iN_=M$0[266],
     _iO_=M$0[267],
     _iP_=M$0[268],
     _iQ_=M$0[269],
     _iR_=M$0[270],
     _iS_=M$0[271],
     _iT_=M$0[272],
     _iU_=M$0[273],
     _iV_=M$0[274],
     _iW_=M$0[275],
     _iX_=M$0[276],
     _iY_=M$0[277],
     _iZ_=M$0[278],
     _i0_=M$0[279],
     _i1_=M$0[280],
     _i2_=M$0[281],
     _i3_=M$0[282],
     _i4_=M$0[283],
     _i5_=M$0[284],
     _i6_=M$0[285],
     _i7_=M$0[286],
     _i8_=M$0[287],
     _i9_=M$0[288],
     _i__=M$0[289],
     _i$_=M$0[290],
     _ja_=M$0[291],
     _jb_=M$0[292],
     _jc_=M$0[293],
     _jd_=M$0[294],
     _je_=M$0[295],
     _jf_=M$0[296],
     _jg_=M$0[297],
     _jh_=M$0[298],
     _ji_=M$0[299],
     _jj_=M$0[300],
     _jk_=M$0[301],
     _jl_=M$0[302],
     _jm_=M$0[303],
     _jn_=M$0[304],
     _jo_=M$0[305],
     _jp_=M$0[306],
     _jq_=M$0[307],
     _jr_=M$0[308],
     _js_=M$0[309],
     _jt_=M$0[310],
     _ju_=M$0[311],
     _jv_=M$0[312],
     _jw_=M$0[313],
     _jx_=M$0[314],
     _jy_=M$0[315],
     _jz_=M$0[316],
     _jA_=M$0[317],
     _jB_=M$0[318],
     _jC_=M$0[319],
     _jD_=M$0[320],
     _jE_=M$0[321],
     _jF_=M$0[322],
     _jG_=M$0[323],
     _jH_=M$0[324],
     _jI_=M$0[325],
     _jJ_=M$0[326],
     _jK_=M$0[327],
     _jL_=M$0[328],
     _jM_=M$0[329],
     _jN_=M$0[330],
     _jO_=M$0[331],
     _jP_=M$0[332],
     _jQ_=M$0[333],
     _jR_=M$0[334],
     _jS_=M$0[335],
     _jT_=M$0[336],
     _jU_=M$0[337],
     _jV_=M$0[338],
     _jW_=M$0[339],
     _jX_=M$0[340],
     _jY_=M$0[341],
     _jZ_=M$0[342],
     pp$1=caml_call4(_j1_,0,0,0,0),
     pp_elt$0=caml_call3(_j0_,0,0,0),
     Tyxml_html=
      [0,
       _eE_,
       _eF_,
       _eG_,
       _eH_,
       _eI_,
       _eJ_,
       _eK_,
       _eL_,
       _eM_,
       _eN_,
       _eO_,
       _eP_,
       _eQ_,
       _eR_,
       _eS_,
       _eT_,
       _eU_,
       _eV_,
       _eW_,
       _eX_,
       _eY_,
       _eZ_,
       _e0_,
       _e1_,
       _e2_,
       _e3_,
       _e4_,
       _e5_,
       _e6_,
       _e7_,
       _e8_,
       _e9_,
       _e__,
       _e$_,
       _fa_,
       _fb_,
       _fc_,
       _fd_,
       _fe_,
       _ff_,
       _fg_,
       _fh_,
       _fi_,
       _fj_,
       _fk_,
       _fl_,
       _fm_,
       _fn_,
       _fo_,
       _fp_,
       _fq_,
       _fr_,
       _fs_,
       _ft_,
       _fu_,
       _fv_,
       _fw_,
       _fx_,
       _fy_,
       _fz_,
       _fA_,
       _fB_,
       _fC_,
       _fD_,
       _fE_,
       _fF_,
       _fG_,
       _fH_,
       _fI_,
       _fJ_,
       _fK_,
       _fL_,
       _fM_,
       _fN_,
       _fO_,
       _fP_,
       _fQ_,
       _fR_,
       _fS_,
       _fT_,
       _fU_,
       _fV_,
       _fW_,
       _fX_,
       _fY_,
       _fZ_,
       _f0_,
       _f1_,
       _f2_,
       _f3_,
       _f4_,
       _f5_,
       _f6_,
       _f7_,
       _f8_,
       _f9_,
       _f__,
       _f$_,
       _ga_,
       _gb_,
       _gc_,
       _gd_,
       _ge_,
       _gf_,
       _gg_,
       _gh_,
       _gi_,
       _gj_,
       _gk_,
       _gl_,
       _gm_,
       _gn_,
       _go_,
       _gp_,
       _gq_,
       _gr_,
       _gs_,
       _gt_,
       _gu_,
       _gv_,
       _gw_,
       _gx_,
       _gy_,
       _gz_,
       _gA_,
       _gB_,
       _gC_,
       _gD_,
       _gE_,
       _gF_,
       _gG_,
       _gH_,
       _gI_,
       _gJ_,
       _gK_,
       _gL_,
       _gM_,
       _gN_,
       _gO_,
       _gP_,
       _gQ_,
       _gR_,
       _gS_,
       _gT_,
       _gU_,
       _gV_,
       _gW_,
       _gX_,
       _gY_,
       _gZ_,
       _g0_,
       _g1_,
       _g2_,
       _g3_,
       _g4_,
       _g5_,
       _g6_,
       _g7_,
       _g8_,
       _g9_,
       _g__,
       _g$_,
       _ha_,
       _hb_,
       _hc_,
       _hd_,
       _he_,
       _hf_,
       _hg_,
       _hh_,
       _hi_,
       _hj_,
       _hk_,
       _hl_,
       _hm_,
       _hn_,
       _ho_,
       _hp_,
       _hq_,
       _hr_,
       _hs_,
       _ht_,
       _hu_,
       _hv_,
       _hw_,
       _hx_,
       _hy_,
       _hz_,
       _hA_,
       _hB_,
       _hC_,
       _hD_,
       _hE_,
       _hF_,
       _hG_,
       _hH_,
       _hI_,
       _hJ_,
       _hK_,
       _hL_,
       _hM_,
       _hN_,
       _hO_,
       _hP_,
       _hQ_,
       _hR_,
       _hS_,
       _hT_,
       _hU_,
       _hV_,
       _hW_,
       _hX_,
       _hY_,
       _hZ_,
       _h0_,
       _h1_,
       _h2_,
       _h3_,
       _h4_,
       _h5_,
       _h6_,
       _h7_,
       _h8_,
       _h9_,
       _h__,
       _h$_,
       _ia_,
       _ib_,
       _ic_,
       _id_,
       _ie_,
       _if_,
       _ig_,
       _ih_,
       _ii_,
       _ij_,
       _ik_,
       _il_,
       _im_,
       _in_,
       _io_,
       _ip_,
       _iq_,
       _ir_,
       _is_,
       _it_,
       _iu_,
       _iv_,
       _iw_,
       _ix_,
       _iy_,
       _iz_,
       _iA_,
       _iB_,
       _iC_,
       _iD_,
       _iE_,
       _iF_,
       _iG_,
       _iH_,
       _iI_,
       _iJ_,
       _iK_,
       _iL_,
       _iM_,
       _iN_,
       _iO_,
       _iP_,
       _iQ_,
       _iR_,
       _iS_,
       _iT_,
       _iU_,
       _iV_,
       _iW_,
       _iX_,
       _iY_,
       _iZ_,
       _i0_,
       _i1_,
       _i2_,
       _i3_,
       _i4_,
       _i5_,
       _i6_,
       _i7_,
       _i8_,
       _i9_,
       _i__,
       _i$_,
       _ja_,
       _jb_,
       _jc_,
       _jd_,
       _je_,
       _jf_,
       _jg_,
       _jh_,
       _ji_,
       _jj_,
       _jk_,
       _jl_,
       _jm_,
       _jn_,
       _jo_,
       _jp_,
       _jq_,
       _jr_,
       _js_,
       _jt_,
       _ju_,
       _jv_,
       _jw_,
       _jx_,
       _jy_,
       _jz_,
       _jA_,
       _jB_,
       _jC_,
       _jD_,
       _jE_,
       _jF_,
       _jG_,
       _jH_,
       _jI_,
       _jJ_,
       _jK_,
       _jL_,
       _jM_,
       _jN_,
       _jO_,
       _jP_,
       _jQ_,
       _jR_,
       _jS_,
       _jT_,
       _jU_,
       _jV_,
       _jW_,
       _jX_,
       _jY_,
       _jZ_,
       _j1_,
       _j0_,
       Make_printer$0,
       pp$1,
       pp_elt$0];
    caml_register_global(21,Tyxml_html,"Tyxml_html");
    var Tyxml=[0];
    caml_register_global(22,Tyxml,"Tyxml");
    return}
  (function(){return this}()));


//# 1 "../../.js/react/react.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_equal=runtime.caml_equal,
     caml_int_compare=runtime.caml_int_compare,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     err_max_rank=caml_string_of_jsbytes("maximal rank exceeded"),
     err_sig_undef=caml_string_of_jsbytes("signal value undefined yet"),
     err_fix=caml_string_of_jsbytes("trying to fix a delayed value"),
     err_retain_never=
      caml_string_of_jsbytes("E.never cannot retain a closure"),
     err_retain_cst_sig=
      caml_string_of_jsbytes("constant signals cannot retain a closure"),
     err_step_executed=caml_string_of_jsbytes("step already executed"),
     err_event_scheduled=
      caml_string_of_jsbytes("event already scheduled on a step"),
     err_signal_scheduled=
      caml_string_of_jsbytes("signal already scheduled on a step"),
     one=[0,1],
     zero=[0,0],
     zero$0=[0,0],
     one$0=[0,1],
     minus_one=[0,-1],
     zero$1=[0,0.],
     one$1=[0,1.],
     minus_one$0=[0,-1.],
     none=[0,0],
     Assert_failure=global_data.Assert_failure,
     Stdlib=global_data.Stdlib,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_weak=global_data.Stdlib__weak,
     _k_=[0,caml_string_of_jsbytes("src/react.ml"),1526,17],
     _j_=[0,caml_string_of_jsbytes("src/react.ml"),1113,18],
     _i_=[0,caml_string_of_jsbytes("src/react.ml"),995,36],
     _h_=[0,caml_string_of_jsbytes("src/react.ml"),761,45],
     _g_=[0,caml_string_of_jsbytes("src/react.ml"),732,53],
     _f_=[0,caml_string_of_jsbytes("src/react.ml"),702,19],
     _e_=[0,1],
     _d_=[0,caml_string_of_jsbytes("src/react.ml"),422,51],
     _c_=[0,caml_string_of_jsbytes("src/react.ml"),411,54];
    function create(size){return [0,caml_call1(Stdlib_weak[1],size),0]}
    function is_empty(a)
     {try
       {var _d0_=a[2] - 1 | 0,_dZ_=0;
        if(! (_d0_ < 0))
         {var i=_dZ_;
          for(;;)
           {if(caml_call2(Stdlib_weak[6],a[1],i))throw Stdlib[3];
            var _d2_=i + 1 | 0;
            if(_d0_ !== i){var i=_d2_;continue}
            break}}
        var _d1_=1;
        return _d1_}
      catch(_d3_)
       {_d3_ = caml_wrap_exception(_d3_);
        if(_d3_ === Stdlib[3])return 0;
        throw _d3_}}
    function clear(a){a[1] = caml_call1(Stdlib_weak[1],0);a[2] = 0;return 0}
    function get(a,i){return caml_call2(Stdlib_weak[4],a[1],i)}
    function swap(a,i$0,i)
     {var v=caml_call2(Stdlib_weak[4],a[1],i);
      caml_call5(Stdlib_weak[8],a[1],i$0,a[1],i,1);
      return caml_call3(Stdlib_weak[3],a[1],i$0,v)}
    function add(a,v)
     {var _dY_=caml_call1(Stdlib_weak[2],a[1]);
      if(a[2] === _dY_)
       {var arr=caml_call1(Stdlib_weak[1],2 * (a[2] + 1 | 0) | 0);
        caml_call5(Stdlib_weak[8],a[1],0,arr,0,a[2]);
        a[1] = arr}
      caml_call3(Stdlib_weak[3],a[1],a[2],[0,v]);
      a[2] = a[2] + 1 | 0;
      return 0}
    function scan_add(a,v)
     {try
       {var _dU_=a[2] - 1 | 0,_dT_=0;
        if(! (_dU_ < 0))
         {var i=_dT_;
          for(;;)
           {var match=caml_call2(Stdlib_weak[4],a[1],i);
            if(! match)
             {caml_call3(Stdlib_weak[3],a[1],i,[0,v]);throw Stdlib[3]}
            var _dW_=i + 1 | 0;
            if(_dU_ !== i){var i=_dW_;continue}
            break}}
        var _dV_=add(a,v);
        return _dV_}
      catch(_dX_)
       {_dX_ = caml_wrap_exception(_dX_);
        if(_dX_ === Stdlib[3])return 0;
        throw _dX_}}
    function rem_last(a)
     {var l=a[2] - 1 | 0;a[2] = l;return caml_call3(Stdlib_weak[3],a[1],l,0)}
    function rem(a,v)
     {try
       {var _dP_=a[2] - 1 | 0,_dO_=0;
        if(! (_dP_ < 0))
         {var i=_dO_;
          for(;;)
           {var match=caml_call2(Stdlib_weak[4],a[1],i);
            if(match)
             {var v$0=match[1];
              if(v === v$0)
               {caml_call3(Stdlib_weak[3],a[1],i,0);throw Stdlib[3]}}
            var _dR_=i + 1 | 0;
            if(_dP_ !== i){var i=_dR_;continue}
            break}}
        var _dQ_=0;
        return _dQ_}
      catch(_dS_)
       {_dS_ = caml_wrap_exception(_dS_);
        if(_dS_ === Stdlib[3])return 0;
        throw _dS_}}
    function fold(f,acc,a)
     {var acc$0=[0,acc],_dM_=a[2] - 1 | 0,_dL_=0;
      if(! (_dM_ < 0))
       {var i=_dL_;
        for(;;)
         {var match=caml_call2(Stdlib_weak[4],a[1],i);
          if(match){var v=match[1];acc$0[1] = caml_call2(f,acc$0[1],v)}
          var _dN_=i + 1 | 0;
          if(_dM_ !== i){var i=_dN_;continue}
          break}}
      return acc$0[1]}
    function compare_down(h,i$0,i)
     {var match=get(h,i$0),match$0=get(h,i);
      if(match)
       {var _dK_=match[1];
        if(match$0){var n=match$0[1];return caml_int_compare(_dK_[1],n[1])}
        return 1}
      return match$0?-1:0}
    function down(h,i)
     {var i$0=i;
      for(;;)
       {var
         last=h[2] - 1 | 0,
         start=2 * i$0 | 0,
         l=start + 1 | 0,
         r=start + 2 | 0;
        if(last < l)return 0;
        var
         child=last < r?l:0 <= compare_down(h,l,r)?r:l,
         _dJ_=0 < compare_down(h,i$0,child)?1:0;
        if(_dJ_){swap(h,i$0,child);var i$0=child;continue}
        return _dJ_}}
    var _a_=Stdlib[19],nil=[0,1,create(0),0,0];
    function create$0(param){var h=create(11);return [0,0,h,0,0]}
    function add$0(c,n$0)
     {if(n$0[2] === c)return 0;
      n$0[2] = c;
      var _dI_=c[2];
      add(_dI_,n$0);
      var i$0=_dI_[2] - 1 | 0,i=i$0,last_none=0;
      for(;;)
       {if(0 === i)return last_none?down(_dI_,0):last_none;
        var p=(i - 1 | 0) / 2 | 0,match=get(_dI_,i),match$0=get(_dI_,p);
        if(match)
         {var _dH_=match[1];
          if(match$0)
           {var n=match$0[1];
            if(0 <= caml_int_compare(_dH_[1],n[1]))
             return last_none?down(_dI_,i):last_none;
            swap(_dI_,i,p);
            var i=p,last_none=0;
            continue}
          swap(_dI_,i,p);
          var i=p,last_none=1;
          continue}
        return 0}}
    function add_deps(c,n)
     {var _dG_=n[6],_dE_=_dG_[2] - 1 | 0,_dD_=0;
      if(! (_dE_ < 0))
       {var i=_dD_;
        for(;;)
         {var match=caml_call2(Stdlib_weak[4],_dG_[1],i);
          if(match){var v=match[1];add$0(c,v)}
          var _dF_=i + 1 | 0;
          if(_dE_ !== i){var i=_dF_;continue}
          break}}
      return 0}
    function add_eop(c,op){c[3] = [0,op,c[3]];return 0}
    function allow_reschedule(n){n[2] = nil;return 0}
    function rebuild(c)
     {var _dC_=c[2],_dA_=(_dC_[2] - 2 | 0) / 2 | 0;
      if(! (_dA_ < 0))
       {var i=_dA_;
        for(;;)
         {down(_dC_,i);
          var _dB_=i - 1 | 0;
          if(0 !== i){var i=_dB_;continue}
          break}}
      return 0}
    function execute(c$1)
     {if(c$1[1])return caml_call1(Stdlib[1],err_step_executed);
      var c=c$1;
      a:
      for(;;)
       {var
         eops=
          function(c)
           {var _dy_=c[3];
            function _dz_(op){return caml_call1(op,0)}
            caml_call2(Stdlib_list[15],_dz_,_dy_);
            c[3] = 0;
            return 0},
         cops=
          function(c)
           {var _dw_=c[4];
            function _dx_(op){return caml_call1(op,0)}
            caml_call2(Stdlib_list[15],_dx_,_dw_);
            c[4] = 0;
            return 0},
         finish=function(c){c[1] = 1;c[2] = create(0);return 0};
        b:
        for(;;)
         {var _ds_=c[2];
          for(;;)
           {var s=_ds_[2];
            if(0 === s)
             var match=0;
            else
             {var v=get(_ds_,0);
              if(1 < s)
               {var _dr_=get(_ds_,s - 1 | 0);
                caml_call1(caml_call2(Stdlib_weak[3],_ds_[1],0),_dr_);
                rem_last(_ds_);
                down(_ds_,0)}
              else
               rem_last(_ds_);
              if(! v)continue;
              var match=v}
            if(match)
             {var n=match[1];
              if(n[1] !== _a_){caml_call1(n[5],c);continue b}
              var c$0=create$0(0);
              eops(c);
              var
               _dt_=c[2],
               _dq_=0,
               _du_=[0,n,fold(function(acc,e){return [0,e,acc]},_dq_,_dt_)],
               _dv_=
                function(c){return function(n){return caml_call1(n[5],c)}}
                 (c$0);
              caml_call2(Stdlib_list[15],_dv_,_du_);
              cops(c);
              finish(c);
              var c=c$0;
              continue a}
            eops(c);
            cops(c);
            return finish(c)}}}}
    function find_unfinished(nl)
     {var param$2=[0,nl,0],next=0,param=param$2;
      a:
      for(;;)
       {if(param)
         {var _dp_=param[1];
          if(_dp_)
           {var todo=param[2],next$0=next,param$1=_dp_;
            for(;;)
             {if(param$1)
               {var nl$0=param$1[2],n=param$1[1];
                if(n[2][1])
                 {var
                   next$1=[0,caml_call1(n[4],0),next$0],
                   next$0=next$1,
                   param$1=nl$0;
                  continue}
                return n[2]}
              var next=next$0,param=todo;
              continue a}}
          var param$0=param[2],param=param$0;
          continue}
        if(0 === next)return nil;
        var param=next,next=0;
        continue}}
    var _b_=Stdlib[20],max_rank=_a_ - 1 | 0;
    function nop(param){return 0}
    function no_producers(param){return 0}
    function create$1(r){return [0,r,nil,nop,no_producers,nop,create(0)]}
    function rem_dep(n$0,n){return rem(n$0[6],n)}
    function add_dep(n$0,n){return scan_add(n$0[6],n)}
    function deps(n)
     {var _dn_=n[6],_do_=0;
      return fold(function(acc,d){return [0,d,acc]},_do_,_dn_)}
    function bind(n,p,u){n[4] = p;n[5] = u;return 0}
    function stop(opt,n)
     {if(opt)var sth=opt[1],strong=sth;else var strong=0;
      if(strong)
       {var param$1=caml_call1(n[4],0);
        n[4] = no_producers;
        n[5] = nop;
        clear(n[6]);
        var next=0,to_rem=n,param=param$1;
        for(;;)
         {if(param)
           {var todo=param[2],n$0=param[1];
            rem_dep(n$0,to_rem);
            if(n$0[1] !== _b_ && ! (1 - is_empty(n$0[6])))
             {var prods=caml_call1(n$0[4],0);
              n$0[4] = no_producers;
              n$0[5] = nop;
              clear(n$0[6]);
              var next$0=[0,[0,n$0,prods],next],next=next$0,param=todo;
              continue}
            var param=todo;
            continue}
          if(next)
           {var
             next$1=next[2],
             match=next[1],
             param$0=match[2],
             to_rem$0=match[1],
             next=next$1,
             to_rem=to_rem$0,
             param=param$0;
            continue}
          return 0}}
      n[4] = no_producers;
      n[5] = nop;
      return clear(n[6])}
    var max=create$1(_b_);
    function rmax(n$0,n){return n[1] < n$0[1]?n$0:n}
    function rsucc(n)
     {return n[1] === _a_
              ?_b_
              :n[1] < max_rank?n[1] + 1 | 0:caml_call1(Stdlib[1],err_max_rank)}
    function rsucc2(n$0,n){var r=rsucc(n$0),r$0=rsucc(n);return r$0 < r?r:r$0}
    function update_rank(n,r)
     {if(n[1] < r)
       {n[1] = r;
        var param$1=[0,n,0],param=param$1;
        for(;;)
         {if(param)
           {var
             todo=param[2],
             n$0=param[1],
             update$0=
              function(n)
               {function update(todo,d)
                 {if(! (n[1] < d[1]) && n[1] !== _a_)
                   {d[1] = rsucc(n);return [0,d,todo]}
                  return todo}
                return update},
             update=update$0(n$0),
             param$0=fold(update,todo,n$0[6]),
             param=param$0;
            continue}
          return 1}}
      return 0}
    function eval$0(m)
     {var _dm_=m[1][1];
      if(_dm_){var v=_dm_[1];return v}
      throw [0,Assert_failure,_c_]}
    function emut(rank){return [0,[0,0],create$1(rank)]}
    function event(m,p,u){bind(m[2],p,u);return [0,m]}
    function eupdate(v,m,c)
     {m[1][1] = [0,v];
      var _dk_=m[1];
      function op(_dl_){_dk_[1] = 0;return 0}
      c[4] = [0,op,c[4]];
      return add_deps(c,m[2])}
    function sval(m)
     {var _dj_=m[1];
      if(_dj_){var v=_dj_[1];return v}
      throw [0,Assert_failure,_d_]}
    function smut(rank,eq){return [0,0,eq,create$1(rank)]}
    function signal(i,m,p,u)
     {bind(m[3],p,u);
      if(i)m[1] = i;
      var c=find_unfinished(caml_call1(m[3][4],0));
      if(c === nil)caml_call1(m[3][5],nil);else add$0(c,m[3]);
      return [1,m]}
    function supdate(v,m,c)
     {var _dh_=m[1];
      if(_dh_)
       {var v$0=_dh_[1];
        if(caml_call2(m[2],v,v$0))return 0;
        m[1] = [0,v];
        var _di_=c !== nil?1:0;
        return _di_?add_deps(c,m[3]):_di_}
      m[1] = [0,v];
      return 0}
    function add_dep$0(m,n)
     {add_dep(m[2],n);
      var _dg_=0 !== m[1][1]?1:0;
      return _dg_?add$0(m[2][2],n):_dg_}
    var never=0;
    function create$2(param)
     {var m=emut(_b_);
      return [0,
              [0,m],
              function(step,v)
               {if(step)
                 {var c=step[1];
                  if(c[1])
                   caml_call1(Stdlib[1],err_step_executed);
                  else
                   if(m[2][2][1])
                    m[2][2] = c;
                   else
                    caml_call1(Stdlib[1],err_event_scheduled);
                  return eupdate(v,m,c)}
                var c$0=create$0(0);
                m[2][2] = c$0;
                eupdate(v,m,c$0);
                return execute(c$0)}]}
    function retain(e,c)
     {if(e){var m=e[1],c$0=m[2][3];m[2][3] = c;return [0,82,c$0]}
      return caml_call1(Stdlib[1],err_retain_never)}
    function stop$0(strong,param)
     {if(param){var m=param[1];return stop(strong,m[2])}return 0}
    function equal(e$0,e)
     {if(e$0)
       {if(e){var m=e[1],m$0=e$0[1];return m$0 === m?1:0}}
      else
       if(! e)return 1;
      return 0}
    function trace(opt,t,e)
     {if(opt)var sth=opt[1],iff=sth;else var iff=_e_;
      if(0 === iff[0])
       {if(0 === iff[1])return e;
        if(e)
         {var
           m=e[1],
           m$0=emut(rsucc(m[2])),
           p=function(param){return [0,m[2],0]},
           u=
            function(c)
             {var v=eval$0(m);caml_call1(t,v);return eupdate(v,m$0,c)};
          add_dep$0(m,m$0[2]);
          return event(m$0,p,u)}
        return e}
      var mc=iff[1];
      if(e)
       {var
         m$1=e[1],
         m$2=emut(rsucc2(mc[3],m$1[2])),
         p$0=function(param){return [0,mc[3],[0,m$1[2],0]]},
         u$0=
          function(c)
           {var _df_=m$1[1][1];
            if(_df_)
             {var v=_df_[1];
              if(sval(mc))caml_call1(t,v);
              return eupdate(v,m$2,c)}
            return 0};
        add_dep(mc[3],m$2[2]);
        add_dep$0(m$1,m$2[2]);
        return event(m$2,p$0,u$0)}
      return 0}
    function once(param)
     {if(param)
       {var
         m=param[1],
         m$0=emut(rsucc(m[2])),
         p=function(param){return [0,m[2],0]},
         u=
          function(c)
           {rem_dep(m[2],m$0[2]);
            eupdate(eval$0(m),m$0,c);
            return stop(0,m$0[2])};
        add_dep$0(m,m$0[2]);
        return event(m$0,p,u)}
      return 0}
    function drop_once(param)
     {if(param)
       {var
         m=param[1],
         m$0=emut(rsucc(m[2])),
         p=function(param){return [0,m[2],0]},
         u=
          function(c)
           {function u(c){return eupdate(eval$0(m),m$0,c)}
            return bind(m$0[2],p,u)};
        add_dep$0(m,m$0[2]);
        return event(m$0,p,u)}
      return 0}
    function app(ef,param)
     {if(param)
       {var m=param[1];
        if(ef)
         {var
           mf=ef[1],
           m$0=emut(rsucc2(m[2],mf[2])),
           p=function(param){return [0,m[2],[0,mf[2],0]]},
           u=
            function(c)
             {var _dd_=mf[1][1],_de_=m[1][1];
              if(_dd_ && _de_)
               {var v=_de_[1],f=_dd_[1];return eupdate(caml_call1(f,v),m$0,c)}
              return 0};
          add_dep$0(m,m$0[2]);
          add_dep$0(mf,m$0[2]);
          return event(m$0,p,u)}
        return 0}
      return 0}
    function map(f,param)
     {if(param)
       {var
         m=param[1],
         m$0=emut(rsucc(m[2])),
         p=function(param){return [0,m[2],0]},
         u=function(c){return eupdate(caml_call1(f,eval$0(m)),m$0,c)};
        add_dep$0(m,m$0[2]);
        return event(m$0,p,u)}
      return 0}
    function stamp(e,v)
     {if(e)
       {var
         m=e[1],
         m$0=emut(rsucc(m[2])),
         p=function(param){return [0,m[2],0]},
         u=function(c){return eupdate(v,m$0,c)};
        add_dep$0(m,m$0[2]);
        return event(m$0,p,u)}
      return 0}
    function filter(pred,param)
     {if(param)
       {var
         m=param[1],
         m$0=emut(rsucc(m[2])),
         p=function(param){return [0,m[2],0]},
         u=
          function(c)
           {var v=eval$0(m);return caml_call1(pred,v)?eupdate(v,m$0,c):0};
        add_dep$0(m,m$0[2]);
        return event(m$0,p,u)}
      return 0}
    function fmap(fm,param)
     {if(param)
       {var
         m=param[1],
         m$0=emut(rsucc(m[2])),
         p=function(param){return [0,m[2],0]},
         u=
          function(c)
           {var match=caml_call1(fm,eval$0(m));
            if(match){var v=match[1];return eupdate(v,m$0,c)}
            return 0};
        add_dep$0(m,m$0[2]);
        return event(m$0,p,u)}
      return 0}
    function diff(d,param)
     {if(param)
       {var
         m=param[1],
         m$0=emut(rsucc(m[2])),
         last=[0,0],
         p=function(param){return [0,m[2],0]},
         u=
          function(c)
           {var v=eval$0(m),_dc_=last[1];
            if(_dc_)
             {var v$0=_dc_[1];
              last[1] = [0,v];
              return eupdate(caml_call2(d,v,v$0),m$0,c)}
            last[1] = [0,v];
            return 0};
        add_dep$0(m,m$0[2]);
        return event(m$0,p,u)}
      return 0}
    function changes(opt,param)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(param)
       {var
         m=param[1],
         m$0=emut(rsucc(m[2])),
         last=[0,0],
         p=function(param){return [0,m[2],0]},
         u=
          function(c)
           {var v=eval$0(m),_db_=last[1];
            if(_db_)
             {var v$0=_db_[1];
              last[1] = [0,v];
              return caml_call2(eq,v,v$0)?0:eupdate(v,m$0,c)}
            last[1] = [0,v];
            return eupdate(v,m$0,c)};
        add_dep$0(m,m$0[2]);
        return event(m$0,p,u)}
      return 0}
    function on(c,e)
     {if(e)
       {var m=e[1];
        if(0 === c[0])return 0 === c[1]?0:e;
        var
         mc=c[1],
         m$0=emut(rsucc2(m[2],mc[3])),
         p=function(param){return [0,m[2],[0,mc[3],0]]},
         u=function(c){return m[1][1]?sval(mc)?eupdate(eval$0(m),m$0,c):0:0};
        add_dep$0(m,m$0[2]);
        add_dep(mc[3],m$0[2]);
        return event(m$0,p,u)}
      return 0}
    function dismiss(c,e)
     {if(e)
       {var m=e[1];
        if(c)
         {var
           mc=c[1],
           m$0=emut(rsucc2(mc[2],m[2])),
           p=function(param){return [0,mc[2],[0,m[2],0]]},
           u=function(c){return mc[1][1]?0:eupdate(eval$0(m),m$0,c)};
          add_dep$0(mc,m$0[2]);
          add_dep$0(m,m$0[2]);
          return event(m$0,p,u)}
        return e}
      return 0}
    function until(c,e)
     {if(e)
       {var m=e[1];
        if(c)
         {var
           mc=c[1],
           m$0=emut(rsucc2(m[2],mc[2])),
           p=function(param){return [0,m[2],[0,mc[2],0]]},
           u=
            function(c)
             {return mc[1][1]
                      ?(rem_dep(m[2],m$0[2]),rem_dep(mc[2],m$0[2]),stop(0,m$0[2]))
                      :eupdate(eval$0(m),m$0,c)};
          add_dep$0(m,m$0[2]);
          add_dep$0(mc,m$0[2]);
          return event(m$0,p,u)}
        return e}
      return 0}
    function accum(ef,i)
     {if(ef)
       {var
         m=ef[1],
         m$0=emut(rsucc(m[2])),
         acc=[0,i],
         p=function(param){return [0,m[2],0]},
         u=
          function(c)
           {var _da_=acc[1];
            acc[1] = caml_call1(eval$0(m),_da_);
            return eupdate(acc[1],m$0,c)};
        add_dep$0(m,m$0[2]);
        return event(m$0,p,u)}
      return 0}
    function fold$0(f,i,param)
     {if(param)
       {var
         m=param[1],
         m$0=emut(rsucc(m[2])),
         acc=[0,i],
         p=function(param){return [0,m[2],0]},
         u=
          function(c)
           {var _c$_=eval$0(m);
            acc[1] = caml_call2(f,acc[1],_c$_);
            return eupdate(acc[1],m$0,c)};
        add_dep$0(m,m$0[2]);
        return event(m$0,p,u)}
      return 0}
    function occurs(m){return 0 !== m[1][1]?1:0}
    function find_muts_and_next_rank(param)
     {var acc=0,max$0=max,param$0=param;
      for(;;)
       {if(param$0)
         {var _c9_=param$0[1];
          if(_c9_)
           {var
             l=param$0[2],
             m=_c9_[1],
             max$1=rmax(max$0,m[2]),
             acc$0=[0,m,acc],
             acc=acc$0,
             max$0=max$1,
             param$0=l;
            continue}
          var param$1=param$0[2],param$0=param$1;
          continue}
        var _c__=rsucc(max$0);
        return [0,caml_call1(Stdlib_list[9],acc),_c__]}}
    function select(el)
     {var
       match=find_muts_and_next_rank(el),
       r=match[2],
       emuts=match[1],
       m=emut(r);
      function p(param)
       {function _c8_(m){return m[2]}
        return caml_call2(Stdlib_list[19],_c8_,emuts)}
      function u(c)
       {try
         {var
           _c6_=
            eupdate(eval$0(caml_call2(Stdlib_list[34],occurs,emuts)),m,c);
          return _c6_}
        catch(_c7_)
         {_c7_ = caml_wrap_exception(_c7_);
          if(_c7_ === Stdlib[8])throw [0,Assert_failure,_f_];
          throw _c7_}}
      function _c5_(m$0){return add_dep$0(m$0,m[2])}
      caml_call2(Stdlib_list[15],_c5_,emuts);
      return event(m,p,u)}
    function merge(f,a,el)
     {var
       match=find_muts_and_next_rank(el),
       r=match[2],
       emuts=match[1],
       m=emut(r);
      function p(param)
       {function _c4_(m){return m[2]}
        return caml_call2(Stdlib_list[19],_c4_,emuts)}
      function u(c)
       {var acc=a,param=emuts;
        for(;;)
         {if(param)
           {var l=param[2],m$0=param[1];
            if(occurs(m$0))
             {var acc$0=caml_call2(f,acc,eval$0(m$0)),acc=acc$0,param=l;
              continue}
            var param=l;
            continue}
          return eupdate(acc,m,c)}}
      function _c3_(m$0){return add_dep$0(m$0,m[2])}
      caml_call2(Stdlib_list[15],_c3_,emuts);
      return event(m,p,u)}
    function switch$0(e,param)
     {if(param)
       {var ms=param[1];
        if(e)var m=e[1],r=rsucc2(m[2],ms[2]);else var r=rsucc(ms[2]);
        var
         m$0=emut(r),
         src=[0,e],
         p=
          function(param)
           {var _c2_=src[1];
            if(_c2_){var m=_c2_[1];return [0,m[2],[0,ms[2],0]]}
            return [0,ms[2],0]},
         u=
          function(c)
           {var _cW_=ms[1][1];
            if(_cW_)
             {var e=_cW_[1],_cX_=src[1];
              if(_cX_){var m=_cX_[1];rem_dep(m[2],m$0[2])}
              src[1] = e;
              if(e)
               {var m$1=e[1];
                add_dep(m$1[2],m$0[2]);
                var _cY_=rsucc2(m$1[2],ms[2]);
                if(update_rank(m$0[2],_cY_))
                 {allow_reschedule(m$0[2]);return rebuild(c)}
                var _cZ_=m$1[1][1];
                if(_cZ_){var v=_cZ_[1];return eupdate(v,m$0,c)}
                return 0}
              var _c0_=rsucc(ms[2]);
              update_rank(m$0[2],_c0_);
              return 0}
            var _c1_=src[1];
            if(_c1_){var m$2=_c1_[1];return eupdate(eval$0(m$2),m$0,c)}
            throw [0,Assert_failure,_g_]};
        if(e){var m$1=e[1];add_dep$0(m$1,m$0[2])}
        add_dep$0(ms,m$0[2]);
        return event(m$0,p,u)}
      return e}
    function fix(f)
     {var m=emut(_a_);
      function _cQ_(param){throw [0,Assert_failure,_h_]}
      var
       e=event(m,function(param){return 0},_cQ_),
       _cR_=caml_call1(f,e),
       _cS_=_cR_[1];
      if(_cS_)
       {var r=_cR_[2],m$0=_cS_[1];
        if(m$0[2][1] === _a_)caml_call1(Stdlib[1],err_fix);
        var
         p=function(param){return 0},
         u=
          function(c)
           {var _cT_=[0,eval$0(m$0)];
            m[1][1] = _cT_;
            var _cU_=m[1];
            add_eop(c,function(_cV_){_cU_[1] = 0;return 0});
            return add_deps(c,m[2])};
        bind(m[2],p,u);
        add_dep$0(m$0,m[2]);
        return r}
      var r$0=_cR_[2];
      return r$0}
    function l2(f,e0,match)
     {if(e0)
       {if(match)
         {var
           m1=match[1],
           m0=e0[1],
           r=rsucc2(m0[2],m1[2]),
           m=emut(r),
           p=function(param){return [0,m0[2],[0,m1[2],0]]},
           u=
            function(c)
             {var _cO_=m0[1][1],_cP_=m1[1][1];
              if(_cO_ && _cP_)
               {var v1=_cP_[1],v0=_cO_[1];
                return eupdate(caml_call2(f,v0,v1),m,c)}
              return 0};
          add_dep$0(m0,m[2]);
          add_dep$0(m1,m[2]);
          return event(m,p,u)}
        return 0}
      return 0}
    function l3(f,e0,e1,match)
     {if(e0)
       {if(e1)
         {if(match)
           {var
             m2=match[1],
             m1=e1[1],
             m0=e0[1],
             _cK_=m2[2],
             r=rsucc(rmax(rmax(m0[2],m1[2]),_cK_)),
             m=emut(r),
             p=function(param){return [0,m0[2],[0,m1[2],[0,m2[2],0]]]},
             u=
              function(c)
               {var _cL_=m0[1][1],_cM_=m1[1][1],_cN_=m2[1][1];
                if(_cL_ && _cM_ && _cN_)
                 {var v2=_cN_[1],v1=_cM_[1],v0=_cL_[1];
                  return eupdate(caml_call3(f,v0,v1,v2),m,c)}
                return 0};
            add_dep$0(m0,m[2]);
            add_dep$0(m1,m[2]);
            add_dep$0(m2,m[2]);
            return event(m,p,u)}
          return 0}
        return 0}
      return 0}
    function l4(f,e0,e1,e2,match)
     {if(e0)
       {if(e1)
         {if(e2)
           {if(match)
             {var
               m3=match[1],
               m2=e2[1],
               m1=e1[1],
               m0=e0[1],
               _cF_=rmax(m2[2],m3[2]),
               r=rsucc(rmax(rmax(m0[2],m1[2]),_cF_)),
               m=emut(r),
               p=
                function(param)
                 {return [0,m0[2],[0,m1[2],[0,m2[2],[0,m3[2],0]]]]},
               u=
                function(c)
                 {var _cG_=m0[1][1],_cH_=m1[1][1],_cI_=m2[1][1],_cJ_=m3[1][1];
                  if(_cG_ && _cH_ && _cI_ && _cJ_)
                   {var v3=_cJ_[1],v2=_cI_[1],v1=_cH_[1],v0=_cG_[1];
                    return eupdate(caml_call4(f,v0,v1,v2,v3),m,c)}
                  return 0};
              add_dep$0(m0,m[2]);
              add_dep$0(m1,m[2]);
              add_dep$0(m2,m[2]);
              add_dep$0(m3,m[2]);
              return event(m,p,u)}
            return 0}
          return 0}
        return 0}
      return 0}
    function l5(f,e0,e1,e2,e3,match)
     {if(e0)
       {if(e1)
         {if(e2)
           {if(e3)
             {if(match)
               {var
                 m4=match[1],
                 m3=e3[1],
                 m2=e2[1],
                 m1=e1[1],
                 m0=e0[1],
                 _cy_=m4[2],
                 _cz_=rmax(m2[2],m3[2]),
                 r=rsucc(rmax(rmax(rmax(m0[2],m1[2]),_cz_),_cy_)),
                 m=emut(r),
                 p=
                  function(param)
                   {return [0,m0[2],[0,m1[2],[0,m2[2],[0,m3[2],[0,m4[2],0]]]]]},
                 u=
                  function(c)
                   {var
                     _cA_=m0[1][1],
                     _cB_=m1[1][1],
                     _cC_=m2[1][1],
                     _cD_=m3[1][1],
                     _cE_=m4[1][1];
                    if(_cA_ && _cB_ && _cC_ && _cD_ && _cE_)
                     {var v4=_cE_[1],v3=_cD_[1],v2=_cC_[1],v1=_cB_[1],v0=_cA_[1];
                      return eupdate(caml_call5(f,v0,v1,v2,v3,v4),m,c)}
                    return 0};
                add_dep$0(m0,m[2]);
                add_dep$0(m1,m[2]);
                add_dep$0(m2,m[2]);
                add_dep$0(m3,m[2]);
                add_dep$0(m4,m[2]);
                return event(m,p,u)}
              return 0}
            return 0}
          return 0}
        return 0}
      return 0}
    function l6(f,e0,e1,e2,e3,e4,match)
     {if(e0)
       {if(e1)
         {if(e2)
           {if(e3)
             {if(e4)
               {if(match)
                 {var
                   m5=match[1],
                   m4=e4[1],
                   m3=e3[1],
                   m2=e2[1],
                   m1=e1[1],
                   m0=e0[1],
                   _cq_=rmax(m4[2],m5[2]),
                   _cr_=rmax(m2[2],m3[2]),
                   r=rsucc(rmax(rmax(rmax(m0[2],m1[2]),_cr_),_cq_)),
                   m=emut(r),
                   p=
                    function(param)
                     {return [0,
                              m0[2],
                              [0,m1[2],[0,m2[2],[0,m3[2],[0,m4[2],[0,m5[2],0]]]]]]},
                   u=
                    function(c)
                     {var
                       _cs_=m0[1][1],
                       _ct_=m1[1][1],
                       _cu_=m2[1][1],
                       _cv_=m3[1][1],
                       _cw_=m4[1][1],
                       _cx_=m5[1][1];
                      if(_cs_ && _ct_ && _cu_ && _cv_ && _cw_ && _cx_)
                       {var
                         v5=_cx_[1],
                         v4=_cw_[1],
                         v3=_cv_[1],
                         v2=_cu_[1],
                         v1=_ct_[1],
                         v0=_cs_[1];
                        return eupdate(caml_call6(f,v0,v1,v2,v3,v4,v5),m,c)}
                      return 0};
                  add_dep$0(m0,m[2]);
                  add_dep$0(m1,m[2]);
                  add_dep$0(m2,m[2]);
                  add_dep$0(m3,m[2]);
                  add_dep$0(m4,m[2]);
                  add_dep$0(m5,m[2]);
                  return event(m,p,u)}
                return 0}
              return 0}
            return 0}
          return 0}
        return 0}
      return 0}
    function some(e){return map(function(v){return [0,v]},e)}
    function value(default$0,e)
     {if(default$0)
       {var _cn_=default$0[1];
        if(0 === _cn_[0])
         {var dv=_cn_[1];
          return map
                  (function(param)
                    {if(param){var v=param[1];return v}return dv},
                   e)}
        var ms=_cn_[1];
        if(e)
         {var
           m=e[1],
           m$0=emut(rsucc2(m[2],ms[3])),
           p=function(param){return [0,m[2],[0,ms[3],0]]},
           u=
            function(c)
             {var _co_=m[1][1];
              if(_co_)
               {var _cp_=_co_[1];
                if(_cp_){var v=_cp_[1];return eupdate(v,m$0,c)}
                return eupdate(sval(ms),m$0,c)}
              return 0};
          add_dep$0(m,m$0[2]);
          add_dep(ms[3],m$0[2]);
          return event(m$0,p,u)}
        return 0}
      return fmap(function(v){return v},e)}
    var Option=[0,some,value];
    function end_of_step_add_dep(opt,stop_if_stopped,m$0,m)
     {if(opt)
       var sth=opt[1],post_add_op=sth;
      else
       var post_add_op=function(param){return 0};
      var c=find_unfinished(caml_call1(m$0[3][4],0));
      if(c === nil){add_dep(m$0[3],m[2]);return caml_call1(post_add_op,0)}
      function add_dep$0(param)
       {if(m$0[3][5] === nop)
         return stop_if_stopped?stop(0,m[2]):stop_if_stopped;
        var _cm_=rsucc(m$0[3]);
        update_rank(m[2],_cm_);
        add_dep(m$0[3],m[2]);
        return caml_call1(post_add_op,0)}
      return add_eop(c,add_dep$0)}
    function const$0(v){return [0,v]}
    function create$3(opt,v)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      var m=smut(_b_,eq);
      m[1] = [0,v];
      return [0,
              [1,m],
              function(step,v)
               {var _cl_=sval(m);
                if(caml_call2(m[2],_cl_,v))return 0;
                if(step)
                 {var c=step[1];
                  if(c[1])
                   caml_call1(Stdlib[1],err_step_executed);
                  else
                   if(m[3][2][1])
                    m[3][2] = c;
                   else
                    caml_call1(Stdlib[1],err_signal_scheduled);
                  m[1] = [0,v];
                  return add_deps(c,m[3])}
                var c$0=create$0(0);
                m[3][2] = c$0;
                m[1] = [0,v];
                add_deps(c$0,m[3]);
                return execute(c$0)}]}
    function retain$0(s,c)
     {if(0 === s[0])return caml_call1(Stdlib[1],err_retain_cst_sig);
      var m=s[1],c$0=m[3][3];
      m[3][3] = c;
      return [0,82,c$0]}
    function eq_fun(param)
     {if(0 === param[0])return 0;var m=param[1];return [0,m[2]]}
    function value$0(param)
     {if(0 === param[0])
       var v=param[1];
      else
       {var _ck_=param[1][1];
        if(! _ck_)return caml_call1(Stdlib[2],err_sig_undef);
        var v=_ck_[1]}
      return v}
    function stop$1(strong,param)
     {if(0 === param[0])return 0;
      var m=param[1];
      if(m[1])return stop(strong,m[3]);
      var c=find_unfinished(caml_call1(m[3][4],0));
      if(c === nil)throw [0,Assert_failure,_i_];
      function stop$0(param){return stop(strong,m[3])}
      return add_eop(c,stop$0)}
    function equal$0(opt,s$0,s)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === s$0[0])
       {var _ci_=s$0[1];
        if(0 === s[0]){var v=s[1];return caml_call2(eq,_ci_,v)}}
      else
       {var _cj_=s$0[1];if(0 !== s[0]){var m=s[1];return _cj_ === m?1:0}}
      return 0}
    function trace$0(opt,t,s)
     {if(opt)var sth=opt[1],iff=sth;else var iff=[0,1];
      if(0 === iff[0])
       {if(0 === iff[1])return s;
        if(0 === s[0]){var v=s[1];caml_call1(t,v);return s}
        var
         m=s[1],
         _cf_=m[2],
         m$0=smut(rsucc(m[3]),_cf_),
         p=function(param){return [0,m[3],0]},
         u=function(c){var v=sval(m);caml_call1(t,v);return supdate(v,m$0,c)};
        add_dep(m[3],m$0[3]);
        return signal(0,m$0,p,u)}
      var mc=iff[1];
      if(0 === s[0])
       {var
         v$0=s[1],
         m$1=smut(rsucc(mc[3]),caml_equal),
         p$0=function(param){return [0,mc[3],0]},
         u$0=
          function(c)
           {if(sval(mc))caml_call1(t,v$0);
            rem_dep(mc[3],m$1[3]);
            return stop(0,m$1[3])};
        add_dep(mc[3],m$1[3]);
        return signal([0,v$0],m$1,p$0,u$0)}
      var m$2=s[1],_cg_=m$2[2],m$3=smut(rsucc2(mc[3],m$2[3]),_cg_);
      function p$1(param){return [0,mc[3],[0,m$2[3],0]]}
      function u$1(c)
       {var v=sval(m$2),_ch_=m$3[1];
        if(_ch_){var v$0=_ch_[1];if(caml_call2(m$3[2],v,v$0))return 0}
        if(sval(mc))caml_call1(t,v);
        return supdate(v,m$3,c)}
      add_dep(mc[3],m$3[3]);
      add_dep(m$2[3],m$3[3]);
      return signal(0,m$3,p$1,u$1)}
    function hold(opt,i,param)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(param)
       {var
         m=param[1],
         m$0=smut(rsucc(m[2]),eq),
         p=function(param){return [0,m[2],0]},
         u=
          function(c)
           {var _ce_=m[1][1];
            if(_ce_){var v=_ce_[1];return supdate(v,m$0,c)}
            return 0};
        add_dep$0(m,m$0[3]);
        return signal([0,i],m$0,p,u)}
      return [0,i]}
    function l1(opt,f,param)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === param[0]){var v=param[1];return [0,caml_call1(f,v)]}
      var m=param[1],m$0=smut(rsucc(m[3]),eq);
      function p(param){return [0,m[3],0]}
      function u(c){return supdate(caml_call1(f,sval(m)),m$0,c)}
      add_dep(m[3],m$0[3]);
      return signal(0,m$0,p,u)}
    function app$0(opt,sf,sv)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === sf[0])
       {var _cb_=sf[1];
        if(0 === sv[0]){var v=sv[1];return [0,caml_call1(_cb_,v)]}
        return l1([0,eq],_cb_,sv)}
      var _cc_=sf[1];
      if(0 === sv[0])
       {var
         v$0=sv[1],
         m=smut(rsucc(_cc_[3]),eq),
         p=function(param){return [0,_cc_[3],0]},
         u=function(c){return supdate(caml_call1(sval(_cc_),v$0),m,c)};
        add_dep(_cc_[3],m[3]);
        return signal(0,m,p,u)}
      var mv=sv[1],m$0=smut(rsucc2(_cc_[3],mv[3]),eq);
      function p$0(param){return [0,_cc_[3],[0,mv[3],0]]}
      function u$0(c)
       {var _cd_=sval(mv);return supdate(caml_call1(sval(_cc_),_cd_),m$0,c)}
      add_dep(_cc_[3],m$0[3]);
      add_dep(mv[3],m$0[3]);
      return signal(0,m$0,p$0,u$0)}
    function filter$0(opt,pred,i,s)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === s[0]){var v=s[1];return caml_call1(pred,v)?s:[0,i]}
      var m=s[1],m$0=smut(rsucc(m[3]),eq);
      function p(param){return [0,m[3],0]}
      function u(c)
       {var v=sval(m);return caml_call1(pred,v)?supdate(v,m$0,c):0}
      add_dep(m[3],m$0[3]);
      return signal([0,i],m$0,p,u)}
    function fmap$0(opt,fm,i,param)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === param[0])
       {var v=param[1],match=caml_call1(fm,v);
        if(match){var v$0=match[1];return [0,v$0]}
        return [0,i]}
      var m=param[1],m$0=smut(rsucc(m[3]),eq);
      function p(param){return [0,m[3],0]}
      function u(c)
       {var match=caml_call1(fm,sval(m));
        if(match){var v=match[1];return supdate(v,m$0,c)}
        return 0}
      add_dep(m[3],m$0[3]);
      return signal([0,i],m$0,p,u)}
    function diff$0(d,param)
     {if(0 === param[0])return 0;
      var m=param[1],m$0=emut(rsucc(m[3])),last=[0,0];
      function p(param){return [0,m[3],0]}
      function u(c)
       {var v=sval(m),_ca_=last[1];
        if(_ca_)
         {var v$0=_ca_[1];
          last[1] = [0,v];
          return eupdate(caml_call2(d,v,v$0),m$0,c)}
        throw [0,Assert_failure,_j_]}
      function post_add_op(param){last[1] = [0,sval(m)];return 0}
      end_of_step_add_dep([0,post_add_op],1,m,m$0);
      return event(m$0,p,u)}
    function changes$0(param)
     {if(0 === param[0])return 0;
      var m=param[1],m$0=emut(rsucc(m[3]));
      function p(param){return [0,m[3],0]}
      function u(c){return eupdate(sval(m),m$0,c)}
      end_of_step_add_dep(0,1,m,m$0);
      return event(m$0,p,u)}
    function sample(f,e,param)
     {if(0 === param[0])
       {var v=param[1];return map(function(ev){return caml_call2(f,ev,v)},e)}
      var ms=param[1];
      if(e)
       {var
         me=e[1],
         m=emut(rsucc2(me[2],ms[3])),
         p=function(param){return [0,me[2],[0,ms[3],0]]},
         u=
          function(c)
           {var _b$_=me[1][1];
            if(_b$_)
             {var v=_b$_[1];return eupdate(caml_call2(f,v,sval(ms)),m,c)}
            return 0};
        add_dep$0(me,m[2]);
        add_dep(ms[3],m[2]);
        return event(m,p,u)}
      return 0}
    function when(opt,c,i,s)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === c[0])return 0 === c[1]?[0,i]:s;
      var mc=c[1];
      if(0 === s[0])
       {var
         v=s[1],
         m=smut(rsucc(mc[3]),eq),
         p=function(param){return [0,mc[3],0]},
         u=function(c){return sval(mc)?supdate(v,m,c):0};
        add_dep(mc[3],m[3]);
        return signal([0,i],m,p,u)}
      var ms=s[1],m$0=smut(rsucc2(mc[3],ms[3]),eq);
      function p$0(param){return [0,mc[3],[0,ms[3],0]]}
      function u$0(c){return sval(mc)?supdate(sval(ms),m$0,c):0}
      add_dep(mc[3],m$0[3]);
      add_dep(ms[3],m$0[3]);
      return signal([0,i],m$0,p$0,u$0)}
    function dismiss$0(opt,c,i,s)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(c)
       {var mc=c[1];
        if(0 === s[0])
         {var
           v=s[1],
           m=smut(rsucc(mc[2]),eq),
           p=function(param){return [0,mc[2],0]},
           u=function(c){return mc[1][1]?0:supdate(v,m,c)};
          add_dep(mc[2],m[3]);
          return signal([0,i],m,p,u)}
        var
         ms=s[1],
         m$0=smut(rsucc2(mc[2],ms[3]),eq),
         p$0=function(param){return [0,mc[2],[0,ms[3],0]]},
         u$0=function(c){return mc[1][1]?0:supdate(sval(ms),m$0,c)};
        add_dep(mc[2],m$0[3]);
        add_dep(ms[3],m$0[3]);
        return signal([0,i],m$0,p$0,u$0)}
      return s}
    function accum$0(opt,ef,i)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(ef)
       {var
         m=ef[1],
         m$0=smut(rsucc(m[2]),eq),
         p=function(param){return [0,m[2],0]},
         u=
          function(c)
           {var _b__=m[1][1];
            if(_b__)
             {var v=_b__[1];return supdate(caml_call1(v,sval(m$0)),m$0,c)}
            return 0};
        add_dep$0(m,m$0[3]);
        return signal([0,i],m$0,p,u)}
      return [0,i]}
    function fold$1(opt,f,i,param)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(param)
       {var
         m=param[1],
         m$0=smut(rsucc(m[2]),eq),
         p=function(param){return [0,m[2],0]},
         u=
          function(c)
           {var _b9_=m[1][1];
            if(_b9_)
             {var v=_b9_[1];return supdate(caml_call2(f,sval(m$0),v),m$0,c)}
            return 0};
        add_dep$0(m,m$0[3]);
        return signal([0,i],m$0,p,u)}
      return [0,i]}
    function merge$0(opt,f,a,sl)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      function rmax$0(acc,param)
       {if(0 === param[0])return acc;var m=param[1];return rmax(acc,m[3])}
      function nodes(acc,param)
       {if(0 === param[0])return acc;var m=param[1];return [0,m[3],acc]}
      var m=smut(rsucc(caml_call3(Stdlib_list[21],rmax$0,max,sl)),eq);
      function p(param){return caml_call3(Stdlib_list[21],nodes,0,sl)}
      function u(c)
       {function _b8_(a,param)
         {if(0 === param[0]){var v=param[1];return caml_call2(f,a,v)}
          var m=param[1];
          return caml_call2(f,a,sval(m))}
        return supdate(caml_call3(Stdlib_list[21],_b8_,a,sl),m,c)}
      function dep(param)
       {if(0 === param[0])return 0;
        var m$0=param[1];
        return add_dep(m$0[3],m[3])}
      caml_call2(Stdlib_list[15],dep,sl);
      return signal(0,m,p,u)}
    function switch$1(opt,param)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === param[0]){var s=param[1];return s}
      var
       mss=param[1],
       dummy=smut(_b_,eq),
       src=[0,[1,dummy]],
       m=smut(rsucc(mss[3]),eq);
      function p(param)
       {var _b7_=src[1];
        if(0 === _b7_[0])return [0,mss[3],0];
        var m=_b7_[1];
        return [0,mss[3],[0,m[3],0]]}
      function u(c)
       {var _b1_=src[1];
        if(sval(mss) === _b1_)
         {var _b2_=src[1];
          if(0 === _b2_[0])return 0;
          var m$0=_b2_[1];
          return supdate(sval(m$0),m,c)}
        var _b3_=src[1];
        if(0 !== _b3_[0]){var m$2=_b3_[1];rem_dep(m$2[3],m[3])}
        var new_src=sval(mss);
        src[1] = new_src;
        if(0 === new_src[0])
         {var v=new_src[1],_b4_=rsucc(mss[3]);
          update_rank(m[3],_b4_);
          return supdate(v,m,c)}
        var m$1=new_src[1];
        add_dep(m$1[3],m[3]);
        if(c === nil)
         {var _b5_=rsucc2(m$1[3],mss[3]);
          update_rank(m[3],_b5_);
          var c$0=find_unfinished([0,m$1[3],0]);
          return c$0 === nil?supdate(sval(m$1),m,c$0):add$0(c$0,m[3])}
        var _b6_=rsucc2(m$1[3],mss[3]);
        return update_rank(m[3],_b6_)
                ?(allow_reschedule(m[3]),rebuild(c),add$0(c,m[3]))
                :supdate(sval(m$1),m,c)}
      add_dep(mss[3],m[3]);
      add_dep(dummy[3],m[3]);
      return signal(0,m,p,u)}
    function bind$0(eq,s,sf)
     {return switch$1
              (eq,l1([0,function(_b0_,_bZ_){return _b0_ === _bZ_?1:0}],sf,s))}
    function fix$0(opt,i,f)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      function update_delayed(n,p,u,nl)
       {bind(n,p,u);
        var c=find_unfinished(nl);
        if(c === nil)
         {var c$0=create$0(0);caml_call1(n[5],c$0);return execute(c$0)}
        return add$0(c,n)}
      var m=smut(_a_,eq);
      function _bU_(param){return 0}
      var
       s=signal([0,i],m,function(param){return 0},_bU_),
       _bV_=caml_call1(f,s),
       _bW_=_bV_[1];
      if(0 === _bW_[0])
       {var
         r=_bV_[2],
         v=_bW_[1],
         p=function(param){return 0},
         u=function(c){return supdate(v,m,c)},
         _bX_=deps(m[3]);
        update_delayed(m[3],p,u,_bX_);
        return r}
      var r$0=_bV_[2],m$0=_bW_[1];
      if(m$0[3][1] === _a_)caml_call1(Stdlib[1],err_fix);
      function p$0(param){return 0}
      function u$0(c){return supdate(sval(m$0),m,c)}
      add_dep(m$0[3],m[3]);
      var _bY_=deps(m[3]);
      update_delayed(m[3],p$0,u$0,[0,m$0[3],_bY_]);
      return r$0}
    function l2$0(opt,f,s$0,s)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === s$0[0])
       {var _bR_=s$0[1];
        if(0 === s[0]){var v=s[1];return [0,caml_call2(f,_bR_,v)]}
        var
         m=s[1],
         m$0=smut(rsucc(m[3]),eq),
         p=function(param){return [0,m[3],0]},
         u=function(c){return supdate(caml_call2(f,_bR_,sval(m)),m$0,c)};
        add_dep(m[3],m$0[3]);
        return signal(0,m$0,p,u)}
      var _bS_=s$0[1];
      if(0 === s[0])
       {var
         v$0=s[1],
         m$1=smut(rsucc(_bS_[3]),eq),
         p$0=function(param){return [0,_bS_[3],0]},
         u$0=function(c){return supdate(caml_call2(f,sval(_bS_),v$0),m$1,c)};
        add_dep(_bS_[3],m$1[3]);
        return signal(0,m$1,p$0,u$0)}
      var m1=s[1],m$2=smut(rsucc2(_bS_[3],m1[3]),eq);
      function p$1(param){return [0,_bS_[3],[0,m1[3],0]]}
      function u$1(c)
       {var _bT_=sval(m1);return supdate(caml_call2(f,sval(_bS_),_bT_),m$2,c)}
      add_dep(_bS_[3],m$2[3]);
      add_dep(m1[3],m$2[3]);
      return signal(0,m$2,p$1,u$1)}
    function l3$0(opt,f,s0,s1,s2)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === s0[0])
       {var _bI_=s0[1];
        if(0 === s1[0])
         {var _bJ_=s1[1];
          if(0 === s2[0]){var v2=s2[1];return [0,caml_call3(f,_bI_,_bJ_,v2)]}}}
      else
       {var _bK_=s0[1];
        if(0 !== s1[0])
         {var _bL_=s1[1];
          if(0 !== s2[0])
           {var
             m2=s2[1],
             _bM_=m2[3],
             r=rsucc(rmax(rmax(_bK_[3],_bL_[3]),_bM_)),
             m=smut(r,eq),
             p=function(param){return [0,_bK_[3],[0,_bL_[3],[0,m2[3],0]]]},
             u=
              function(c)
               {var _bP_=sval(m2),_bQ_=sval(_bL_);
                return supdate(caml_call3(f,sval(_bK_),_bQ_,_bP_),m,c)};
            add_dep(_bK_[3],m[3]);
            add_dep(_bL_[3],m[3]);
            add_dep(m2[3],m[3]);
            return signal(0,m,p,u)}}}
      return app$0
              ([0,eq],
               l2$0([0,function(_bO_,_bN_){return _bO_ === _bN_?1:0}],f,s0,s1),
               s2)}
    function l4$0(opt,f,s0,s1,s2,s3)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === s0[0])
       {var _bw_=s0[1];
        if(0 === s1[0])
         {var _bx_=s1[1];
          if(0 === s2[0])
           {var _by_=s2[1];
            if(0 === s3[0])
             {var v3=s3[1];return [0,caml_call4(f,_bw_,_bx_,_by_,v3)]}}}}
      else
       {var _bz_=s0[1];
        if(0 !== s1[0])
         {var _bA_=s1[1];
          if(0 !== s2[0])
           {var _bB_=s2[1];
            if(0 !== s3[0])
             {var
               m3=s3[1],
               _bC_=rmax(_bB_[3],m3[3]),
               r=rsucc(rmax(rmax(_bz_[3],_bA_[3]),_bC_)),
               m=smut(r,eq),
               p=
                function(param)
                 {return [0,_bz_[3],[0,_bA_[3],[0,_bB_[3],[0,m3[3],0]]]]},
               u=
                function(c)
                 {var _bF_=sval(m3),_bG_=sval(_bB_),_bH_=sval(_bA_);
                  return supdate(caml_call4(f,sval(_bz_),_bH_,_bG_,_bF_),m,c)};
              add_dep(_bz_[3],m[3]);
              add_dep(_bA_[3],m[3]);
              add_dep(_bB_[3],m[3]);
              add_dep(m3[3],m[3]);
              return signal(0,m,p,u)}}}}
      return app$0
              ([0,eq],
               l3$0
                ([0,function(_bE_,_bD_){return _bE_ === _bD_?1:0}],f,s0,s1,s2),
               s3)}
    function l5$0(opt,f,s0,s1,s2,s3,s4)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === s0[0])
       {var _bg_=s0[1];
        if(0 === s1[0])
         {var _bh_=s1[1];
          if(0 === s2[0])
           {var _bi_=s2[1];
            if(0 === s3[0])
             {var _bj_=s3[1];
              if(0 === s4[0])
               {var v4=s4[1];return [0,caml_call5(f,_bg_,_bh_,_bi_,_bj_,v4)]}}}}}
      else
       {var _bk_=s0[1];
        if(0 !== s1[0])
         {var _bl_=s1[1];
          if(0 !== s2[0])
           {var _bm_=s2[1];
            if(0 !== s3[0])
             {var _bn_=s3[1];
              if(0 !== s4[0])
               {var
                 m4=s4[1],
                 _bo_=rmax(_bn_[3],m4[3]),
                 _bp_=rmax(_bm_[3],_bo_),
                 r=rsucc(rmax(rmax(_bk_[3],_bl_[3]),_bp_)),
                 m=smut(r,eq),
                 p=
                  function(param)
                   {return [0,
                            _bk_[3],
                            [0,_bl_[3],[0,_bm_[3],[0,_bn_[3],[0,m4[3],0]]]]]},
                 u=
                  function(c)
                   {var
                     _bs_=sval(m4),
                     _bt_=sval(_bn_),
                     _bu_=sval(_bm_),
                     _bv_=sval(_bl_),
                     v=caml_call5(f,sval(_bk_),_bv_,_bu_,_bt_,_bs_);
                    return supdate(v,m,c)};
                add_dep(_bk_[3],m[3]);
                add_dep(_bl_[3],m[3]);
                add_dep(_bm_[3],m[3]);
                add_dep(_bn_[3],m[3]);
                add_dep(m4[3],m[3]);
                return signal(0,m,p,u)}}}}}
      return app$0
              ([0,eq],
               l4$0
                ([0,function(_br_,_bq_){return _br_ === _bq_?1:0}],
                 f,
                 s0,
                 s1,
                 s2,
                 s3),
               s4)}
    function l6$0(opt,f,s0,s1,s2,s3,s4,s5)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === s0[0])
       {var _aY_=s0[1];
        if(0 === s1[0])
         {var _aZ_=s1[1];
          if(0 === s2[0])
           {var _a0_=s2[1];
            if(0 === s3[0])
             {var _a1_=s3[1];
              if(0 === s4[0])
               {var _a2_=s4[1];
                if(0 === s5[0])
                 {var v5=s5[1];
                  return [0,caml_call6(f,_aY_,_aZ_,_a0_,_a1_,_a2_,v5)]}}}}}}
      else
       {var _a3_=s0[1];
        if(0 !== s1[0])
         {var _a4_=s1[1];
          if(0 !== s2[0])
           {var _a5_=s2[1];
            if(0 !== s3[0])
             {var _a6_=s3[1];
              if(0 !== s4[0])
               {var _a7_=s4[1];
                if(0 !== s5[0])
                 {var
                   m5=s5[1],
                   _a8_=rmax(_a7_[3],m5[3]),
                   _a9_=rmax(_a6_[3],_a8_),
                   _a__=rmax(_a4_[3],_a5_[3]),
                   m=rmax(rmax(_a3_[3],_a__),_a9_),
                   m$0=smut(rsucc(m),eq),
                   p=
                    function(param)
                     {return [0,
                              _a3_[3],
                              [0,_a4_[3],[0,_a5_[3],[0,_a6_[3],[0,_a7_[3],[0,m5[3],0]]]]]]},
                   u=
                    function(c)
                     {var
                       _bb_=sval(m5),
                       _bc_=sval(_a7_),
                       _bd_=sval(_a6_),
                       _be_=sval(_a5_),
                       _bf_=sval(_a4_),
                       v=caml_call6(f,sval(_a3_),_bf_,_be_,_bd_,_bc_,_bb_);
                      return supdate(v,m$0,c)};
                  add_dep(_a3_[3],m$0[3]);
                  add_dep(_a4_[3],m$0[3]);
                  add_dep(_a5_[3],m$0[3]);
                  add_dep(_a6_[3],m$0[3]);
                  add_dep(_a7_[3],m$0[3]);
                  add_dep(m5[3],m$0[3]);
                  return signal(0,m$0,p,u)}}}}}}
      return app$0
              ([0,eq],
               l5$0
                ([0,function(_ba_,_a$_){return _ba_ === _a$_?1:0}],
                 f,
                 s0,
                 s1,
                 s2,
                 s3,
                 s4),
               s5)}
    function equal$1(_aX_,_aW_){return _aX_ === _aW_?1:0}
    function not(s){return l1([0,equal$1],function(_aV_){return 1 - _aV_},s)}
    function symbol(s$0,s)
     {return l2$0
              ([0,equal$1],
               function(_aT_,_aS_){var _aU_=_aT_?_aS_:_aT_;return _aU_},
               s$0,
               s)}
    function symbol$0(s$0,s)
     {return l2$0
              ([0,equal$1],
               function(_aQ_,_aP_){var _aR_=_aQ_ || _aP_;return _aR_},
               s$0,
               s)}
    function edge(s){return changes$0(s)}
    function edge_detect(edge,param)
     {if(0 === param[0])return 0;
      var m=param[1],m$0=emut(rsucc(m[3]));
      function p(param){return [0,m[3],0]}
      function u(c)
       {var _aO_=caml_equal(sval(m),edge);return _aO_?eupdate(0,m$0,c):_aO_}
      end_of_step_add_dep(0,1,m,m$0);
      return event(m$0,p,u)}
    function rise(s){return edge_detect(1,s)}
    function fall(s){return edge_detect(0,s)}
    function flip(b,param)
     {if(param)
       {var
         m=param[1],
         _aL_=function(_aN_,_aM_){return _aN_ === _aM_?1:0},
         m$0=smut(rsucc(m[2]),_aL_),
         p=function(param){return [0,m[2],0]},
         u=function(c){return m[1][1]?supdate(1 - sval(m$0),m$0,c):0};
        add_dep$0(m,m$0[3]);
        return signal([0,b],m$0,p,u)}
      return [0,b]}
    function equal$2(_aK_,_aJ_){return _aK_ === _aJ_?1:0}
    function symbol$1(s)
     {return l1([0,equal$2],function(_aI_){return - _aI_ | 0},s)}
    function succ(s)
     {return l1([0,equal$2],function(_aH_){return _aH_ + 1 | 0},s)}
    function pred(s)
     {return l1([0,equal$2],function(_aG_){return _aG_ - 1 | 0},s)}
    function symbol$2(s$0,s)
     {return l2$0
              ([0,equal$2],function(_aF_,_aE_){return _aF_ + _aE_ | 0},s$0,s)}
    function symbol$3(s$0,s)
     {return l2$0
              ([0,equal$2],function(_aD_,_aC_){return _aD_ - _aC_ | 0},s$0,s)}
    function symbol$4(s$0,s){return l2$0([0,equal$2],runtime.caml_mul,s$0,s)}
    function mod(s$0,s){return l2$0([0,equal$2],runtime.caml_mod,s$0,s)}
    function abs(s){return l1([0,equal$2],Stdlib[18],s)}
    var max_int=[0,Stdlib[19]],min_int=[0,Stdlib[20]];
    function land(s$0,s)
     {return l2$0([0,equal$2],function(_aB_,_aA_){return _aB_ & _aA_},s$0,s)}
    function lor(s$0,s)
     {return l2$0([0,equal$2],function(_az_,_ay_){return _az_ | _ay_},s$0,s)}
    function lxor(s$0,s)
     {return l2$0([0,equal$2],function(_ax_,_aw_){return _ax_ ^ _aw_},s$0,s)}
    function lnot(s){return l1([0,equal$2],Stdlib[21],s)}
    function lsl(s$0,s)
     {return l2$0([0,equal$2],function(_av_,_au_){return _av_ << _au_},s$0,s)}
    function lsr(s$0,s)
     {return l2$0
              ([0,equal$2],
               function(_at_,_as_){return _at_ >>> _as_ | 0},
               s$0,
               s)}
    function asr(s$0,s)
     {return l2$0([0,equal$2],function(_ar_,_aq_){return _ar_ >> _aq_},s$0,s)}
    function equal$3(_ap_,_ao_){return _ap_ == _ao_?1:0}
    function symbol$5(s)
     {return l1([0,equal$3],function(_an_){return - _an_},s)}
    function symbol$6(s$0,s)
     {return l2$0([0,equal$3],function(_am_,_al_){return _am_ + _al_},s$0,s)}
    function symbol$7(s$0,s)
     {return l2$0([0,equal$3],function(_ak_,_aj_){return _ak_ - _aj_},s$0,s)}
    function symbol$8(s$0,s)
     {return l2$0([0,equal$3],function(_ai_,_ah_){return _ai_ * _ah_},s$0,s)}
    function symbol$9(s$0,s)
     {return l2$0([0,equal$3],function(_ag_,_af_){return _ag_ / _af_},s$0,s)}
    function symbol$10(s$0,s)
     {return l2$0
              ([0,equal$3],
               function(_ae_,_ad_){return Math.pow(_ae_,_ad_)},
               s$0,
               s)}
    function sqrt(s)
     {return l1([0,equal$3],function(_ac_){return Math.sqrt(_ac_)},s)}
    function exp(s)
     {return l1([0,equal$3],function(_ab_){return Math.exp(_ab_)},s)}
    function log(s)
     {return l1([0,equal$3],function(_aa_){return Math.log(_aa_)},s)}
    function log10(s){return l1([0,equal$3],runtime.caml_log10_float,s)}
    function cos(s)
     {return l1([0,equal$3],function(_$_){return Math.cos(_$_)},s)}
    function sin(s)
     {return l1([0,equal$3],function(___){return Math.sin(___)},s)}
    function tan(s)
     {return l1([0,equal$3],function(_Z_){return Math.tan(_Z_)},s)}
    function acos(s)
     {return l1([0,equal$3],function(_Y_){return Math.acos(_Y_)},s)}
    function asin(s)
     {return l1([0,equal$3],function(_X_){return Math.asin(_X_)},s)}
    function atan(s)
     {return l1([0,equal$3],function(_W_){return Math.atan(_W_)},s)}
    function atan2(s$0,s)
     {return l2$0
              ([0,equal$3],
               function(_V_,_U_){return Math.atan2(_V_,_U_)},
               s$0,
               s)}
    function cosh(s){return l1([0,equal$3],runtime.caml_cosh_float,s)}
    function sinh(s){return l1([0,equal$3],runtime.caml_sinh_float,s)}
    function tanh(s){return l1([0,equal$3],runtime.caml_tanh_float,s)}
    function ceil(s)
     {return l1([0,equal$3],function(_T_){return Math.ceil(_T_)},s)}
    function floor(s)
     {return l1([0,equal$3],function(_S_){return Math.floor(_S_)},s)}
    function abs_float(s)
     {return l1([0,equal$3],function(_R_){return Math.abs(_R_)},s)}
    function mod_float(s$0,s)
     {return l2$0([0,equal$3],function(_Q_,_P_){return _Q_ % _P_},s$0,s)}
    function frexp(s){return l1([0,caml_equal],runtime.caml_frexp_float,s)}
    function ldexp(s$0,s)
     {return l2$0([0,equal$3],runtime.caml_ldexp_float,s$0,s)}
    function modf(s){return l1([0,caml_equal],runtime.caml_modf_float,s)}
    function float$0(s){return l1([0,equal$3],function(_O_){return _O_},s)}
    function float_of_int(s)
     {return l1([0,equal$3],function(_N_){return _N_},s)}
    function truncate(s)
     {return l1([0,equal$2],function(_M_){return _M_ | 0},s)}
    function int_of_float(s)
     {return l1([0,equal$2],function(_L_){return _L_ | 0},s)}
    var
     infinity=[0,Stdlib[22]],
     neg_infinity=[0,Stdlib[23]],
     nan=[0,Stdlib[24]],
     max_float=[0,Stdlib[25]],
     min_float=[0,Stdlib[26]],
     epsilon_float=[0,Stdlib[27]];
    function classify_float(s)
     {var _I_=runtime.caml_classify_float;
      return l1([0,function(_K_,_J_){return _K_ === _J_?1:0}],_I_,s)}
    function pair(eq,s$0,s)
     {return l2$0(eq,function(x,y){return [0,x,y]},s$0,s)}
    function fst(eq,s){return l1(eq,function(_H_){return _H_[1]},s)}
    function snd(eq,s){return l1(eq,function(_G_){return _G_[2]},s)}
    var Pair=[0,pair,fst,snd];
    function some$0(s)
     {var match=eq_fun(s);
      if(match)
       var
        eq=match[1],
        eq$0=
         function(v,match)
          {if(v && match)
            {var v$0=match[1],v$1=v[1];return caml_call2(eq,v$1,v$0)}
           throw [0,Assert_failure,_k_]},
        eq$1=[0,eq$0];
      else
       var eq$1=0;
      return l1(eq$1,function(v){return [0,v]},s)}
    function value$1(opt,default$0,s)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(0 === s[0])
       {var _D_=s[1];
        if(_D_){var v=_D_[1];return [0,v]}
        if(815032112 <= default$0[1])
         {var d=default$0[2];
          if(0 === d[0]){var d$0=d[1];return [0,d$0]}
          var md=d[1],c=find_unfinished([0,md[3],0]);
          if(c === nil)return [0,sval(md)];
          var
           m=smut(rsucc(md[3]),eq),
           p=function(param){return [0,md[3],0]},
           u=
            function(c)
             {rem_dep(md[3],m[3]);supdate(sval(md),m,c);return stop(0,m[3])};
          add_dep(md[3],m[3]);
          return signal(0,m,p,u)}
        var d$1=default$0[2];
        return d$1}
      var m$0=s[1];
      if(815032112 <= default$0[1])
       {var _E_=default$0[2];
        if(0 === _E_[0])
         {var d$2=_E_[1];return fmap$0([0,eq],function(v){return v},d$2,s)}
        var md$0=_E_[1],c$0=find_unfinished([0,md$0[3],0]);
        if(c$0 === nil)
         {var
           m$1=smut(rsucc(m$0[3]),eq),
           p$0=function(param){return [0,m$0[3],0]},
           u$0=
            function(c)
             {var match=sval(m$0);
              if(match){var v=match[1];return supdate(v,m$1,c)}
              return 0};
          add_dep(m$0[3],m$1[3]);
          return signal([0,sval(md$0)],m$1,p$0,u$0)}
        var
         m$2=smut(rsucc2(m$0[3],md$0[3]),eq),
         p$1=function(param){return [0,m$0[3],0]},
         u$1=
          function(c)
           {var match=sval(m$0);
            if(match){var v=match[1];return supdate(v,m$2,c)}
            return 0},
         p_first=function(param){return [0,m$0[3],[0,md$0[3],0]]},
         u_first=
          function(c)
           {rem_dep(md$0[3],m$2[3]);
            var match=sval(m$0);
            if(match)
             {var v=match[1];supdate(v,m$2,c)}
            else
             supdate(sval(md$0),m$2,c);
            return bind(m$2[3],p$1,u$1)};
        add_dep(m$0[3],m$2[3]);
        add_dep(md$0[3],m$2[3]);
        return signal(0,m$2,p_first,u_first)}
      var _F_=default$0[2];
      if(0 === _F_[0])
       {var d$3=_F_[1];
        return l1
                ([0,eq],
                 function(param){if(param){var v=param[1];return v}return d$3},
                 s)}
      var md$1=_F_[1],m$3=smut(rsucc2(m$0[3],md$1[3]),eq);
      function p$2(param){return [0,m$0[3],[0,md$1[3],0]]}
      function u$2(c)
       {var match=sval(m$0);
        if(match){var v=match[1];return supdate(v,m$3,c)}
        return supdate(sval(md$1),m$3,c)}
      add_dep(m$0[3],m$3[3]);
      add_dep(md$1[3],m$3[3]);
      return signal(0,m$3,p$2,u$2)}
    var Option$0=[0,none,some$0,value$1];
    function symbol$11(s$0,s){return l2$0([0,equal$1],caml_equal,s$0,s)}
    function symbol$12(s$0,s)
     {return l2$0([0,equal$1],runtime.caml_notequal,s$0,s)}
    function symbol$13(s$0,s)
     {return l2$0([0,equal$1],runtime.caml_lessthan,s$0,s)}
    function symbol$14(s$0,s)
     {return l2$0([0,equal$1],runtime.caml_greaterthan,s$0,s)}
    function symbol$15(s$0,s)
     {return l2$0([0,equal$1],runtime.caml_lessequal,s$0,s)}
    function symbol$16(s$0,s)
     {return l2$0([0,equal$1],runtime.caml_greaterequal,s$0,s)}
    function compare(s$0,s)
     {return l2$0([0,equal$2],runtime.caml_compare,s$0,s)}
    function symbol$17(s$0,s)
     {return l2$0([0,equal$1],function(_C_,_B_){return _C_ === _B_?1:0},s$0,s)}
    function symbol$18(s$0,s)
     {return l2$0([0,equal$1],function(_A_,_z_){return _A_ !== _z_?1:0},s$0,s)}
    function Make(Eq)
     {var eq=Eq[1];
      function create(v){return create$3([0,eq],v)}
      function equal(s$0,s){return equal$0([0,eq],s$0,s)}
      function hold$0(v,e){return hold([0,eq],v,e)}
      function app(sf,sv){return app$0([0,eq],sf,sv)}
      function map(f,s){return l1([0,eq],f,s)}
      function filter(pred,i)
       {var _x_=[0,eq];return function(_y_){return filter$0(_x_,pred,i,_y_)}}
      function fmap(fm,i)
       {var _v_=[0,eq];return function(_w_){return fmap$0(_v_,fm,i,_w_)}}
      function when$0(c,i,s){return when([0,eq],c,i,s)}
      function dismiss(c,s)
       {var _t_=[0,eq];return function(_u_){return dismiss$0(_t_,c,s,_u_)}}
      function accum(ef,i){return accum$0([0,eq],ef,i)}
      function fold(f,i)
       {var _r_=[0,eq];return function(_s_){return fold$1(_r_,f,i,_s_)}}
      function merge(f,a,sl){return merge$0([0,eq],f,a,sl)}
      function switch$0(s){return switch$1([0,eq],s)}
      function bind(s,sf){return bind$0([0,eq],s,sf)}
      function fix(f)
       {var _p_=[0,eq];return function(_q_){return fix$0(_p_,f,_q_)}}
      function l2(f,s$0,s){return l2$0([0,eq],f,s$0,s)}
      function l3(f,s0,s1,s2){return l3$0([0,eq],f,s0,s1,s2)}
      function l4(f,s0,s1,s2,s3){return l4$0([0,eq],f,s0,s1,s2,s3)}
      function l5(f,s0,s1,s2,s3,s4){return l5$0([0,eq],f,s0,s1,s2,s3,s4)}
      function l6(f,s0,s1,s2,s3,s4,s5)
       {return l6$0([0,eq],f,s0,s1,s2,s3,s4,s5)}
      return [0,
              eq,
              create,
              equal,
              hold$0,
              app,
              map,
              filter,
              fmap,
              when$0,
              dismiss,
              accum,
              fold,
              merge,
              switch$0,
              bind,
              fix,
              map,
              l2,
              l3,
              l4,
              l5,
              l6]}
    var
     Sb=Make([0,equal$1]),
     Si=Make([0,equal$2]),
     Sf=Make([0,equal$3]),
     _l_=[0,create$0,execute],
     _m_=
      [0,
       [0,
        Sb[2],
        Sb[3],
        Sb[4],
        Sb[5],
        Sb[6],
        Sb[7],
        Sb[8],
        Sb[9],
        Sb[10],
        Sb[11],
        Sb[12],
        Sb[13],
        Sb[14],
        Sb[15],
        Sb[16],
        Sb[17],
        Sb[18],
        Sb[19],
        Sb[20],
        Sb[21],
        Sb[22]],
       [0,
        Si[2],
        Si[3],
        Si[4],
        Si[5],
        Si[6],
        Si[7],
        Si[8],
        Si[9],
        Si[10],
        Si[11],
        Si[12],
        Si[13],
        Si[14],
        Si[15],
        Si[16],
        Si[17],
        Si[18],
        Si[19],
        Si[20],
        Si[21],
        Si[22]],
       [0,
        Sf[2],
        Sf[3],
        Sf[4],
        Sf[5],
        Sf[6],
        Sf[7],
        Sf[8],
        Sf[9],
        Sf[10],
        Sf[11],
        Sf[12],
        Sf[13],
        Sf[14],
        Sf[15],
        Sf[16],
        Sf[17],
        Sf[18],
        Sf[19],
        Sf[20],
        Sf[21],
        Sf[22]]],
     React=
      [0,
       [0,
        never,
        create$2,
        retain,
        stop$0,
        equal,
        trace,
        once,
        drop_once,
        app,
        map,
        stamp,
        filter,
        fmap,
        diff,
        changes,
        on,
        on,
        dismiss,
        until,
        accum,
        fold$0,
        select,
        merge,
        switch$0,
        fix,
        map,
        l2,
        l3,
        l4,
        l5,
        l6,
        Option],
       [0,
        const$0,
        create$3,
        value$0,
        retain$0,
        eq_fun,
        stop$1,
        equal$0,
        trace$0,
        hold,
        app$0,
        l1,
        filter$0,
        fmap$0,
        diff$0,
        changes$0,
        sample,
        when,
        when,
        dismiss$0,
        accum$0,
        fold$1,
        merge$0,
        switch$1,
        bind$0,
        fix$0,
        l1,
        l2$0,
        l3$0,
        l4$0,
        l5$0,
        l6$0,
        [0,zero,one,not,symbol,symbol$0,edge,rise,fall,flip],
        [0,
         zero$0,
         one$0,
         minus_one,
         symbol$1,
         succ,
         pred,
         symbol$2,
         symbol$3,
         symbol$4,
         mod,
         abs,
         max_int,
         min_int,
         land,
         lor,
         lxor,
         lnot,
         lsl,
         lsr,
         asr],
        [0,
         zero$1,
         one$1,
         minus_one$0,
         symbol$5,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         sqrt,
         exp,
         log,
         log10,
         cos,
         sin,
         tan,
         acos,
         asin,
         atan,
         atan2,
         cosh,
         sinh,
         tanh,
         ceil,
         floor,
         abs_float,
         mod_float,
         frexp,
         ldexp,
         modf,
         float$0,
         float_of_int,
         truncate,
         int_of_float,
         infinity,
         neg_infinity,
         nan,
         max_float,
         min_float,
         epsilon_float,
         classify_float],
        Pair,
        Option$0,
        [0,
         symbol$11,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         symbol$16,
         compare,
         symbol$17,
         symbol$18],
        function(_n_)
         {var _o_=Make(_n_);
          return [0,
                  _o_[2],
                  _o_[3],
                  _o_[4],
                  _o_[5],
                  _o_[6],
                  _o_[7],
                  _o_[8],
                  _o_[9],
                  _o_[10],
                  _o_[11],
                  _o_[12],
                  _o_[13],
                  _o_[14],
                  _o_[15],
                  _o_[16],
                  _o_[17],
                  _o_[18],
                  _o_[19],
                  _o_[20],
                  _o_[21],
                  _o_[22]]},
        _m_],
       _l_];
    runtime.caml_register_global(30,React,"React");
    return}
  (function(){return this}()));


//# 1 "../../.js/reactiveData/reactiveData.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_equal=runtime.caml_equal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_invalid_index=caml_string_of_jsbytes("invalid index"),
     cst_merge_invalid_index=caml_string_of_jsbytes("merge: invalid index"),
     cst_merge_invalid_index$0=caml_string_of_jsbytes("merge: invalid index"),
     cst_linear_merge_X_not_support=
      caml_string_of_jsbytes("linear_merge: X not supported"),
     cst_ReactiveData_Rlist_merge$0=
      caml_string_of_jsbytes("ReactiveData.Rlist.merge"),
     cst_ReactiveData_Rlist_merge=
      caml_string_of_jsbytes("ReactiveData.Rlist.merge"),
     cst_ReactiveData_Rlist_merge$1=
      caml_string_of_jsbytes("ReactiveData.Rlist.merge"),
     cst_ReactiveData_Rlist_merge$2=
      caml_string_of_jsbytes("ReactiveData.Rlist.merge"),
     Stdlib_list=global_data.Stdlib__list,
     React=global_data.React,
     Stdlib=global_data.Stdlib,
     Assert_failure=global_data.Assert_failure,
     Stdlib_map=global_data.Stdlib__map,
     Stdlib_hashtbl=global_data.Stdlib__hashtbl,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_set=global_data.Stdlib__set,
     _T_=[0,68],
     _I_=[0,caml_string_of_jsbytes("src/reactiveData.ml"),558,6],
     _E_=[0,caml_string_of_jsbytes("src/reactiveData.ml"),459,23],
     _D_=[0,caml_string_of_jsbytes("src/reactiveData.ml"),427,17],
     _C_=[0,0,0],
     _e_=[0,caml_string_of_jsbytes("src/reactiveData.ml"),215,4],
     _f_=[0,caml_string_of_jsbytes("src/reactiveData.ml"),251,4];
    function _a_(_gI_)
     {var _gJ_=_gI_[1],_gL_=_gI_[3],_gK_=_gI_[2],_gM_=[0,_gI_[4]];
      function _gN_(_hF_)
       {var _hG_=caml_call1(React[1][2],0),_hH_=[0,_hF_],_hI_=_hG_[1];
        function _hJ_(_hL_)
         {_hH_[1] = 0 === _hL_[0]?caml_call2(_gJ_,_hL_[1],_hH_[1]):_hL_[1];
          return _hL_}
        var _hK_=caml_call2(React[1][10],_hJ_,_hI_);
        return [0,[1,[0,_hH_,_hK_]],_hG_[2]]}
      function _gO_(_hB_,_hA_)
       {var _hC_=[0,_hB_];
        function _hD_(_hE_)
         {_hC_[1] = 0 === _hE_[0]?caml_call2(_gJ_,_hE_[1],_hC_[1]):_hE_[1];
          return _hE_}
        return [1,[0,_hC_,caml_call2(React[1][10],_hD_,_hA_)]]}
      function _gP_(_hz_){return [0,_hz_]}
      function _gQ_(_hy_,_hx_)
       {return 0 === _hx_[0]
                ?[0,caml_call2(_gK_,_hy_,_hx_[1])]
                :[1,caml_call2(_gL_,_hy_,_hx_[1])]}
      function _gR_(_hq_,_hp_)
       {if(0 === _hp_[0])return [0,caml_call2(_gL_,_hq_,_hp_[1])];
        var
         _hr_=_hp_[1],
         _hs_=[0,caml_call2(_gL_,_hq_,_hr_[1][1])],
         _ht_=_hr_[2];
        function _hu_(_hv_)
         {var _hw_=_gQ_(_hq_,_hv_);
          _hs_[1] = 0 === _hw_[0]?caml_call2(_gJ_,_hw_[1],_hs_[1]):_hw_[1];
          return _hw_}
        return [1,[0,_hs_,caml_call2(React[1][10],_hu_,_ht_)]]}
      function _gS_(_ho_){return 0 === _ho_[0]?_ho_[1]:_ho_[1][1][1]}
      function _gT_(_hn_){return 0 === _hn_[0]?React[1][1]:_hn_[1][2]}
      function _gU_(_hm_,_hl_){return caml_call2(_hm_,0,[0,_hl_])}
      function _gV_(_hk_,_hj_){return caml_call2(_hk_,0,[1,_hj_])}
      function _gW_(_hf_,_he_,_hd_)
       {if(0 === _he_[0])
         {var _hg_=caml_call2(_hf_,_hd_,[1,_he_[1]]);
          return caml_call1(React[2][1],_hg_)}
        var _hh_=_he_[1],_hi_=caml_call2(_hf_,_hd_,[1,_hh_[1][1]]);
        return caml_call4(React[2][21],0,_hf_,_hi_,_hh_[2])}
      function _gX_(_g6_,_g5_)
       {var _g7_=_g6_?_g6_[1]:caml_equal;
        if(0 === _g5_[0])return caml_call1(React[2][1],_g5_[1]);
        var _g8_=_g5_[1],_g9_=_g8_[2],_g__=_g8_[1][1];
        function _g$_(_hc_,_hb_)
         {return 0 === _hb_[0]?caml_call2(_gJ_,_hb_[1],_hc_):_hb_[1]}
        var _ha_=[0,caml_call1(_gI_[5],_g7_)];
        return caml_call4(React[2][21],_ha_,_g$_,_g__,_g9_)}
      return [0,
              _gM_,
              _gN_,
              _gO_,
              function(_gZ_,_gY_)
               {var _g0_=_gZ_?_gZ_[1]:caml_equal;
                function _g1_(_g4_,_g3_)
                 {return [0,caml_call3(_gI_[6],_g0_,_g3_,_g4_)]}
                var _g2_=caml_call2(React[2][14],_g1_,_gY_);
                return _gO_(caml_call1(React[2][3],_gY_),_g2_)},
              _gP_,
              _gU_,
              _gV_,
              _gQ_,
              _gR_,
              _gS_,
              _gW_,
              _gX_,
              _gT_]}
    var _b_=0,_c_=Stdlib_list[17];
    function _d_(_gD_)
     {function _gE_(_gH_)
       {switch(_gH_[0])
         {case 0:var _gF_=caml_call1(_gD_,_gH_[2]);return [0,_gH_[1],_gF_];
          case 1:return [1,_gH_[1]];
          case 2:var _gG_=caml_call1(_gD_,_gH_[2]);return [2,_gH_[1],_gG_];
          default:return [3,_gH_[1],_gH_[2]]}}
      return caml_call1(Stdlib_list[17],_gE_)}
    function _g_(_f3_,_f2_)
     {var _fZ_=0,_fY_=_f3_;
      for(;;)
       {if(0 <= _fZ_)
         {if(_fY_)
           {var _f0_=_fY_[1];
            if(3 !== _f0_[0])
             {var _f1_=_f0_[1];
              if(_fZ_ <= _f1_){var _fZ_=_f1_,_fY_=_fY_[2];continue}}
            var _f4_=0}
          else
           var _f4_=1;
          if(_f4_)
           {var _fR_=0,_fQ_=0,_fP_=_f3_,_fO_=_f2_;
            for(;;)
             {var switch$0=0;
              if(_fP_)
               {var _fS_=_fP_[1];
                if(3 !== _fS_[0])
                 {var _fT_=_fS_[1];
                  if(_fQ_ < _fT_)
                   {var _fN_=_fR_,_fM_=_fT_ - _fQ_ | 0,_fL_=_fO_;
                    for(;;)
                     {if(! (0 <= _fM_))throw [0,Assert_failure,_e_];
                      if(0 < _fM_)
                       {if(_fL_)
                         {var _fN_=[0,_fL_[1],_fN_],_fM_=_fM_ - 1 | 0,_fL_=_fL_[2];
                          continue}
                        var _fU_=caml_call1(Stdlib[1],cst_invalid_index)}
                      else
                       var _fU_=[0,_fL_,_fN_];
                      var _fW_=_fU_[1],_fV_=_fU_[2];
                      switch$0 = 1;
                      break}}}}
              if(! switch$0)var _fW_=_fO_,_fV_=_fR_;
              if(_fP_)
               {var _fX_=_fP_[1];
                switch(_fX_[0])
                 {case 0:
                   var
                    _fR_=_fV_,
                    _fQ_=_fX_[1],
                    _fP_=_fP_[2],
                    _fO_=[0,_fX_[2],_fW_];
                   continue;
                  case 1:
                   if(_fW_)
                    {var _fR_=_fV_,_fQ_=_fX_[1],_fP_=_fP_[2],_fO_=_fW_[2];
                     continue}
                   return caml_call1(Stdlib[1],cst_merge_invalid_index);
                  case 2:
                   if(_fW_)
                    {var
                      _fR_=_fV_,
                      _fQ_=_fX_[1],
                      _fP_=_fP_[2],
                      _fO_=[0,_fX_[2],_fW_[2]];
                     continue}
                   return caml_call1(Stdlib[1],cst_merge_invalid_index$0);
                  default:
                   return caml_call1(Stdlib[2],cst_linear_merge_X_not_support)}}
              return caml_call2(Stdlib_list[12],_fV_,_fW_)}}
          var
           _f5_=
            function(_gC_,_gB_)
             {switch(_gB_[0])
               {case 0:
                 var
                  _f7_=_gB_[1],
                  _f6_=_gB_[2],
                  _f8_=
                   0 <= _f7_
                    ?_f7_
                    :(caml_call1(Stdlib_list[1],_gC_) + 1 | 0) + _f7_ | 0,
                  _f$_=0,
                  _f__=_f8_,
                  _f9_=_gC_;
                 for(;;)
                  {if(0 === _f__)
                    return caml_call2(Stdlib_list[12],_f$_,[0,_f6_,_f9_]);
                   if(_f9_)
                    {var _f$_=[0,_f9_[1],_f$_],_f__=_f__ - 1 | 0,_f9_=_f9_[2];
                     continue}
                   return caml_call1(Stdlib[2],cst_ReactiveData_Rlist_merge)}
                case 1:
                 var
                  _ga_=_gB_[1],
                  _gb_=
                   0 <= _ga_?_ga_:caml_call1(Stdlib_list[1],_gC_) + _ga_ | 0,
                  _ge_=0,
                  _gd_=_gb_,
                  _gc_=_gC_;
                 for(;;)
                  {if(0 === _gd_ && _gc_)
                    return caml_call2(Stdlib_list[12],_ge_,_gc_[2]);
                   if(_gc_)
                    {var _ge_=[0,_gc_[1],_ge_],_gd_=_gd_ - 1 | 0,_gc_=_gc_[2];
                     continue}
                   return caml_call1(Stdlib[2],cst_ReactiveData_Rlist_merge$0)}
                case 2:
                 var
                  _gf_=_gB_[1],
                  _gg_=
                   0 <= _gf_?_gf_:caml_call1(Stdlib_list[1],_gC_) + _gf_ | 0,
                  _gh_=caml_call1(Stdlib_array[12],_gC_),
                  _gi_=_gB_[2];
                 caml_check_bound(_gh_,_gg_)[1 + _gg_] = _gi_;
                 return caml_call1(Stdlib_array[11],_gh_);
                default:
                 var
                  _gj_=_gB_[2],
                  _gk_=_gB_[1],
                  _gl_=caml_call1(Stdlib_array[12],_gC_),
                  _gm_=_gl_.length - 1,
                  _gn_=0 <= _gk_?_gk_:_gm_ + _gk_ | 0,
                  _go_=caml_check_bound(_gl_,_gn_)[1 + _gn_];
                 if(0 < _gj_)
                  {if(_gm_ <= (_gn_ + _gj_ | 0))
                    caml_call1(Stdlib[2],cst_ReactiveData_Rlist_merge$1);
                   var _gp_=(_gn_ + _gj_ | 0) - 1 | 0;
                   if(! (_gp_ < _gn_))
                    {var _gr_=_gn_;
                     for(;;)
                      {var
                        _gs_=_gr_ + 1 | 0,
                        _gt_=caml_check_bound(_gl_,_gs_)[1 + _gs_];
                       caml_check_bound(_gl_,_gr_)[1 + _gr_] = _gt_;
                       var _gu_=_gr_ + 1 | 0;
                       if(_gp_ !== _gr_){var _gr_=_gu_;continue}
                       break}}
                   var _gq_=_gn_ + _gj_ | 0;
                   caml_check_bound(_gl_,_gq_)[1 + _gq_] = _go_}
                 else
                  {if((_gn_ + _gj_ | 0) < 0)
                    caml_call1(Stdlib[2],cst_ReactiveData_Rlist_merge$2);
                   var _gv_=(_gn_ + _gj_ | 0) + 1 | 0;
                   if(! (_gn_ < _gv_))
                    {var _gx_=_gn_;
                     for(;;)
                      {var
                        _gy_=_gx_ - 1 | 0,
                        _gz_=caml_check_bound(_gl_,_gy_)[1 + _gy_];
                       caml_check_bound(_gl_,_gx_)[1 + _gx_] = _gz_;
                       var _gA_=_gx_ - 1 | 0;
                       if(_gv_ !== _gx_){var _gx_=_gA_;continue}
                       break}}
                   var _gw_=_gn_ + _gj_ | 0;
                   caml_check_bound(_gl_,_gw_)[1 + _gw_] = _go_}
                 return caml_call1(Stdlib_array[11],_gl_)}};
          return caml_call3(Stdlib_list[21],_f5_,_f2_,_f3_)}
        throw [0,Assert_failure,_f_]}}
    function _h_(_fI_,_fH_,_fG_)
     {var _fK_=_fH_,_fJ_=_fG_;
      for(;;)
       {if(_fK_)
         {if(_fJ_ && caml_call2(_fI_,_fK_[1],_fJ_[1]))
           {var _fK_=_fK_[2],_fJ_=_fJ_[2];continue}}
        else
         if(! _fJ_)return 1;
        return 0}}
    function _i_(_fx_)
     {var
       _fy_=Stdlib_hashtbl[27],
       _fz_=[0,function(_fF_,_fE_){return _fF_ === _fE_?1:0},_fy_],
       _fA_=caml_call1(Stdlib_hashtbl[25],_fz_),
       _fB_=caml_call1(_fA_[1],16);
      function _fC_(_fD_){return caml_call3(_fA_[5],_fB_,_fD_,0)}
      caml_call2(Stdlib_list[15],_fC_,_fx_);
      return caml_call1(_fA_[11],_fB_)}
    var
     _j_=
      _a_
       ([0,
         _g_,
         _d_,
         _c_,
         _b_,
         _h_,
         function(_fo_,_fn_,_fm_)
          {function _fp_(_fw_,_fv_,_fu_){return [0,[0,_fv_,_fu_],_fw_]}
           function _fq_(_ft_,_fs_){return [0,[1,_fs_],_ft_]}
           var
            _fr_=0,
            _e8_=[0,_fo_]?_fo_:caml_equal,
            _e9_=_i_(_fn_),
            _fd_=_fr_,
            _fc_=1,
            _fb_=_fn_,
            _fa_=_fm_,
            _e$_=0,
            _e__=_i_(_fm_);
           for(;;)
            {if(_fb_)
              {var _fe_=_fb_[2],_ff_=_fb_[1];
               if(_fa_)
                {var _fg_=_fa_[2],_fh_=_fa_[1];
                 if(caml_call2(_e8_,_ff_,_fh_))
                  {var _fb_=_fe_,_fa_=_fg_,_e$_=_e$_ + 1 | 0;continue}
                 if(caml_call1(_e__,_ff_))
                  {if(caml_call1(_e9_,_fh_))
                    {if(_fc_)
                      {var _fd_=_fq_(_fd_,_e$_),_fc_=0,_fb_=_fe_;continue}
                     var
                      _fd_=_fp_(_fd_,_e$_,_fh_),
                      _fc_=1,
                      _fa_=_fg_,
                      _e$_=_e$_ + 1 | 0;
                     continue}
                   var _fd_=_fp_(_fd_,_e$_,_fh_),_fa_=_fg_,_e$_=_e$_ + 1 | 0;
                   continue}
                 var _fd_=_fq_(_fd_,_e$_),_fb_=_fe_;
                 continue}
               var _fd_=_fq_(_fd_,_e$_),_fb_=_fe_,_fa_=0;
               continue}
             if(_fa_)
              {var
                _fi_=_fp_(_fd_,_e$_,_fa_[1]),
                _fd_=_fi_,
                _fb_=0,
                _fa_=_fa_[2],
                _e$_=_e$_ + 1 | 0;
               continue}
             var _fk_=0,_fj_=_fd_;
             for(;;)
              {var _fl_=_fk_?_fk_[1]:_fk_;
               if(_fj_){var _fk_=[0,[0,_fj_[1],_fl_]],_fj_=_fj_[2];continue}
               return _fl_}}}]),
     _k_=_j_[3],
     _l_=_j_[5],
     _m_=_j_[6],
     _n_=_j_[10],
     _o_=_j_[13];
    function _p_(_e7_,_e6_){return caml_call2(_m_,_e6_,[0,[0,0,_e7_],0])}
    function _q_(_e5_,_e4_){return caml_call2(_m_,_e4_,[0,[0,-1,_e5_],0])}
    function _r_(_e3_,_e2_,_e1_)
     {return caml_call2(_m_,_e1_,[0,[0,_e2_,_e3_],0])}
    function _s_(_e0_,_eZ_,_eY_)
     {return caml_call2(_m_,_eY_,[0,[2,_eZ_,_e0_],0])}
    function _t_(_eX_,_eW_,_eV_)
     {return caml_call2(_m_,_eV_,[0,[3,_eX_,_eW_],0])}
    function _u_(_eU_,_eT_){return caml_call2(_m_,_eT_,[0,[1,_eU_],0])}
    function _v_(_eP_,_eO_,_eN_)
     {var _eQ_=_eP_?_eP_[1]:caml_equal,_eS_=0,_eR_=_eO_;
      for(;;)
       {if(_eR_)
         {if(caml_call2(_eQ_,_eR_[1],_eN_))return _eS_;
          var _eS_=_eS_ + 1 | 0,_eR_=_eR_[2];
          continue}
        throw Stdlib[8]}}
    function _w_(_eL_,_eK_,_eJ_,_eI_)
     {var _eM_=_v_(_eL_,caml_call1(_n_,_eK_[1]),_eJ_);
      return _s_(_eI_,_eM_,_eK_[2])}
    function _x_(_eF_)
     {var _eG_=_eF_[2],_eH_=caml_call1(_n_,_eF_[1]);
      return _u_(caml_call1(Stdlib_list[1],_eH_) - 1 | 0,_eG_)}
    function _y_(_eD_,_eC_,_eB_)
     {var _eE_=_v_(_eD_,caml_call1(_n_,_eC_[1]),_eB_);
      return _u_(_eE_,_eC_[2])}
    function _z_(_eA_){return caml_call1(_l_,[0,_eA_,0])}
    function _A_(_et_)
     {var
       _eu_=[0,1],
       _ev_=caml_call1(React[1][2],0),
       _ew_=_ev_[2],
       _ex_=caml_call2(_k_,0,_ev_[1]);
      function _ey_(_ez_)
       {return _eu_[1]
                ?(_eu_[1] = 0,caml_call2(_ew_,0,[0,[0,[0,0,_ez_],0]]))
                :caml_call2(_ew_,0,[0,[0,[2,0,_ez_],0]])}
      caml_call3(React[2][11],0,_ey_,_et_);
      return _ex_}
    function _B_(_dh_,_dg_)
     {var
       _di_=caml_call1(_n_,_dh_),
       _dj_=caml_call1(_n_,_dg_),
       _dk_=[0,0],
       _dl_=[0,0];
      function _dm_(_es_,_er_)
       {switch(_er_[0])
         {case 0:_es_[1]++;return 0;
          case 1:_es_[1] += -1;return 0;
          default:return 0}}
      function _dn_(_eq_,_ep_)
       {_eq_[1] = caml_call1(Stdlib_list[1],_ep_);return 0}
      _dn_(_dk_,_di_);
      _dn_(_dl_,_dj_);
      function _do_(_ed_)
       {switch(_ed_[0])
         {case 0:
           var
            _ee_=_ed_[1],
            _ef_=0 <= _ee_?_ee_:_ee_ - _dl_[1] | 0,
            _eg_=[0,_ef_,_ed_[2]];
           break;
          case 1:
           var
            _eh_=_ed_[1],
            _ei_=0 <= _eh_?_eh_:_eh_ - _dl_[1] | 0,
            _eg_=[1,_ei_];
           break;
          case 2:
           var
            _ej_=_ed_[1],
            _ek_=_ed_[2],
            _el_=0 <= _ej_?_ej_:_ej_ - _dl_[1] | 0,
            _eg_=[2,_el_,_ek_];
           break;
          default:
           var
            _em_=_ed_[1],
            _en_=_ed_[2],
            _eo_=0 <= _em_?_em_:_em_ - _dl_[1] | 0,
            _eg_=[3,_eo_,_en_]}
        _dm_(_dk_,_eg_);
        return _eg_}
      var _dp_=caml_call1(Stdlib_list[17],_do_);
      function _dq_(_d2_)
       {switch(_d2_[0])
         {case 0:
           var
            _d3_=_d2_[1],
            _d4_=_d2_[2],
            _d5_=0 <= _d3_?_dk_[1] + _d3_ | 0:_d3_,
            _d6_=[0,_d5_,_d4_];
           break;
          case 1:
           var
            _d7_=_d2_[1],
            _d8_=0 <= _d7_?_dk_[1] + _d7_ | 0:_d7_,
            _d6_=[1,_d8_];
           break;
          case 2:
           var
            _d9_=_d2_[1],
            _d__=_d2_[2],
            _d$_=0 <= _d9_?_dk_[1] + _d9_ | 0:_d9_,
            _d6_=[2,_d$_,_d__];
           break;
          default:
           var
            _ea_=_d2_[1],
            _eb_=_d2_[2],
            _ec_=0 <= _ea_?_dk_[1] + _ea_ | 0:_ea_,
            _d6_=[3,_ec_,_eb_]}
        _dm_(_dl_,_d6_);
        return _d6_}
      var
       _dr_=caml_call1(Stdlib_list[17],_dq_),
       _ds_=0,
       _dt_=caml_call1(_o_,_dg_);
      function _du_(_d1_){return [0,15437,_d1_]}
      var
       _dv_=[0,caml_call2(React[1][10],_du_,_dt_),_ds_],
       _dw_=caml_call1(_o_,_dh_);
      function _dx_(_d0_){return [0,15436,_d0_]}
      var _dy_=[0,caml_call2(React[1][10],_dx_,_dw_),_dv_];
      function _dz_(_dY_,_dX_)
       {var _dZ_=_dY_[1];
        if(! _dZ_ && typeof _dX_ !== "number" && 15436 === _dX_[1])
         return [0,[0,_dX_[2]],_dY_[2]];
        if(! _dY_[2] && typeof _dX_ !== "number" && 15437 === _dX_[1])
         return [0,_dZ_,[0,_dX_[2]]];
        throw [0,Assert_failure,_D_]}
      var _dA_=caml_call3(React[1][23],_dz_,_C_,_dy_);
      function _dB_(_dD_)
       {var _dE_=_dD_[1];
        if(_dE_)
         {var _dF_=_dE_[1];
          if(0 === _dF_[0])
           {var _dG_=_dD_[2],_dH_=_dF_[1];
            if(_dG_)
             {var _dI_=_dG_[1];
              if(0 === _dI_[0])
               {var _dJ_=caml_call1(_dp_,_dH_),_dK_=caml_call1(_dr_,_dI_[1]);
                return [0,caml_call2(Stdlib[37],_dJ_,_dK_)]}
              var _dL_=_dI_[1],_dM_=caml_call1(_n_,_dh_);
              _dn_(_dk_,_dM_);
              _dn_(_dl_,_dL_);
              return [1,caml_call2(Stdlib[37],_dM_,_dL_)]}
            return [0,caml_call1(_dp_,_dH_)]}
          var _dN_=_dD_[2],_dO_=_dF_[1];
          if(_dN_)
           {var _dP_=_dN_[1];
            if(0 === _dP_[0])
             {_dn_(_dk_,_dO_);
              var _dQ_=caml_call1(_n_,_dg_);
              _dn_(_dl_,_dQ_);
              return [1,caml_call2(Stdlib[37],_dO_,_dQ_)]}
            var _dR_=_dP_[1];
            _dn_(_dk_,_dO_);
            _dn_(_dl_,_dR_);
            return [1,caml_call2(Stdlib[37],_dO_,_dR_)]}
          _dn_(_dk_,_dO_);
          var _dS_=caml_call1(_n_,_dg_);
          return [1,caml_call2(Stdlib[37],_dO_,_dS_)]}
        var _dT_=_dD_[2];
        if(_dT_)
         {var _dU_=_dT_[1];
          if(0 === _dU_[0])return [0,caml_call1(_dr_,_dU_[1])];
          var _dV_=_dU_[1];
          _dn_(_dl_,_dV_);
          var _dW_=caml_call1(_n_,_dh_);
          return [1,caml_call2(Stdlib[37],_dW_,_dV_)]}
        throw [0,Assert_failure,_E_]}
      var _dC_=caml_call2(React[1][10],_dB_,_dA_);
      return caml_call2(_k_,caml_call2(Stdlib[37],_di_,_dj_),_dC_)}
    function _F_(_df_)
     {switch(_df_[0])
       {case 0:return [0,(- _df_[1] | 0) - 1 | 0,_df_[2]];
        case 1:return [1,(- _df_[1] | 0) - 1 | 0];
        case 2:return [2,(- _df_[1] | 0) - 1 | 0,_df_[2]];
        default:return [3,(- _df_[1] | 0) - 1 | 0,- _df_[2] | 0]}}
    function _G_(_c$_)
     {var _da_=caml_call1(_o_,_c$_);
      function _db_(_de_)
       {return 0 === _de_[0]
                ?[0,caml_call2(Stdlib_list[17],_F_,_de_[1])]
                :[1,caml_call1(Stdlib_list[9],_de_[1])]}
      var _dc_=caml_call2(React[1][10],_db_,_da_),_dd_=caml_call1(_n_,_c$_);
      return caml_call2(_k_,caml_call1(Stdlib_list[9],_dd_),_dc_)}
    function _H_(_bE_,_bD_)
     {var
       _bF_=caml_call1(Stdlib_map[1],[0,caml_compare]),
       _bG_=[0,_bF_[1]],
       _bH_=[0,0];
      function _bI_(_c4_)
       {_bH_[1] = caml_call1(Stdlib_list[1],_c4_);
        _bG_[1] = _bF_[1];
        var _c8_=_c4_,_c7_=0,_c6_=0,_c5_=-1;
        for(;;)
         {if(_c8_)
           {var _c9_=_c8_[2],_c__=_c8_[1];
            if(caml_call1(_bE_,_c__))
             {_bG_[1] = caml_call3(_bF_[4],_c6_,_c5_ + 1 | 0,_bG_[1]);
              var
               _c8_=_c9_,
               _c7_=[0,_c__,_c7_],
               _c6_=_c6_ + 1 | 0,
               _c5_=_c5_ + 1 | 0;
              continue}
            var _c8_=_c9_,_c6_=_c6_ + 1 | 0;
            continue}
          return caml_call1(Stdlib_list[9],_c7_)}}
      function _bJ_(_c3_){return 0 <= _c3_?_c3_:(_bH_[1] + 1 | 0) + _c3_ | 0}
      function _bK_(_cR_,_cQ_)
       {var
         _cS_=_bJ_(_cR_),
         _cT_=caml_call2(_bF_[26],_cS_,_bG_[1]),
         _cU_=_cT_[3],
         _cV_=_cT_[2],
         _cW_=_cT_[1],
         _cX_=_cV_?caml_call3(_bF_[4],_cS_,_cV_[1],_cU_):_cU_;
        function _cY_(_c1_,_c0_)
         {var _c2_=_cQ_?_c0_ + 1 | 0:_c0_;
          _bG_[1] = caml_call3(_bF_[4],_c1_ + 1 | 0,_c2_,_bG_[1]);
          return 0}
        caml_call2(_bF_[12],_cY_,_cX_);
        var
         _cZ_=
          caml_call1(_bF_[2],_cW_)?0:caml_call1(_bF_[22],_cW_)[2] + 1 | 0;
        if(_cQ_)_bG_[1] = caml_call3(_bF_[4],_cS_,_cZ_,_bG_[1]);
        _bH_[1]++;
        return _cZ_}
      function _bL_(_cA_,_cz_,_cy_)
       {var _cB_=_cy_?1:_cy_;
        if(_cA_ < _cz_)
         {var _cC_=_cA_ + 1 | 0;
          if(! (_cz_ < _cC_))
           {var _cD_=_cC_;
            for(;;)
             {var _cE_=_cB_?-1:0;
              try
               {var _cG_=caml_call2(_bF_[27],_cD_,_bG_[1]) + _cE_ | 0;
                _bG_[1] = caml_call3(_bF_[4],_cD_ - 1 | 0,_cG_,_bG_[1])}
              catch(_cO_)
               {_cO_ = caml_wrap_exception(_cO_);
                if(_cO_ !== Stdlib[8])throw _cO_;
                var _cM_=_cO_}
              var _cF_=_cD_ + 1 | 0;
              if(_cz_ !== _cD_){var _cD_=_cF_;continue}
              break}}}
        else
         {var _cH_=_cA_ - 1 | 0;
          if(! (_cH_ < _cz_))
           {var _cI_=_cH_;
            for(;;)
             {try
               {var
                 _cK_=_cB_?1:0,
                 _cL_=caml_call2(_bF_[27],_cI_,_bG_[1]) + _cK_ | 0;
                _bG_[1] = caml_call3(_bF_[4],_cI_ + 1 | 0,_cL_,_bG_[1])}
              catch(_cP_)
               {_cP_ = caml_wrap_exception(_cP_);
                if(_cP_ !== Stdlib[8])throw _cP_;
                var _cN_=_cP_}
              var _cJ_=_cI_ - 1 | 0;
              if(_cz_ !== _cI_){var _cI_=_cJ_;continue}
              break}}}
        return _cy_
                ?(_bG_[1] = caml_call3(_bF_[4],_cz_,_cy_[1],_bG_[1]),0)
                :(_bG_[1] = caml_call2(_bF_[7],_cz_,_bG_[1]),0)}
      function _bM_(_bS_)
       {switch(_bS_[0])
         {case 0:
           var _bT_=_bS_[2],_bU_=_bS_[1];
           return caml_call1(_bE_,_bT_)
                   ?[0,[0,_bK_(_bU_,1),_bT_],0]
                   :(_bK_(_bU_,0),0);
          case 1:
           var _bV_=_bJ_(_bS_[1]);
           try
            {var _b1_=[0,[1,caml_call2(_bF_[27],_bV_,_bG_[1])],0],_bW_=_b1_}
           catch(_cv_)
            {_cv_ = caml_wrap_exception(_cv_);
             if(_cv_ !== Stdlib[8])throw _cv_;
             var _bW_=0}
           var
            _bX_=caml_call2(_bF_[3],_bV_,_bG_[1]),
            _bY_=caml_call2(_bF_[26],_bV_,_bG_[1]),
            _bZ_=
             function(_ct_,_cs_)
              {var _cu_=_bX_?_cs_:_cs_ - 1 | 0;
               _bG_[1] = caml_call3(_bF_[4],_ct_ - 1 | 0,_cu_,_bG_[1]);
               return 0};
           if(1 - caml_call1(_bF_[2],_bG_[1]))
            {var _b0_=caml_call1(_bF_[22],_bG_[1]);
             _bG_[1] = caml_call2(_bF_[7],_b0_[1],_bG_[1])}
           _bH_[1] += -1;
           caml_call2(_bF_[12],_bZ_,_bY_[3]);
           return _bW_;
          case 2:
           var _b2_=_bS_[2],_b3_=_bJ_(_bS_[1]);
           try
            {var _b$_=caml_call2(_bF_[27],_b3_,_bG_[1]);
             if(caml_call1(_bE_,_b2_))
              var _ca_=[0,[2,_b$_,_b2_],0];
             else
              {var
                _cb_=caml_call2(_bF_[26],_b3_,_bG_[1]),
                _cc_=
                 function(_cr_,_cq_)
                  {_bG_[1] = caml_call3(_bF_[4],_cr_,_cq_ - 1 | 0,_bG_[1]);
                   return 0};
               _bG_[1] = caml_call2(_bF_[7],_b3_,_bG_[1]);
               caml_call2(_bF_[12],_cc_,_cb_[3]);
               var _ca_=[0,[1,_b$_],0]}
             return _ca_}
           catch(_cm_)
            {_cm_ = caml_wrap_exception(_cm_);
             if(_cm_ === Stdlib[8])
              {var _b4_=caml_call1(_bE_,_b2_);
               if(_b4_)
                {var _b5_=caml_call2(_bF_[26],_b3_,_bG_[1]);
                 if(0 !== _b5_[2])throw [0,Assert_failure,_I_];
                 var
                  _b6_=
                   function(_cp_,_co_)
                    {_bG_[1] = caml_call3(_bF_[4],_cp_,_co_ + 1 | 0,_bG_[1]);
                     return 0};
                 try
                  {var _b__=caml_call1(_bF_[22],_b5_[1])[2],_b7_=_b__}
                 catch(_cn_)
                  {_cn_ = caml_wrap_exception(_cn_);
                   if(_cn_ !== Stdlib[8])throw _cn_;
                   var _b7_=-1}
                 var _b8_=_b7_ + 1 | 0;
                 _bG_[1] = caml_call3(_bF_[4],_b3_,_b8_,_bG_[1]);
                 caml_call2(_bF_[12],_b6_,_b5_[3]);
                 var _b9_=[0,[0,_b8_,_b2_],0]}
               else
                var _b9_=_b4_;
               return _b9_}
             throw _cm_}
          default:
           var _cd_=_bJ_(_bS_[1]),_ce_=_cd_ + _bS_[2] | 0;
           try
            {var _cf_=caml_call2(_bF_[27],_cd_,_bG_[1]);
             try
              {var _cl_=caml_call2(_bF_[27],_ce_,_bG_[1]),_ci_=_cl_}
             catch(_cx_)
              {_cx_ = caml_wrap_exception(_cx_);
               if(_cx_ !== Stdlib[8])throw _cx_;
               var
                _cg_=caml_call2(_bF_[26],_cd_,_bG_[1])[1],
                _ch_=
                 caml_call1(_bF_[2],_cg_)
                  ?0
                  :caml_call1(_bF_[22],_cg_)[2] + 1 | 0,
                _ci_=_ch_}
             _bL_(_cd_,_ce_,[0,_ci_]);
             var
              _cj_=_ci_ !== _cf_?1:0,
              _ck_=_cj_?[0,[3,_cf_,_ci_ - _cf_ | 0],0]:_cj_;
             return _ck_}
           catch(_cw_)
            {_cw_ = caml_wrap_exception(_cw_);
             if(_cw_ === Stdlib[8]){_bL_(_cd_,_ce_,0);return 0}
             throw _cw_}}}
      function _bN_(_bQ_)
       {if(0 === _bQ_[0])
         {var _bR_=caml_call2(Stdlib_list[17],_bM_,_bQ_[1]);
          return [0,caml_call1(Stdlib_list[13],_bR_)]}
        return [1,_bI_(_bQ_[1])]}
      var _bO_=caml_call1(_o_,_bD_),_bP_=caml_call2(React[1][10],_bN_,_bO_);
      return caml_call2(_k_,_bI_(caml_call1(_n_,_bD_)),_bP_)}
    var _J_=caml_call1(Stdlib_set[1],[0,caml_compare]);
    function _K_(_aW_,_aV_)
     {function _aX_(_bC_,_bB_,_bA_)
       {return caml_call1(_aW_,_bA_)?_bC_:caml_call2(_J_[4],_bB_,_bC_)}
      var _aY_=_J_[1],_aZ_=0;
      function _a0_(_bz_)
       {var _bw_=_aZ_,_bv_=_aY_,_bu_=_bz_;
        for(;;)
         {if(_bu_)
           {var
             _bx_=_bu_[2],
             _by_=_aX_(_bv_,_bw_,_bu_[1]),
             _bw_=_bw_ + 1 | 0,
             _bv_=_by_,
             _bu_=_bx_;
            continue}
          return _bv_}}
      function _a1_(_br_,_bq_,_bp_)
       {function _bs_(_bt_){return _br_ <= _bt_?caml_call2(_bq_,_bt_,1):_bt_}
        return caml_call2(_J_[15],_bs_,_bp_)}
      function _a2_(_a7_,_a6_)
       {if(0 === _a6_[0])
         {var
           _a8_=_a6_[1],
           _a9_=
            function(_a$_,_a__)
             {switch(_a__[0])
               {case 0:
                 var
                  _ba_=_a__[1],
                  _bb_=
                   _a1_(_ba_,function(_bo_,_bn_){return _bo_ + _bn_ | 0},_a$_);
                 return _aX_(_bb_,_ba_,_a__[2]);
                case 1:
                 var _bc_=_a__[1],_bd_=caml_call2(_J_[6],_bc_,_a$_);
                 return _a1_
                         (_bc_,function(_bm_,_bl_){return _bm_ - _bl_ | 0},_bd_);
                case 2:
                 var _be_=_a__[1],_bf_=_a__[2];
                 return _aX_(caml_call2(_J_[6],_be_,_a$_),_be_,_bf_);
                default:
                 var
                  _bg_=_a__[2],
                  _bh_=_a__[1],
                  _bi_=caml_call2(_J_[3],_bg_,_a$_);
                 if(caml_call2(_J_[3],_bh_,_a$_) === _bi_)return _a$_;
                 if(caml_call2(_J_[3],_bh_,_a$_))
                  {var _bj_=caml_call2(_J_[6],_bh_,_a$_);
                   return caml_call2(_J_[4],_bg_,_bj_)}
                 var _bk_=caml_call2(_J_[6],_bg_,_a$_);
                 return caml_call2(_J_[4],_bh_,_bk_)}};
          return caml_call3(Stdlib_list[21],_a9_,_a7_,_a8_)}
        return _a0_(_a6_[1])}
      var
       _a3_=caml_call1(_o_,_aV_),
       _a4_=_a0_(caml_call1(_n_,_aV_)),
       _a5_=caml_call4(React[2][21],0,_a2_,_a4_,_a3_);
      return caml_call3(React[2][11],0,_J_[2],_a5_)}
    var
     _L_=_j_[12],
     _M_=_j_[11],
     _N_=_j_[9],
     _O_=_j_[8],
     _P_=_j_[7],
     _Q_=_j_[4],
     _R_=_j_[2],
     _S_=_j_[1],
     ReactiveData=
      [0,
       [0,
        _S_,
        _R_,
        _k_,
        _Q_,
        _l_,
        _m_,
        _P_,
        _O_,
        _N_,
        _n_,
        _M_,
        _L_,
        _o_,
        _p_,
        _q_,
        _r_,
        _u_,
        _x_,
        _y_,
        _s_,
        _w_,
        _t_,
        _z_,
        _A_,
        _B_,
        _G_,
        _H_,
        _K_],
       function(_ac_)
        {function _U_(_aQ_,_aP_)
          {function _aR_(_aU_,_aT_)
            {if(3404203 <= _aT_[1])return caml_call2(_ac_[7],_aT_[2],_aU_);
             var _aS_=_aT_[2];
             return caml_call3(_ac_[4],_aS_[1],_aS_[2],_aU_)}
           return caml_call3(Stdlib_list[21],_aR_,_aP_,_aQ_)}
         function _V_(_aK_)
          {function _aL_(_aO_)
            {if(3404203 <= _aO_[1])return [0,3404203,_aO_[2]];
             var _aM_=_aO_[2],_aN_=caml_call1(_aK_,_aM_[2]);
             return [0,3254785,[0,_aM_[1],_aN_]]}
           return caml_call1(Stdlib_list[17],_aL_)}
         function _W_(_aJ_,_aI_){return caml_call2(_ac_[33],_aJ_,_aI_)}
         var _X_=_ac_[1];
         function _Y_(_aH_){return caml_call1(_ac_[11],_aH_)}
         var
          _Z_=
           _a_
            ([0,
              _U_,
              _V_,
              _W_,
              _X_,
              _Y_,
              function(_au_,_at_,_as_)
               {function _av_(_aE_,_aD_,_aC_)
                 {if(_aD_)
                   {if(_aC_)
                     {var _aF_=_aC_[1];
                      return caml_call2(_au_,_aD_[1],_aF_)?0:[0,[0,85,_aF_]]}
                    return _T_}
                  var _aG_=_aC_?[0,[0,65,_aC_[1]]]:_aC_;
                  return _aG_}
                var _aw_=caml_call3(_ac_[8],_av_,_at_,_as_);
                function _ax_(_aB_,_aA_,_az_)
                 {return typeof _aA_ === "number"
                          ?[0,[0,3404203,_aB_],_az_]
                          :85 <= _aA_[1]
                            ?[0,[0,3404203,_aB_],[0,[0,3254785,[0,_aB_,_aA_[2]]],_az_]]
                            :[0,[0,3254785,[0,_aB_,_aA_[2]]],_az_]}
                var _ay_=caml_call3(_ac_[13],_ax_,_aw_,0);
                return caml_call1(Stdlib_list[9],_ay_)}]),
          ___=_Z_[3],
          _$_=_Z_[10],
          _aa_=_Z_[13];
         function _ab_(_ae_,_ad_)
          {function _af_(_am_)
            {if(3404203 <= _am_[1])return [0,[0,3404203,_am_[2]],0];
             var
              _an_=_am_[2],
              _ao_=_an_[2],
              _ap_=_an_[1],
              _aq_=caml_call2(_ae_,_ap_,_ao_),
              _ar_=_aq_?[0,[0,3254785,[0,_ap_,_ao_]],0]:_aq_;
             return _ar_}
           function _ag_(_ak_)
            {if(0 === _ak_[0])
              {var _al_=caml_call2(Stdlib_list[17],_af_,_ak_[1]);
               return [0,caml_call1(Stdlib_list[13],_al_)]}
             return [1,caml_call2(_ac_[16],_ae_,_ak_[1])]}
           var
            _ah_=caml_call1(_aa_,_ad_),
            _ai_=caml_call2(React[1][10],_ag_,_ah_),
            _aj_=caml_call1(_$_,_ad_);
           return caml_call2(___,caml_call2(_ac_[16],_ae_,_aj_),_ai_)}
         return [0,
                 _Z_[1],
                 _Z_[2],
                 ___,
                 _Z_[4],
                 _Z_[5],
                 _Z_[6],
                 _Z_[7],
                 _Z_[8],
                 _Z_[9],
                 _$_,
                 _Z_[11],
                 _Z_[12],
                 _aa_,
                 _ab_]},
       _a_];
    runtime.caml_register_global(23,ReactiveData,"ReactiveData");
    return}
  (function(){return this}()));


//# 1 "../../.js/js_of_ocaml-tyxml/js_of_ocaml_tyxml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_of_video$0=caml_string_of_jsbytes("of_video"),
     cst_of_audio$0=caml_string_of_jsbytes("of_audio"),
     cst_of_iFrame=caml_string_of_jsbytes("of_iFrame"),
     cst_of_canvas$0=caml_string_of_jsbytes("of_canvas"),
     cst_of_table$0=caml_string_of_jsbytes("of_table"),
     cst_of_tableCaption=caml_string_of_jsbytes("of_tableCaption"),
     cst_of_tableSection=caml_string_of_jsbytes("of_tableSection"),
     cst_of_tableCol=caml_string_of_jsbytes("of_tableCol"),
     cst_of_tableRow=caml_string_of_jsbytes("of_tableRow"),
     cst_of_tableCell=caml_string_of_jsbytes("of_tableCell"),
     cst_of_embed$0=caml_string_of_jsbytes("of_embed"),
     cst_of_script$0=caml_string_of_jsbytes("of_script"),
     cst_of_map$0=caml_string_of_jsbytes("of_map"),
     cst_of_area$0=caml_string_of_jsbytes("of_area"),
     cst_of_param$0=caml_string_of_jsbytes("of_param"),
     cst_of_object$0=caml_string_of_jsbytes("of_object"),
     cst_of_image=caml_string_of_jsbytes("of_image"),
     cst_of_anchor=caml_string_of_jsbytes("of_anchor"),
     cst_of_mod=caml_string_of_jsbytes("of_mod"),
     cst_of_hr$0=caml_string_of_jsbytes("of_hr"),
     cst_of_br$0=caml_string_of_jsbytes("of_br"),
     cst_of_pre$0=caml_string_of_jsbytes("of_pre"),
     cst_of_quote=caml_string_of_jsbytes("of_quote"),
     cst_of_heading$0=caml_string_of_jsbytes("of_heading"),
     cst_of_paragraph=caml_string_of_jsbytes("of_paragraph"),
     cst_of_div$0=caml_string_of_jsbytes("of_div"),
     cst_of_li$0=caml_string_of_jsbytes("of_li"),
     cst_of_dList=caml_string_of_jsbytes("of_dList"),
     cst_of_oList=caml_string_of_jsbytes("of_oList"),
     cst_of_uList=caml_string_of_jsbytes("of_uList"),
     cst_of_legend$0=caml_string_of_jsbytes("of_legend"),
     cst_of_fieldSet=caml_string_of_jsbytes("of_fieldSet"),
     cst_of_label$0=caml_string_of_jsbytes("of_label"),
     cst_of_button$0=caml_string_of_jsbytes("of_button"),
     cst_of_textArea=caml_string_of_jsbytes("of_textArea"),
     cst_of_input$0=caml_string_of_jsbytes("of_input"),
     cst_of_select$0=caml_string_of_jsbytes("of_select"),
     cst_of_option$0=caml_string_of_jsbytes("of_option"),
     cst_of_optGroup=caml_string_of_jsbytes("of_optGroup"),
     cst_of_form$0=caml_string_of_jsbytes("of_form"),
     cst_of_body$0=caml_string_of_jsbytes("of_body"),
     cst_of_style$0=caml_string_of_jsbytes("of_style"),
     cst_of_base$0=caml_string_of_jsbytes("of_base"),
     cst_of_meta$0=caml_string_of_jsbytes("of_meta"),
     cst_of_title$0=caml_string_of_jsbytes("of_title"),
     cst_of_link$0=caml_string_of_jsbytes("of_link"),
     cst_of_head$0=caml_string_of_jsbytes("of_head"),
     cst_of_html$0=caml_string_of_jsbytes("of_html"),
     cst_of_element$0=caml_string_of_jsbytes("of_element"),
     cst_of_wbr=caml_string_of_jsbytes("of_wbr"),
     cst_of_var=caml_string_of_jsbytes("of_var"),
     cst_of_u=caml_string_of_jsbytes("of_u"),
     cst_of_time=caml_string_of_jsbytes("of_time"),
     cst_of_th=caml_string_of_jsbytes("of_th"),
     cst_of_sup=caml_string_of_jsbytes("of_sup"),
     cst_of_summary=caml_string_of_jsbytes("of_summary"),
     cst_of_sub=caml_string_of_jsbytes("of_sub"),
     cst_of_strong=caml_string_of_jsbytes("of_strong"),
     cst_of_span=caml_string_of_jsbytes("of_span"),
     cst_of_source=caml_string_of_jsbytes("of_source"),
     cst_of_small=caml_string_of_jsbytes("of_small"),
     cst_of_section=caml_string_of_jsbytes("of_section"),
     cst_of_samp=caml_string_of_jsbytes("of_samp"),
     cst_of_ruby=caml_string_of_jsbytes("of_ruby"),
     cst_of_rt=caml_string_of_jsbytes("of_rt"),
     cst_of_rp=caml_string_of_jsbytes("of_rp"),
     cst_of_q=caml_string_of_jsbytes("of_q"),
     cst_of_progress=caml_string_of_jsbytes("of_progress"),
     cst_of_output=caml_string_of_jsbytes("of_output"),
     cst_of_noscript=caml_string_of_jsbytes("of_noscript"),
     cst_of_nav=caml_string_of_jsbytes("of_nav"),
     cst_of_meter=caml_string_of_jsbytes("of_meter"),
     cst_of_menu=caml_string_of_jsbytes("of_menu"),
     cst_of_mark=caml_string_of_jsbytes("of_mark"),
     cst_of_main=caml_string_of_jsbytes("of_main"),
     cst_of_keygen=caml_string_of_jsbytes("of_keygen"),
     cst_of_kbd=caml_string_of_jsbytes("of_kbd"),
     cst_of_i=caml_string_of_jsbytes("of_i"),
     cst_of_hgroup=caml_string_of_jsbytes("of_hgroup"),
     cst_of_header=caml_string_of_jsbytes("of_header"),
     cst_of_footer=caml_string_of_jsbytes("of_footer"),
     cst_of_figure=caml_string_of_jsbytes("of_figure"),
     cst_of_figcaption=caml_string_of_jsbytes("of_figcaption"),
     cst_of_embed=caml_string_of_jsbytes("of_embed"),
     cst_of_em=caml_string_of_jsbytes("of_em"),
     cst_of_dt=caml_string_of_jsbytes("of_dt"),
     cst_of_dfn=caml_string_of_jsbytes("of_dfn"),
     cst_of_details=caml_string_of_jsbytes("of_details"),
     cst_of_dd=caml_string_of_jsbytes("of_dd"),
     cst_of_datalist=caml_string_of_jsbytes("of_datalist"),
     cst_of_command=caml_string_of_jsbytes("of_command"),
     cst_of_colgroup=caml_string_of_jsbytes("of_colgroup"),
     cst_of_code=caml_string_of_jsbytes("of_code"),
     cst_of_cite=caml_string_of_jsbytes("of_cite"),
     cst_of_bdo=caml_string_of_jsbytes("of_bdo"),
     cst_of_b=caml_string_of_jsbytes("of_b"),
     cst_of_aside=caml_string_of_jsbytes("of_aside"),
     cst_of_article=caml_string_of_jsbytes("of_article"),
     cst_of_address=caml_string_of_jsbytes("of_address"),
     cst_of_abbr=caml_string_of_jsbytes("of_abbr"),
     cst_of_h6=caml_string_of_jsbytes("of_h6"),
     cst_of_h5=caml_string_of_jsbytes("of_h5"),
     cst_of_h4=caml_string_of_jsbytes("of_h4"),
     cst_of_h3=caml_string_of_jsbytes("of_h3"),
     cst_of_h2=caml_string_of_jsbytes("of_h2"),
     cst_of_h1=caml_string_of_jsbytes("of_h1"),
     cst_of_video=caml_string_of_jsbytes("of_video"),
     cst_of_audio=caml_string_of_jsbytes("of_audio"),
     cst_of_iframe=caml_string_of_jsbytes("of_iframe"),
     cst_of_canvas=caml_string_of_jsbytes("of_canvas"),
     cst_of_table=caml_string_of_jsbytes("of_table"),
     cst_of_caption=caml_string_of_jsbytes("of_caption"),
     cst_of_tbody=caml_string_of_jsbytes("of_tbody"),
     cst_of_thead=caml_string_of_jsbytes("of_thead"),
     cst_of_tfoot=caml_string_of_jsbytes("of_tfoot"),
     cst_of_col=caml_string_of_jsbytes("of_col"),
     cst_of_tr=caml_string_of_jsbytes("of_tr"),
     cst_of_td=caml_string_of_jsbytes("of_td"),
     cst_of_script=caml_string_of_jsbytes("of_script"),
     cst_of_map=caml_string_of_jsbytes("of_map"),
     cst_of_area=caml_string_of_jsbytes("of_area"),
     cst_of_param=caml_string_of_jsbytes("of_param"),
     cst_of_object=caml_string_of_jsbytes("of_object"),
     cst_of_img=caml_string_of_jsbytes("of_img"),
     cst_of_a=caml_string_of_jsbytes("of_a"),
     cst_of_del=caml_string_of_jsbytes("of_del"),
     cst_of_ins=caml_string_of_jsbytes("of_ins"),
     cst_of_hr=caml_string_of_jsbytes("of_hr"),
     cst_of_br=caml_string_of_jsbytes("of_br"),
     cst_of_pre=caml_string_of_jsbytes("of_pre"),
     cst_of_blockquote=caml_string_of_jsbytes("of_blockquote"),
     cst_of_heading=caml_string_of_jsbytes("of_heading"),
     cst_of_p=caml_string_of_jsbytes("of_p"),
     cst_of_div=caml_string_of_jsbytes("of_div"),
     cst_of_li=caml_string_of_jsbytes("of_li"),
     cst_of_dl=caml_string_of_jsbytes("of_dl"),
     cst_of_ol=caml_string_of_jsbytes("of_ol"),
     cst_of_ul=caml_string_of_jsbytes("of_ul"),
     cst_of_legend=caml_string_of_jsbytes("of_legend"),
     cst_of_fieldset=caml_string_of_jsbytes("of_fieldset"),
     cst_of_label=caml_string_of_jsbytes("of_label"),
     cst_of_button=caml_string_of_jsbytes("of_button"),
     cst_of_textarea=caml_string_of_jsbytes("of_textarea"),
     cst_of_input=caml_string_of_jsbytes("of_input"),
     cst_of_select=caml_string_of_jsbytes("of_select"),
     cst_of_option=caml_string_of_jsbytes("of_option"),
     cst_of_optgroup=caml_string_of_jsbytes("of_optgroup"),
     cst_of_form=caml_string_of_jsbytes("of_form"),
     cst_of_body=caml_string_of_jsbytes("of_body"),
     cst_of_style=caml_string_of_jsbytes("of_style"),
     cst_of_base=caml_string_of_jsbytes("of_base"),
     cst_of_meta=caml_string_of_jsbytes("of_meta"),
     cst_of_title=caml_string_of_jsbytes("of_title"),
     cst_of_link=caml_string_of_jsbytes("of_link"),
     cst_of_head=caml_string_of_jsbytes("of_head"),
     cst_of_html=caml_string_of_jsbytes("of_html"),
     cst_of_pcdata=caml_string_of_jsbytes("of_pcdata"),
     cst_of_node=caml_string_of_jsbytes("of_node"),
     cst_of_element=caml_string_of_jsbytes("of_element"),
     cst$7=caml_string_of_jsbytes(" "),
     cst$6=caml_string_of_jsbytes(","),
     cst$5=caml_string_of_jsbytes(" "),
     cst_filter_attrib_not_implemen=
      caml_string_of_jsbytes
       ("filter_attrib not implemented for event handler"),
     cst_style=caml_string_of_jsbytes("style"),
     cst_style$0=caml_string_of_jsbytes("style"),
     cst$2=caml_string_of_jsbytes(""),
     cst_amp=caml_string_of_jsbytes("amp"),
     cst_apos=caml_string_of_jsbytes("apos"),
     cst_gt=caml_string_of_jsbytes("gt"),
     cst_lt=caml_string_of_jsbytes("lt"),
     cst_quot=caml_string_of_jsbytes("quot"),
     cst$3=caml_string_of_jsbytes(";"),
     cst$4=caml_string_of_jsbytes("&"),
     cst$1=caml_string_of_jsbytes(" "),
     cst$0=caml_string_of_jsbytes(","),
     cst=caml_string_of_jsbytes(" "),
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_char=global_data.Stdlib__char,
     Js_of_ocaml_Dom_svg=global_data.Js_of_ocaml__Dom_svg,
     Js_of_ocaml_Dom_html=global_data.Js_of_ocaml__Dom_html,
     React=global_data.React,
     Stdlib=global_data.Stdlib,
     Js_of_ocaml_Js=global_data.Js_of_ocaml__Js,
     ReactiveData=global_data.ReactiveData,
     Stdlib_list=global_data.Stdlib__list,
     Js_of_ocaml_Dom=global_data.Js_of_ocaml__Dom,
     Assert_failure=global_data.Assert_failure,
     Stdlib_printf=global_data.Stdlib__printf,
     Xml_wrap=global_data.Xml_wrap,
     Svg_f=global_data.Svg_f,
     Html_f=global_data.Html_f,
     Js_of_ocaml_tyxml=[0];
    caml_register_global(245,Js_of_ocaml_tyxml,"Js_of_ocaml_tyxml__");
    var
     Poly=[0],
     _d_=[0,caml_string_of_jsbytes("lib/tyxml/tyxml_js.ml"),327,8],
     _e_=[0,caml_string_of_jsbytes("lib/tyxml/tyxml_js.ml"),333,15],
     _f_=[0,caml_string_of_jsbytes("lib/tyxml/tyxml_js.ml"),341,17],
     _c_=[0,caml_string_of_jsbytes("lib/tyxml/tyxml_js.ml"),314,4],
     _a_=
      [0,
       [11,caml_string_of_jsbytes("Invalid entity "),[3,0,0]],
       caml_string_of_jsbytes("Invalid entity %S")];
    function symbol(x,y){return x < y?1:0}
    function symbol$0(x,y){return x <= y?1:0}
    function symbol$1(x,y){return x !== y?1:0}
    function symbol$2(x,y){return x === y?1:0}
    function symbol$3(x,y){return y < x?1:0}
    function symbol$4(x,y){return y <= x?1:0}
    var compare=runtime.caml_int_compare;
    function equal(x,y){return x === y?1:0}
    function max(x,y){return y <= x?x:y}
    function min(x,y){return x <= y?x:y}
    var
     Int_replace_polymorphic_compar=
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       compare,
       equal,
       max,
       min],
     make=Stdlib_string[1],
     init=Stdlib_string[2],
     copy=Stdlib_string[3],
     sub=Stdlib_string[4],
     fill=Stdlib_string[5],
     blit=Stdlib_string[6],
     concat=Stdlib_string[7],
     iter=Stdlib_string[8],
     iteri=Stdlib_string[9],
     map=Stdlib_string[10],
     mapi=Stdlib_string[11],
     trim=Stdlib_string[12],
     escaped=Stdlib_string[13],
     index=Stdlib_string[14],
     index_opt=Stdlib_string[15],
     rindex=Stdlib_string[16],
     rindex_opt=Stdlib_string[17],
     index_from=Stdlib_string[18],
     index_from_opt=Stdlib_string[19],
     rindex_from=Stdlib_string[20],
     rindex_from_opt=Stdlib_string[21],
     contains=Stdlib_string[22],
     contains_from=Stdlib_string[23],
     rcontains_from=Stdlib_string[24],
     uppercase=Stdlib_string[25],
     lowercase=Stdlib_string[26],
     capitalize=Stdlib_string[27],
     uncapitalize=Stdlib_string[28],
     uppercase_ascii=Stdlib_string[29],
     lowercase_ascii=Stdlib_string[30],
     capitalize_ascii=Stdlib_string[31],
     uncapitalize_ascii=Stdlib_string[32],
     compare$0=Stdlib_string[33],
     split_on_char=Stdlib_string[35],
     to_seq=Stdlib_string[36],
     to_seqi=Stdlib_string[37],
     of_seq=Stdlib_string[38],
     equal$0=runtime.caml_string_equal,
     String=
      [0,
       make,
       init,
       copy,
       sub,
       fill,
       blit,
       concat,
       iter,
       iteri,
       map,
       mapi,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$0,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       equal$0],
     chr=Stdlib_char[1],
     escaped$0=Stdlib_char[2],
     lowercase$0=Stdlib_char[3],
     uppercase$0=Stdlib_char[4],
     lowercase_ascii$0=Stdlib_char[5],
     uppercase_ascii$0=Stdlib_char[6],
     compare$1=Stdlib_char[7];
    function equal$1(x,y){return x === y?1:0}
    var
     Char=
      [0,
       chr,
       escaped$0,
       lowercase$0,
       uppercase$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$1,
       equal$1],
     symbol$5=Int_replace_polymorphic_compar[1],
     symbol$6=Int_replace_polymorphic_compar[2],
     symbol$7=Int_replace_polymorphic_compar[3],
     symbol$8=Int_replace_polymorphic_compar[4],
     symbol$9=Int_replace_polymorphic_compar[5],
     symbol$10=Int_replace_polymorphic_compar[6],
     compare$2=Int_replace_polymorphic_compar[7],
     equal$2=Int_replace_polymorphic_compar[8],
     max$0=Int_replace_polymorphic_compar[9],
     min$0=Int_replace_polymorphic_compar[10],
     Js_of_ocaml_tyxml_Import=
      [0,
       Poly,
       Int_replace_polymorphic_compar,
       String,
       Char,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       compare$2,
       equal$2,
       max$0,
       min$0];
    caml_register_global
     (248,Js_of_ocaml_tyxml_Import,"Js_of_ocaml_tyxml__Import");
    var Js_of_ocaml_tyxml_Tyxml_cast_s=[0];
    caml_register_global
     (249,Js_of_ocaml_tyxml_Tyxml_cast_s,"Js_of_ocaml_tyxml__Tyxml_cast_sigs");
    function MakeTo(C)
     {function rebuild_node(param,x){return caml_call1(C[1],x)}
      function of_element(elt){return rebuild_node(cst_of_element,elt)}
      function of_node(elt){return rebuild_node(cst_of_node,elt)}
      function of_pcdata(elt){return rebuild_node(cst_of_pcdata,elt)}
      function of_html(elt){return rebuild_node(cst_of_html,elt)}
      function of_head(elt){return rebuild_node(cst_of_head,elt)}
      function of_link(elt){return rebuild_node(cst_of_link,elt)}
      function of_title(elt){return rebuild_node(cst_of_title,elt)}
      function of_meta(elt){return rebuild_node(cst_of_meta,elt)}
      function of_base(elt){return rebuild_node(cst_of_base,elt)}
      function of_style(elt){return rebuild_node(cst_of_style,elt)}
      function of_body(elt){return rebuild_node(cst_of_body,elt)}
      function of_form(elt){return rebuild_node(cst_of_form,elt)}
      function of_optgroup(elt){return rebuild_node(cst_of_optgroup,elt)}
      function of_option(elt){return rebuild_node(cst_of_option,elt)}
      function of_select(elt){return rebuild_node(cst_of_select,elt)}
      function of_input(elt){return rebuild_node(cst_of_input,elt)}
      function of_textarea(elt){return rebuild_node(cst_of_textarea,elt)}
      function of_button(elt){return rebuild_node(cst_of_button,elt)}
      function of_label(elt){return rebuild_node(cst_of_label,elt)}
      function of_fieldset(elt){return rebuild_node(cst_of_fieldset,elt)}
      function of_legend(elt){return rebuild_node(cst_of_legend,elt)}
      function of_ul(elt){return rebuild_node(cst_of_ul,elt)}
      function of_ol(elt){return rebuild_node(cst_of_ol,elt)}
      function of_dl(elt){return rebuild_node(cst_of_dl,elt)}
      function of_li(elt){return rebuild_node(cst_of_li,elt)}
      function of_div(elt){return rebuild_node(cst_of_div,elt)}
      function of_p(elt){return rebuild_node(cst_of_p,elt)}
      function of_heading(elt){return rebuild_node(cst_of_heading,elt)}
      function of_blockquote(elt){return rebuild_node(cst_of_blockquote,elt)}
      function of_pre(elt){return rebuild_node(cst_of_pre,elt)}
      function of_br(elt){return rebuild_node(cst_of_br,elt)}
      function of_hr(elt){return rebuild_node(cst_of_hr,elt)}
      function of_ins(elt){return rebuild_node(cst_of_ins,elt)}
      function of_del(elt){return rebuild_node(cst_of_del,elt)}
      function of_a(elt){return rebuild_node(cst_of_a,elt)}
      function of_img(elt){return rebuild_node(cst_of_img,elt)}
      function of_object(elt){return rebuild_node(cst_of_object,elt)}
      function of_param(elt){return rebuild_node(cst_of_param,elt)}
      function of_area(elt){return rebuild_node(cst_of_area,elt)}
      function of_map(elt){return rebuild_node(cst_of_map,elt)}
      function of_script(elt){return rebuild_node(cst_of_script,elt)}
      function of_td(elt){return rebuild_node(cst_of_td,elt)}
      function of_tr(elt){return rebuild_node(cst_of_tr,elt)}
      function of_col(elt){return rebuild_node(cst_of_col,elt)}
      function of_tfoot(elt){return rebuild_node(cst_of_tfoot,elt)}
      function of_thead(elt){return rebuild_node(cst_of_thead,elt)}
      function of_tbody(elt){return rebuild_node(cst_of_tbody,elt)}
      function of_caption(elt){return rebuild_node(cst_of_caption,elt)}
      function of_table(elt){return rebuild_node(cst_of_table,elt)}
      function of_canvas(elt){return rebuild_node(cst_of_canvas,elt)}
      function of_iframe(elt){return rebuild_node(cst_of_iframe,elt)}
      function of_audio(elt){return rebuild_node(cst_of_audio,elt)}
      function of_video(elt){return rebuild_node(cst_of_video,elt)}
      function of_h1(elt){return rebuild_node(cst_of_h1,elt)}
      function of_h2(elt){return rebuild_node(cst_of_h2,elt)}
      function of_h3(elt){return rebuild_node(cst_of_h3,elt)}
      function of_h4(elt){return rebuild_node(cst_of_h4,elt)}
      function of_h5(elt){return rebuild_node(cst_of_h5,elt)}
      function of_h6(elt){return rebuild_node(cst_of_h6,elt)}
      function of_abbr(elt){return rebuild_node(cst_of_abbr,elt)}
      function of_address(elt){return rebuild_node(cst_of_address,elt)}
      function of_article(elt){return rebuild_node(cst_of_article,elt)}
      function of_aside(elt){return rebuild_node(cst_of_aside,elt)}
      function of_b(elt){return rebuild_node(cst_of_b,elt)}
      function of_bdo(elt){return rebuild_node(cst_of_bdo,elt)}
      function of_cite(elt){return rebuild_node(cst_of_cite,elt)}
      function of_code(elt){return rebuild_node(cst_of_code,elt)}
      function of_colgroup(elt){return rebuild_node(cst_of_colgroup,elt)}
      function of_command(elt){return rebuild_node(cst_of_command,elt)}
      function of_datalist(elt){return rebuild_node(cst_of_datalist,elt)}
      function of_dd(elt){return rebuild_node(cst_of_dd,elt)}
      function of_details(elt){return rebuild_node(cst_of_details,elt)}
      function of_dfn(elt){return rebuild_node(cst_of_dfn,elt)}
      function of_dt(elt){return rebuild_node(cst_of_dt,elt)}
      function of_em(elt){return rebuild_node(cst_of_em,elt)}
      function of_embed(elt){return rebuild_node(cst_of_embed,elt)}
      function of_figcaption(elt){return rebuild_node(cst_of_figcaption,elt)}
      function of_figure(elt){return rebuild_node(cst_of_figure,elt)}
      function of_footer(elt){return rebuild_node(cst_of_footer,elt)}
      function of_header(elt){return rebuild_node(cst_of_header,elt)}
      function of_hgroup(elt){return rebuild_node(cst_of_hgroup,elt)}
      function of_i(elt){return rebuild_node(cst_of_i,elt)}
      function of_kbd(elt){return rebuild_node(cst_of_kbd,elt)}
      function of_keygen(elt){return rebuild_node(cst_of_keygen,elt)}
      function of_main(elt){return rebuild_node(cst_of_main,elt)}
      function of_mark(elt){return rebuild_node(cst_of_mark,elt)}
      function of_menu(elt){return rebuild_node(cst_of_menu,elt)}
      function of_meter(elt){return rebuild_node(cst_of_meter,elt)}
      function of_nav(elt){return rebuild_node(cst_of_nav,elt)}
      function of_noscript(elt){return rebuild_node(cst_of_noscript,elt)}
      function of_output(elt){return rebuild_node(cst_of_output,elt)}
      function of_progress(elt){return rebuild_node(cst_of_progress,elt)}
      function of_q(elt){return rebuild_node(cst_of_q,elt)}
      function of_rp(elt){return rebuild_node(cst_of_rp,elt)}
      function of_rt(elt){return rebuild_node(cst_of_rt,elt)}
      function of_ruby(elt){return rebuild_node(cst_of_ruby,elt)}
      function of_samp(elt){return rebuild_node(cst_of_samp,elt)}
      function of_section(elt){return rebuild_node(cst_of_section,elt)}
      function of_small(elt){return rebuild_node(cst_of_small,elt)}
      function of_source(elt){return rebuild_node(cst_of_source,elt)}
      function of_span(elt){return rebuild_node(cst_of_span,elt)}
      function of_strong(elt){return rebuild_node(cst_of_strong,elt)}
      function of_sub(elt){return rebuild_node(cst_of_sub,elt)}
      function of_summary(elt){return rebuild_node(cst_of_summary,elt)}
      function of_sup(elt){return rebuild_node(cst_of_sup,elt)}
      function of_th(elt){return rebuild_node(cst_of_th,elt)}
      function of_time(elt){return rebuild_node(cst_of_time,elt)}
      function of_u(elt){return rebuild_node(cst_of_u,elt)}
      function of_var(elt){return rebuild_node(cst_of_var,elt)}
      function of_wbr(elt){return rebuild_node(cst_of_wbr,elt)}
      return [0,
              of_element,
              of_node,
              of_pcdata,
              of_html,
              of_head,
              of_link,
              of_title,
              of_meta,
              of_base,
              of_style,
              of_body,
              of_form,
              of_optgroup,
              of_option,
              of_select,
              of_input,
              of_textarea,
              of_button,
              of_label,
              of_fieldset,
              of_legend,
              of_ul,
              of_ol,
              of_dl,
              of_li,
              of_div,
              of_p,
              of_heading,
              of_blockquote,
              of_pre,
              of_br,
              of_hr,
              of_del,
              of_ins,
              of_a,
              of_img,
              of_object,
              of_param,
              of_area,
              of_map,
              of_script,
              of_td,
              of_tr,
              of_col,
              of_tfoot,
              of_thead,
              of_tbody,
              of_caption,
              of_table,
              of_canvas,
              of_iframe,
              of_audio,
              of_video,
              of_h1,
              of_h2,
              of_h3,
              of_h4,
              of_h5,
              of_h6,
              of_abbr,
              of_address,
              of_article,
              of_aside,
              of_b,
              of_bdo,
              of_cite,
              of_code,
              of_colgroup,
              of_command,
              of_datalist,
              of_dd,
              of_details,
              of_dfn,
              of_dt,
              of_em,
              of_embed,
              of_figcaption,
              of_figure,
              of_footer,
              of_header,
              of_hgroup,
              of_i,
              of_kbd,
              of_keygen,
              of_main,
              of_mark,
              of_menu,
              of_meter,
              of_nav,
              of_noscript,
              of_output,
              of_progress,
              of_q,
              of_rp,
              of_rt,
              of_ruby,
              of_samp,
              of_section,
              of_small,
              of_source,
              of_span,
              of_strong,
              of_sub,
              of_summary,
              of_sup,
              of_th,
              of_time,
              of_u,
              of_var,
              of_wbr]}
    function MakeOf(C)
     {function rebuild_node(param,x){return caml_call1(C[1],x)}
      function of_element(elt){return rebuild_node(cst_of_element$0,elt)}
      function of_html(elt){return rebuild_node(cst_of_html$0,elt)}
      function of_head(elt){return rebuild_node(cst_of_head$0,elt)}
      function of_link(elt){return rebuild_node(cst_of_link$0,elt)}
      function of_title(elt){return rebuild_node(cst_of_title$0,elt)}
      function of_meta(elt){return rebuild_node(cst_of_meta$0,elt)}
      function of_base(elt){return rebuild_node(cst_of_base$0,elt)}
      function of_style(elt){return rebuild_node(cst_of_style$0,elt)}
      function of_body(elt){return rebuild_node(cst_of_body$0,elt)}
      function of_form(elt){return rebuild_node(cst_of_form$0,elt)}
      function of_optGroup(elt){return rebuild_node(cst_of_optGroup,elt)}
      function of_option(elt){return rebuild_node(cst_of_option$0,elt)}
      function of_select(elt){return rebuild_node(cst_of_select$0,elt)}
      function of_input(elt){return rebuild_node(cst_of_input$0,elt)}
      function of_textArea(elt){return rebuild_node(cst_of_textArea,elt)}
      function of_button(elt){return rebuild_node(cst_of_button$0,elt)}
      function of_label(elt){return rebuild_node(cst_of_label$0,elt)}
      function of_fieldSet(elt){return rebuild_node(cst_of_fieldSet,elt)}
      function of_legend(elt){return rebuild_node(cst_of_legend$0,elt)}
      function of_uList(elt){return rebuild_node(cst_of_uList,elt)}
      function of_oList(elt){return rebuild_node(cst_of_oList,elt)}
      function of_dList(elt){return rebuild_node(cst_of_dList,elt)}
      function of_li(elt){return rebuild_node(cst_of_li$0,elt)}
      function of_div(elt){return rebuild_node(cst_of_div$0,elt)}
      function of_paragraph(elt){return rebuild_node(cst_of_paragraph,elt)}
      function of_heading(elt){return rebuild_node(cst_of_heading$0,elt)}
      function of_quote(elt){return rebuild_node(cst_of_quote,elt)}
      function of_pre(elt){return rebuild_node(cst_of_pre$0,elt)}
      function of_br(elt){return rebuild_node(cst_of_br$0,elt)}
      function of_hr(elt){return rebuild_node(cst_of_hr$0,elt)}
      function of_mod(elt){return rebuild_node(cst_of_mod,elt)}
      function of_anchor(elt){return rebuild_node(cst_of_anchor,elt)}
      function of_image(elt){return rebuild_node(cst_of_image,elt)}
      function of_object(elt){return rebuild_node(cst_of_object$0,elt)}
      function of_param(elt){return rebuild_node(cst_of_param$0,elt)}
      function of_area(elt){return rebuild_node(cst_of_area$0,elt)}
      function of_map(elt){return rebuild_node(cst_of_map$0,elt)}
      function of_script(elt){return rebuild_node(cst_of_script$0,elt)}
      function of_embed(elt){return rebuild_node(cst_of_embed$0,elt)}
      function of_tableCell(elt){return rebuild_node(cst_of_tableCell,elt)}
      function of_tableRow(elt){return rebuild_node(cst_of_tableRow,elt)}
      function of_tableCol(elt){return rebuild_node(cst_of_tableCol,elt)}
      function of_tableSection(elt)
       {return rebuild_node(cst_of_tableSection,elt)}
      function of_tableCaption(elt)
       {return rebuild_node(cst_of_tableCaption,elt)}
      function of_table(elt){return rebuild_node(cst_of_table$0,elt)}
      function of_canvas(elt){return rebuild_node(cst_of_canvas$0,elt)}
      function of_iFrame(elt){return rebuild_node(cst_of_iFrame,elt)}
      function of_audio(elt){return rebuild_node(cst_of_audio$0,elt)}
      function of_video(elt){return rebuild_node(cst_of_video$0,elt)}
      return [0,
              of_element,
              of_html,
              of_head,
              of_link,
              of_title,
              of_meta,
              of_base,
              of_style,
              of_body,
              of_form,
              of_optGroup,
              of_option,
              of_select,
              of_input,
              of_textArea,
              of_button,
              of_label,
              of_fieldSet,
              of_legend,
              of_uList,
              of_oList,
              of_dList,
              of_li,
              of_div,
              of_paragraph,
              of_heading,
              of_quote,
              of_pre,
              of_br,
              of_hr,
              of_mod,
              of_anchor,
              of_image,
              of_object,
              of_param,
              of_area,
              of_map,
              of_script,
              of_embed,
              of_tableCell,
              of_tableRow,
              of_tableCol,
              of_tableSection,
              of_tableCaption,
              of_table,
              of_canvas,
              of_iFrame,
              of_audio,
              of_video]}
    var Js_of_ocaml_tyxml_Tyxml_cast=[0,MakeTo,MakeOf];
    caml_register_global
     (250,Js_of_ocaml_tyxml_Tyxml_cast,"Js_of_ocaml_tyxml__Tyxml_cast");
    function uri_of_string(s){return s}
    function string_of_uri(s){return s}
    function attr(name,v){return [0,name,[4,caml_call1(React[2][1],[0,v])]]}
    function float_attrib(name,value){return attr(name,value.toString())}
    function int_attrib(name,value){return attr(name,value.toString())}
    function string_attrib(name,value)
     {return attr(name,caml_jsstring_of_string(value))}
    function space_sep_attrib(name,values)
     {return attr
              (name,caml_jsstring_of_string(caml_call2(String[7],cst,values)))}
    function comma_sep_attrib(name,values)
     {return attr
              (name,
               caml_jsstring_of_string(caml_call2(String[7],cst$0,values)))}
    function event_handler_attrib(name,value){return [0,name,[0,value]]}
    function mouse_event_handler_attrib(name,value){return [0,name,[1,value]]}
    function keyboard_event_handler_attrib(name,value)
     {return [0,name,[2,value]]}
    function touch_event_handler_attrib(name,value){return [0,name,[3,value]]}
    function uri_attrib(name,value)
     {return attr(name,caml_jsstring_of_string(value))}
    function uris_attrib(name,values)
     {return attr
              (name,
               caml_jsstring_of_string(caml_call2(String[7],cst$1,values)))}
    function empty(param)
     {return Js_of_ocaml_Dom_html[2].createDocumentFragment()}
    function comment(c)
     {return Js_of_ocaml_Dom_html[2].createComment(caml_jsstring_of_string(c))}
    function pcdata(s)
     {return Js_of_ocaml_Dom_html[2].createTextNode
              (caml_jsstring_of_string(s))}
    function encodedpcdata(s)
     {return Js_of_ocaml_Dom_html[2].createTextNode
              (caml_jsstring_of_string(s))}
    function string_fold(s,pos,init,f)
     {var r=[0,init],_P_=caml_ml_string_length(s) - 1 | 0;
      if(! (_P_ < pos))
       {var i=pos;
        for(;;)
         {var c=caml_string_get(s,i);
          r[1] = caml_call2(f,r[1],c);
          var _Q_=i + 1 | 0;
          if(_P_ !== i){var i=_Q_;continue}
          break}}
      return r[1]}
    function invalid_entity(e)
     {var _O_=caml_call2(Stdlib_printf[4],_a_,e);
      return caml_call1(Stdlib[2],_O_)}
    function parse_int(pos,base,e)
     {return string_fold
              (e,
               pos,
               0,
               function(acc,x)
                {var switch$0=0;
                 if(65 <= x)
                  if(97 <= x)
                   if(103 <= x)
                    switch$0 = 1;
                   else
                    var match=[0,(x - 97 | 0) + 10 | 0];
                  else
                   if(71 <= x)
                    switch$0 = 1;
                   else
                    var match=[0,(x - 65 | 0) + 10 | 0];
                 else
                  {var switcher=x - 48 | 0;
                   if(9 < switcher >>> 0)
                    switch$0 = 1;
                   else
                    var match=[0,x - 48 | 0]}
                 if(switch$0)var match=0;
                 if(match)
                  {var d=match[1];
                   if(caml_call2(symbol$5,d,base))
                    return runtime.caml_mul(acc,base) + d | 0}
                 return invalid_entity(e)})}
    function entity(e)
     {var len=caml_ml_string_length(e),switch$0=0;
      if(caml_call2(symbol$10,len,1))
       {var _I_=caml_string_get(e,0);
        if(caml_call2(Char[8],_I_,35))
         {var switch$1=0;
          if(caml_call2(symbol$10,len,2))
           {var _J_=caml_string_get(e,1),switch$2=0;
            if(! caml_call2(Char[8],_J_,120))
             {var _K_=caml_string_get(e,1);
              if(! caml_call2(Char[8],_K_,88))switch$2 = 1}
            if(! switch$2){var i=parse_int(2,16,e);switch$1 = 1}}
          if(! switch$1)var i=parse_int(1,10,e);
          var str=Js_of_ocaml_Js[9].fromCharCode(i)}
        else
         switch$0 = 1}
      else
       switch$0 = 1;
      if(switch$0)
       if
        (string_fold
          (e,
           0,
           1,
           function(acc,x)
            {if(acc)
              {var _N_=x - 48 | 0,switch$0=0;
               if(42 < _N_ >>> 0)
                {if(! (25 < (_N_ - 49 | 0) >>> 0))switch$0 = 1}
               else
                if(6 < (_N_ - 10 | 0) >>> 0)switch$0 = 1;
               return switch$0?1:0}
             return acc}))
        if(caml_string_notequal(e,cst$2))
         if(caml_string_notequal(e,cst_amp))
          if(caml_string_notequal(e,cst_apos))
           if(caml_string_notequal(e,cst_gt))
            if(caml_string_notequal(e,cst_lt))
             if(caml_string_notequal(e,cst_quot))
              var
               _L_=caml_call2(Stdlib[28],e,cst$3),
               _M_=caml_jsstring_of_string(caml_call2(Stdlib[28],cst$4,_L_)),
               str=caml_call1(Js_of_ocaml_Dom_html[122],_M_);
             else
              var str='"';
            else
             var str="<";
           else
            var str=">";
          else
           var str="'";
         else
          var str="&";
        else
         var str=invalid_entity(e);
       else
        var str=invalid_entity(e);
      return Js_of_ocaml_Dom_html[2].createTextNode(str)}
    function get_prop(node,name)
     {return caml_call1(Js_of_ocaml_Js[6][5],node[name])?[0,name]:0}
    function iter_prop_protected(node,name,f)
     {var match=get_prop(node,name);
      if(match)
       {var n=match[1];
        try {var _G_=caml_call1(f,n);return _G_}catch(_H_){return 0}}
      return 0}
    function attach_attribs(node,l)
     {function _E_(param)
       {var att=param[2],n=param[1],n$0=caml_jsstring_of_string(n);
        switch(att[0])
         {case 0:
           var h=att[1];
           return node[n$0] = function(ev){return ! ! caml_call1(h,ev)};
          case 1:
           var h$0=att[1];
           return node[n$0] = function(ev){return ! ! caml_call1(h$0,ev)};
          case 2:
           var h$1=att[1];
           return node[n$0] = function(ev){return ! ! caml_call1(h$1,ev)};
          case 3:
           var h$2=att[1];
           return node[n$0] = function(ev){return ! ! caml_call1(h$2,ev)};
          default:
           var
            a=att[1],
            _F_=
             function(param)
              {if(param)
                {var v=param[1];
                 node.setAttribute(n$0,v);
                 return caml_string_notequal(n,cst_style)
                         ?iter_prop_protected
                           (node,n$0,function(name){return node[name] = v})
                         :node.style.cssText = v}
               node.removeAttribute(n$0);
               return caml_string_notequal(n,cst_style$0)
                       ?iter_prop_protected
                         (node,
                          n$0,
                          function(name){return node[name] = Js_of_ocaml_Js[1]})
                       :node.style.cssText = ""};
           caml_call3(React[2][11],0,_F_,a);
           return 0}}
      return caml_call2(Stdlib_list[15],_E_,l)}
    function leaf(opt,name)
     {if(opt)var sth=opt[1],a=sth;else var a=0;
      var
       e=
        Js_of_ocaml_Dom_html[2].createElement(caml_jsstring_of_string(name));
      attach_attribs(e,a);
      return e}
    function node(opt,name,children)
     {if(opt)var sth=opt[1],a=sth;else var a=0;
      var
       e=
        Js_of_ocaml_Dom_html[2].createElement(caml_jsstring_of_string(name));
      attach_attribs(e,a);
      function _D_(c){e.appendChild(c);return 0}
      caml_call2(Stdlib_list[15],_D_,children);
      return e}
    function cdata(s){return pcdata(s)}
    function cdata_script(s){return cdata(s)}
    function cdata_style(s){return cdata(s)}
    function leaf$0(opt,name)
     {if(opt)var sth=opt[1],a=sth;else var a=0;
      var
       e=
        Js_of_ocaml_Dom_html[2].createElementNS
         (Js_of_ocaml_Dom_svg[1],caml_jsstring_of_string(name));
      attach_attribs(e,a);
      return e}
    function node$0(opt,name,children)
     {if(opt)var sth=opt[1],a=sth;else var a=0;
      var
       e=
        Js_of_ocaml_Dom_html[2].createElementNS
         (Js_of_ocaml_Dom_svg[1],caml_jsstring_of_string(name));
      attach_attribs(e,a);
      function _C_(c){e.appendChild(c);return 0}
      caml_call2(Stdlib_list[15],_C_,children);
      return e}
    var
     Svg=
      caml_call1
       (Svg_f[1],
        [0,
         Xml_wrap[1],
         string_of_uri,
         uri_of_string,
         float_attrib,
         int_attrib,
         string_attrib,
         space_sep_attrib,
         comma_sep_attrib,
         event_handler_attrib,
         mouse_event_handler_attrib,
         keyboard_event_handler_attrib,
         touch_event_handler_attrib,
         uri_attrib,
         uris_attrib,
         empty,
         comment,
         pcdata,
         encodedpcdata,
         entity,
         leaf$0,
         node$0,
         cdata,
         cdata_script,
         cdata_style]),
     _b_=
      [0,
       Svg[2],
       Svg[3],
       Svg[4],
       Svg[5],
       Svg[6],
       Svg[7],
       Svg[8],
       Svg[9],
       Svg[10],
       Svg[11],
       Svg[12],
       Svg[13],
       Svg[14],
       Svg[15],
       Svg[16],
       Svg[17],
       Svg[18],
       Svg[19],
       Svg[20],
       Svg[21],
       Svg[22],
       Svg[23],
       Svg[24],
       Svg[25],
       Svg[26],
       Svg[27],
       Svg[28],
       Svg[29],
       Svg[30],
       Svg[31],
       Svg[32],
       Svg[33],
       Svg[34],
       Svg[35],
       Svg[36],
       Svg[37],
       Svg[38],
       Svg[39],
       Svg[40],
       Svg[41],
       Svg[42],
       Svg[43],
       Svg[44],
       Svg[45],
       Svg[46],
       Svg[47],
       Svg[48],
       Svg[49],
       Svg[50],
       Svg[51],
       Svg[52],
       Svg[53],
       Svg[54],
       Svg[55],
       Svg[56],
       Svg[57],
       Svg[58],
       Svg[59],
       Svg[60],
       Svg[61],
       Svg[62],
       Svg[63],
       Svg[64],
       Svg[65],
       Svg[66],
       Svg[67],
       Svg[68],
       Svg[69],
       Svg[70],
       Svg[71],
       Svg[72],
       Svg[73],
       Svg[74],
       Svg[75],
       Svg[76],
       Svg[77],
       Svg[78],
       Svg[79],
       Svg[80],
       Svg[81],
       Svg[82],
       Svg[83],
       Svg[84],
       Svg[85],
       Svg[86],
       Svg[87],
       Svg[88],
       Svg[89],
       Svg[90],
       Svg[91],
       Svg[92],
       Svg[93],
       Svg[94],
       Svg[95],
       Svg[96],
       Svg[97],
       Svg[98],
       Svg[99],
       Svg[100],
       Svg[101],
       Svg[102],
       Svg[103],
       Svg[104],
       Svg[105],
       Svg[106],
       Svg[107],
       Svg[108],
       Svg[109],
       Svg[110],
       Svg[111],
       Svg[112],
       Svg[113],
       Svg[114],
       Svg[115],
       Svg[116],
       Svg[117],
       Svg[118],
       Svg[119],
       Svg[120],
       Svg[121],
       Svg[122],
       Svg[123],
       Svg[124],
       Svg[125],
       Svg[126],
       Svg[127],
       Svg[128],
       Svg[129],
       Svg[130],
       Svg[131],
       Svg[132],
       Svg[133],
       Svg[134],
       Svg[135],
       Svg[136],
       Svg[137],
       Svg[138],
       Svg[139],
       Svg[140],
       Svg[141],
       Svg[142],
       Svg[143],
       Svg[144],
       Svg[145],
       Svg[146],
       Svg[147],
       Svg[148],
       Svg[149],
       Svg[150],
       Svg[151],
       Svg[152],
       Svg[153],
       Svg[154],
       Svg[155],
       Svg[156],
       Svg[157],
       Svg[158],
       Svg[159],
       Svg[160],
       Svg[161],
       Svg[162],
       Svg[163],
       Svg[164],
       Svg[165],
       Svg[166],
       Svg[167],
       Svg[168],
       Svg[169],
       Svg[170],
       Svg[171],
       Svg[172],
       Svg[173],
       Svg[174],
       Svg[175],
       Svg[176],
       Svg[177],
       Svg[178],
       Svg[179],
       Svg[180],
       Svg[181],
       Svg[182],
       Svg[183],
       Svg[184],
       Svg[185],
       Svg[186],
       Svg[187],
       Svg[188],
       Svg[189],
       Svg[190],
       Svg[191],
       Svg[192],
       Svg[193],
       Svg[194],
       Svg[195],
       Svg[196],
       Svg[197],
       Svg[198],
       Svg[199],
       Svg[200],
       Svg[201],
       Svg[202],
       Svg[203],
       Svg[204],
       Svg[205],
       Svg[206],
       Svg[207],
       Svg[208],
       Svg[209],
       Svg[210],
       Svg[211],
       Svg[212],
       Svg[213],
       Svg[214],
       Svg[215],
       Svg[216],
       Svg[217],
       Svg[218],
       Svg[219],
       Svg[220],
       Svg[221],
       Svg[222],
       Svg[223],
       Svg[224],
       Svg[225],
       Svg[226],
       Svg[227],
       Svg[228],
       Svg[229],
       Svg[230],
       Svg[231],
       Svg[232],
       Svg[233],
       Svg[234],
       Svg[235],
       Svg[236],
       Svg[237],
       Svg[238],
       Svg[239],
       Svg[240],
       Svg[241],
       Svg[242],
       Svg[243],
       Svg[244],
       Svg[245],
       Svg[246],
       Svg[247],
       Svg[248],
       Svg[249],
       Svg[250],
       Svg[251],
       Svg[252],
       Svg[253],
       Svg[254],
       Svg[255],
       Svg[256],
       Svg[257],
       Svg[258],
       Svg[259],
       Svg[260],
       Svg[261],
       Svg[262],
       Svg[263],
       Svg[264],
       Svg[265],
       Svg[266],
       Svg[267],
       Svg[268],
       Svg[269],
       Svg[270],
       Svg[271],
       Svg[272],
       Svg[273],
       Svg[274],
       Svg[275],
       Svg[276],
       Svg[277],
       Svg[278],
       Svg[279],
       Svg[280],
       Svg[281],
       Svg[282],
       Svg[283],
       Svg[284],
       Svg[285],
       Svg[286],
       Svg[287],
       Svg[288],
       Svg[289],
       Svg[290],
       Svg[291],
       Svg[292],
       Svg[293],
       Svg[294],
       Svg[295],
       Svg[296],
       Svg[297],
       Svg[298],
       Svg[299],
       Svg[300],
       Svg[301],
       Svg[302],
       Svg[303],
       Svg[304],
       Svg[305],
       Svg[306],
       Svg[307],
       Svg[308],
       Svg[309],
       Svg[310],
       Svg[311],
       Svg[312],
       Svg[313],
       Svg[314],
       Svg[315],
       Svg[316],
       Svg[317],
       Svg[318],
       Svg[319],
       Svg[320],
       Svg[321],
       Svg[322],
       Svg[323],
       Svg[324],
       Svg[325],
       Svg[326],
       Svg[327],
       Svg[328],
       Svg[329],
       Svg[330]],
     Html=
      caml_call1
       (caml_call1
         (Html_f[1],
          [0,
           Xml_wrap[1],
           string_of_uri,
           uri_of_string,
           float_attrib,
           int_attrib,
           string_attrib,
           space_sep_attrib,
           comma_sep_attrib,
           event_handler_attrib,
           mouse_event_handler_attrib,
           keyboard_event_handler_attrib,
           touch_event_handler_attrib,
           uri_attrib,
           uris_attrib,
           empty,
           comment,
           pcdata,
           encodedpcdata,
           entity,
           leaf,
           node,
           cdata,
           cdata_script,
           cdata_style]),
        _b_),
     elt=Html[337],
     To_dom=MakeTo([0,elt]),
     elt$0=Html[335],
     Of_dom=MakeOf([0,elt$0]);
    function add_to(opt,node,content)
     {if(opt)var sth=opt[1],keep=sth;else var keep=1;
      if(1 - keep)
       {var l=node.childNodes,_w_=l.length - 1 | 0,_v_=0;
        if(! (_w_ < 0))
         {var i=_v_;
          for(;;)
           {var _x_=function(x){node.removeChild(x);return 0},_y_=l.item(i);
            caml_call2(Js_of_ocaml_Js[5][6],_y_,_x_);
            var _z_=i + 1 | 0;
            if(_w_ !== i){var i=_z_;continue}
            break}}}
      function _A_(x)
       {var _B_=caml_call1(To_dom[1],x);
        return caml_call2(Js_of_ocaml_Dom[5],node,_B_)}
      return caml_call2(Stdlib_list[15],_A_,content)}
    function id(keep,id,content)
     {var node=caml_call1(Js_of_ocaml_Dom_html[6],id);
      return add_to(keep,node,content)}
    function body(keep,content)
     {return add_to(keep,Js_of_ocaml_Dom_html[2].body,content)}
    function head(keep,content)
     {return add_to(keep,Js_of_ocaml_Dom_html[2].head,content)}
    function html(head,body)
     {if(head)
       {var h=head[1],_t_=caml_call1(To_dom[5],h);
        Js_of_ocaml_Dom_html[2].head = _t_}
      var _u_=caml_call1(To_dom[11],body);
      Js_of_ocaml_Dom_html[2].body = _u_;
      return 0}
    var return$0=React[2][1];
    function fmap(f){return caml_call2(React[2][11],0,f)}
    function nil(param){return ReactiveData[1][1]}
    var singleton=ReactiveData[1][24];
    function cons(x,xs)
     {var _s_=caml_call1(singleton,x);
      return caml_call2(ReactiveData[1][25],_s_,xs)}
    function map$0(f){return caml_call1(ReactiveData[1][9],f)}
    function append(x,y){return caml_call2(ReactiveData[1][25],x,y)}
    function insertAt(dom,i,x)
     {var nodes=dom.childNodes;
      if(caml_call2(symbol$6,i,nodes.length))
       return caml_call2(symbol$8,i,nodes.length)
               ?(dom.appendChild(x),0)
               :(dom.insertBefore(x,nodes.item(i)),0);
      throw [0,Assert_failure,_c_]}
    function removeChildren(dom)
     {for(;;)
       {var match=caml_call1(Js_of_ocaml_Js[5][10],dom.lastChild);
        if(match){var c=match[1];dom.removeChild(c);continue}
        return 0}}
    function update_children(dom,nodes)
     {removeChildren(dom);
      var _j_=0;
      function _k_(param,msg)
       {if(0 === msg[0])
         {var
           p=msg[1],
           _l_=
            function(p)
             {switch(p[0])
               {case 0:
                 var
                  x=p[2],
                  i=p[1],
                  i$0=
                   caml_call2(symbol$5,i,0)
                    ?(dom.childNodes.length + 1 | 0) + i | 0
                    :i;
                 return insertAt(dom,i$0,x);
                case 1:
                 var
                  i$1=p[1],
                  i$2=
                   caml_call2(symbol$5,i$1,0)
                    ?dom.childNodes.length + i$1 | 0
                    :i$1,
                  nodes=dom.childNodes;
                 if
                  (caml_call2(symbol$10,i$2,0)
                   &&
                   caml_call2(symbol$5,i$2,nodes.length))
                  {var
                    _n_=function(n){return caml_call2(Js_of_ocaml_Dom[4],dom,n)},
                    _o_=nodes.item(i$2);
                   return caml_call2(Js_of_ocaml_Js[5][6],_o_,_n_)}
                 throw [0,Assert_failure,_d_];
                case 2:
                 var
                  x$0=p[2],
                  i$3=p[1],
                  i$4=
                   caml_call2(symbol$5,i$3,0)
                    ?dom.childNodes.length + i$3 | 0
                    :i$3,
                  _p_=dom.childNodes.item(i$4),
                  match=caml_call1(Js_of_ocaml_Js[5][10],_p_);
                 if(match)
                  {var old=match[1];dom.replaceChild(x$0,old);return 0}
                 throw [0,Assert_failure,_e_];
                default:
                 var
                  move=p[2],
                  i$5=p[1],
                  i$6=
                   caml_call2(symbol$5,i$5,0)
                    ?dom.childNodes.length + i$5 | 0
                    :i$5;
                 if(caml_call2(symbol$8,move,0))return 0;
                 var
                  _q_=dom.childNodes.item(i$6),
                  match$0=caml_call1(Js_of_ocaml_Js[5][10],_q_);
                 if(match$0)
                  {var
                    i$7=match$0[1],
                    _r_=caml_call2(symbol$9,move,0)?move + 1 | 0:move;
                   return insertAt(dom,i$6 + _r_ | 0,i$7)}
                 throw [0,Assert_failure,_f_]}};
          return caml_call2(Stdlib_list[15],_l_,p)}
        var l=msg[1];
        removeChildren(dom);
        function _m_(l){dom.appendChild(l);return 0}
        return caml_call2(Stdlib_list[15],_m_,l)}
      caml_call3(ReactiveData[1][11],_k_,nodes,_j_);
      return 0}
    function filter_attrib(param,on)
     {var a=param[2],name=param[1];
      if(4 === a[0])
       {var a$0=a[1],_i_=function(on,a){return on?a:0};
        return [0,name,[4,caml_call4(React[2][27],0,_i_,on,a$0)]]}
      throw [0,Stdlib[6],cst_filter_attrib_not_implemen]}
    function attr$0(name,f,s)
     {var a=caml_call1(fmap(f),s);return [0,name,[4,a]]}
    function float_attrib$0(name,s)
     {return attr$0(name,function(f){return [0,f.toString()]},s)}
    function int_attrib$0(name,s)
     {return attr$0(name,function(f){return [0,f.toString()]},s)}
    function string_attrib$0(name,s)
     {return attr$0(name,function(f){return [0,caml_jsstring_of_string(f)]},s)}
    function space_sep_attrib$0(name,s)
     {return attr$0
              (name,
               function(f)
                {return [0,
                         caml_jsstring_of_string(caml_call2(String[7],cst$5,f))]},
               s)}
    function comma_sep_attrib$0(name,s)
     {return attr$0
              (name,
               function(f)
                {return [0,
                         caml_jsstring_of_string(caml_call2(String[7],cst$6,f))]},
               s)}
    function event_handler_attrib$0(name,s)
     {return event_handler_attrib(name,s)}
    function mouse_event_handler_attrib$0(name,s)
     {return mouse_event_handler_attrib(name,s)}
    function keyboard_event_handler_attrib$0(name,s)
     {return keyboard_event_handler_attrib(name,s)}
    function touch_event_handler_attrib$0(name,s)
     {return touch_event_handler_attrib(name,s)}
    function uri_attrib$0(name,s)
     {return attr$0(name,function(f){return [0,caml_jsstring_of_string(f)]},s)}
    function uris_attrib$0(name,s)
     {return attr$0
              (name,
               function(f)
                {return [0,
                         caml_jsstring_of_string(caml_call2(String[7],cst$7,f))]},
               s)}
    function pcdata$0(s)
     {var e=Js_of_ocaml_Dom_html[2].createTextNode("");
      function _h_(s){return e.data = caml_jsstring_of_string(s)}
      caml_call3(React[2][11],0,_h_,s);
      return e}
    function encodedpcdata$0(s){return pcdata$0(s)}
    function entity$0(s){return entity(s)}
    function node$1(opt,name,l)
     {if(opt)var sth=opt[1],a=sth;else var a=0;
      var
       e=
        Js_of_ocaml_Dom_html[2].createElement(caml_jsstring_of_string(name));
      attach_attribs(e,a);
      update_children(e,l);
      return e}
    function node$2(opt,name,l)
     {if(opt)var sth=opt[1],a=sth;else var a=0;
      var
       e=
        Js_of_ocaml_Dom_html[2].createElementNS
         (Js_of_ocaml_Dom_svg[1],caml_jsstring_of_string(name));
      attach_attribs(e,a);
      update_children(e,l);
      return e}
    var
     Svg$0=
      caml_call1
       (Svg_f[1],
        [0,
         [0,return$0,fmap,nil,singleton,cons,append,map$0],
         string_of_uri,
         uri_of_string,
         float_attrib$0,
         int_attrib$0,
         string_attrib$0,
         space_sep_attrib$0,
         comma_sep_attrib$0,
         event_handler_attrib$0,
         mouse_event_handler_attrib$0,
         keyboard_event_handler_attrib$0,
         touch_event_handler_attrib$0,
         uri_attrib$0,
         uris_attrib$0,
         empty,
         comment,
         pcdata$0,
         encodedpcdata$0,
         entity$0,
         leaf$0,
         node$2,
         cdata,
         cdata_script,
         cdata_style]),
     _g_=
      [0,
       Svg$0[2],
       Svg$0[3],
       Svg$0[4],
       Svg$0[5],
       Svg$0[6],
       Svg$0[7],
       Svg$0[8],
       Svg$0[9],
       Svg$0[10],
       Svg$0[11],
       Svg$0[12],
       Svg$0[13],
       Svg$0[14],
       Svg$0[15],
       Svg$0[16],
       Svg$0[17],
       Svg$0[18],
       Svg$0[19],
       Svg$0[20],
       Svg$0[21],
       Svg$0[22],
       Svg$0[23],
       Svg$0[24],
       Svg$0[25],
       Svg$0[26],
       Svg$0[27],
       Svg$0[28],
       Svg$0[29],
       Svg$0[30],
       Svg$0[31],
       Svg$0[32],
       Svg$0[33],
       Svg$0[34],
       Svg$0[35],
       Svg$0[36],
       Svg$0[37],
       Svg$0[38],
       Svg$0[39],
       Svg$0[40],
       Svg$0[41],
       Svg$0[42],
       Svg$0[43],
       Svg$0[44],
       Svg$0[45],
       Svg$0[46],
       Svg$0[47],
       Svg$0[48],
       Svg$0[49],
       Svg$0[50],
       Svg$0[51],
       Svg$0[52],
       Svg$0[53],
       Svg$0[54],
       Svg$0[55],
       Svg$0[56],
       Svg$0[57],
       Svg$0[58],
       Svg$0[59],
       Svg$0[60],
       Svg$0[61],
       Svg$0[62],
       Svg$0[63],
       Svg$0[64],
       Svg$0[65],
       Svg$0[66],
       Svg$0[67],
       Svg$0[68],
       Svg$0[69],
       Svg$0[70],
       Svg$0[71],
       Svg$0[72],
       Svg$0[73],
       Svg$0[74],
       Svg$0[75],
       Svg$0[76],
       Svg$0[77],
       Svg$0[78],
       Svg$0[79],
       Svg$0[80],
       Svg$0[81],
       Svg$0[82],
       Svg$0[83],
       Svg$0[84],
       Svg$0[85],
       Svg$0[86],
       Svg$0[87],
       Svg$0[88],
       Svg$0[89],
       Svg$0[90],
       Svg$0[91],
       Svg$0[92],
       Svg$0[93],
       Svg$0[94],
       Svg$0[95],
       Svg$0[96],
       Svg$0[97],
       Svg$0[98],
       Svg$0[99],
       Svg$0[100],
       Svg$0[101],
       Svg$0[102],
       Svg$0[103],
       Svg$0[104],
       Svg$0[105],
       Svg$0[106],
       Svg$0[107],
       Svg$0[108],
       Svg$0[109],
       Svg$0[110],
       Svg$0[111],
       Svg$0[112],
       Svg$0[113],
       Svg$0[114],
       Svg$0[115],
       Svg$0[116],
       Svg$0[117],
       Svg$0[118],
       Svg$0[119],
       Svg$0[120],
       Svg$0[121],
       Svg$0[122],
       Svg$0[123],
       Svg$0[124],
       Svg$0[125],
       Svg$0[126],
       Svg$0[127],
       Svg$0[128],
       Svg$0[129],
       Svg$0[130],
       Svg$0[131],
       Svg$0[132],
       Svg$0[133],
       Svg$0[134],
       Svg$0[135],
       Svg$0[136],
       Svg$0[137],
       Svg$0[138],
       Svg$0[139],
       Svg$0[140],
       Svg$0[141],
       Svg$0[142],
       Svg$0[143],
       Svg$0[144],
       Svg$0[145],
       Svg$0[146],
       Svg$0[147],
       Svg$0[148],
       Svg$0[149],
       Svg$0[150],
       Svg$0[151],
       Svg$0[152],
       Svg$0[153],
       Svg$0[154],
       Svg$0[155],
       Svg$0[156],
       Svg$0[157],
       Svg$0[158],
       Svg$0[159],
       Svg$0[160],
       Svg$0[161],
       Svg$0[162],
       Svg$0[163],
       Svg$0[164],
       Svg$0[165],
       Svg$0[166],
       Svg$0[167],
       Svg$0[168],
       Svg$0[169],
       Svg$0[170],
       Svg$0[171],
       Svg$0[172],
       Svg$0[173],
       Svg$0[174],
       Svg$0[175],
       Svg$0[176],
       Svg$0[177],
       Svg$0[178],
       Svg$0[179],
       Svg$0[180],
       Svg$0[181],
       Svg$0[182],
       Svg$0[183],
       Svg$0[184],
       Svg$0[185],
       Svg$0[186],
       Svg$0[187],
       Svg$0[188],
       Svg$0[189],
       Svg$0[190],
       Svg$0[191],
       Svg$0[192],
       Svg$0[193],
       Svg$0[194],
       Svg$0[195],
       Svg$0[196],
       Svg$0[197],
       Svg$0[198],
       Svg$0[199],
       Svg$0[200],
       Svg$0[201],
       Svg$0[202],
       Svg$0[203],
       Svg$0[204],
       Svg$0[205],
       Svg$0[206],
       Svg$0[207],
       Svg$0[208],
       Svg$0[209],
       Svg$0[210],
       Svg$0[211],
       Svg$0[212],
       Svg$0[213],
       Svg$0[214],
       Svg$0[215],
       Svg$0[216],
       Svg$0[217],
       Svg$0[218],
       Svg$0[219],
       Svg$0[220],
       Svg$0[221],
       Svg$0[222],
       Svg$0[223],
       Svg$0[224],
       Svg$0[225],
       Svg$0[226],
       Svg$0[227],
       Svg$0[228],
       Svg$0[229],
       Svg$0[230],
       Svg$0[231],
       Svg$0[232],
       Svg$0[233],
       Svg$0[234],
       Svg$0[235],
       Svg$0[236],
       Svg$0[237],
       Svg$0[238],
       Svg$0[239],
       Svg$0[240],
       Svg$0[241],
       Svg$0[242],
       Svg$0[243],
       Svg$0[244],
       Svg$0[245],
       Svg$0[246],
       Svg$0[247],
       Svg$0[248],
       Svg$0[249],
       Svg$0[250],
       Svg$0[251],
       Svg$0[252],
       Svg$0[253],
       Svg$0[254],
       Svg$0[255],
       Svg$0[256],
       Svg$0[257],
       Svg$0[258],
       Svg$0[259],
       Svg$0[260],
       Svg$0[261],
       Svg$0[262],
       Svg$0[263],
       Svg$0[264],
       Svg$0[265],
       Svg$0[266],
       Svg$0[267],
       Svg$0[268],
       Svg$0[269],
       Svg$0[270],
       Svg$0[271],
       Svg$0[272],
       Svg$0[273],
       Svg$0[274],
       Svg$0[275],
       Svg$0[276],
       Svg$0[277],
       Svg$0[278],
       Svg$0[279],
       Svg$0[280],
       Svg$0[281],
       Svg$0[282],
       Svg$0[283],
       Svg$0[284],
       Svg$0[285],
       Svg$0[286],
       Svg$0[287],
       Svg$0[288],
       Svg$0[289],
       Svg$0[290],
       Svg$0[291],
       Svg$0[292],
       Svg$0[293],
       Svg$0[294],
       Svg$0[295],
       Svg$0[296],
       Svg$0[297],
       Svg$0[298],
       Svg$0[299],
       Svg$0[300],
       Svg$0[301],
       Svg$0[302],
       Svg$0[303],
       Svg$0[304],
       Svg$0[305],
       Svg$0[306],
       Svg$0[307],
       Svg$0[308],
       Svg$0[309],
       Svg$0[310],
       Svg$0[311],
       Svg$0[312],
       Svg$0[313],
       Svg$0[314],
       Svg$0[315],
       Svg$0[316],
       Svg$0[317],
       Svg$0[318],
       Svg$0[319],
       Svg$0[320],
       Svg$0[321],
       Svg$0[322],
       Svg$0[323],
       Svg$0[324],
       Svg$0[325],
       Svg$0[326],
       Svg$0[327],
       Svg$0[328],
       Svg$0[329],
       Svg$0[330]],
     Html$0=
      caml_call1
       (caml_call1
         (Html_f[1],
          [0,
           [0,return$0,fmap,nil,singleton,cons,append,map$0],
           string_of_uri,
           uri_of_string,
           float_attrib$0,
           int_attrib$0,
           string_attrib$0,
           space_sep_attrib$0,
           comma_sep_attrib$0,
           event_handler_attrib$0,
           mouse_event_handler_attrib$0,
           keyboard_event_handler_attrib$0,
           touch_event_handler_attrib$0,
           uri_attrib$0,
           uris_attrib$0,
           empty,
           comment,
           pcdata$0,
           encodedpcdata$0,
           entity$0,
           leaf,
           node$1,
           cdata,
           cdata_script,
           cdata_style]),
        _g_),
     Js_of_ocaml_tyxml_Tyxml_js=
      [0,
       [0,
        Xml_wrap[1],
        string_of_uri,
        uri_of_string,
        float_attrib,
        int_attrib,
        string_attrib,
        space_sep_attrib,
        comma_sep_attrib,
        event_handler_attrib,
        mouse_event_handler_attrib,
        keyboard_event_handler_attrib,
        touch_event_handler_attrib,
        uri_attrib,
        uris_attrib,
        empty,
        comment,
        pcdata,
        encodedpcdata,
        entity,
        leaf,
        node,
        cdata,
        cdata_script,
        cdata_style],
       Svg,
       Html,
       Html,
       [0,html,body,head,id],
       [0,return$0,fmap,nil,singleton,cons,append,map$0],
       [0,update_children],
       [0,
        [0,
         [0,return$0,fmap,nil,singleton,cons,append,map$0],
         string_of_uri,
         uri_of_string,
         float_attrib$0,
         int_attrib$0,
         string_attrib$0,
         space_sep_attrib$0,
         comma_sep_attrib$0,
         event_handler_attrib$0,
         mouse_event_handler_attrib$0,
         keyboard_event_handler_attrib$0,
         touch_event_handler_attrib$0,
         uri_attrib$0,
         uris_attrib$0,
         empty,
         comment,
         pcdata$0,
         encodedpcdata$0,
         entity$0,
         leaf,
         node$1,
         cdata,
         cdata_script,
         cdata_style],
        Svg$0,
        Html$0,
        filter_attrib,
        Html$0],
       To_dom,
       Of_dom];
    caml_register_global
     (264,Js_of_ocaml_tyxml_Tyxml_js,"Js_of_ocaml_tyxml__Tyxml_js");
    var Js_of_ocaml_tyxml$0=[0];
    caml_register_global(265,Js_of_ocaml_tyxml$0,"Js_of_ocaml_tyxml");
    return}
  (function(){return this}()));


//# 1 "../../.js/base64/base64.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_set16=runtime.caml_bytes_set16,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_get16=runtime.caml_string_get16,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Length_of_alphabet_must_be=
      caml_string_of_jsbytes("Length of alphabet must be 64"),
     cst_Alphabet_can_not_contain_p=
      caml_string_of_jsbytes("Alphabet can not contain padding character"),
     cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ=
      caml_string_of_jsbytes
       ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),
     cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ$0=
      caml_string_of_jsbytes
       ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),
     cst_Base64_Out_of_bounds=caml_string_of_jsbytes("Base64.Out_of_bounds"),
     cst_Base64_Too_much_input=caml_string_of_jsbytes("Base64.Too_much_input"),
     Stdlib=global_data.Stdlib,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Assert_failure=global_data.Assert_failure,
     Stdlib_format=global_data.Stdlib__format,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib_sys=global_data.Stdlib__sys,
     Base64=[0];
    caml_register_global(12,Base64,"Base64__");
    var Base64_Unsafe=[0];
    caml_register_global(13,Base64_Unsafe,"Base64__Unsafe");
    var
     _e_=
      [0,
       [11,caml_string_of_jsbytes("Invalid bounds"),0],
       caml_string_of_jsbytes("Invalid bounds")],
     _f_=
      [0,
       [11,caml_string_of_jsbytes("Wrong padding"),0],
       caml_string_of_jsbytes("Wrong padding")],
     _g_=
      [0,
       [11,caml_string_of_jsbytes("Malformed input"),0],
       caml_string_of_jsbytes("Malformed input")],
     _h_=
      [0,
       [11,caml_string_of_jsbytes("Too much input"),0],
       caml_string_of_jsbytes("Too much input")],
     _c_=[0,caml_string_of_jsbytes("src/base64.ml"),135,15],
     _b_=
      [0,
       [11,caml_string_of_jsbytes("Invalid bounds"),0],
       caml_string_of_jsbytes("Invalid bounds")];
    function symbol(x,y)
     {if(y < 1)throw Stdlib[13];
      return 0 < x?1 + runtime.caml_div(x - 1 | 0,y) | 0:0}
    function unsafe_set_uint8(t,off,v)
     {runtime.caml_bytes_unsafe_set(t,off,caml_call1(Stdlib_char[1],v));
      return 0}
    function make_alphabet(alphabet)
     {if(64 !== caml_ml_string_length(alphabet))
       caml_call1(Stdlib[1],cst_Length_of_alphabet_must_be);
      if(caml_call2(Stdlib_string[22],alphabet,61))
       caml_call1(Stdlib[1],cst_Alphabet_can_not_contain_p);
      function _z_(i){return runtime.caml_string_get(alphabet,i)}
      var
       emap=caml_call2(Stdlib_array[2],caml_ml_string_length(alphabet),_z_),
       dmap=runtime.caml_make_vect(256,-1);
      function _A_(idx,chr)
       {runtime.caml_check_bound(dmap,chr)[1 + chr] = idx;return 0}
      caml_call2(Stdlib_string[9],_A_,alphabet);
      return [0,emap,dmap]}
    function length_alphabet(param){var emap=param[1];return emap.length - 1}
    function alphabet(param){var emap=param[1];return emap}
    var
     default_alphabet=make_alphabet(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ),
     uri_safe_alphabet=make_alphabet(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ$0),
     unsafe_set_be_uint16=
      Stdlib_sys[11]
       ?caml_bytes_set16
       :function(t,off,v)
         {return caml_bytes_set16(t,off,runtime.caml_bswap16(v))},
     Out_of_bounds=[248,cst_Base64_Out_of_bounds,caml_fresh_oo_id(0)],
     Too_much_input=[248,cst_Base64_Too_much_input,caml_fresh_oo_id(0)];
    function get_uint8(t,off)
     {var _x_=off < 0?1:0,_y_=_x_ || (caml_ml_string_length(t) <= off?1:0);
      if(_y_)throw Out_of_bounds;
      return caml_string_unsafe_get(t,off)}
    var padding=61;
    function error_msgf(fmt)
     {function _w_(err){return [1,[0,3854881,err]]}
      return caml_call2(Stdlib_format[133],_w_,fmt)}
    function _a_(pad,param,opt,len,input)
     {var emap=param[1];
      if(opt)var sth=opt[1],off=sth;else var off=0;
      if(len)
       var len$0=len[1],len$1=len$0;
      else
       var len$1=caml_ml_string_length(input) - off | 0;
      if
       (0
        <=
        len$1
        &&
        0
        <=
        off
        &&
        !
        ((caml_ml_string_length(input) - len$1 | 0) < off))
       {var
         n=symbol(len$1,3) * 4 | 0,
         res=caml_create_bytes(n),
         emap$0=function(i){return emap[1 + i]},
         emit=
          function(b1,b2,b3,i)
           {var _u_=emap$0((b1 << 4 | b2 >>> 4 | 0) & 63);
            unsafe_set_be_uint16(res,i,emap$0((b1 >>> 2 | 0) & 63) << 8 | _u_);
            var _v_=emap$0(b3 & 63);
            return unsafe_set_be_uint16
                    (res,
                     i + 2 | 0,
                     emap$0((b2 << 2 | b3 >>> 6 | 0) & 63) << 8 | _v_)},
         j=0,
         i=0;
        for(;;)
         {if(i !== len$1)
           if(i === (len$1 - 1 | 0))
            emit(caml_string_unsafe_get(input,off + i | 0),0,0,j);
           else
            {if(i !== (len$1 - 2 | 0))
              {emit
                (caml_string_unsafe_get(input,off + i | 0),
                 caml_string_unsafe_get(input,(off + i | 0) + 1 | 0),
                 caml_string_unsafe_get(input,(off + i | 0) + 2 | 0),
                 j);
               var i$0=i + 3 | 0,j$0=j + 4 | 0,j=j$0,i=i$0;
               continue}
             emit
              (caml_string_unsafe_get(input,off + i | 0),
               caml_string_unsafe_get(input,(off + i | 0) + 1 | 0),
               0,
               j)}
          var i$3=(3 - (len$1 % 3 | 0) | 0) % 3 | 0;
          if(pad)
           {var i$1=i$3;
            for(;;)
             {if(0 === i$1)
               return [0,[0,caml_call1(Stdlib_bytes[42],res),0,n]];
              unsafe_set_uint8(res,n - i$1 | 0,padding);
              var i$2=i$1 - 1 | 0,i$1=i$2;
              continue}}
          return [0,[0,caml_call1(Stdlib_bytes[42],res),0,n - i$3 | 0]]}}
      return error_msgf(_b_)}
    function encode(opt,_t_,off,len,input)
     {if(opt)var sth=opt[1],pad=sth;else var pad=1;
      if(_t_)
       var sth$0=_t_[1],alphabet=sth$0;
      else
       var alphabet=default_alphabet;
      var err=_a_(pad,alphabet,off,len,input);
      if(0 === err[0])
       {var match=err[1],len$0=match[3],off$0=match[2],res=match[1];
        return [0,caml_call3(Stdlib_string[4],res,off$0,len$0)]}
      return err}
    function encode_string(pad,alphabet,input)
     {var match=encode(pad,alphabet,0,0,input);
      if(0 === match[0]){var res=match[1];return res}
      throw [0,Assert_failure,_c_]}
    function encode_sub(opt,_s_,off,len,input)
     {if(opt)var sth=opt[1],pad=sth;else var pad=1;
      if(_s_)
       var sth$0=_s_[1],alphabet=sth$0;
      else
       var alphabet=default_alphabet;
      return _a_(pad,alphabet,off,len,input)}
    function encode_exn(pad,alphabet,off,len,input)
     {var match=encode(pad,alphabet,off,len,input);
      if(0 === match[0]){var v=match[1];return v}
      var match$0=match[1],err=match$0[2];
      return caml_call1(Stdlib[1],err)}
    function _d_(opt,param,_i_,len,input)
     {var dmap=param[2];
      if(opt)var sth=opt[1],pad=sth;else var pad=1;
      if(_i_)var sth$0=_i_[1],off=sth$0;else var off=0;
      if(len)
       var len$0=len[1],len$1=len$0;
      else
       var len$1=caml_ml_string_length(input) - off | 0;
      if
       (0
        <=
        len$1
        &&
        0
        <=
        off
        &&
        !
        ((caml_ml_string_length(input) - len$1 | 0) < off))
       {var
         n=symbol(len$1,4) * 4 | 0,
         n$0=symbol(n,4) * 3 | 0,
         t=caml_create_bytes(n$0),
         get_uint8_or_padding=
          pad
           ?function(t,i)
             {if(len$1 <= i)throw Out_of_bounds;
              return get_uint8(t,off + i | 0)}
           :function(t,i)
             {try
               {var _q_=i < len$1?get_uint8(t,off + i | 0):padding;return _q_}
              catch(_r_)
               {_r_ = caml_wrap_exception(_r_);
                if(_r_ === Out_of_bounds)return padding;
                throw _r_}},
         emit=
          function(a,b,c,d,j)
           {var x=a << 18 | b << 12 | c << 6 | d,v=x >>> 8 | 0,switch$0=0;
            if(0 <= j && ! (caml_ml_bytes_length(t) < (j + 1 | 0)))
             {var switch$1=0;
              if(0 <= j && ! (caml_ml_bytes_length(t) < (j + 2 | 0)))
               {unsafe_set_be_uint16(t,j,v);switch$1 = 1}
              if(! switch$1)unsafe_set_uint8(t,j,v >>> 8 | 0)}
            else
             switch$0 = 1;
            var v$0=x & 255,off=j + 2 | 0;
            if(0 <= off && ! (caml_ml_bytes_length(t) <= off))
             return unsafe_set_uint8(t,off,v$0);
            return 0},
         dmap$0=
          function(i){var x=dmap[1 + i];if(x === -1)throw Stdlib[8];return x},
         only_padding=
          function(pad,idx)
           {var pad$0=[0,pad + 3 | 0],idx$0=[0,idx];
            for(;;)
             {if((idx$0[1] + 4 | 0) < len$1)
               {var
                 _o_=15677 !== caml_string_get16(input,off + idx$0[1] | 0)?1:0,
                 _p_=
                  _o_
                  ||
                  (15677
                    !==
                    caml_string_get16(input,(off + idx$0[1] | 0) + 2 | 0)
                    ?1
                    :0);
                if(_p_)throw Stdlib[8];
                idx$0[1] = idx$0[1] + 4 | 0;
                pad$0[1] = pad$0[1] + 3 | 0;
                continue}
              for(;;)
               {if(idx$0[1] < len$1)
                 {if(caml_string_unsafe_get(input,off + idx$0[1] | 0) !== 61)
                   throw Stdlib[8];
                  idx$0[1]++;
                  continue}
                return pad$0[1]}}};
        try
         {var j=0,i=0;
          for(;;)
           {if(i === n)
             var pad$5=0;
            else
             {var x=get_uint8_or_padding(input,i + 3 | 0);
              try
               {var pad$4=0,_m_=dmap$0(x),d=_m_,pad$0=pad$4}
              catch(exn$0)
               {exn$0 = caml_wrap_exception(exn$0);
                var switch$0=0;
                if(exn$0 === Stdlib[8] && x === 61)
                 var d=0,pad$0=1;
                else
                 switch$0 = 1;
                if(switch$0)throw exn$0;
                var exn=exn$0}
              var x$0=get_uint8_or_padding(input,i + 2 | 0);
              try
               {var _l_=dmap$0(x$0),c=_l_,pad$1=pad$0}
              catch(exn)
               {exn = caml_wrap_exception(exn);
                var switch$1=0;
                if(exn === Stdlib[8] && x$0 === 61 && 1 === pad$0)
                 {var c=0,pad$1=2;switch$1 = 1}
                if(! switch$1)throw exn;
                var exn$0=exn}
              var x$1=get_uint8_or_padding(input,i + 1 | 0);
              try
               {var _k_=dmap$0(x$1),b=_k_,pad$2=pad$1}
              catch(exn)
               {exn = caml_wrap_exception(exn);
                var switch$2=0;
                if(exn === Stdlib[8] && x$1 === 61 && 2 === pad$1)
                 {var b=0,pad$2=3;switch$2 = 1}
                if(! switch$2)throw exn;
                var exn$1=exn}
              var x$2=get_uint8_or_padding(input,i);
              try
               {var _j_=dmap$0(x$2),a=_j_,pad$3=pad$2}
              catch(exn)
               {exn = caml_wrap_exception(exn);
                var switch$3=0;
                if(exn === Stdlib[8] && x$2 === 61 && 3 === pad$2)
                 {var a=0,pad$3=4;switch$3 = 1}
                if(! switch$3)throw exn;
                var exn$2=exn}
              emit(a,b,c,d,j);
              if((i + 4 | 0) === n)
               var pad$5=0 === pad$3?0:4 === pad$3?3:pad$3;
              else
               {if(0 === pad$3)
                 {var i$0=i + 4 | 0,j$0=j + 3 | 0,j=j$0,i=i$0;continue}
                if(4 === pad$3)
                 var pad$5=only_padding(3,i + 4 | 0);
                else
                 {if(1 === pad)throw Too_much_input;
                  var pad$5=only_padding(pad$3,i + 4 | 0)}}}
            break}}
        catch(_n_)
         {_n_ = caml_wrap_exception(_n_);
          if(_n_ === Out_of_bounds)return error_msgf(_f_);
          if(_n_ === Stdlib[8])return error_msgf(_g_);
          if(_n_ === Too_much_input)return error_msgf(_h_);
          throw _n_}
        return 0 === pad$5
                ?[0,[0,caml_call1(Stdlib_bytes[42],t),0,n$0]]
                :[0,[0,caml_call1(Stdlib_bytes[42],t),0,n$0 - pad$5 | 0]]}
      return error_msgf(_e_)}
    function decode(pad,opt,off,len,input)
     {if(opt)var sth=opt[1],alphabet=sth;else var alphabet=default_alphabet;
      var err=_d_(pad,alphabet,off,len,input);
      if(0 === err[0])
       {var match=err[1],len$0=match[3],off$0=match[2],res=match[1];
        return [0,caml_call3(Stdlib_string[4],res,off$0,len$0)]}
      return err}
    function decode_sub(pad,opt,off,len,input)
     {if(opt)var sth=opt[1],alphabet=sth;else var alphabet=default_alphabet;
      return _d_(pad,alphabet,off,len,input)}
    function decode_exn(pad,alphabet,off,len,input)
     {var match=decode(pad,alphabet,off,len,input);
      if(0 === match[0]){var res=match[1];return res}
      var match$0=match[1],err=match$0[2];
      return caml_call1(Stdlib[1],err)}
    var
     Base64$0=
      [0,
       default_alphabet,
       uri_safe_alphabet,
       make_alphabet,
       length_alphabet,
       alphabet,
       decode_exn,
       decode_sub,
       decode,
       encode,
       encode_string,
       encode_sub,
       encode_exn];
    caml_register_global(22,Base64$0,"Base64");
    return}
  (function(){return this}()));


//# 1 ".app.eobjs/byte/dune__exe__App.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_equal=runtime.caml_equal,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_pick=caml_string_of_jsbytes("pick"),
     cst_Truth=caml_string_of_jsbytes("Truth:"),
     cst_Lie=caml_string_of_jsbytes("Lie:"),
     cst_Error=caml_string_of_jsbytes("Error: "),
     cst$1=caml_string_of_jsbytes("\n"),
     cst$2=caml_string_of_jsbytes("\n"),
     cst$0=caml_string_of_jsbytes(""),
     liesInput=caml_string_of_jsbytes("liesInput"),
     lieCodeInput=caml_string_of_jsbytes("lieCodeInput"),
     truthsInput=caml_string_of_jsbytes("truthsInput"),
     cst=caml_string_of_jsbytes(""),
     cst_Lie_code_to_send_click_to_=
      caml_string_of_jsbytes("Lie code to send: (click to select all)"),
     cst_Encode=caml_string_of_jsbytes("Encode"),
     cst$3=caml_string_of_jsbytes(""),
     cst_Lie_s_to_send_newline_sepa=
      caml_string_of_jsbytes("Lie(s) to send, newline-separated:"),
     cst_Would_I_Lie_to_You=caml_string_of_jsbytes("Would I Lie to You?"),
     cst_Lie_code_you_received=
      caml_string_of_jsbytes("Lie code you received:"),
     cst$4=caml_string_of_jsbytes(""),
     cst_Truth_s_about_yourself_new=
      caml_string_of_jsbytes("Truth(s) about yourself, newline-separated:"),
     cst_app=caml_string_of_jsbytes("app"),
     Stdlib=global_data.Stdlib,
     Js_of_ocaml_tyxml_Tyxml_js=global_data.Js_of_ocaml_tyxml__Tyxml_js,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_random=global_data.Stdlib__random,
     Js_of_ocaml_Dom_html=global_data.Js_of_ocaml__Dom_html,
     Js_of_ocaml_Js=global_data.Js_of_ocaml__Js,
     Base64=global_data.Base64,
     React=global_data.React,
     ReactiveData=global_data.ReactiveData,
     Js_of_ocaml_Dom=global_data.Js_of_ocaml__Dom,
     Ids=[0,liesInput,lieCodeInput,truthsInput],
     _Q_=[0,caml_string_of_jsbytes("text-danger"),0],
     _i_=[0,caml_string_of_jsbytes(""),0],
     _k_=[0,caml_string_of_jsbytes(""),0],
     _j_=
      [1,
       caml_string_of_jsbytes
        ("You must input at least one truth and at least one lie.")],
     _f_=[0,0],
     _m_=
      [0,
       caml_string_of_jsbytes("user-select-all"),
       [0,
        caml_string_of_jsbytes("bg-light"),
        [0,
         caml_string_of_jsbytes("rounded"),
         [0,
          caml_string_of_jsbytes("p-3"),
          [0,caml_string_of_jsbytes("overflow-auto"),0]]]]],
     _u_=
      [0,
       caml_string_of_jsbytes("btn"),
       [0,caml_string_of_jsbytes("btn-primary"),0]],
     _x_=[0,caml_string_of_jsbytes("input-group-append"),0],
     _C_=[0,caml_string_of_jsbytes("form-control"),0],
     _G_=[0,caml_string_of_jsbytes("input-group"),0],
     _M_=[0,caml_string_of_jsbytes("my-3"),0],
     _S_=
      [0,
       caml_string_of_jsbytes("bg-light"),
       [0,
        caml_string_of_jsbytes("rounded"),
        [0,caml_string_of_jsbytes("p-3"),0]]],
     _Y_=
      [0,
       caml_string_of_jsbytes("btn"),
       [0,caml_string_of_jsbytes("btn-primary"),0]],
     _$_=
      [0,
       caml_string_of_jsbytes("m-3"),
       [0,caml_string_of_jsbytes("text-center"),0]],
     _ac_=[0,caml_string_of_jsbytes("form-control"),0],
     _al_=[0,caml_string_of_jsbytes("form-control"),0],
     _as_=[0,caml_string_of_jsbytes("my-3"),0],
     _a_=Base64[10],
     _b_=[0,Base64[2]];
    function encode(_aR_){return caml_call2(_a_,_aR_,_b_)}
    var _c_=Base64[6],_d_=[0,Base64[2]];
    function decode(_aQ_){return caml_call2(_c_,_aQ_,_d_)}
    var
     match=caml_call2(React[2][2],0,cst),
     set_text_to_encode=match[2],
     text_to_encode_s=match[1];
    function _e_(eta){return caml_call1(encode(0),eta)}
    var
     encoded_text_s=caml_call3(React[2][11],0,_e_,text_to_encode_s),
     match$0=caml_call2(React[2][2],0,_f_),
     _g_=match$0[2],
     _h_=match$0[1];
    function value_of_input(id)
     {var
       _aN_=caml_call1(Js_of_ocaml_Dom_html[4],id),
       input_opt=caml_call1(Js_of_ocaml_Dom_html[117][33],_aN_);
      function _aO_(input){return caml_string_of_jsstring(input.value)}
      var value_opt=caml_call2(Js_of_ocaml_Js[5][3],input_opt,_aO_);
      function _aP_(param){return cst$0}
      return caml_call2(Js_of_ocaml_Js[5][8],value_opt,_aP_)}
    function set_value_of_input(id,v)
     {var
       _aL_=caml_call1(Js_of_ocaml_Dom_html[4],id),
       input_opt=caml_call1(Js_of_ocaml_Dom_html[117][33],_aL_);
      function _aM_(input){return input.value = caml_jsstring_of_string(v)}
      return caml_call2(Js_of_ocaml_Js[5][6],input_opt,_aM_)}
    function value_of_textarea(id)
     {var
       _aI_=caml_call1(Js_of_ocaml_Dom_html[4],id),
       input_opt=caml_call1(Js_of_ocaml_Dom_html[117][55],_aI_);
      function _aJ_(input){return caml_string_of_jsstring(input.value)}
      var value_opt=caml_call2(Js_of_ocaml_Js[5][3],input_opt,_aJ_);
      function _aK_(param){return caml_call1(Stdlib[2],id)}
      return caml_call2(Js_of_ocaml_Js[5][8],value_opt,_aK_)}
    function set_value_of_textarea(id,v)
     {var
       _aG_=caml_call1(Js_of_ocaml_Dom_html[4],id),
       input_opt=caml_call1(Js_of_ocaml_Dom_html[117][55],_aG_);
      function _aH_(input){return input.value = caml_jsstring_of_string(v)}
      return caml_call2(Js_of_ocaml_Js[5][6],input_opt,_aH_)}
    function encode_text_handler(param)
     {caml_call2(set_text_to_encode,0,value_of_textarea(Ids[1]));return 0}
    function pick(param)
     {if(param)
       {var xs=param[2],x=param[1];
        return function(n)
         {if(0 === n)return [0,x,xs];
          var match=caml_call1(pick(xs),n - 1 | 0),ys=match[2],y=match[1];
          return [0,y,[0,x,ys]]}}
      return caml_call1(Stdlib[2],cst_pick)}
    function wilty_handler(param)
     {var
       eta=value_of_input(Ids[2]),
       _aD_=caml_call3(decode(0),0,0,eta),
       lies=caml_call2(Stdlib_string[35],10,_aD_),
       _aE_=value_of_textarea(Ids[3]),
       truths=caml_call2(Stdlib_string[35],10,_aE_),
       num_truths=caml_call1(Stdlib_list[1],truths),
       num_lies=caml_call1(Stdlib_list[1],lies),
       switch$0=0;
      if(! caml_equal(lies,_i_) && ! caml_equal(truths,_k_))
       {var i=caml_call1(Stdlib_random[5],num_lies + num_truths | 0);
        if(i < num_lies)
         {var
           match=caml_call1(pick(lies),i),
           remaining_lies=match[2],
           lie=match[1];
          caml_call2(_g_,0,[0,[0,[0,0,lie]]]);
          var
           eta$0=caml_call2(Stdlib_string[7],cst$1,remaining_lies),
           new_lie_code=caml_call1(encode(0),eta$0);
          set_value_of_input(Ids[2],new_lie_code)}
        else
         {var
           match$0=caml_call1(pick(truths),i - num_lies | 0),
           remaining_truths=match$0[2],
           truth=match$0[1];
          caml_call2(_g_,0,[0,[0,[0,1,truth]]]);
          var _aF_=caml_call2(Stdlib_string[7],cst$2,remaining_truths);
          set_value_of_textarea(Ids[3],_aF_)}
        switch$0 = 1}
      if(! switch$0)caml_call2(_g_,0,_j_);
      return 0}
    var
     _l_=
      [0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[8][3][218],encoded_text_s),0],
     _n_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_m_),0]],
     _o_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][243],_n_,_l_),0],
     _p_=
      [0,
       caml_call1
        (Js_of_ocaml_tyxml_Tyxml_js[3][218],cst_Lie_code_to_send_click_to_),
       0],
     _q_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][243],0,_p_),_o_],
     _r_=[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][218],cst_Encode),0],
     _s_=
      [0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][62],encode_text_handler),0],
     _t_=[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][183],242538002),_s_],
     _v_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_u_),_t_]],
     _w_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][305],_v_,_r_),0],
     _y_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_x_),0]],
     _z_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][243],_y_,_w_),0],
     _A_=caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][218],cst$3),
     _B_=[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][172],3),0],
     _D_=[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_C_),_B_],
     _E_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][7],Ids[1]),_D_]],
     _F_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][310],_E_,_A_),_z_],
     _H_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_G_),0]],
     _I_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][243],_H_,_F_),_q_],
     _J_=
      [0,
       caml_call1
        (Js_of_ocaml_tyxml_Tyxml_js[3][218],cst_Lie_s_to_send_newline_sepa),
       0],
     _K_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][162],Ids[1]),0]],
     _L_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][303],_K_,_J_),_I_],
     _N_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_M_),0]],
     send_lies_app=caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][243],_N_,_L_),
     _O_=0;
    function _P_(param)
     {if(0 === param[0])
       {var _aw_=param[1];
        if(_aw_)
         {var
           match=_aw_[1],
           stmt=match[2],
           is_truth=match[1],
           _ax_=[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][218],stmt),0],
           _ay_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][263],0,0),_ax_],
           _az_=is_truth?cst_Truth:cst_Lie;
          return [0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][218],_az_),_ay_]}
        return 0}
      var
       msg=param[1],
       _aA_=caml_call2(Stdlib[28],cst_Error,msg),
       _aB_=[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][218],_aA_),0],
       _aC_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_Q_),0]];
      return [0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][271],_aC_,_aB_),0]}
    var
     eta=caml_call3(React[2][11],0,_P_,_h_),
     arg=ReactiveData[1][4],
     _R_=caml_call2(arg,0,eta),
     _T_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_S_),0]],
     _U_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[8][3][243],_T_,_R_),_O_],
     _V_=
      [0,
       caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][218],cst_Would_I_Lie_to_You),
       0],
     _W_=[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][62],wilty_handler),0],
     _X_=[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][183],242538002),_W_],
     _Z_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_Y_),_X_]],
     ___=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][305],_Z_,_V_),0],
     _aa_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_$_),0]],
     _ab_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][243],_aa_,___),_U_],
     _ad_=[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_ac_),0],
     _ae_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][7],Ids[2]),_ad_]],
     _af_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][304],_ae_,0),_ab_],
     _ag_=
      [0,
       caml_call1
        (Js_of_ocaml_tyxml_Tyxml_js[3][218],cst_Lie_code_you_received),
       0],
     _ah_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][162],Ids[2]),0]],
     _ai_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][303],_ah_,_ag_),_af_],
     _aj_=caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][218],cst$4),
     _ak_=[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][172],3),0],
     _am_=[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_al_),_ak_],
     _an_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][7],Ids[3]),_am_]],
     _ao_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][310],_an_,_aj_),_ai_],
     _ap_=
      [0,
       caml_call1
        (Js_of_ocaml_tyxml_Tyxml_js[3][218],cst_Truth_s_about_yourself_new),
       0],
     _aq_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][162],Ids[3]),0]],
     _ar_=[0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][303],_aq_,_ap_),_ao_],
     _at_=[0,[0,caml_call1(Js_of_ocaml_tyxml_Tyxml_js[3][5],_as_),0]],
     wilty_app=caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][243],_at_,_ar_),
     _au_=
      [0,
       send_lies_app,
       [0,caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][252],0,0),[0,wilty_app,0]]],
     app=caml_call2(Js_of_ocaml_tyxml_Tyxml_js[3][300],0,_au_);
    caml_call1(Stdlib_random[3],0);
    var
     app_container=caml_call1(Js_of_ocaml_Dom_html[4],cst_app),
     _av_=caml_call1(Js_of_ocaml_tyxml_Tyxml_js[9][1],app);
    caml_call2(Js_of_ocaml_Dom[5],app_container,_av_);
    var
     Dune_exe_App=
      [0,
       Ids,
       encode,
       decode,
       text_to_encode_s,
       set_text_to_encode,
       encoded_text_s,
       _h_,
       _g_,
       value_of_input,
       set_value_of_input,
       value_of_textarea,
       set_value_of_textarea,
       encode_text_handler,
       pick,
       wilty_handler,
       send_lies_app,
       wilty_app,
       app];
    runtime.caml_register_global(52,Dune_exe_App,"Dune__exe__App");
    return}
  (function(){return this}()));


//# 1 "../../.js/stdlib/std_exit.cmo.js"
(function(joo_global_object)
   {"use strict";
    var runtime=joo_global_object.jsoo_runtime;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    var global_data=runtime.caml_get_global_data(),Stdlib=global_data.Stdlib;
    caml_call1(Stdlib[103],0);
    var Std_exit=[0];
    runtime.caml_register_global(1,Std_exit,"Std_exit");
    return}
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhcHAuYmMuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiY2FtbF9pbnQ2NF9pc196ZXJvIiwieCIsImNhbWxfc3RyX3JlcGVhdCIsIm4iLCJzIiwiciIsImwiLCJjYW1sX2ludDY0X29mZnNldCIsIk1hdGgiLCJjYW1sX3JhaXNlX2NvbnN0YW50IiwidGFnIiwiY2FtbF9nbG9iYWxfZGF0YSIsImNhbWxfcmFpc2VfemVyb19kaXZpZGUiLCJNbEludDY0IiwibG8iLCJtaSIsImhpIiwidGhpcyIsInhoaSIsImgiLCJzaWduIiwib2Zmc2V0IiwibW9kdWx1cyIsImRpdmlzb3IiLCJxdW90aWVudCIsInkiLCJxIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX2ludDY0X2lzX25lZ2F0aXZlIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMiLCJhIiwiaSIsImxlbiIsImYiLCJTdHJpbmciLCJudWxsIiwiY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyIsImNhbWxfanNieXRlc19vZl9zdHJpbmciLCJjYW1sX3JhaXNlX3dpdGhfYXJnIiwiYXJnIiwianNvb19pc19hc2NpaSIsImNhbWxfdXRmMTZfb2ZfdXRmOCIsImIiLCJ0IiwiYyIsImMxIiwiYzIiLCJ2IiwiaiIsIk1sQnl0ZXMiLCJjb250ZW50cyIsImxlbmd0aCIsImNvbnRlbnQiLCJjYW1sX2J5dGVzX29mX2pzYnl0ZXMiLCJjYW1sX3N0cmluZ19vZl9qc2J5dGVzIiwiY2FtbF9yYWlzZV93aXRoX3N0cmluZyIsIm1zZyIsImNhbWxfaW52YWxpZF9hcmd1bWVudCIsImNhbWxfcGFyc2VfZm9ybWF0IiwiZm10IiwiY2FtbF9maW5pc2hfZm9ybWF0dGluZyIsInJhd2J1ZmZlciIsImJ1ZmZlciIsImNhbWxfaW50NjRfZm9ybWF0Iiwid2Jhc2UiLCJjdnRibCIsInAiLCJjYW1sX2V4cG0xX2Zsb2F0IiwieiIsImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIiwiam9vX2dsb2JhbF9vYmplY3QiLCJjYW1sX2N1cnJlbnRfZGlyIiwiY2FtbF9tYWtlX3BhdGgiLCJuYW1lIiwiY29tcCIsIm5jb21wIiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF91dGY4X29mX3V0ZjE2IiwiZCIsImNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmciLCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZyIsImNhbWxfcmFpc2Vfc3lzX2Vycm9yIiwiY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUiLCJjYW1sX2J5dGVzX2JvdW5kX2Vycm9yIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IiwiQXJyYXkiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsImNhbWxfYmxpdF9zdHJpbmciLCJlIiwiTWxGaWxlIiwiTWxGYWtlRmlsZSIsIm9sZCIsImJ1ZiIsInBvcyIsImNsZW4iLCJuZXdfc3RyIiwib2xkX2RhdGEiLCJNbEZha2VEZXZpY2UiLCJyb290IiwicmVzIiwibmFtZV9zbGFzaCIsIlJlZ0V4cCIsInNlZW4iLCJtIiwib2siLCJmaWxlIiwiYnl0ZXMiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ191bnNhZmVfZ2V0IiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX2FycmF5X29mX2J5dGVzIiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9ieXRlc19zZXQiLCJNbE5vZGVGaWxlIiwiZmQiLCJyZXF1aXJlIiwiZXJyIiwiYnVmX29mZnNldCIsIk1sTm9kZURldmljZSIsImNvbnN0cyIsImtleSIsIm8iLCJjYW1sX3Jvb3QiLCJmc19ub2RlX3N1cHBvcnRlZCIsImpzb29fbW91bnRfcG9pbnQiLCJyZXNvbHZlX2ZzX2RldmljZSIsInBhdGgiLCJjYW1sX3N5c19pc19kaXJlY3RvcnkiLCJjYW1sX3JhaXNlX25vdF9mb3VuZCIsImNhbWxfc3lzX2dldGVudiIsImciLCJ1bmRlZmluZWQiLCJzaGlmdF9yaWdodF9uYXQiLCJuYXQxIiwib2ZzMSIsImxlbjEiLCJuYXQyIiwib2ZzMiIsIm5iaXRzIiwid3JhcCIsImNhbWxfbmFtZWRfdmFsdWVzIiwiY2FtbF9uYW1lZF92YWx1ZSIsIm5tIiwiY2FtbF9ncl9zdGF0ZSIsImNhbWxfZ3Jfc3RhdGVfZ2V0IiwiY2FtbF9ncl9wb2ludF9jb2xvciIsImltIiwiTWxPYmplY3RUYWJsZSIsIk5haXZlTG9va3VwIiwib2JqcyIsImNhbWxfZmFpbHdpdGgiLCJjYW1sX3N5c19yZW5hbWUiLCJvX3Jvb3QiLCJuX3Jvb3QiLCJjYW1sX2xvZzEwX2Zsb2F0IiwiY2FtbF9ydW50aW1lX3dhcm5pbmdzIiwiY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyIsImJvb2wiLCJjYW1sX2NsYXNzaWZ5X2Zsb2F0IiwiaXNGaW5pdGUiLCJpc05hTiIsImNhbWxfbWxfcmVmaWxsX2lucHV0IiwiY2hhbiIsInN0ciIsInN0cl9sZW4iLCJjYW1sX21sX2NoYW5uZWxzIiwiY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IiwiY2hhbmlkIiwiY2FtbF9hcnJheV9ib3VuZF9lcnJvciIsImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lIiwiY2FtbF9nY19taW5vciIsImNhbWxfaW50NjRfb2ZfYnl0ZXMiLCJjYW1sX2JhX3VpbnQ4X2dldDY0IiwiYmEiLCJpMCIsIm9mcyIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJjYW1sX2ludDY0X3RvX2J5dGVzIiwiY2FtbF9pbnQ2NF9tYXJzaGFsIiwid3JpdGVyIiwic2l6ZXMiLCJjYW1sX2JhX251bV9kaW1zIiwiY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY3JlYXRlX2ZpbGUiLCJjYW1sX2ZzX2luaXQiLCJ0bXAiLCJjYW1sX3NldF9wYXJzZXJfdHJhY2UiLCJjYW1sX2xpc3Rfb2ZfanNfYXJyYXkiLCJ1bml4X2dldHRpbWVvZmRheSIsIkRhdGUiLCJjYW1sX211bCIsImNhbWxfaGFzaF9taXhfaW50IiwibnVtX2RpZ2l0c19uYXQiLCJuYXQiLCJjYW1sX2hhc2hfbmF0IiwiY2FtbF9jYWxsX2dlbiIsImFyZ3MiLCJhcmdzTGVuIiwiZXh0cmFfYXJncyIsImFyZ3VtZW50cyIsIm5hcmdzIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9nY19jb3VudGVycyIsImNhbWxfZ3Jfc3luY2hyb25pemUiLCJsb2cyX29rIiwianNvb19mbG9vcl9sb2cyIiwiSW5maW5pdHkiLCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQiLCJmbG9hdDMyYSIsImludDMyYSIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IiwiZXhwIiwiayIsInIzIiwicjIiLCJyMSIsImNhbWxfYmFfc2VyaWFsaXplIiwic3oiLCJjb21wbGV4IiwiY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudCIsImtpbmQiLCJjYW1sX2JhX2NyZWF0ZV9idWZmZXIiLCJzaXplIiwidmlldyIsImRhdGEiLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJOYU4iLCJjYW1sX2JhX2dldF9zaXplIiwiZGltcyIsIm5fZGltcyIsImNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIiwiY2FtbF9pbnQ2NF9oaTMyIiwiY2FtbF9pbnQ2NF9sbzMyIiwiY2FtbF9iYV9jdXN0b21fbmFtZSIsIk1sX0JpZ2FycmF5IiwibGF5b3V0IiwicmUiLCJ0b3RhbCIsImsxIiwiazIiLCJNbF9CaWdhcnJheV9jXzFfMSIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwibnVtX2RpbXMiLCJzaXplX2RpbSIsInNpemVfZGltX2hpIiwic2l6ZV9kaW1fbG8iLCJzaXh0eSIsImludDY0IiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwidyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X2NvbXBhcmUiLCJjYW1sX2ludDY0X2hhc2giLCJjYW1sX2N1c3RvbV9vcHMiLCJjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20iLCJjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20iLCJudW0iLCJjdXN0b20iLCJzd2FwIiwiY2FtbF9jb21wYXJlX3ZhbF90YWciLCJOdW1iZXIiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9ieXRlc19jb21wYXJlIiwiY2FtbF9zdHJpbmdfY29tcGFyZSIsImNhbWxfY29tcGFyZV92YWwiLCJzdGFjayIsInRhZ19hIiwidGFnX2IiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiZGl2X2hlbHBlciIsImRpdl9kaWdpdF9uYXQiLCJuYXRxIiwib2ZzcSIsIm5hdHIiLCJvZnNyIiwicmVtIiwibnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0Iiwic2hpZnRfbGVmdF9uYXQiLCJNbE5hdCIsImNyZWF0ZV9uYXQiLCJhcnIiLCJzZXRfdG9femVyb19uYXQiLCJpbmNyX25hdCIsImNhcnJ5X2luIiwiY2FycnkiLCJhZGRfbmF0IiwibGVuMiIsIm5hdF9vZl9hcnJheSIsIm11bHRfZGlnaXRfbmF0IiwibmF0MyIsIm9mczMiLCJ4MSIsIngyIiwieDMiLCJkZWNyX25hdCIsImJvcnJvdyIsInN1Yl9uYXQiLCJjb21wYXJlX25hdCIsImRpdl9uYXQiLCJxdW8iLCJjYW1sX2JhX2JsaXQiLCJzcmMiLCJkc3QiLCJpc19kaWdpdF9pbnQiLCJjYW1sX2ludDY0X2RpdiIsImNhbWxfanNfaHRtbF9lbnRpdGllcyIsImVudGl0eSIsInRlbXAiLCJkb2N1bWVudCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQiLCJjYW1sX2ludDY0X29mX2Zsb2F0IiwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjQiLCJjYW1sX2JhX3NldF8yIiwiY2FtbF9hcmd2IiwibWFpbiIsImFyZ3YiLCJhcmdzMiIsImNhbWxfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9qc19ldmFsX3N0cmluZyIsImV2YWwiLCJjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZCIsImxvYyIsInNoYXBlIiwidW5kZWZfbW9kdWxlIiwiX3giLCJsb29wIiwic3RydWN0IiwiaWR4Iiwic2VyaWFsaXplX25hdCIsImNhbWxfbWVtcHJvZl9zZXQiLCJfY29udHJvbCIsImNhbWxfc3lzX2V4aXQiLCJjb2RlIiwiY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3IiLCJjYW1sX2pzX2Zyb21fYXJyYXkiLCJjYW1sX2JhX3Jlc2hhcGUiLCJ2aW5kIiwibmV3X2RpbSIsImNhbWxfb29fbGFzdF9pZCIsImNhbWxfc2V0X29vX2lkIiwiY2FtbF9ncl9maWxsX3JlY3QiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYSIsInN0cjEiLCJwb3MxIiwiYmEyIiwicG9zMiIsInNsaWNlIiwiY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlIiwianNuYW1lIiwiY2FtbF9nZXRfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImNhbWxfY29tcGFyZSIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX2ludDY0X3RvX2Zsb2F0IiwiY2FtbF9iYV9nZXRfMSIsImNhbWxfYmlnc3RyaW5nX21lbWNtcCIsImNhbWxfbmV3X3N0cmluZyIsImNhbWxfYmFfdWludDhfZ2V0MzIiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX2dyX2NsZWFyX2dyYXBoIiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImJzIiwibHhvcl9kaWdpdF9uYXQiLCJjYW1sX2ZpbmFsX3JlbGVhc2UiLCJjYW1sX2pzX3RvX2FycmF5IiwiY2FtbF9ncl9wbG90IiwiY29sb3IiLCJjYW1sX2J5dGVzX3NldDY0IiwiaTY0IiwiY2FtbF9ieXRlc19zZXQxNiIsImkxNiIsImNhbWxfc3RyaW5nX3NldDE2IiwiY2FtbF9pbnQ2NF9ic3dhcCIsImNhbWxfZmlsbF9ieXRlcyIsImNhbWxfZmlsbF9zdHJpbmciLCJjYW1sX2djX21ham9yIiwiY2FtbF9sZXhfYXJyYXkiLCJjYW1sX2xleF9lbmdpbmUiLCJ0YmwiLCJzdGFydF9zdGF0ZSIsImxleGJ1ZiIsImxleF9idWZmZXIiLCJsZXhfYnVmZmVyX2xlbiIsImxleF9zdGFydF9wb3MiLCJsZXhfY3Vycl9wb3MiLCJsZXhfbGFzdF9wb3MiLCJsZXhfbGFzdF9hY3Rpb24iLCJsZXhfZW9mX3JlYWNoZWQiLCJsZXhfYmFzZSIsImxleF9iYWNrdHJrIiwibGV4X2RlZmF1bHQiLCJsZXhfdHJhbnMiLCJsZXhfY2hlY2siLCJzdGF0ZSIsImJhc2UiLCJiYWNrdHJrIiwiY2FtbF9zeXNfZmlsZV9leGlzdHMiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9hcnJheV9zdWIiLCJhMiIsImNhbWxfYnl0ZXNfZXF1YWwiLCJjYW1sX2dyX3NpemVfeCIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4iLCJjYW1sX2Nvc2hfZmxvYXQiLCJjYW1sX2VwaGVfa2V5X29mZnNldCIsImNhbWxfd2Vha19jaGVjayIsImNhbWxfZXBoZV9jaGVja19rZXkiLCJjYW1sX2hhc2hfbWl4X2ZpbmFsIiwiY2FtbF9ncl90ZXh0X3NpemUiLCJ0eHQiLCJjYW1sX2xleF9ydW5fbWVtIiwibWVtIiwiY3Vycl9wb3MiLCJjYW1sX2xleF9ydW5fdGFnIiwiY2FtbF9uZXdfbGV4X2VuZ2luZSIsImxleF9tZW0iLCJsZXhfYmFzZV9jb2RlIiwibGV4X2JhY2t0cmtfY29kZSIsImxleF9kZWZhdWx0X2NvZGUiLCJsZXhfdHJhbnNfY29kZSIsImxleF9jaGVja19jb2RlIiwibGV4X2NvZGUiLCJwY19vZmYiLCJwc3RhdGUiLCJiYXNlX2NvZGUiLCJjYW1sX2JhX3VpbnQ4X3NldDY0IiwiY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9sZXNzZXF1YWwiLCJjYW1sX21sX2ZsdXNoIiwib3V0cHV0IiwiY2FtbF9tbF9zZWVrX291dF82NCIsImNvbXBhcmVfbmF0X3JlYWwiLCJjYW1sX2djX3NldCIsImNhbWxfanNfZ2V0IiwiY2FtbF9nY19jb21wYWN0aW9uIiwiY2FtbF93ZWFrX2dldCIsImNhbWxfZXBoZV9nZXRfa2V5IiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYSIsIndpbl9jbGVhbnVwIiwiY2FtbF9zeXNfY2xvc2UiLCJjYW1sX21sX2Nsb3NlX2NoYW5uZWwiLCJjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZSIsImV4biIsImZvcmNlIiwiY2FtbF9zeXNfaXNhdHR5IiwiX2NoYW4iLCJpc19kaWdpdF96ZXJvIiwidW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nIiwiY2FtbF9qc19zZXQiLCJjYW1sX2FycmF5X2dldCIsImFycmF5IiwiaW5kZXgiLCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSIsImNhbWxfaW50NjRfc3ViIiwiY2FtbF9tbF9zZWVrX2luXzY0IiwiY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IiwiY2FtbF9ub3RlcXVhbCIsImNhbWxfc3lzX2NvbnN0X2ludF9zaXplIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2siLCJjYW1sX2lzX2pzIiwiY2FtbF9iYV9kaW0iLCJjYW1sX2JhX2RpbV8xIiwidW5peF9sb2NhbHRpbWUiLCJkX251bSIsImphbnVhcnlmaXJzdCIsImRveSIsImphbiIsImp1bCIsInN0ZFRpbWV6b25lT2Zmc2V0IiwiY2FtbF9qc19tZXRoX2NhbGwiLCJjYW1sX3dlYWtfY3JlYXRlIiwiY2FtbF9lcGhlX2NyZWF0ZSIsImNhbWxfanNfdG9fYnl0ZV9zdHJpbmciLCJ1bml4X21rdGltZSIsInRtIiwidG0yIiwiY2FtbF90cmFtcG9saW5lIiwiY2FtbF9ieXRlc19nZXQ2NCIsImNhbWxfd2Vha19zZXQiLCJjYW1sX3N5c19yZW1vdmUiLCJjYW1sX3N0cmluZ19ib3VuZF9lcnJvciIsImNhbWxfc3RyaW5nX2dldDMyIiwiY2FtbF9oeXBvdF9mbG9hdCIsImNhbWxfanNfY2FsbCIsImNhbWxfc3lzX2NvbnN0X21heF93b3NpemUiLCJjYW1sX2VwaGVfdW5zZXRfa2V5IiwiY2FtbF9oYXNoX21peF9ieXRlc19hcnIiLCJjYW1sX2hhc2hfbWl4X2pzYnl0ZXMiLCJjYW1sX2hhc2hfbWl4X2J5dGVzIiwiY2FtbF9ieXRlc19sZXNzdGhhbiIsImNhbWxfZ3JfZmlsbF9wb2x5IiwiYXIiLCJjYW1sX2djX3F1aWNrX3N0YXQiLCJjYW1sX3JhaXNlX2VuZF9vZl9maWxlIiwiY2FtbF9tbF9pbnB1dF9pbnQiLCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSIsIm50aF9kaWdpdF9uYXQiLCJjYW1sX2FycmF5X2JsaXQiLCJhMSIsImNhbWxfZmxvYXRfb2Zfc3RyaW5nIiwibTMiLCJtYW50aXNzYSIsInBhcnNlSW50IiwiZXhwb25lbnQiLCJjYW1sX3N5c19nZXRjd2QiLCJjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuIiwiY2FtbF9saXN0X3RvX2pzX2FycmF5IiwiY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUiLCJjYW1sX291dHB1dF92YWwiLCJXcml0ZXIiLCJ2YWx1ZSIsImZsYWdzIiwibm9fc2hhcmluZyIsImNsb3N1cmVzIiwiaW50ZXJuX29ial90YWJsZSIsIm1lbW8iLCJleGlzdGluZ19vZmZzZXQiLCJleHRlcm5fcmVjIiwib3BzIiwic3pfMzJfNjQiLCJoZWFkZXJfcG9zIiwib2xkX3BvcyIsInR5cGVfb2ZfdiIsImNhbWxfc3RyaW5nX29mX2FycmF5IiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIiwiY2FtbF9yYWlzZV9ub3RfYV9kaXIiLCJjYW1sX3N5c19zeXN0ZW1fY29tbWFuZCIsImNtZCIsInVuaXhfaXNhdHR5IiwiZmlsZURlc2NyaXB0b3IiLCJ0dHkiLCJjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbiIsImRlc2VyaWFsaXplX25hdCIsImluaXRpYWxpemVfbmF0IiwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyIsImpzX3ByaW50X3N0ZG91dCIsImNhbWxfY29weXNpZ25fZmxvYXQiLCJjYW1sX2dyX3NldF90ZXh0X3NpemUiLCJjYW1sX21kNV9ieXRlcyIsImFkZCIsInh4IiwiZmYiLCJnZyIsImhoIiwiaWkiLCJtZDUiLCJjYW1sX2JhX3NldF9nZW5lcmljIiwiY2FtbF9lcGhlX3NldF9rZXkiLCJjYW1sX2J5dGVzX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbCIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXQiLCJiaXRzIiwib25lIiwiY2FtbF9ncl9zaXplX3kiLCJjYW1sX21sX3Bvc19pbiIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIiwiY2FtbF9zdGRfb3V0cHV0Iiwic2xlbiIsImpzX3ByaW50X3N0ZGVyciIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJpbmZvIiwiY2FtbF9zeXNfb3BlbiIsIl9wZXJtcyIsIk1sU3RyaW5nUmVhZGVyIiwiY2FtbF9mbG9hdF9vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIiLCJfbWFnaWMiLCJfYmxvY2tfbGVuIiwibnVtX29iamVjdHMiLCJfc2l6ZV8zMiIsIl9zaXplXzY0Iiwib2JqX2NvdW50ZXIiLCJpbnRlcm5fcmVjIiwiaGVhZGVyIiwiZXhwZWN0ZWRfc2l6ZSIsImNhbWxfc3RyaW5nX29mX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIiwiY2FtbF9zdHJpbmdfZ2V0IiwicmVfbWF0Y2giLCJyZV93b3JkX2xldHRlcnMiLCJvcGNvZGVzIiwiaXNfd29yZF9sZXR0ZXIiLCJpbl9iaXRzZXQiLCJyZV9tYXRjaF9pbXBsIiwicGFydGlhbCIsInByb2ciLCJjcG9vbCIsIm5vcm10YWJsZSIsIm51bWdyb3VwcyIsIm51bXJlZ2lzdGVycyIsInN0YXJ0Y2hhcnMiLCJwYyIsInF1aXQiLCJncm91cHMiLCJyZV9yZWdpc3RlciIsImJhY2t0cmFjayIsIml0ZW0iLCJwdXNoIiwiYWNjZXB0IiwicmVzdWx0IiwicHJlZml4X21hdGNoIiwib3AiLCJzYXJnIiwidWFyZyIsImdyb3VwIiwiRXJyb3IiLCJyZV9zZWFyY2hfYmFja3dhcmQiLCJjYW1sX2pzX2Zyb21fc3RyaW5nIiwiY2FtbF9iYV9zdWIiLCJjaGFuZ2VkX2RpbSIsIm11bCIsIm5ld19kaW1zIiwibmV3X2RhdGEiLCJjYW1sX2djX2Z1bGxfbWFqb3IiLCJjYW1sX2J5dGVzX3NldDMyIiwiaTMyIiwiY2FtbF9ncl9zaWdpb19zaWduYWwiLCJjYW1sX2JhX3VpbnQ4X3NldDMyIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXgiLCJjYW1sX3NpZ25iaXRfZmxvYXQiLCJjYW1sX2dyX2N1cnJlbnRfeCIsImNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgiLCJjYW1sX2dyX3NldF9mb250IiwiY2FtbF9ncl9zZXRfY29sb3IiLCJjb252ZXJ0IiwibnVtYmVyIiwiY19zdHIiLCJjYW1sX2dyX21vdmV0byIsImNhbWxfZ3JfcmVzaXplX3dpbmRvdyIsImNhbWxfZ3Jfc3RhdGVfaW5pdCIsImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSIsInRhIiwiY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IiwiY2FtbF9tbF9zZWVrX291dCIsImNhbWxfanNfdHlwZW9mIiwiY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UiLCJidCIsImNhbWxfZ3JfbGluZXRvIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIiwiY2FtbF9iYV9kaW1fMyIsImNhbWxfZXBoZV9kYXRhX29mZnNldCIsImNhbWxfZXBoZV9jaGVja19kYXRhIiwiY2FtbF9ieXRlc19nZXQxNiIsImNhbWxfb2JqX21ha2VfZm9yd2FyZCIsImNhbWxfanNfZnJvbV9ib29sIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lIiwiY2FtbF9ncl9jbG9zZV9ncmFwaCIsImNhbWxfY3JlYXRlX3N0cmluZyIsImNhbWxfbWQ1X3N0cmluZyIsImNhbWxfbWQ1X2NoYW4iLCJjaGFuX2xlbiIsImNhbWxfb2JqX2R1cCIsImNhbWxfd2Vha19nZXRfY29weSIsImNhbWxfbWxfb3V0cHV0X2J5dGVzIiwic3RyaW5nIiwianNzdHJpbmciLCJpZCIsImNhbWxfbWxfb3V0cHV0IiwiY2FtbF9lcGhlX2dldF9kYXRhIiwiY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUiLCJ1bml0IiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfYXJyYXlfYXBwZW5kIiwibDEiLCJsMiIsImNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsIiwiY2FtbF9qc19leHByIiwiY2FtbF9pbnQ2NF9tdWwiLCJjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCIsIl91bml0IiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMiLCJjYW1sX2hhc2hfdW5pdl9wYXJhbSIsImNvdW50IiwibGltaXQiLCJvYmoiLCJoYXNoX2FjY3UiLCJoYXNoX2F1eCIsImpzYnl0ZXMiLCJjYW1sX3N0cmluZ19lcXVhbCIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciIsInJlX3JlcGxhY2VtZW50X3RleHQiLCJyZXBsIiwib3JpZyIsImN1ciIsInN0YXJ0IiwiZW5kIiwiY2FtbF9wdXJlX2pzX2V4cHIiLCJibGl0X25hdCIsImNhbWxfaW50NjRfdWx0IiwiY2FtbF9pbnQ2NF94b3IiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzIiwiYmExIiwiYnl0ZXMyIiwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSIsImNhbWxfdG9fanNfc3RyaW5nIiwiY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIiwiY2FtbF9wYXJzZV9kaWdpdCIsImNhbWxfaW50NjRfb2Zfc3RyaW5nIiwiYmFzZTY0IiwidGhyZXNob2xkIiwicmVfc2VhcmNoX2ZvcndhcmQiLCJjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyIsImNhbWxfbWFrZV92ZWN0IiwiaW5pdCIsImNhbWxfbWxfc2Vla19pbiIsImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5IiwiY2FtbF9tbF9vdXRwdXRfY2hhciIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiIsImNhbWxfb2JqX2lzX2Jsb2NrIiwiY2FtbF9tbF9pbnB1dF9jaGFyIiwiY2FtbF9qc192YXIiLCJjYW1sX3RydW5jX2Zsb2F0IiwiY2FtbF9lcGhlX2JsaXRfZGF0YSIsImNhbWxfaXNfcHJpbnRhYmxlIiwiY2FtbF9lcXVhbCIsInJlX3BhcnRpYWxfbWF0Y2giLCJjYW1sX3N5c19yYW5kb21fc2VlZCIsIm5vdyIsImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8yIiwid2luX2hhbmRsZV9mZCIsImNhbWxfYmFfdWludDhfc2V0MTYiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsInByZXYiLCJjYW1sX21hcnNoYWxfY29uc3RhbnRzIiwiY2FtbF9qc19lcXVhbHMiLCJiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2dyX2FyY19hdXgiLCJjdHgiLCJjeCIsImN5IiwicnkiLCJyeCIsInJvdCIsInhQb3MiLCJ5UG9zIiwieFBvc19wcmV2IiwieVBvc19wcmV2Iiwic3BhY2UiLCJkZWx0YSIsImNhbWxfZ3JfZmlsbF9hcmMiLCJjYW1sX2JhX3NsaWNlIiwibnVtX2luZHMiLCJzdWJfZGltcyIsImNhbWxfbWFyc2hhbF9kYXRhX3NpemUiLCJnZXQzMiIsImNhbWxfaW5wdXRfdmFsdWUiLCJjYW1sX2JhX2tpbmQiLCJjYW1sX2pzX2Z1bl9jYWxsIiwiY2FtbF9qc19wdXJlX2V4cHIiLCJjb21wYXJlX2RpZ2l0c19uYXQiLCJjYW1sX21sX2lucHV0IiwiY2FtbF9ncl93YWl0X2V2ZW50IiwiX2V2bCIsImNhbWxfZ3Jfc2lnaW9faGFuZGxlciIsImNhbWxfaGFzaF9taXhfYmlnc3RyaW5nIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlIiwidW5peF9nbXRpbWUiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwiY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIiwidW5peF90aW1lIiwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJhYiIsImNhbWxfbW9kIiwiY2FtbF9iYV9pbml0IiwicmVfc3RyaW5nX21hdGNoIiwiQmlnU3RyaW5nUmVhZGVyIiwiY2FtbF9ncl9kdW1wX2ltYWdlIiwiY2FtbF9iYV9nZXRfZ2VuZXJpYyIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsInRvRml4ZWQiLCJkcCIsInByZWMiLCJjYW1sX21vdW50X2F1dG9sb2FkIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYSIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9zdHJpbmdfbGVzc3RoYW4iLCJjYW1sX3N0cmluZ19ncmVhdGVydGhhbiIsImNhbWxfZGl2IiwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkiLCJjYW1sX21lbXByb2Zfc3RhcnQiLCJyYXRlIiwic3RhY2tfc2l6ZSIsInRyYWNrZXIiLCJjYW1sX3N5c19nZXRfYXJndiIsImNhbWxfanNfdG9fYm9vbCIsImNhbWxfZ3JfY3JlYXRlX2ltYWdlIiwiY2FtbF9lcGhlX2dldF9rZXlfY29weSIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsIm11bHRfbmF0IiwibGVuMyIsInNxdWFyZV9uYXQiLCJjYW1sX2pzX2Zyb21fZmxvYXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9nY19zdGF0IiwiY2FtbF9zeXNfbW9kaWZ5X2FyZ3YiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImNhbWxfanNfZ2V0X2NvbnNvbGUiLCJjYW1sX3N5c191bnNhZmVfZ2V0ZW52IiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4iLCJjaGFubmVsIiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwiY2FtbF9yb3VuZF9mbG9hdCIsImNhbWxfb2pzX25ld19hcnIiLCJGIiwiY29tcGxlbWVudF9uYXQiLCJjYW1sX2pzX3JlZ2V4cHMiLCJjYW1sX2pzX2h0bWxfZXNjYXBlIiwiY2FtbF9iYV9kaW1fMiIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc2luaF9mbG9hdCIsImNhbWxfbGRleHBfZmxvYXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJhcml0eSIsImNhbWxfYmFfc2V0XzEiLCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayIsImxhbmRfZGlnaXRfbmF0IiwiY2FtbF9pbnQ2NF9tb2QiLCJjYW1sX29ial9zZXRfdGFnIiwiY2FtbF9jcmVhdGVfZmlsZV9leHRlcm4iLCJjYW1sX2ludDMyX2Jzd2FwIiwid2luX3N0YXJ0dXAiLCJjYW1sX2JhX3NldF8zIiwiY2FtbF9qc19pbnN0YW5jZW9mIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmciLCJudGhfZGlnaXRfbmF0X25hdGl2ZSIsInNldF9kaWdpdF9uYXRfbmF0aXZlIiwiZGlnaXQiLCJjYW1sX3N0cmluZ19zZXQ2NCIsImNhbWxfZ3Jfc3RhdGVfY3JlYXRlIiwiY2FudmFzIiwiY29udGV4dCIsImNhbWxfanNfd3JhcF9jYWxsYmFjayIsImNhbWxfZ3JfZHJhd19hcmMiLCJjYW1sX2JhX21hcF9maWxlIiwidmZkIiwic2hhcmVkIiwiY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZSIsImFyZ24iLCJjYW1sX2JhX2NyZWF0ZV9mcm9tIiwiZGF0YTEiLCJkYXRhMiIsImpzdHlwIiwiY2FtbF90YW5oX2Zsb2F0IiwiY2FtbF9ncl9kcmF3X3N0ciIsImR4IiwiY2FtbF9ncl9kcmF3X3N0cmluZyIsImNhbWxfZ3JfZHJhd19jaGFyIiwiY2FtbF91bm1vdW50IiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyIsImNhbWxfbWxfcG9zX2luXzY0IiwiY2FtbF9ncl9kcmF3X2ltYWdlIiwiaW1hZ2UiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9zdHJpbmdfc2V0IiwiY2FtbF9tbF9wb3Nfb3V0IiwiY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyIsImNhbWxfanNfb2JqZWN0IiwiY2FtbF9iYV9jcmVhdGUiLCJkaW1zX21sIiwiY2FtbF93ZWFrX2JsaXQiLCJjYW1sX2dyX3JlbWVtYmVyX21vZGUiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZSIsIm1vZGUiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX3N0cmluZ19nZXQxNiIsImNhbWxfZXBoZV91bnNldF9kYXRhIiwiY2FtbF9vdXRwdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8zIiwiY2FtbF9lcGhlX2JsaXRfa2V5IiwiY2FtbF9pbml0aWFsX3RpbWUiLCJjYW1sX3N5c190aW1lIiwiY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiY2FtbF9oYXNoIiwic2VlZCIsInF1ZXVlIiwicmQiLCJ3ciIsImNhbWxfb2JqX3RhZyIsIkZ1bmN0aW9uIiwiY2FtbF9iYV90b190eXBlZF9hcnJheSIsImNhbWxfanNfZXhwb3J0X3ZhciIsIm1vZHVsZSIsImNhbWxfYnl0ZXNfZ2V0MzIiLCJjYW1sX2ZyZXhwX2Zsb2F0IiwibmVnIiwiY2FtbF9zdHJpbmdfZ2V0NjQiLCJjYW1sX21sX3Bvc19vdXRfNjQiLCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyIsImNhbWxfc2V0X3N0YXRpY19lbnYiLCJjYW1sX2JhX2NoYW5nZV9sYXlvdXQiLCJjYW1sX2pzX25ldyIsImNhbWxfZ3JfY3VycmVudF95IiwiY2FtbF9mb3JtYXRfaW50IiwiY2FtbF9vYmpfdHJ1bmNhdGUiLCJjYW1sX2pzX3RvX3N0cmluZyIsImlzX2RpZ2l0X29kZCIsImNhbWxfcnVudGltZV92YXJpYW50IiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IiwiY2FtbF9hcnJheV9jb25jYXQiLCJjYW1sX2dyX29wZW5fZ3JhcGgiLCJnZXQiLCJzcGVjcyIsInRhcmdldCIsInN0YXR1cyIsIndpbiIsImRvYyIsInRpdGxlIiwiYm9keSIsImNhbWxfZXBoZV9zZXRfZGF0YSIsImNhbWxfbWFrZV9mbG9hdF92ZWN0IiwiY2FtbF9tZW1wcm9mX3N0b3AiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIiwiY2FtbF9sb2cxcF9mbG9hdCIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkIiwibG9yX2RpZ2l0X25hdCIsImNhbWxfZ3JfYmxpdF9pbWFnZSIsImltMiIsImNhbWxfZ3Jfd2luZG93X2lkIiwiY2FtbF9qc19vbl9pZSIsInVhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfYmFfbGF5b3V0IiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJjYW1sX2FycmF5X3NldCIsIm5ld3ZhbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsIiwic2V0X2RpZ2l0X25hdCIsImNhbWxfdXBkYXRlX2R1bW15IiwiY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZCIsInJlYWwiLCJjYW1sX2dyX2RvY19vZl9zdGF0ZSIsImNhbWxfbWxfb3V0cHV0X2ludCIsImNhbWxfb2JqX3dpdGhfdGFnIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0Iiwic3R5bGUiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJjYW1sX2JhY2t0cmFjZV9zdGF0dXMiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX3N5c19hcmd2IiwiY2FtbF9iYV9maWxsIiwiY2FtbF9tb2RmX2Zsb2F0IiwiY2FtbF9nY19nZXQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19zZXQzMiIsImNhbWxfcGFyc2VfZW5naW5lIiwidGFibGVzIiwiZW52IiwiRVJSQ09ERSIsInRlc3RzaGlmdCIsInNoaWZ0Iiwic2hpZnRfcmVjb3ZlciIsInJlZHVjZSIsIlJFQURfVE9LRU4iLCJSQUlTRV9QQVJTRV9FUlJPUiIsIkdST1dfU1RBQ0tTXzEiLCJHUk9XX1NUQUNLU18yIiwiQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04iLCJDQUxMX0VSUk9SX0ZVTkNUSU9OIiwiZW52X3Nfc3RhY2siLCJlbnZfdl9zdGFjayIsImVudl9zeW1iX3N0YXJ0X3N0YWNrIiwiZW52X3N5bWJfZW5kX3N0YWNrIiwiZW52X3N0YWNrc2l6ZSIsImVudl9zdGFja2Jhc2UiLCJlbnZfY3Vycl9jaGFyIiwiZW52X2x2YWwiLCJlbnZfc3ltYl9zdGFydCIsImVudl9zeW1iX2VuZCIsImVudl9hc3AiLCJlbnZfcnVsZV9sZW4iLCJlbnZfcnVsZV9udW1iZXIiLCJlbnZfc3AiLCJlbnZfc3RhdGUiLCJlbnZfZXJyZmxhZyIsInRibF90cmFuc2xfY29uc3QiLCJ0YmxfdHJhbnNsX2Jsb2NrIiwidGJsX2xocyIsInRibF9sZW4iLCJ0YmxfZGVmcmVkIiwidGJsX2Rnb3RvIiwidGJsX3NpbmRleCIsInRibF9yaW5kZXgiLCJ0YmxfZ2luZGV4IiwidGJsX3RhYmxlc2l6ZSIsInRibF90YWJsZSIsInRibF9jaGVjayIsIm4xIiwibjIiLCJzdGF0ZTEiLCJzcCIsImVycmZsYWciLCJhc3AiLCJjYW1sX2FycmF5X2ZpbGwiLCJjYW1sX3N0cmluZ19ub3RlcXVhbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4iLCJjYW1sX2dyX21ha2VfaW1hZ2UiLCJjYW1sX21sX3NldF9jaGFubmVsX291dHB1dCIsImNhbWxfcmVhZF9maWxlX2NvbnRlbnQiLCJjYW1sX2pzX3RvX2Zsb2F0IiwiZXJyX25vX3ByZWQiLCJlcnJfbm9fc3VjYyIsInplcm8kMiIsIm9uZSQyIiwibWludXNfb25lJDIiLCJtaW5faW50JDIiLCJtYXhfaW50JDIiLCJkdW1teV9wb3MiLCJ6ZXJvX3BvcyIsInN1Yl9mb3JtYXQiLCJmb3JtYXR0aW5nX2xpdCIsImxvY2ZtdCIsImN1cnJlbnRfZGlyX25hbWUiLCJwYXJlbnRfZGlyX25hbWUiLCJkaXJfc2VwIiwicXVvdGVxdW90ZSIsImN1cnJlbnRfZGlyX25hbWUkMCIsInBhcmVudF9kaXJfbmFtZSQwIiwiZGlyX3NlcCQwIiwiY3VycmVudF9kaXJfbmFtZSQxIiwicGFyZW50X2Rpcl9uYW1lJDEiLCJkaXJfc2VwJDEiLCJ6ZXJvJDQiLCJvbmUkNCIsImkiLCJlcmFzZV9yZWwiLCJyZXN0IiwicmVzdCQwIiwicmVzdCQxIiwicmVzdCQyIiwicmVzdCQzIiwicmVzdCQ0IiwicmVzdCQ1IiwicmVzdCQ2IiwicmVzdCQ3IiwidHkiLCJyZXN0JDgiLCJ0eTEiLCJyZXN0JDkiLCJyZXN0JDEwIiwicmVzdCQxMSIsInJlc3QkMTIiLCJyZXN0JDEzIiwiY29uY2F0X2ZtdHR5IiwiZm10dHkxIiwiZm10dHkyIiwidHkyIiwiY29uY2F0X2ZtdCIsImZtdDEiLCJmbXQyIiwicGFkIiwicGFkJDAiLCJwcmVjIiwicGFkJDEiLCJpY29udiIsInByZWMkMCIsInBhZCQyIiwiaWNvbnYkMCIsInByZWMkMSIsInBhZCQzIiwiaWNvbnYkMSIsInByZWMkMiIsInBhZCQ0IiwiaWNvbnYkMiIsInByZWMkMyIsInBhZCQ1IiwiZmNvbnYiLCJwYWQkNiIsInN0ciIsImNociIsImZtdHR5IiwicGFkJDciLCJmbXR0eSQwIiwicGFkJDgiLCJyZXN0JDE0IiwicmVzdCQxNSIsInJlc3QkMTYiLCJmbXRpbmdfbGl0IiwicmVzdCQxNyIsImZtdGluZ19nZW4iLCJyZXN0JDE4IiwicmVzdCQxOSIsImNoYXJfc2V0Iiwid2lkdGhfb3B0IiwicmVzdCQyMCIsImNvdW50ZXIiLCJyZXN0JDIxIiwicmVzdCQyMiIsImlnbiIsInJlc3QkMjMiLCJmIiwiYXJpdHkiLCJzIiwieCIsInkiLCJpbmZpbml0eSIsIm5lZ19pbmZpbml0eSIsIm5hbiIsIm1heF9mbG9hdCIsIm1pbl9mbG9hdCIsImVwc2lsb24iLCJtYXhfaW50IiwiczEiLCJzMiIsImwxIiwibDIiLCJuIiwiYiIsImwiLCJpJDAiLCJ0b19zdHJpbmciLCJvZl9zdHJpbmdfb3B0IiwiYXBwZW5kIiwidGwiLCJoZCIsIm1vZGUiLCJwZXJtIiwibmFtZSIsImMiLCJpdGVyIiwiYSIsIm9jIiwib2ZzIiwibGVuIiwiY2hhbiIsInYiLCJpYyIsInVuc2FmZV9yZWFsbHlfaW5wdXQiLCJvZnMkMCIsImxlbiQwIiwiciIsImxlbiQxIiwib2ZzJDEiLCJidWlsZF9yZXN1bHQiLCJidWYiLCJhY2N1IiwiYmVnIiwiYWNjdSQwIiwicmVzIiwic3RyMiIsInN0cjEiLCJleGl0X2Z1bmN0aW9uIiwiZyIsImZfYWxyZWFkeV9yYW4iLCJyZXRjb2RlIiwiZW1wdHkiLCJyZXR1cm4kMCIsIm1hcCIsInNlcSIsIm5leHQiLCJmaWx0ZXJfbWFwIiwic2VxJDAiLCJmaWx0ZXIiLCJmbGF0X21hcCQwIiwiZmxhdF9tYXBfYXBwJDAiLCJ0YWlsIiwiZmxhdF9tYXBfYXBwIiwiZmxhdF9tYXAiLCJmb2xkX2xlZnQiLCJhY2MiLCJhY2MkMCIsImFjYyQxIiwibm9uZSIsInNvbWUiLCJ2YWx1ZSIsIm8iLCJkZWZhdWx0JDAiLCJnZXQiLCJiaW5kIiwiam9pbiIsIm1hcCQwIiwiZm9sZCIsIml0ZXIkMCIsImlzX25vbmUiLCJpc19zb21lIiwiZXF1YWwiLCJlcSIsIm8wIiwibzEiLCJ2MSIsInYwIiwiY29tcGFyZSIsImNtcCIsInRvX3Jlc3VsdCIsInRvX2xpc3QiLCJ0b19zZXEiLCJvayIsImVycm9yIiwiZSIsInZhbHVlJDAiLCJnZXRfb2siLCJnZXRfZXJyb3IiLCJiaW5kJDAiLCJqb2luJDAiLCJtYXAkMSIsIm1hcF9lcnJvciIsImZvbGQkMCIsIml0ZXIkMSIsIml0ZXJfZXJyb3IiLCJpc19vayIsImlzX2Vycm9yIiwiZXF1YWwkMCIsInIwIiwibWF0Y2giLCJlMSIsImNvbXBhcmUkMCIsInRvX29wdGlvbiIsInRvX2xpc3QkMCIsInRvX3NlcSQwIiwiZXF1YWwkMSIsImNvbXBhcmUkMSIsInRvX2ludCIsInRvX2Zsb2F0IiwidG9fc3RyaW5nJDAiLCJlc2NhcGVkIiwicyQwIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiY29tcGFyZSQyIiwiYzEiLCJjMiIsImVxdWFsJDIiLCJtaW4kMCIsIm1heCQwIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsImJvbSIsInJlcCIsInN1Y2MiLCJ1IiwicHJlZCIsImlzX3ZhbGlkIiwib2ZfaW50IiwiaXNfY2hhciIsIm9mX2NoYXIiLCJ0b19jaGFyIiwidW5zYWZlX3RvX2NoYXIiLCJlcXVhbCQzIiwiY29tcGFyZSQzIiwiaGFzaCIsIm1hdGNoJDEiLCJsZW5ndGgiLCJwYXJhbSQwIiwiY29ucyIsIm50aCIsImwkMCIsIm4kMCIsImwkMSIsIm4kMSIsIm50aF9vcHQiLCJyZXZfYXBwZW5kIiwibDEkMCIsImwyJDAiLCJsMSQxIiwibDIkMSIsInJldiIsImluaXRfYXV4IiwicmV2X2luaXRfdGhyZXNob2xkIiwicGFyYW0iLCJhY2N1JDEiLCJhMiIsImExIiwicCIsInBhaXIiLCJyeSIsInJ4IiwidDIiLCJoMiIsInQxIiwiaDEiLCJjaG9wIiwiayIsImskMCIsImskMSIsInJldl9zb3J0IiwieDIiLCJ4MSIsIngzIiwieDIkMCIsIngxJDAiLCJuMSIsIm4yIiwic29ydCIsImMkMCIsImMkMSIsImMkMiIsImMkMyIsImMkNCIsImMkNSIsImMkNiIsImFjY3UkMiIsImF1eCIsImRpcmVjdCIsImRlcHRoIiwic3ltYm9sJDEiLCJsZWZ0IiwicmlnaHQiLCJzcmNvZmYiLCJkc3RvZmYiLCJjcHlsZW4iLCJvZnMxIiwib2ZzMiIsInNlcCIsInNlcGxlbiIsImRzdCIsImlzX3NwYWNlIiwiaiIsImFwcGx5MSIsImluZGV4X3JlYyIsImxpbSIsImkkMSIsImluZGV4X3JlY19vcHQiLCJyaW5kZXhfcmVjIiwicmluZGV4X3JlY19vcHQiLCJuZXdfbGVuIiwibmV3X2J1ZiIsImlzX3NwYWNlJDAiLCJpbmRleF9yZWMkMCIsImluZGV4X3JlY19vcHQkMCIsInJpbmRleF9yZWMkMCIsInJpbmRleF9yZWNfb3B0JDAiLCJlcXVhbCQ2IiwiY29tcGFyZSQ2IiwidG9fc3RyaW5nJDIiLCJ0b19idWZmZXIiLCJidWZmIiwiZmxhZ3MiLCJoZWFkZXJfc2l6ZSIsImRhdGFfc2l6ZSIsInRvdGFsX3NpemUiLCJmcm9tX2J5dGVzIiwiZnJvbV9zdHJpbmciLCJpc19ibG9jayIsImRvdWJsZV9maWVsZCIsInNldF9kb3VibGVfZmllbGQiLCJtYXJzaGFsIiwib2JqIiwidW5tYXJzaGFsIiwicG9zIiwiZmlyc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yIiwibGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfIiwibGF6eV90YWciLCJjbG9zdXJlX3RhZyIsIm9iamVjdF90YWciLCJpbmZpeF90YWciLCJmb3J3YXJkX3RhZyIsIm5vX3NjYW5fdGFnIiwiYWJzdHJhY3RfdGFnIiwic3RyaW5nX3RhZyIsImRvdWJsZV90YWciLCJkb3VibGVfYXJyYXlfdGFnIiwiY3VzdG9tX3RhZyIsImludF90YWciLCJvdXRfb2ZfaGVhcF90YWciLCJ1bmFsaWduZWRfdGFnIiwib2ZfdmFsIiwic2xvdCIsImlkIiwiZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwiZXh0ZW5zaW9uX25hbWUiLCJleHRlbnNpb25faWQiLCJtYXhfZXBoZV9sZW5ndGgiLCJjcmVhdGUiLCJsZW5ndGgkMCIsInJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IiwibXNnIiwiZ2V0X2tleSIsImdldF9rZXlfY29weSIsInNldF9rZXkiLCJ1bnNldF9rZXkiLCJjaGVja19rZXkiLCJibGl0X2tleSIsImUyIiwibzIiLCJzeCIsInN5IiwiaW5pdCIsImxhIiwibGIiLCJyZXMkMCIsImxpc3RfbGVuZ3RoIiwicGFyYW0kMSIsInRsJDAiLCJoZCQwIiwibWF4c29uIiwiaTMxIiwidHJpY2tsZWRvd24iLCJ0cmlja2xlIiwiYnViYmxlZG93biIsImJ1YmJsZSIsImkkMiIsImUkMCIsImZhdGhlciIsIm1lcmdlIiwic3JjMW9mcyIsInNyYzFsZW4iLCJzcmMyIiwic3JjMm9mcyIsInNyYzJsZW4iLCJkc3RvZnMiLCJzcmMxciIsInNyYzJyIiwiczIkMSIsInMxJDEiLCJpMSIsImkyIiwiZCIsImkyJDAiLCJkJDAiLCJzMiQwIiwiaTEkMCIsImQkMSIsInMxJDAiLCJpc29ydHRvIiwic3Jjb2ZzIiwic29ydHRvIiwidCIsInplcm8iLCJvbmUiLCJtaW51c19vbmUiLCJpc19maW5pdGUiLCJpc19pbmZpbml0ZSIsImlzX25hbiIsInBpIiwiaXNfaW50ZWdlciIsInN1Y2MkMCIsInByZWQkMCIsImVxdWFsJDciLCJtaW4kMSIsIm1heCQxIiwibWluX21heCIsIm1pbl9udW0iLCJtYXhfbnVtIiwibWluX21heF9udW0iLCJoYXNoJDAiLCJ1bnNhZmVfZmlsbCIsInVuc2FmZV9ibGl0Iiwic3JjIiwic29mcyIsImRvZnMiLCJjaGVjayIsIm1ha2UkMSIsInJlc3VsdCIsImluaXQkMyIsImFwcGVuZCQxIiwiY29uY2F0JDIiLCJobGVuIiwic3ViJDIiLCJjb3B5JDIiLCJmaWxsJDEiLCJibGl0JDIiLCJ0b19saXN0JDIiLCJvZl9saXN0JDAiLCJoIiwiaXRlciQ2IiwiaXRlcjIkMSIsIm1hcCQ2IiwibWFwMiQxIiwiaXRlcmkkMyIsIm1hcGkkMyIsImZvbGRfbGVmdCQyIiwiZm9sZF9yaWdodCQxIiwiZXhpc3RzJDEiLCJmb3JfYWxsJDEiLCJtZW0kMSIsIm1lbV9pZWVlIiwic29ydCQwIiwic3RhYmxlX3NvcnQiLCJ0b19zZXEkNSIsInRvX3NlcWkkMiIsIm9mX3NlcSQzIiwibWFwX3RvX2FycmF5IiwibWFwX2Zyb21fYXJyYXkiLCJ6ZXJvJDAiLCJvbmUkMCIsIm1pbnVzX29uZSQwIiwiYWJzJDAiLCJtYXhfaW50JDAiLCJtaW5faW50JDAiLCJsb2dub3QiLCJlcXVhbCQ4IiwiY29tcGFyZSQ3IiwidG9fc3RyaW5nJDMiLCJ6ZXJvJDEiLCJvbmUkMSIsIm1pbnVzX29uZSQxIiwic3VjYyQxIiwicHJlZCQxIiwiYWJzJDEiLCJtaW5faW50JDEiLCJtYXhfaW50JDEiLCJsb2dub3QkMCIsInVuc2lnbmVkX3RvX2ludCIsInRvX3N0cmluZyQ0Iiwib2Zfc3RyaW5nX29wdCQwIiwiY29tcGFyZSQ4IiwiZXF1YWwkOSIsInVuc2lnbmVkX2NvbXBhcmUiLCJtIiwidW5zaWduZWRfZGl2IiwicSIsInVuc2lnbmVkX3JlbSIsInN1Y2MkMiIsInByZWQkMiIsImFicyQyIiwibG9nbm90JDEiLCJtYXhfaW50JDMiLCJ1bnNpZ25lZF90b19pbnQkMCIsInRvX3N0cmluZyQ1Iiwib2Zfc3RyaW5nX29wdCQxIiwiY29tcGFyZSQ5IiwiZXF1YWwkMTAiLCJ1bnNpZ25lZF9jb21wYXJlJDAiLCJ1bnNpZ25lZF9kaXYkMCIsInVuc2lnbmVkX3JlbSQwIiwiemVybyQzIiwib25lJDMiLCJtaW51c19vbmUkMyIsInN1Y2MkMyIsInByZWQkMyIsImFicyQzIiwibWluX2ludCQzIiwibWF4X2ludCQ0IiwibG9nbm90JDIiLCJ1bnNpZ25lZF90b19pbnQkMSIsInRvX3N0cmluZyQ2Iiwib2Zfc3RyaW5nX29wdCQyIiwiY29tcGFyZSQxMCIsImVxdWFsJDExIiwidW5zaWduZWRfY29tcGFyZSQxIiwidW5zaWduZWRfZGl2JDEiLCJ1bnNpZ25lZF9yZW0kMSIsImVuZ2luZSIsInRibCIsInN0YXRlIiwibmV3X2VuZ2luZSIsImZyb21fZnVuY3Rpb24iLCJvcHQiLCJzdGgiLCJ3aXRoX3Bvc2l0aW9ucyIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwiZnJvbV9zdHJpbmckMCIsImxleGVtZSIsInN1Yl9sZXhlbWUiLCJzdWJfbGV4ZW1lX29wdCIsInN1Yl9sZXhlbWVfY2hhciIsInN1Yl9sZXhlbWVfY2hhcl9vcHQiLCJsZXhlbWVfY2hhciIsImxleGVtZV9zdGFydCIsImxleGVtZV9lbmQiLCJsZXhlbWVfc3RhcnRfcCIsImxleGVtZV9lbmRfcCIsIm5ld19saW5lIiwibGNwIiwiZmx1c2hfaW5wdXQiLCJlbnYiLCJncm93X3N0YWNrcyIsIm9sZHNpemUiLCJuZXdzaXplIiwibmV3X3MiLCJuZXdfdiIsIm5ld19zdGFydCIsIm5ld19lbmQiLCJjbGVhcl9wYXJzZXIiLCJjdXJyZW50X2xvb2thaGVhZF9mdW4iLCJ5eXBhcnNlIiwidGFibGVzIiwic3RhcnQiLCJsZXhlciIsImluaXRfYXNwIiwiaW5pdF9zcCIsImluaXRfc3RhY2tiYXNlIiwiaW5pdF9zdGF0ZSIsImluaXRfY3Vycl9jaGFyIiwiaW5pdF9sdmFsIiwiaW5pdF9lcnJmbGFnIiwiY21kIiwiYXJnIiwiYXJnJDAiLCJjbWQkMCIsImFyZyQxIiwiZXhuIiwiY3Vycl9jaGFyIiwidG9rIiwicGVla192YWwiLCJzeW1ib2xfc3RhcnRfcG9zIiwic3QiLCJlbiIsInN5bWJvbF9lbmRfcG9zIiwicmhzX3N0YXJ0X3BvcyIsInJoc19lbmRfcG9zIiwic3ltYm9sX3N0YXJ0Iiwic3ltYm9sX2VuZCIsInJoc19zdGFydCIsInJoc19lbmQiLCJpc19jdXJyZW50X2xvb2thaGVhZCIsInBhcnNlX2Vycm9yIiwiaGVpZ2h0IiwiaGwiLCJoJDAiLCJociIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiIsImxybCIsInJyIiwicnYiLCJybCIsInJsciIsInJsdiIsInJsbCIsImFkZCIsInNpbmdsZXRvbiIsImFkZF9taW5fZWxlbWVudCIsImFkZF9tYXhfZWxlbWVudCIsInJoIiwibGgiLCJtaW5fZWx0IiwibWluX2VsdF9vcHQiLCJtYXhfZWx0IiwibWF4X2VsdF9vcHQiLCJyZW1vdmVfbWluX2VsdCIsInIkMCIsImNvbmNhdCIsInNwbGl0IiwicHJlcyIsInByZXMkMCIsImlzX2VtcHR5IiwibWVtIiwicmVtb3ZlIiwidW5pb24iLCJyMiIsInYyIiwicjEiLCJyMiQwIiwicjEkMCIsImludGVyIiwic3BsaXRfYmlzIiwiZGlzam9pbnQiLCJkaWZmIiwiY29uc19lbnVtIiwicyQxIiwiZSQxIiwiZTIkMiIsImUxJDIiLCJlMiQwIiwiZTEkMCIsImUyJDEiLCJlMSQxIiwic3Vic2V0IiwiZm9yX2FsbCIsImV4aXN0cyIsInB2IiwicGFydGl0aW9uIiwibGYiLCJsdCIsInJmIiwicnQiLCJjYXJkaW5hbCIsImVsZW1lbnRzX2F1eCIsImVsZW1lbnRzIiwiZmluZCIsImZpbmRfZmlyc3QiLCJ2JDAiLCJmaW5kX2ZpcnN0X29wdCIsImZpbmRfbGFzdCIsImZpbmRfbGFzdF9vcHQiLCJmaW5kX29wdCIsIm9mX2xpc3QiLCJzdWIiLCJsJDMiLCJ4MCIsImwkNCIsIngwJDAiLCJsJDUiLCJ4MCQxIiwibmwiLCJtaWQiLCJsJDIiLCJ4NCIsImFkZF9zZXEiLCJvZl9zZXEiLCJzZXFfb2ZfZW51bSIsInRvX3NlcV9mcm9tIiwibG93IiwibGQiLCJscmQiLCJyZCIsInJsZCIsImRhdGEiLCJtaW5fYmluZGluZyIsIm1pbl9iaW5kaW5nX29wdCIsIm1heF9iaW5kaW5nIiwibWF4X2JpbmRpbmdfb3B0IiwicmVtb3ZlX21pbl9iaW5kaW5nIiwidXBkYXRlIiwiZGF0YSQwIiwibWFwaSIsIm0kMCIsImFkZF9taW5fYmluZGluZyIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJtJDEiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjcmVhdGUkMCIsImNsZWFyIiwiY29weSQzIiwicHVzaCIsInBvcCIsInBvcF9vcHQiLCJ0b3AiLCJ0b3Bfb3B0IiwibGVuZ3RoJDEiLCJpdGVyJDciLCJmb2xkJDEiLCJ0b19zZXEkNiIsIm9mX3NlcSQ0IiwiY3JlYXRlJDEiLCJjbGVhciQwIiwiY2VsbCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlIiwidGFrZV9vcHQiLCJjb3B5JDQiLCJxX3JlcyIsInByZXYiLCJpc19lbXB0eSQwIiwibGVuZ3RoJDIiLCJpdGVyJDgiLCJmb2xkJDIiLCJ0cmFuc2ZlciIsInExIiwicTIiLCJ0b19zZXEkNyIsImFkZF9zZXEkMCIsIm9mX3NlcSQ1IiwicmFpc2VfdW5kZWZpbmVkIiwiZm9yY2VfbGF6eV9ibG9jayIsImJsayIsImNsb3N1cmUiLCJmb3JjZV92YWxfbGF6eV9ibG9jayIsImZvcmNlIiwibHp2IiwiZm9yY2VfdmFsIiwiZnJvbV9mdW4iLCJmcm9tX3ZhbCIsImlzX3ZhbCIsImNvdW50IiwiZmlsbF9idWZmIiwiZ2V0X2RhdGEiLCJkMTEiLCJhJDAiLCJhJDEiLCJwZWVrX2RhdGEiLCJwZWVrJDAiLCJqdW5rX2RhdGEiLCJqdW5rIiwibmdldF9kYXRhIiwiYWwiLCJucGVlayIsImVtcHR5JDEiLCJpdGVyJDkiLCJzdHJtIiwiZnJvbSIsIm9mX2xpc3QkMSIsIm9mX3N0cmluZyQwIiwib2ZfYnl0ZXMiLCJvZl9jaGFubmVsIiwiaWFwcCIsImljb25zIiwiaXNpbmciLCJsYXBwIiwibGNvbnMiLCJsc2luZyIsInNlbXB0eSIsInNsYXp5IiwiZHVtcF9kYXRhIiwiZHVtcCIsImNyZWF0ZSQyIiwiY29udGVudHMiLCJ0b19ieXRlcyIsInN1YiQzIiwiYmxpdCQzIiwibnRoJDAiLCJsZW5ndGgkMyIsImNsZWFyJDEiLCJyZXNldCIsInJlc2l6ZSIsIm1vcmUiLCJvbGRfcG9zIiwib2xkX2xlbiIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsImFkZF91dGZfOF91Y2hhciIsInBvcyQwIiwicG9zJDEiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJ1JDAiLCJoaSIsImxvIiwiYWRkX3V0Zl8xNmxlX3VjaGFyIiwiYWRkX3N1YnN0cmluZyIsIm9mZnNldCIsIm5ld19wb3NpdGlvbiIsImFkZF9zdWJieXRlcyIsImFkZF9zdHJpbmciLCJhZGRfYnl0ZXMiLCJhZGRfYnVmZmVyIiwiYnMiLCJhZGRfY2hhbm5lbCIsImFscmVhZHlfcmVhZCIsInRvX3JlYWQiLCJhbHJlYWR5X3JlYWQkMCIsInRvX3JlYWQkMCIsIm91dHB1dF9idWZmZXIiLCJhZGRfc3Vic3RpdHV0ZSIsImxpbSQxIiwicHJldmlvdXMiLCJpJDciLCJjdXJyZW50IiwiaSQ4Iiwib3BlbmluZyIsImkkNiIsImxpbSQwIiwiaSQzIiwic3RvcCIsImkkNCIsImkkNSIsImskMiIsIm5leHRfaSIsImlkZW50IiwiaSQ5IiwiaSQxMCIsImkkMTEiLCJ0cnVuY2F0ZSIsInRvX3NlcSQ4IiwidG9fc2VxaSQzIiwiYWRkX3NlcSQxIiwib2Zfc2VxJDYiLCJhZGRfaW50OCIsImFkZF9pbnQxNl9uZSIsImFkZF9pbnQzMl9uZSIsImFkZF9pbnQ2NF9uZSIsImFkZF9pbnQxNl9sZSIsImFkZF9pbnQxNl9iZSIsIngkMCIsImFkZF9pbnQzMl9sZSIsImFkZF9pbnQzMl9iZSIsImFkZF9pbnQ2NF9sZSIsImFkZF9pbnQ2NF9iZSIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImNGIiwiYnByaW50X3BhZHR5IiwicGFkdHkiLCJicHJpbnRfaWdub3JlZF9mbGFnIiwiaWduX2ZsYWciLCJicHJpbnRfcGFkX29wdCIsImJwcmludF9wYWRkaW5nIiwicGFkdHkkMCIsImJwcmludF9wcmVjaXNpb24iLCJicHJpbnRfaWNvbnZfZmxhZyIsImJwcmludF9hbHRpbnRfZm10IiwiYnByaW50X2Zjb252X2ZsYWciLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQiLCJzdHIkMCIsInN0cmluZ19vZl9mb3JtYXR0aW5nX2dlbiIsImZvcm1hdHRpbmdfZ2VuIiwiYnByaW50X2NoYXJfbGl0ZXJhbCIsImJwcmludF9zdHJpbmdfbGl0ZXJhbCIsImJwcmludF9mbXR0eSIsInN1Yl9mbXR0eSIsInN1Yl9mbXR0eSQwIiwiaW50X29mX2N1c3RvbV9hcml0eSIsInN0cmluZ19vZl9mbXQiLCJmbXQkMSIsImNociQwIiwicHJpbnRfY2hhciIsImlzX2Fsb25lJDAiLCJpc19hbG9uZSIsImFmdGVyIiwiYmVmb3JlIiwiaiQwIiwiaiQxIiwiZm10JDAiLCJzeW1tIiwidHJhbnMiLCJyZXN0MiIsInJlc3QyJDAiLCJyZXN0MiQxIiwicmVzdDIkMiIsInJlc3QyJDMiLCJyZXN0MiQ0IiwicmVzdDIkNSIsInJlc3QyJDYiLCJyZXN0MiQ3IiwicmVzdDIkOCIsInR5MjIiLCJ0eTIxIiwiZm10dHlfcmVsX2RldCIsImY0IiwiZjIiLCJyZXN0MiQ5IiwicmVzdDIkMTAiLCJyZXN0MiQxMSIsInJlc3QyJDEyIiwicmVzdDIkMTMiLCJkZSIsImVkIiwiYWYiLCJmYSIsImRlJDAiLCJlZCQwIiwiYWYkMCIsImZhJDAiLCJkZSQxIiwiZWQkMSIsImFmJDEiLCJmYSQxIiwiZGUkMiIsImVkJDIiLCJhZiQyIiwiZmEkMiIsImRlJDMiLCJlZCQzIiwiYWYkMyIsImZhJDMiLCJkZSQ0IiwiZWQkNCIsImFmJDQiLCJmYSQ0IiwiZGUkNSIsImVkJDUiLCJhZiQ1IiwiZmEkNSIsImRlJDYiLCJlZCQ2IiwiYWYkNiIsImZhJDYiLCJkZSQ3IiwiZWQkNyIsImFmJDciLCJmYSQ3IiwiZGUkOCIsImVkJDgiLCJhZiQ4IiwiZmEkOCIsImpkIiwiZGoiLCJnYSIsImFnIiwiZGUkOSIsImVkJDkiLCJhZiQ5IiwiZmEkOSIsImRlJDEwIiwiZWQkMTAiLCJhZiQxMCIsImZhJDEwIiwiZGUkMTEiLCJlZCQxMSIsImFmJDExIiwiZmEkMTEiLCJkZSQxMiIsImVkJDEyIiwiYWYkMTIiLCJmYSQxMiIsImRlJDEzIiwiZWQkMTMiLCJhZiQxMyIsImZhJDEzIiwiZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IiwiZm10dHlfb2ZfcGFkZGluZ19mbXR0eSIsImZtdHR5X29mX2N1c3RvbSIsImFyaXR5JDAiLCJmbXR0eV9vZl9mbXQiLCJ0eV9yZXN0IiwicHJlY190eSIsInR5X3Jlc3QkMCIsInByZWNfdHkkMCIsInR5X3Jlc3QkMSIsInByZWNfdHkkMSIsInR5X3Jlc3QkMiIsInByZWNfdHkkMiIsInR5X3Jlc3QkMyIsInByZWNfdHkkMyIsImZtdHR5JDEiLCJmbXR0eSQyIiwiZm10dHkkMyIsInR5JDAiLCJmbXR0eSQ0IiwiZm10dHkkNSIsInR5cGVfcGFkZGluZyIsInciLCJ0eXBlX3BhZHByZWMiLCJ0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGkiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJmbXR0eV9yZXN0Iiwic3ViX2ZtdHR5X3Jlc3QiLCJzdWJfZm10dHlfcmVzdCQwIiwiZm10dHlfcmVzdCQwIiwic3ViX2ZtdHR5X3Jlc3QkMSIsInN1Yl9mbXR0eV9yZXN0JDIiLCJmbXR0eV9yZXN0JDEiLCJzdWJfZm10dHlfcmVzdCQzIiwiZm10JDIiLCJzdWJfZm10dHlfcmVzdCQ0IiwiZm10dHlfcmVzdCQyIiwic3ViX2ZtdHR5X3Jlc3QkNSIsImZtdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNiIsImZtdHR5X3Jlc3QkMyIsInN1Yl9mbXR0eV9yZXN0JDciLCJmbXQkNCIsInN1Yl9mbXR0eV9yZXN0JDgiLCJmbXR0eV9yZXN0JDQiLCJzdWJfZm10dHlfcmVzdCQ5IiwiZm10JDUiLCJzdWJfZm10dHlfcmVzdCQxMCIsImZtdHR5X3Jlc3QkNSIsInN1Yl9mbXR0eV9yZXN0JDExIiwiZm10JDYiLCJzdWJfZm10dHlfcmVzdCQxMiIsImZtdHR5X3Jlc3QkNiIsInN1Yl9mbXR0eV9yZXN0JDEzIiwiZm10JDciLCJzdWJfZm10dHlfcmVzdCQxNCIsImZtdHR5X3Jlc3QkNyIsInN1YjJfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNSIsInN1YjJfZm10dHkkMCIsImZtdCQ4Iiwic3ViX2ZtdHR5X3Jlc3QkMTYiLCJmbXR0eV9yZXN0JDgiLCJzdWIyX2ZtdHR5JDEiLCJzdWIxX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTciLCJzdWIyX2ZtdHR5JDIiLCJzdWIxX2ZtdHR5JDAiLCJmbXQkOSIsInN1Yl9mbXR0eV9yZXN0JDE4IiwiZm10dHlfcmVzdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTkiLCJmbXQkMTAiLCJzdWJfZm10dHlfcmVzdCQyMCIsImZtdHR5X3Jlc3QkMTAiLCJzdWJfZm10dHlfcmVzdCQyMSIsImZtdCQxMSIsInN1Yl9mbXR0eV9yZXN0JDIyIiwiZm10dHlfcmVzdCQxMSIsInN1Yl9mbXR0eV9yZXN0JDIzIiwiZm10JDEyIiwic3ViX2ZtdHR5X3Jlc3QkMjQiLCJmbXR0eV9yZXN0JDEyIiwic3ViX2ZtdHR5X3Jlc3QkMjUiLCJmbXQkMTMiLCJzdWJfZm10dHlfcmVzdCQyNiIsImZtdF9yZXN0IiwiZm10X3Jlc3QkMCIsImZtdF9yZXN0JDEiLCJmbXRfcmVzdCQyIiwiZm10X3Jlc3QkMyIsImZtdF9yZXN0JDQiLCJmbXRfcmVzdCQ1IiwiZm10dHkkNiIsImZtdF9yZXN0JDYiLCJmbXR0eSQ3IiwiZm10X3Jlc3QkNyIsImZtdHR5JDgiLCJmbXRfcmVzdCQ4IiwiZm10dHkkOSIsImZtdF9yZXN0JDkiLCJmbXR0eSQxMCIsImZtdF9yZXN0JDEwIiwiZm10dHkkMTEiLCJmbXRfcmVzdCQxMSIsImZtdHR5JDEyIiwiZm10X3Jlc3QkMTIiLCJmbXR0eSQxMyIsInN1Yl9mbXR0eTEiLCJmbXRfcmVzdCQxMyIsInN1Yl9mbXR0eSQxIiwiZm10dHkkMTQiLCJmbXQkMTQiLCJmbXRfcmVzdCQxNCIsImZtdHR5JDE1IiwiZm10JDE1IiwiZm10X3Jlc3QkMTUiLCJmbXR0eSQxNiIsImZtdCQxNiIsImZtdF9yZXN0JDE2IiwiZm10dHkkMTciLCJmbXQkMTciLCJmbXRfcmVzdCQxNyIsImZtdHR5MyIsImZtdDMiLCJzdHIkMSIsImZtdDEkMCIsImZtdHR5MiQwIiwiZm10MiQwIiwiZm10dHkzJDAiLCJmbXQzJDAiLCJmbXR0eV9yZXN0JDEzIiwiZm10X3Jlc3QkMTgiLCJmbXR0eSQxOCIsImZtdCQxOCIsImZtdHR5X3Jlc3QkMTQiLCJmbXRfcmVzdCQxOSIsImZtdHR5JDE5IiwiZm10JDE5IiwiZm10dHlfcmVzdCQxNSIsImZtdF9yZXN0JDIwIiwiZm10dHkkMjAiLCJmbXQkMjAiLCJ0eXBlX2lnbm9yZWRfcGFyYW1fb25lIiwiZm10dHlfcmVzdCQxNiIsImZtdHR5JDIxIiwiZm10JDIxIiwic3ViX2ZtdHR5JDIiLCJzdWJfZm10dHkkMyIsImZtdHR5JDIyIiwiZm10JDIyIiwic3ViX2ZtdHR5JDQiLCJ0eXBlX2Zvcm1hdCIsInJlY2FzdCIsImZpeF9wYWRkaW5nIiwid2lkdGgkMCIsImZpeF9pbnRfcHJlY2lzaW9uIiwicmVzJDEiLCJzdHJpbmdfdG9fY2FtbF9zdHJpbmciLCJ0cmFuc2Zvcm1faW50X2FsdCIsImRpZ2l0cyIsInB1dCIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJzaWduIiwic3ltYiIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfcHJpbnRmJDAiLCJuZXdfYWNjIiwibWFrZV9wcmludGYiLCJtYWtlX3BhZGRpbmciLCJtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiIsInAkMCIsInAkMSIsImFjYyQyIiwiYWNjJDMiLCJhY2MkNCIsImskMyIsImthY2MiLCJrJDQiLCJtYWtlX2lnbm9yZWRfcGFyYW0kMCIsIm1ha2VfY3VzdG9tJDAiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9mcm9tX2ZtdHR5JDAiLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2N1c3RvbSIsIm1ha2VfaWdub3JlZF9wYXJhbSIsIm1ha2VfaXByaW50ZiQwIiwibWFrZV9pcHJpbnRmIiwiZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24iLCJrb2MiLCJyZXN0JDI0IiwicmVzdCQyNSIsImZuX29mX2N1c3RvbV9hcml0eSQwIiwiZm5fb2ZfY3VzdG9tX2FyaXR5Iiwib3V0cHV0X2FjYyIsInAkMiIsInAkMyIsInAkNCIsImJ1ZnB1dF9hY2MiLCJzdHJwdXRfYWNjIiwiZmFpbHdpdGhfbWVzc2FnZSIsIm9wZW5fYm94X29mX3N0cmluZyIsImludmFsaWRfYm94IiwicGFyc2Vfc3BhY2VzIiwicGFyc2VfbHdvcmQiLCJwYXJzZV9pbnQiLCJ3c3RhcnQiLCJ3ZW5kIiwiYm94X25hbWUiLCJuc3RhcnQiLCJuZW5kIiwiaW5kZW50IiwiZXhwX2VuZCIsImJveF90eXBlIiwibWFrZV9wYWRkaW5nX2ZtdF9lYmIiLCJtYWtlX3BhZHByZWNfZm10X2ViYiIsImZtdF9lYmJfb2Zfc3RyaW5nIiwibGVnYWN5X2JlaGF2aW9yIiwiZmxhZyIsImxlZ2FjeV9iZWhhdmlvciQwIiwiaW52YWxpZF9mb3JtYXRfbWVzc2FnZSIsInVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCIsImVuZF9pbmQiLCJpbnZhbGlkX2Zvcm1hdF93aXRob3V0IiwiZXhwZWN0ZWRfY2hhcmFjdGVyIiwiZXhwZWN0ZWQiLCJhZGRfbGl0ZXJhbCIsImxpdF9zdGFydCIsInNpemUiLCJwYXJzZV9wb3NpdGl2ZSIsInN0cl9pbmQkMCIsInN0cl9pbmQkMSIsInBhcnNlX2ludGVnZXIiLCJuZXh0X2luZCIsImluY29tcGF0aWJsZV9mbGFnIiwicGN0X2luZCIsIm9wdGlvbiIsInN1YmZtdCIsImNvbXB1dGVfaW50X2NvbnYiLCJwbHVzIiwic3BhY2UiLCJwbHVzJDAiLCJzcGFjZSQwIiwic2VhcmNoX3N1YmZvcm1hdF9lbmQiLCJzdWJfZW5kIiwic3RyX2luZCQyIiwic3ViX2VuZCQwIiwic3RyX2luZCQzIiwic3ViX2VuZCQxIiwic3RyX2luZCQ0Iiwic3RyX2luZCQ1Iiwic3ViX2VuZCQyIiwic3RyX2luZCQ2Iiwic3RyX2luZCQ3IiwicGFyc2VfbWFnaWNfc2l6ZSIsInN0cl9pbmRfMSIsInN0cl9pbmRfMiIsInN0cl9pbmRfMyIsInBhcnNlIiwicGFyc2VfZ29vZF9icmVhayIsImZvcm1hdHRpbmdfbGl0JDAiLCJzdHJfaW5kXzQiLCJzdHJfaW5kXzUiLCJwYXJzZV90YWciLCJpc19vcGVuX3RhZyIsImluZCIsInN1Yl9zdHIiLCJzdWJfZm10Iiwic3ViX2Zvcm1hdCQwIiwiZm9ybWF0dGluZyQwIiwiZm9ybWF0dGluZyIsInBhcnNlX2ZsYWdzIiwibWludXMiLCJzZXRfZmxhZyIsIm5ld19pbmQiLCJwYXJzZV9hZnRlcl9wYWRkaW5nIiwicGFyc2VfbGl0ZXJhbCIsInBhcnNlX2FmdGVyX3ByZWNpc2lvbiIsInN5bWIkMCIsIm1pbnVzJDAiLCJwYXJzZV9jb252ZXJzaW9uIiwicGFyc2VfY29udiIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwid2lkdGgkMSIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZm10X3Jlc3VsdCIsImlnbm9yZWQkMiIsImNvdW50ZXIkMCIsImlnbm9yZWQkNiIsImlnbm9yZWQkNyIsImFkZF9yYW5nZSIsImZhaWxfc2luZ2xlX3BlcmNlbnQiLCJwYXJzZV9jaGFyX3NldF9jb250ZW50IiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciQwIiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciIsInJldmVyc2UiLCJjaGFyX3NldCQxIiwiaWdub3JlZCQ5IiwiY2hhcl9mb3JtYXQiLCJmbXRfcmVzdCQyMSIsImZtdF9yZXN0JDIyIiwicGFkJDkiLCJmbXRfcmVzdCQyMyIsImlnbm9yZWQkMTAiLCJmbXRfcmVzdCQyNCIsInBhZCQxMCIsImZtdF9yZXN0JDI1Iiwic3ViX2ZtdCQwIiwiZm10X3Jlc3QkMjYiLCJpZ25vcmVkJDExIiwiaWdub3JlZCQzIiwiaWdub3JlZCQ1IiwiaWdub3JlZCQ4IiwicHJlYyQ0Iiwic3BhY2UkMSIsInBsdXMkMiIsImtpbmQiLCJpZ25vcmVkJDQiLCJpZ25vcmVkIiwiaWdub3JlZCQwIiwiaWdub3JlZCQxIiwicGx1cyQxIiwiaWduJDAiLCJmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IiwiZm9ybWF0X29mX3N0cmluZ19mb3JtYXQiLCJrZnByaW50ZiIsImticHJpbnRmIiwiaWtmcHJpbnRmIiwiZnByaW50ZiIsImJwcmludGYiLCJpZnByaW50ZiIsInByaW50ZiIsImVwcmludGYiLCJrc3ByaW50ZiIsInNwcmludGYiLCJhc3NvYzMiLCJ5MiIsInkxIiwic3BsaXQkMCIsIm1ha2Vfc3ltbGlzdCIsInByZWZpeCIsInN1ZmZpeCIsImhlbHBfYWN0aW9uIiwiYWRkX2hlbHAiLCJzcGVjbGlzdCIsImFkZDIiLCJ1c2FnZV9iIiwiZXJybXNnIiwiZG9jIiwic3BlYyIsImtleSIsInVzYWdlX3N0cmluZyIsInVzYWdlIiwiYm9vbF9vZl9zdHJpbmdfb3B0JDAiLCJpbnRfb2Zfc3RyaW5nX29wdCQwIiwiZmxvYXRfb2Zfc3RyaW5nX29wdCIsInBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXyIsImFsbG93X2V4cGFuZCIsImFyZ3YiLCJhbm9uZnVuIiwiaW5pdHBvcyIsImNvbnZlcnRfZXJyb3IiLCJwcm9nbmFtZSIsImFjdGlvbiIsImZvbGxvdyQwIiwia2V5d29yZCIsIm5vX2FyZyQwIiwiZm9sbG93Iiwibm9fYXJnIiwiZ2V0X2FyZyQwIiwiZ2V0X2FyZyIsImNvbnN1bWVfYXJnJDAiLCJjb25zdW1lX2FyZyIsInRyZWF0X2FjdGlvbiQwIiwidHJlYXRfYWN0aW9uIiwiZiQwIiwiZiQxIiwiciQxIiwiZiQyIiwiciQyIiwiYXJnJDIiLCJmJDMiLCJhcmckMyIsIngkMSIsInIkMyIsImFyZyQ0IiwieCQyIiwic3BlY3MiLCJmJDQiLCJhcmckNSIsImYkNSIsImYkNiIsImFyZyQ2IiwibmV3YXJnIiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMiLCJwYXJzZV9hcmd2X2R5bmFtaWMiLCJjdXJyZW50JDAiLCJwYXJzZV9hcmd2IiwibXNnJDAiLCJtc2ckMSIsInBhcnNlX2R5bmFtaWMiLCJwYXJzZV9leHBhbmQiLCJzZWNvbmRfd29yZCIsImxvb3AiLCJtYXhfYXJnX2xlbiIsImN1ciIsImt3ZCIsInJlcGxhY2VfbGVhZGluZ190YWIiLCJzZWVuIiwiYWxpZ24iLCJsaW1pdCIsImNvbXBsZXRlZCIsImtzZCIsImN1dGNvbCQwIiwic3BhY2VzJDAiLCJjdXRjb2wiLCJrd2RfbGVuIiwic3BhY2VzIiwicmVhZF9hdXgiLCJ0cmltIiwiZmlsZSIsIndvcmRzIiwic3Rhc2giLCJ3b3JkIiwicmVhZF9hcmciLCJyZWFkX2FyZzAiLCJ3cml0ZV9hdXgiLCJhcmdzIiwid3JpdGVfYXJnIiwid3JpdGVfYXJnMCIsInByaW50ZXJzIiwiZmllbGQiLCJvdGhlcl9maWVsZHMiLCJ1c2VfcHJpbnRlcnMiLCJjb252IiwidG9fc3RyaW5nX2RlZmF1bHQiLCJjaGFyJDAiLCJsaW5lIiwiY2hhciQxIiwibGluZSQwIiwiZmlsZSQwIiwiY2hhciQyIiwibGluZSQxIiwiZmlsZSQxIiwiY29uc3RydWN0b3IiLCJ0b19zdHJpbmckNyIsInByaW50IiwiZmN0IiwiY2F0Y2gkMCIsImNvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImJ0IiwiZm9ybWF0X2JhY2t0cmFjZV9zbG90IiwiaW5mbyIsImlzX3JhaXNlIiwicHJpbnRfcmF3X2JhY2t0cmFjZSIsIm91dGNoYW4iLCJyYXdfYmFja3RyYWNlIiwiYmFja3RyYWNlIiwicHJpbnRfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZV90b19zdHJpbmciLCJiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSIsImJhY2t0cmFjZV9zbG90X2lzX2lubGluZSIsImJhY2t0cmFjZV9zbG90X2xvY2F0aW9uIiwiYmFja3RyYWNlX3Nsb3RzIiwiZ2V0X2JhY2t0cmFjZSIsInJlZ2lzdGVyX3ByaW50ZXIiLCJmbiIsImV4bl9zbG90IiwiZXhuX3Nsb3RfaWQiLCJleG5fc2xvdF9uYW1lIiwidW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJjb25zdCQwIiwiZmxpcCIsIm5lZ2F0ZSIsInByb3RlY3QiLCJmaW5hbGx5JDAiLCJ3b3JrIiwiZmluYWxseV9ub19leG4iLCJ3b3JrX2V4biIsIndvcmtfYnQiLCJwcmludF9zdGF0IiwiYWxsb2NhdGVkX2J5dGVzIiwibWEiLCJwcm8iLCJtaSIsImNyZWF0ZV9hbGFybSIsImRlbGV0ZV9hbGFybSIsInN0cmluZyIsImJ5dGVzIiwic3Vic3RyaW5nIiwic3ViYnl0ZXMiLCJmaWxlbmFtZSIsIm91dHB1dCQwIiwiZGlnZXN0IiwiaW5wdXQkMCIsImNoYXJfaGV4IiwidG9faGV4IiwiZnJvbV9oZXgiLCJkaWdpdCIsIm5ld19zdGF0ZSIsImFzc2lnbiIsInN0MSIsInN0MiIsImZ1bGxfaW5pdCIsInNlZWQiLCJzZWVkJDAiLCJtYWtlJDIiLCJtYWtlX3NlbGZfaW5pdCIsImNvcHkkNSIsImJpdHMiLCJjdXJ2YWwiLCJuZXd2YWwiLCJuZXd2YWwzMCIsImludCQwIiwiYm91bmQiLCJpbnQzMiIsImIxIiwiYjIiLCJpbnQ2NCIsImIzIiwibmF0aXZlaW50IiwiZmxvYXQkMCIsImJvb2wiLCJiaXRzJDAiLCJpbnQkMSIsImludDMyJDAiLCJuYXRpdmVpbnQkMCIsImludDY0JDAiLCJmbG9hdCQxIiwic2NhbGUiLCJib29sJDAiLCJmdWxsX2luaXQkMCIsImluaXQkNCIsInNlbGZfaW5pdCIsImdldF9zdGF0ZSIsInNldF9zdGF0ZSIsImhhc2gkMSIsImhhc2hfcGFyYW0iLCJzZWVkZWRfaGFzaCIsIm9uZ29pbmdfdHJhdmVyc2FsIiwiZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCIsInBhcmFtcyIsInJhbmRvbWl6ZWRfZGVmYXVsdCIsInJhbmRvbWl6ZWQiLCJyYW5kb21pemUiLCJpc19yYW5kb21pemVkIiwicHJuZyIsImNyZWF0ZSQzIiwiaW5pdGlhbF9zaXplIiwicmFuZG9tIiwiY2xlYXIkMiIsInJlc2V0JDAiLCJjb3B5X2J1Y2tldGxpc3QiLCJrZXkkMCIsIm5leHQkMCIsImNvcHkkNiIsImxlbmd0aCQ0IiwicmVzaXplJDAiLCJpbmRleGZ1biIsIm9kYXRhIiwib3NpemUiLCJuc2l6ZSIsIm5kYXRhIiwibmRhdGFfdGFpbCIsImlucGxhY2UiLCJjZWxsJDAiLCJuaWR4IiwibWF0Y2gkMCIsImtleV9pbmRleCIsImFkZCQwIiwiYnVja2V0IiwiZmluZCQwIiwiazEiLCJuZXh0MSIsImsyIiwibmV4dDIiLCJrMyIsImQzIiwibmV4dDMiLCJmaW5kX29wdCQwIiwiZmluZF9hbGwkMCIsImZpbmRfaW5fYnVja2V0IiwicmVwbGFjZSIsIm1lbSQyIiwiaXRlciQxMCIsImRvX2J1Y2tldCIsIm9sZF90cmF2IiwiZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCIsImZpbHRlcl9tYXBfaW5wbGFjZSIsImZvbGQkMyIsImIkMCIsImJ1Y2tldF9sZW5ndGgiLCJzdGF0cyIsIm1ibCIsImhpc3RvIiwidG9fc2VxJDkiLCJ0YmxfZGF0YSIsImJ1Y2siLCJidWNrJDAiLCJidWNrJDEiLCJ0b19zZXFfa2V5cyIsInRvX3NlcV92YWx1ZXMiLCJhZGRfc2VxJDIiLCJyZXBsYWNlX3NlcSIsIm9mX3NlcSQ3IiwiZmluZF9hbGwiLCJjb3B5Iiwic3oiLCJ3ZWFrX2NyZWF0ZSIsImxlbmd0aCQ1IiwicmFpc2VfaWZfaW52YWxpZF9vZmZzZXQkMCIsInNldCIsImdldCQwIiwiZ2V0X2NvcHkiLCJjaGVjayQwIiwiYmxpdCQ0IiwiZmlsbCQyIiwiYXIiLCJlbXB0eWJ1Y2tldCIsImdldF9pbmRleCIsInN6JDAiLCJzeiQxIiwiY291bnRfYnVja2V0IiwiYWRkX2F1eCIsInNldHRlciIsImluZGV4IiwiYnVja2V0JDAiLCJoYXNoZXMiLCJuZXdzeiIsIm5ld2J1Y2tldCQwIiwibmV3aGFzaGVzIiwiaGJ1Y2tldCIsInByZXZfbGVuIiwibGl2ZSIsImokMiIsIm5ld2J1Y2tldCIsIm5ld3QiLCJvYiIsIm9oIiwic2V0dGVyJDAiLCJuYiIsIm5pIiwiZmluZF9vciIsImlmbm90Zm91bmQiLCJmaW5kX3NoYWRvdyIsImlmZm91bmQiLCJsZW5zIiwidG90bGVuIiwiaWQkMCIsInVua25vd24iLCJwcF9lbnF1ZXVlIiwidG9rZW4iLCJwcF9pbmZpbml0eSIsInBwX291dHB1dF9zdHJpbmciLCJwcF9vdXRwdXRfbmV3bGluZSIsImZvcm1hdF9wcF90ZXh0IiwidGV4dCIsImZvcm1hdF9zdHJpbmciLCJicmVha19uZXdfbGluZSIsInJlYWxfaW5kZW50IiwiYnJlYWtfbGluZSIsImJyZWFrX3NhbWVfbGluZSIsImFkdmFuY2VfbGVmdCIsInNpemUkMCIsInBlbmRpbmdfY291bnQiLCJzaXplJDEiLCJ0YWJzIiwiYWRkX3RhYiIsImxzIiwidGFnX25hbWUiLCJtYXJrZXIiLCJicmVha3MiLCJmaXRzIiwib2ZmIiwiYm94X3R5cGUkMCIsIm9mZiQwIiwiaW5zZXJ0aW9uX3BvaW50IiwidGFicyQwIiwiZmlyc3QiLCJoZWFkIiwidGFiIiwib2ZmJDEiLCJpbnNlcnRpb25fcG9pbnQkMCIsIndpZHRoJDIiLCJib3hfdHlwZSQxIiwidGJveCIsInRhZ19uYW1lJDAiLCJtYXJrZXIkMCIsImVucXVldWVfYWR2YW5jZSIsImVucXVldWVfc3RyaW5nX2FzIiwiaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIiwic3RhY2siLCJxdWV1ZV9lbGVtIiwic2V0X3NpemUiLCJsZWZ0X3RvdGFsIiwic2Nhbl9wdXNoIiwiZWxlbSIsInBwX29wZW5fYm94X2dlbiIsImJyX3R5IiwicHBfY2xvc2VfYm94IiwicHBfb3Blbl9zdGFnIiwicHBfY2xvc2Vfc3RhZyIsInBwX29wZW5fdGFnIiwicHBfY2xvc2VfdGFnIiwicHBfc2V0X3ByaW50X3RhZ3MiLCJwcF9zZXRfbWFya190YWdzIiwicHBfZ2V0X3ByaW50X3RhZ3MiLCJwcF9nZXRfbWFya190YWdzIiwicHBfc2V0X3RhZ3MiLCJwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb24iLCJwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb24iLCJwY3QiLCJwb3QiLCJtY3QiLCJtb3QiLCJwcF9yaW5pdCIsInBwX2ZsdXNoX3F1ZXVlIiwicHBfcHJpbnRfYXNfc2l6ZSIsInBwX3ByaW50X2FzIiwiaXNpemUiLCJwcF9wcmludF9zdHJpbmciLCJwcF9wcmludF9pbnQiLCJwcF9wcmludF9mbG9hdCIsInBwX3ByaW50X2Jvb2wiLCJwcF9wcmludF9jaGFyIiwicHBfb3Blbl9oYm94IiwicHBfb3Blbl92Ym94IiwicHBfb3Blbl9odmJveCIsInBwX29wZW5faG92Ym94IiwicHBfb3Blbl9ib3giLCJwcF9wcmludF9uZXdsaW5lIiwicHBfcHJpbnRfZmx1c2giLCJwcF9mb3JjZV9uZXdsaW5lIiwicHBfcHJpbnRfaWZfbmV3bGluZSIsInBwX3ByaW50X2N1c3RvbV9icmVhayIsInBwX3ByaW50X2JyZWFrIiwicHBfcHJpbnRfc3BhY2UiLCJwcF9wcmludF9jdXQiLCJwcF9vcGVuX3Rib3giLCJwcF9jbG9zZV90Ym94IiwicHBfcHJpbnRfdGJyZWFrIiwicHBfcHJpbnRfdGFiIiwicHBfc2V0X3RhYiIsInBwX3NldF9tYXhfYm94ZXMiLCJwcF9nZXRfbWF4X2JveGVzIiwicHBfb3Zlcl9tYXhfYm94ZXMiLCJwcF9zZXRfZWxsaXBzaXNfdGV4dCIsInBwX2dldF9lbGxpcHNpc190ZXh0IiwicHBfbGltaXQiLCJwcF9zZXRfbWF4X2luZGVudCIsInBwX2dldF9tYXhfaW5kZW50IiwicHBfc2V0X21hcmdpbiIsIm5ld19tYXhfaW5kZW50IiwiY2hlY2tfZ2VvbWV0cnkiLCJnZW9tZXRyeSIsInBwX2dldF9tYXJnaW4iLCJwcF9zZXRfZ2VvbWV0cnkiLCJtYXhfaW5kZW50IiwibWFyZ2luIiwicHBfc2FmZV9zZXRfZ2VvbWV0cnkiLCJwcF9nZXRfZ2VvbWV0cnkiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJkaXNwbGF5X25ld2xpbmUiLCJibGFua19saW5lIiwiZGlzcGxheV9pbmRlbnQiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwiZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnIiwiZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWciLCJkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyIsInBwX21ha2VfZm9ybWF0dGVyIiwicHBfcXVldWUiLCJzeXNfdG9rIiwic2Nhbl9zdGFjayIsImZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIiwib3V0X2Z1bnMiLCJtYWtlX2Zvcm1hdHRlciIsIm91dHB1dCIsImZsdXNoIiwicHBmIiwiZm9ybWF0dGVyX29mX291dF9jaGFubmVsIiwiZm9ybWF0dGVyX29mX2J1ZmZlciIsInBwX2J1ZmZlcl9zaXplIiwicHBfbWFrZV9idWZmZXIiLCJzdGRidWYiLCJzdGRfZm9ybWF0dGVyIiwiZXJyX2Zvcm1hdHRlciIsInN0cl9mb3JtYXR0ZXIiLCJmbHVzaF9idWZmZXJfZm9ybWF0dGVyIiwiZmx1c2hfc3RyX2Zvcm1hdHRlciIsIm1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJzb2IiLCJnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImZsdXNoX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJpdGVtcyIsImFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSIsIml0ZW0iLCJmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2IiLCJvcGVuX2hib3giLCJvcGVuX3Zib3giLCJvcGVuX2h2Ym94Iiwib3Blbl9ob3Zib3giLCJvcGVuX2JveCIsImNsb3NlX2JveCIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwib3Blbl9zdGFnIiwiY2xvc2Vfc3RhZyIsInByaW50X2FzIiwicHJpbnRfc3RyaW5nJDAiLCJwcmludF9pbnQkMCIsInByaW50X2Zsb2F0JDAiLCJwcmludF9jaGFyJDAiLCJwcmludF9ib29sIiwicHJpbnRfYnJlYWsiLCJwcmludF9jdXQiLCJwcmludF9zcGFjZSIsImZvcmNlX25ld2xpbmUiLCJwcmludF9mbHVzaCIsInByaW50X25ld2xpbmUkMCIsInByaW50X2lmX25ld2xpbmUiLCJvcGVuX3Rib3giLCJjbG9zZV90Ym94IiwicHJpbnRfdGJyZWFrIiwic2V0X3RhYiIsInByaW50X3RhYiIsInNldF9tYXJnaW4iLCJnZXRfbWFyZ2luIiwic2V0X21heF9pbmRlbnQiLCJnZXRfbWF4X2luZGVudCIsInNldF9nZW9tZXRyeSIsInNhZmVfc2V0X2dlb21ldHJ5IiwiZ2V0X2dlb21ldHJ5Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2xpc3QiLCJwcF92Iiwib3B0JDAiLCJwcF9zZXAiLCJvcHQkMSIsInBwX3ByaW50X3RleHQiLCJwcF9wcmludF9vcHRpb24iLCJwcF9wcmludF9yZXN1bHQiLCJjb21wdXRlX3RhZyIsInRhZ19hY2MiLCJvdXRwdXRfZm9ybWF0dGluZ19saXQiLCJvdXRwdXRfYWNjJDAiLCJidHkiLCJwJDUiLCJwJDYiLCJzdHJwdXRfYWNjJDAiLCJrZnByaW50ZiQwIiwiaWtmcHJpbnRmJDAiLCJpZnByaW50ZiQwIiwiZnByaW50ZiQwIiwicHJpbnRmJDAiLCJlcHJpbnRmJDAiLCJrZHByaW50ZiIsImRwcmludGYiLCJrcHJpbnRmIiwic3ByaW50ZiQwIiwia2FzcHJpbnRmIiwiYXNwcmludGYiLCJmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzIiwicHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1IiwicHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1Iiwic2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0IiwiZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0IiwiYnByaW50ZiQwIiwicHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwic3RyaW5naWZ5IiwicHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwiZnVucyIsIm1hcmtfb3Blbl90YWciLCJtYXJrX2Nsb3NlX3RhZyIsInByaW50X29wZW5fdGFnIiwicHJpbnRfY2xvc2VfdGFnIiwic2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIiwibnVsbF9jaGFyIiwibmV4dF9jaGFyIiwiaWIiLCJwZWVrX2NoYXIiLCJjaGVja2VkX3BlZWtfY2hhciIsImVuZF9vZl9pbnB1dCIsImJlZ2lubmluZ19vZl9pbnB1dCIsIm5hbWVfb2ZfaW5wdXQiLCJmbmFtZSIsImNoYXJfY291bnQiLCJyZXNldF90b2tlbiIsImludmFsaWRhdGVfY3VycmVudF9jaGFyIiwidG9rZW5fc3RyaW5nIiwidG9rZW5fYnVmZmVyIiwic2tpcF9jaGFyIiwiaWdub3JlX2NoYXIiLCJzdG9yZV9jaGFyIiwiZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSIsImNyZWF0ZSQ0IiwiaW5hbWUiLCJmcm9tX3N0cmluZyQxIiwiZnJvbV9mdW5jdGlvbiQwIiwic2Nhbl9jbG9zZV9hdF9lbmQiLCJzY2FuX3JhaXNlX2F0X2VuZCIsImZyb21faWMiLCJzY2FuX2Nsb3NlX2ljIiwiZW9mIiwic3RkaWIiLCJvcGVuX2luX2ZpbGUiLCJvcGVuX2luIiwiZnJvbV9maWxlIiwiZnJvbV9maWxlX2JpbiIsImZyb21fY2hhbm5lbCQwIiwiY2xvc2VfaW4kMCIsImljJDAiLCJtZW1vIiwibWVtb19mcm9tX2ljIiwibWVtb19mcm9tX2NoYW5uZWwiLCJiYWRfaW5wdXQiLCJiYWRfaW5wdXRfZXNjYXBlIiwiYmFkX3Rva2VuX2xlbmd0aCIsIm1lc3NhZ2UiLCJiYWRfZmxvYXQiLCJiYWRfaGV4X2Zsb2F0IiwiY2hhcmFjdGVyX21pc21hdGNoIiwiY2kiLCJjaGVja190aGlzX2NoYXIiLCJjaGVja19jaGFyIiwidG9rZW5fY2hhciIsInRva2VuX2Jvb2wiLCJpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciIsInRva2VuX2ludF9saXRlcmFsIiwidG9rZW5fZmxvYXQiLCJzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciIsInNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQiLCJzY2FuX2RpZ2l0X3BsdXMiLCJiYXNpcyIsImRpZ2l0cCIsIndpZHRoJDMiLCJpc19iaW5hcnlfZGlnaXQiLCJzY2FuX2JpbmFyeV9pbnQiLCJpc19vY3RhbF9kaWdpdCIsInNjYW5fb2N0YWxfaW50IiwiaXNfaGV4YV9kaWdpdCIsInNjYW5faGV4YWRlY2ltYWxfaW50Iiwic2Nhbl9zaWduIiwic2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsIiwic2Nhbl9pbnRfY29udmVyc2lvbiIsInNjYW5fZnJhY3Rpb25hbF9wYXJ0Iiwic2Nhbl9leHBvbmVudF9wYXJ0Iiwic2Nhbl9mbG9hdCIsInByZWNpc2lvbiIsInByZWNpc2lvbiQwIiwiY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmciLCJzY2FuX2hleF9mbG9hdCIsIndpZHRoJDQiLCJ3aWR0aCQ1Iiwid2lkdGgkNiIsIndpZHRoJDEwIiwid2lkdGgkNyIsIndpZHRoJDgiLCJ3aWR0aCQ5Iiwic2Nhbl9jYW1sX2Zsb2F0X3Jlc3QiLCJ3aWR0aF9wcmVjaXNpb24iLCJmcmFjX3dpZHRoIiwic2Nhbl9jYW1sX2Zsb2F0Iiwic2Nhbl9zdHJpbmciLCJzdHAiLCJzY2FuX2NoYXIiLCJoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIiwiY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmciLCJzY2FuX2JhY2tzbGFzaF9jaGFyIiwiYzAiLCJnZXRfZGlnaXQiLCJnZXRfZGlnaXQkMCIsImMxJDAiLCJjMiQwIiwic2Nhbl9jYW1sX2NoYXIiLCJmaW5kX3N0b3AiLCJzY2FuX2NhbWxfc3RyaW5nIiwiZmluZF9zdG9wJDAiLCJza2lwX3NwYWNlcyIsInNjYW5fY2hhcnNfaW5fY2hhcl9zZXQiLCJzY2FuX2luZGljIiwic2Nhbl9jaGFycyIsInNjYW5mX2JhZF9pbnB1dCIsImdldF9jb3VudGVyIiwid2lkdGhfb2ZfcGFkX29wdCIsInN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQiLCJmbXRpbmciLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzJDAiLCJ0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzJDAiLCJyZWFkZXIiLCJuZXdfayIsInJlYWRlcnNfcmVzdCIsInRha2VfZm9ybWF0X3JlYWRlcnMiLCJmbXQkMjMiLCJmbXQkMjQiLCJmbXQkMjUiLCJ0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIiwibWFrZV9zY2FuZiIsInJlYWRlcnMiLCJzY2FuJDAiLCJzdHJfcmVzdCIsInBhZF9wcmVjX3NjYW5mIiwic2NhbiQxIiwic2NhbiQyIiwic2NhbiIsInNjYW4kMyIsInNjYW4kNCIsImNvbnYkMCIsInNjYW4kNSIsImNvbnYkMSIsInNjYW4kNiIsImNvbnYkMiIsInNjYW4kNyIsInByZWMkNSIsInNjYW4kOCIsImZtdGluZ19saXQkMCIsInN0cCQwIiwicyQyIiwic3RyX3Jlc3QkMCIsImFyZ19yZXN0Iiwia3NjYW5mIiwiZWYiLCJhcHBseSIsImFyZ3MkMCIsImV4YyIsImJzY2FuZiIsImtzc2NhbmYiLCJzc2NhbmYiLCJzY2FuZiIsImJzY2FuZl9mb3JtYXQiLCJmb3JtYXQiLCJzc2NhbmZfZm9ybWF0IiwiZm9ybWF0X2Zyb21fc3RyaW5nIiwidW5lc2NhcGVkIiwia2ZzY2FuZiIsImZzY2FuZiIsInJlZ2lzdGVyIiwicmVnaXN0ZXJfZXhjZXB0aW9uIiwibyQwIiwicGFyYW1zJDAiLCJpbml0aWFsX29iamVjdF9zaXplIiwiZHVtbXlfaXRlbSIsInRhZyIsImNvbXBhcmUkMTEiLCJjb21wYXJlJDEyIiwiY29tcGFyZSQxMyIsImR1bW15X3RhYmxlIiwidGFibGVfY291bnQiLCJkdW1teV9tZXQiLCJmaXRfc2l6ZSIsIm5ld190YWJsZSIsInB1Yl9sYWJlbHMiLCJtZXRob2RzIiwicmVzaXplJDEiLCJhcnJheSIsIm5ld19zaXplIiwib2xkX3NpemUiLCJuZXdfYnVjayIsIm1ldGhvZF9jb3VudCIsImluc3RfdmFyX2NvdW50IiwibmV3X21ldGhvZCIsInRhYmxlIiwiZ2V0X21ldGhvZF9sYWJlbCIsImxhYmVsIiwiZ2V0X21ldGhvZF9sYWJlbHMiLCJuYW1lcyIsInNldF9tZXRob2QiLCJlbGVtZW50IiwiZ2V0X21ldGhvZCIsInRvX2xpc3QkMyIsImFyciIsIm5hcnJvdyIsInZhcnMiLCJ2aXJ0X21ldGhzIiwiY29uY3JfbWV0aHMiLCJ2YXJzJDAiLCJ2aXJ0X21ldGhzJDAiLCJjb25jcl9tZXRocyQwIiwidmlydF9tZXRoX2xhYnMiLCJjb25jcl9tZXRoX2xhYnMiLCJsYWIiLCJ0dmFycyIsImJ5X25hbWUiLCJieV9sYWJlbCIsIm1ldCIsImhtIiwid2lkZW4iLCJzYXZlZF92YXJzIiwic2F2ZWRfaGlkZGVuX21ldGhzIiwibmV3X3Nsb3QiLCJuZXdfdmFyaWFibGUiLCJ0b19hcnJheSIsIm5ld19tZXRob2RzX3ZhcmlhYmxlcyIsIm1ldGhzIiwidmFscyIsIm1ldGhzJDAiLCJubWV0aHMiLCJudmFscyIsImdldF92YXJpYWJsZSIsImdldF92YXJpYWJsZXMiLCJhZGRfaW5pdGlhbGl6ZXIiLCJjcmVhdGVfdGFibGUiLCJwdWJsaWNfbWV0aG9kcyIsInRhZ3MiLCJpbml0X2NsYXNzIiwiaW5oZXJpdHMiLCJjbGEiLCJzdXBlciQwIiwibm0iLCJtYWtlX2NsYXNzIiwicHViX21ldGhzIiwiY2xhc3NfaW5pdCIsImVudl9pbml0IiwibWFrZV9jbGFzc19zdG9yZSIsImluaXRfdGFibGUiLCJkdW1teV9jbGFzcyIsImxvYyIsInVuZGVmIiwiY3JlYXRlX29iamVjdCIsImNyZWF0ZV9vYmplY3Rfb3B0Iiwib2JqXzAiLCJpdGVyX2YiLCJydW5faW5pdGlhbGl6ZXJzIiwiaW5pdHMiLCJydW5faW5pdGlhbGl6ZXJzX29wdCIsImNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaSIsImdldF9kYXRhJDAiLCJidWlsZF9wYXRoIiwia2V5cyIsImxvb2t1cF90YWJsZXMiLCJyb290IiwidGFibGVzJDIiLCJ0YWJsZXMkMCIsInRhYmxlcyQxIiwibmV3X2NhY2hlIiwic2V0X21ldGhvZHMiLCJjbG8iLCJjbG8kMCIsIm4kMiIsIm4kMyIsIm4kNCIsIm4kNSIsIm4kNiIsIngkMyIsIm4kNyIsIngkNCIsIm4kOCIsImYkNyIsIm4kOSIsIngkNSIsImYkOCIsImUkMiIsIm4kMTAiLCJ4JDYiLCJmJDkiLCJuJDExIiwieCQ3IiwibiQxMiIsIngkOCIsIm4kMTMiLCJuJDE0IiwiZSQzIiwibiQxNSIsIm0kMiIsIngkOSIsIm0kMyIsIm4kMTYiLCJtJDQiLCJlJDQiLCJuJDE3IiwibSQ1IiwibiQxOCIsInN0YXRzJDAiLCJpbml0aWFsX2J1ZmZlciIsImJ1ZmZlciIsImJ1ZnBvcyIsInJlc2V0X2J1ZmZlciIsInN0b3JlIiwibmV3YnVmZmVyIiwiZ2V0X3N0cmluZyIsIm1ha2VfbGV4ZXIiLCJrZXl3b3JkcyIsImt3ZF90YWJsZSIsImlkZW50X29yX2tleXdvcmQiLCJrZXl3b3JkX29yX2Vycm9yIiwiY29tbWVudCIsImVzY2FwZSIsImVuZF9leHBvbmVudF9wYXJ0IiwiZXhwb25lbnRfcGFydCIsIm51bWJlciIsImlkZW50MiIsIm5lZ19udW1iZXIiLCJuZXh0X3Rva2VuJDAiLCJtYXliZV9jb21tZW50IiwibmV4dF90b2tlbiIsImlucHV0IiwiaGtleSIsImNsZWFuIiwiaW5zZXJ0X2J1Y2tldCIsImNvbnRhaW5lciIsInJlbW92ZV9idWNrZXQiLCJoayIsInJlcGxhY2VfYnVja2V0IiwibmV3X2QiLCJidWNrZXRfbGVuZ3RoX2FsaXZlIiwic3RhdHNfYWxpdmUiLCJjcmVhdGUkNSIsImdldF9rZXkkMCIsImdldF9rZXlfY29weSQwIiwic2V0X2tleSQwIiwidW5zZXRfa2V5JDAiLCJjaGVja19rZXkkMCIsImJsaXRfa2V5JDAiLCJnZXRfZGF0YSQxIiwiZ2V0X2RhdGFfY29weSIsInNldF9kYXRhIiwidW5zZXRfZGF0YSIsImNoZWNrX2RhdGEiLCJibGl0X2RhdGEiLCJzZXRfa2V5X2RhdGEiLCJjcmVhdGUkNiIsImdldF9rZXkxIiwiZ2V0X2tleTFfY29weSIsInNldF9rZXkxIiwidW5zZXRfa2V5MSIsImNoZWNrX2tleTEiLCJnZXRfa2V5MiIsImdldF9rZXkyX2NvcHkiLCJzZXRfa2V5MiIsInVuc2V0X2tleTIiLCJjaGVja19rZXkyIiwiYmxpdF9rZXkxIiwiYmxpdF9rZXkyIiwiYmxpdF9rZXkxMiIsImdldF9kYXRhJDIiLCJnZXRfZGF0YV9jb3B5JDAiLCJzZXRfZGF0YSQwIiwidW5zZXRfZGF0YSQwIiwiY2hlY2tfZGF0YSQwIiwiYmxpdF9kYXRhJDAiLCJrMiQwIiwiazEkMCIsImNyZWF0ZSQ3IiwibGVuZ3RoJDYiLCJnZXRfa2V5JDEiLCJnZXRfa2V5X2NvcHkkMSIsInNldF9rZXkkMSIsInVuc2V0X2tleSQxIiwiY2hlY2tfa2V5JDEiLCJibGl0X2tleSQxIiwiZ2V0X2RhdGEkMyIsImdldF9kYXRhX2NvcHkkMSIsInNldF9kYXRhJDEiLCJ1bnNldF9kYXRhJDEiLCJjaGVja19kYXRhJDEiLCJibGl0X2RhdGEkMSIsImtpIiwiazAiLCJnZW5lcmljX2Jhc2VuYW1lIiwiaXNfZGlyX3NlcCIsImdlbmVyaWNfZGlybmFtZSIsImlzX3JlbGF0aXZlIiwiaXNfaW1wbGljaXQiLCJjaGVja19zdWZmaXgiLCJzdWZmIiwiY2hvcF9zdWZmaXhfb3B0IiwibGVuX3MiLCJsZW5fZiIsInF1b3RlIiwiYmFzZW5hbWUiLCJkaXJuYW1lIiwiaXNfZGlyX3NlcCQwIiwiaXNfcmVsYXRpdmUkMCIsImlzX2ltcGxpY2l0JDAiLCJjaGVja19zdWZmaXgkMCIsImNob3Bfc3VmZml4X29wdCQwIiwidGVtcF9kaXJfbmFtZSIsInF1b3RlJDAiLCJhZGRfYnMiLCJsb29wJDAiLCJsb29wX2JzIiwiZHJpdmVfYW5kX3BhdGgiLCJkaXJuYW1lJDAiLCJwYXRoIiwiZHJpdmUiLCJkaXIiLCJiYXNlbmFtZSQwIiwiYmFzZW5hbWUkMSIsImRpcm5hbWUkMSIsImN1cnJlbnRfZGlyX25hbWUkMiIsInBhcmVudF9kaXJfbmFtZSQyIiwiZGlyX3NlcCQyIiwiaXNfZGlyX3NlcCQxIiwiaXNfcmVsYXRpdmUkMSIsImlzX2ltcGxpY2l0JDEiLCJjaGVja19zdWZmaXgkMSIsImNob3Bfc3VmZml4X29wdCQxIiwidGVtcF9kaXJfbmFtZSQwIiwicXVvdGUkMSIsImJhc2VuYW1lJDIiLCJkaXJuYW1lJDIiLCJjb25jYXQkMyIsImNob3Bfc3VmZml4IiwiZXh0ZW5zaW9uX2xlbiIsImV4dGVuc2lvbiIsImNob3BfZXh0ZW5zaW9uIiwicmVtb3ZlX2V4dGVuc2lvbiIsInBybmckMCIsInRlbXBfZmlsZV9uYW1lIiwidGVtcF9kaXIiLCJybmQiLCJjdXJyZW50X3RlbXBfZGlyX25hbWUiLCJzZXRfdGVtcF9kaXJfbmFtZSIsImdldF90ZW1wX2Rpcl9uYW1lIiwidGVtcF9maWxlIiwidHJ5X25hbWUiLCJjb3VudGVyJDEiLCJvcGVuX3RlbXBfZmlsZSIsInN0aCQwIiwicGVybXMiLCJzdGgkMSIsImFkZCQxIiwic3ViJDQiLCJuZWciLCJjb25qIiwibXVsIiwiZGl2IiwiaW52Iiwibm9ybTIiLCJub3JtIiwicSQwIiwicG9sYXIiLCJzcXJ0IiwidyQwIiwiZXhwIiwibG9nIiwicG93IiwiZW5hYmxlZCIsImlmX3NwYWNldGltZV9lbmFibGVkIiwiY3JlYXRlJDgiLCJjaGFubmVsIiwic2F2ZV9ldmVudCIsInRpbWUiLCJldmVudF9uYW1lIiwic2F2ZV9hbmRfY2xvc2UiLCJ0YWtlJDAiLCJjbG9zZWQiLCJzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHMiLCJmbG9hdDMyIiwiZmxvYXQ2NCIsImludDhfc2lnbmVkIiwiaW50OF91bnNpZ25lZCIsImludDE2X3NpZ25lZCIsImludDE2X3Vuc2lnbmVkIiwiaW50MzIkMSIsImludDY0JDEiLCJpbnQkMiIsIm5hdGl2ZWludCQxIiwiY29tcGxleDMyIiwiY29tcGxleDY0Iiwia2luZF9zaXplX2luX2J5dGVzIiwiY19sYXlvdXQiLCJmb3J0cmFuX2xheW91dCIsImRpbXMiLCJzaXplX2luX2J5dGVzIiwiY3JlYXRlJDkiLCJsYXlvdXQiLCJnZXQkMSIsInNldCQwIiwic2l6ZV9pbl9ieXRlcyQwIiwib2ZfdmFsdWUiLCJjcmVhdGUkMTAiLCJkaW0iLCJzaXplX2luX2J5dGVzJDEiLCJzbGljZSIsIm9mX2FycmF5IiwiYmEiLCJjcmVhdGUkMTEiLCJkaW0xIiwiZGltMiIsInNpemVfaW5fYnl0ZXMkMiIsInNsaWNlX2xlZnQiLCJzbGljZV9yaWdodCIsIm9mX2FycmF5JDAiLCJyb3ciLCJjcmVhdGUkMTIiLCJkaW0zIiwic2l6ZV9pbl9ieXRlcyQzIiwic2xpY2VfbGVmdF8xIiwic2xpY2VfcmlnaHRfMSIsInNsaWNlX2xlZnRfMiIsInNsaWNlX3JpZ2h0XzIiLCJvZl9hcnJheSQxIiwiY29sIiwiYXJyYXkwX29mX2dlbmFycmF5IiwiYXJyYXkxX29mX2dlbmFycmF5IiwiYXJyYXkyX29mX2dlbmFycmF5IiwiYXJyYXkzX29mX2dlbmFycmF5IiwicmVzaGFwZV8wIiwicmVzaGFwZV8xIiwicmVzaGFwZV8yIiwicmVzaGFwZV8zIiwiam9vX2dsb2JhbF9vYmplY3QiLCJudWxsIiwidW5kZWZpbmVkIiwiZXhuIiwiZXZlbnQiLCJsaWVzSW5wdXQiLCJsaWVDb2RlSW5wdXQiLCJ0cnV0aHNJbnB1dCIsImVuY29kZSIsImRlY29kZSIsInNldF90ZXh0X3RvX2VuY29kZSIsInRleHRfdG9fZW5jb2RlX3MiLCJlbmNvZGVkX3RleHRfcyIsInZhbHVlX29mX2lucHV0IiwiaWQiLCJpbnB1dF9vcHQiLCJpbnB1dCIsInZhbHVlX29wdCIsInNldF92YWx1ZV9vZl9pbnB1dCIsInYiLCJ2YWx1ZV9vZl90ZXh0YXJlYSIsInNldF92YWx1ZV9vZl90ZXh0YXJlYSIsImVuY29kZV90ZXh0X2hhbmRsZXIiLCJwaWNrIiwieHMiLCJ4IiwibiIsInlzIiwieSIsIndpbHR5X2hhbmRsZXIiLCJsaWVzIiwidHJ1dGhzIiwibnVtX3RydXRocyIsIm51bV9saWVzIiwiaSIsInJlbWFpbmluZ19saWVzIiwibGllIiwibmV3X2xpZV9jb2RlIiwicmVtYWluaW5nX3RydXRocyIsInRydXRoIiwic2VuZF9saWVzX2FwcCIsInN0bXQiLCJpc190cnV0aCIsIm1zZyIsIndpbHR5X2FwcCIsImFwcCIsImFwcF9jb250YWluZXIiXSwic291cmNlcyI6WyIvYnVpbHRpbi8raW50NjQuanMiLCIvYnVpbHRpbi8rbWxCeXRlcy5qcyIsIi9idWlsdGluLytmYWlsLmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8rZnMuanMiLCIvYnVpbHRpbi8rc3lzLmpzIiwiL2J1aWx0aW4vK2ZzX2Zha2UuanMiLCIvYnVpbHRpbi8rZnNfbm9kZS5qcyIsIi9idWlsdGluLytuYXQuanMiLCIvYnVpbHRpbi8rZ3JhcGhpY3MuanMiLCIvYnVpbHRpbi8rbWFyc2hhbC5qcyIsIi9idWlsdGluLytpby5qcyIsIi9idWlsdGluLytnYy5qcyIsIi9idWlsdGluLytiaWdhcnJheS5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytwYXJzaW5nLmpzIiwiL2J1aWx0aW4vK2pzbGliX2pzX29mX29jYW1sLmpzIiwiL2J1aWx0aW4vK3VuaXguanMiLCIvYnVpbHRpbi8raW50cy5qcyIsIi9idWlsdGluLytoYXNoLmpzIiwiL2J1aWx0aW4vK2NvbXBhcmUuanMiLCIvYnVpbHRpbi8raW50ZXJuYWxNb2QuanMiLCIvYnVpbHRpbi8rb2JqLmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy5qcyIsIi9idWlsdGluLytiYWNrdHJhY2UuanMiLCIvYnVpbHRpbi8rbGV4aW5nLmpzIiwiL2J1aWx0aW4vK2FycmF5LmpzIiwiL2J1aWx0aW4vK3dlYWsuanMiLCIvYnVpbHRpbi8rbWQ1LmpzIiwiL2J1aWx0aW4vK3N0ci5qcyIsIi9idWlsdGluLytiaWdzdHJpbmctY3N0cnVjdC5qcyIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC91Y2hhci5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9pbnQ2NC5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9sZXhpbmcubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0Lm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL3ByaW50ZXhjLm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL2ZpbGVuYW1lLm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL2NvbXBsZXgubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0QmFzaWNzLm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL3N0ZGxpYi5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9uYXRpdmVpbnQubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvbGlzdC5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9zZXEubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvb3B0aW9uLm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL3Jlc3VsdC5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9ib29sLm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL2NoYXIubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvYnl0ZXMubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL3VuaXQubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvbWFyc2hhbC5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9vYmoubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvYXJyYXkubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvaW50Lm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL2ludDMyLm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL3BhcnNpbmcubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvc2V0Lm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL21hcC5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9zdGFjay5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9xdWV1ZS5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxMYXp5Lm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL2xhenkubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvc3RyZWFtLm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL2J1ZmZlci5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9wcmludGYubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvYXJnLm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL2Z1bi5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9nYy5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9kaWdlc3QubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvcmFuZG9tLm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL2hhc2h0YmwubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvd2Vhay5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9mb3JtYXQubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvc2NhbmYubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvY2FsbGJhY2subWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvY2FtbGludGVybmFsT08ubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvZ2VubGV4Lm1sIiwiL2hvbWUvdmlqYXkvLm9wYW0vYXJndWUvbGliL29jYW1sL2VwaGVtZXJvbi5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9zcGFjZXRpbWUubWwiLCIvaG9tZS92aWpheS8ub3BhbS9hcmd1ZS9saWIvb2NhbWwvYmlnYXJyYXkubWwiLCIiLCIvaG9tZS92aWpheS92aWpheXJhbWFtdXJ0aHkubWUvX2J1aWxkL2RlZmF1bHQvd2lsdHkvYXBwL2FwcC5tbCIsIi9ob21lL3ZpamF5Ly5vcGFtL2FyZ3VlL2xpYi9vY2FtbC9zdGRfZXhpdC5tbCJdLCJtYXBwaW5ncyI6Ijs7OztJQTBPQSxTQUFTQSxtQkFBbUJDLEdBQUssU0FBUSxVQUFZO0lDekxyRCxTQUFTQyxnQkFBZ0JDLEVBQUdDO01BQzFCLEdBQUdELE9BQVE7TUFDWCxHQUFJQyxTQUFVLE9BQVEsU0FBU0Q7TUFDL0IsSUFBTSxLQUFRO01BQ2Q7T0FBUSxDQUNOLEdBQUlBLE1BQU9FLEtBQUtEO1FBQ2hCRDtRQUNBLEdBQUlBLE9BQVEsT0FBT0U7UUFDbkJELEtBQUtBO1FBQ0xFO1FBQ0EsR0FBSUEsT0FBUSxhQU1oQjtJRDdDQSxJQUFJQyxrQkFBb0I7SUVBeEIsU0FBU0Usb0JBQXFCQyxLQUFPLE1BQU1BLEdBQUs7SUMyQ2hELElBQUlDO0lEUkosU0FBU0M7TUFDUCxvQkFBb0JELGtDQUN0QjtJRmpDQSxTQUFTRSxRQUFTQyxHQUFHQyxHQUFHQztNQUN0QkMsVUFBVUgsY0FDVkcsVUFBVUYsY0FDVkUsVUFBVUQsV0FDWjtJQUNBSDtJQUNBQTs7ZUFDRSxXQUFXQSxRQUFRSSxRQUFRQSxRQUFRQSxRQURaO0lBSXpCSjs7YUFBdUNaO01BQ3JDLEdBQUlnQixVQUFVaEIsS0FBTTtNQUNwQixHQUFJZ0IsVUFBVWhCLEtBQU07TUFDcEIsR0FBSWdCLFVBQVVoQixLQUFNO01BQ3BCLEdBQUlnQixVQUFVaEIsS0FBTTtNQUNwQixHQUFJZ0IsVUFBVWhCLEtBQU07TUFDcEIsR0FBSWdCLFVBQVVoQixLQUFNO01BQ3BCLFFBUDJCO0lBUzdCWTs7YUFBc0NaO01BQ3BDLElBQU8sR0FBRWdCLGNBQ0QsSUFBRWhCO01BQ1YsR0FBSWUsS0FBS0UsSUFBSztNQUNkLEdBQUlGLEtBQUtFLElBQUs7TUFDZCxHQUFJRCxVQUFVaEIsS0FBTTtNQUNwQixHQUFJZ0IsVUFBVWhCLEtBQU07TUFDcEIsR0FBSWdCLFVBQVVoQixLQUFNO01BQ3BCLEdBQUlnQixVQUFVaEIs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QnVFO01BRTlCLHdCQUF3QjlCLEtBQzFCO0lZNU9BLFNBQVMrOUIsaUJBQWlCemlDLEdBQUssT0FBT0EsQ0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1U7Ozs7Ozs7SWM3QjFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDa0JLMGlDO0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDd0JBQztLQUNBQztLQUNBQztLQUlBQztLQUNBQzs7OztLQ3pCQUM7S0FvSEFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3c5RU1DO0tBUVFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0N2bEZkQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NtREVDO0tBQ0FDO0tBQ0FDOzs7S0EzRFlDO0tBMEZaQztLQUNBQztLQUNBQzs7O0tBNEVBQztLQUNBQztLQUNBQzs7O0tDdEtGQztLQUNBQztLQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ0NDQzs7S0RERCxXQ0NDQztLRERELElDQ0NDO0lEREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCQ0NZQyxLQUFPLE1BQU1BLEdBQXZCO0lEREY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQ0NDQyxNREREOzs7Ozs7Ozs7O3lCQ0NDQSxNREREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7O0tBREc7S0FETjtLQURNO0tBQVI7OztNQThEVTs7O1VBWUE7O1dBSGtCbUI7V0FBVkM7V0FHUixzREFIa0JEO1dBRWxCO2dCQUZRQztVQUNSO1FBRlM7TUFQRTs7T0FJTCxxQ0FKRkM7T0FJRjtPQUZBO01BREYscUVBWUg7SUFkSDs7OztLQUZBO0tBREY7S0FISTs7OztLQUZBLG9EQTNGSmQ7S0EwRkk7S0FEQTtLQURGO0tBRkE7S0FERjtLQUZFO0tBREE7S0FERjtLQURHOzs7OztLQURHO0tBRE47S0FERTtLQURBO0tBREE7S0FEQTtLQURGO0tBREc7Ozs7O0tBREc7S0FETjtLQURNO0tBQVI7S0FxREU7O09BdkZBVztVQXVGQSxzREF2REFJO0tBcURGO0lBUUE7SUE3Qkk7S0E4QmdCO0tBQ1UsaURBWjVCQztJQVlGLDhCQURJQztJQTlCQTs7OztPQTVJRnRDO09BQ0FDO09BRUFFO09BQWtCRDtPQUNsQkU7OztPQUdBQztPQUtBSztPQU1BRTtPQUtBQztPQU1BQztPQUlJQztPQVFKTTtPQW1DQVc7T0FnQ0FJO09BbURBQztJQVlGO1VEekxIOzs7Ozs7O0lDQUE7Ozs7SUNrQlM7OztVRGxCVCIsInNvdXJjZXNDb250ZW50IjpbIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mZnNldFxudmFyIGNhbWxfaW50NjRfb2Zmc2V0ID0gTWF0aC5wb3coMiwgLTI0KTtcblxuLy9Qcm92aWRlczogTWxJbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIE1sSW50NjQgKGxvLG1pLGhpKSB7XG4gIHRoaXMubG8gPSBsbyAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gbWkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IGhpICYgMHhmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcIl9qXCJcbk1sSW50NjQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvLHRoaXMubWksdGhpcy5oaSk7XG59XG5cbk1sSW50NjQucHJvdG90eXBlLnVjb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgaWYgKHRoaXMuaGkgPiB4LmhpKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMuaGkgPCB4LmhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGhpID0gdGhpcy5oaSA8PCAxNjtcbiAgdmFyIHhoaSA9IHguaGkgPDwgMTY7XG4gIGlmIChoaSA+IHhoaSkgcmV0dXJuIDE7XG4gIGlmIChoaSA8IHhoaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG8gPSAtIHRoaXMubG87XG4gIHZhciBtaSA9IC0gdGhpcy5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IC0gdGhpcy5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKyB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pICsgeC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgKyB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAtIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgLSB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSAtIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICogeC5sbztcbiAgdmFyIG1pID0gKChsbyAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5taSAqIHgubG8gKyB0aGlzLmxvICogeC5taTtcbiAgdmFyIGhpID0gKChtaSAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5oaSAqIHgubG8gKyB0aGlzLm1pICogeC5taSArIHRoaXMubG8gKiB4LmhpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5sb3x0aGlzLm1pfHRoaXMuaGkpID09IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmhpIDw8IDE2KSA8IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyAmIHgubG8sIHRoaXMubWkgJiB4Lm1pLCB0aGlzLmhpICYgeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvfHgubG8sIHRoaXMubWl8eC5taSwgdGhpcy5oaXx4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvXngubG8sIHRoaXMubWleeC5taSwgdGhpcy5oaV54LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X2xlZnQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNCkge1xuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5sbyA8PCBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgcykgfCAodGhpcy5sbyA+PiAoMjQgLSBzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5oaSA8PCBzKSB8ICh0aGlzLm1pID4+ICgyNCAtIHMpKSk7XG4gIH1cbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvIDw8IChzIC0gMjQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgKHMgLSAyNCkpIHwgKHRoaXMubG8gPj4gKDQ4IC0gcykpKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KDAsIDAsIHRoaXMubG8gPDwgKHMgLSA0OCkpXG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodF91bnNpZ25lZCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKHRoaXMuaGkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gcykpO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiAocyAtIDI0KSksXG4gICAgICAwKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmhpID4+IChzIC0gNDgpLCAwLCAwKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIHZhciBoID0gKHRoaXMuaGkgPDwgMTYpID4+IDE2O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKGggPDwgKDI0IC0gcykpLFxuICAgICAgKCh0aGlzLmhpIDw8IDE2KSA+PiBzKSA+Pj4gMTYpO1xuICB2YXIgc2lnbiA9ICh0aGlzLmhpIDw8IDE2KSA+PiAzMTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMjQpID4+IDE2LFxuICAgICAgc2lnbiAmIDB4ZmZmZik7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMzIpLCBzaWduLCBzaWduKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzbDEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGkgPSAodGhpcy5oaSA8PCAxKSB8ICh0aGlzLm1pID4+IDIzKTtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA8PCAxKSB8ICh0aGlzLmxvID4+IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5sbyA9ICh0aGlzLmxvIDw8IDEpICYgMHhmZmZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc3IxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvID0gKCh0aGlzLmxvID4+PiAxKSB8ICh0aGlzLm1pIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA+Pj4gMSkgfCAodGhpcy5oaSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSB0aGlzLmhpID4+PiAxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudWRpdm1vZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgbW9kdWx1cyA9IHRoaXMuY29weSgpO1xuICB2YXIgZGl2aXNvciA9IHguY29weSgpO1xuICB2YXIgcXVvdGllbnQgPSBuZXcgTWxJbnQ2NCgwLDAsMCk7XG4gIHdoaWxlIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID4gMCkge1xuICAgIG9mZnNldCsrO1xuICAgIGRpdmlzb3IubHNsMSgpO1xuICB9XG4gIHdoaWxlIChvZmZzZXQgPj0gMCkge1xuICAgIG9mZnNldCAtLTtcbiAgICBxdW90aWVudC5sc2wxKCk7XG4gICAgaWYgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPj0gMCkge1xuICAgICAgcXVvdGllbnQubG8gKys7XG4gICAgICBtb2R1bHVzID0gbW9kdWx1cy5zdWIoZGl2aXNvcik7XG4gICAgfVxuICAgIGRpdmlzb3IubHNyMSgpO1xuICB9XG4gIHJldHVybiB7IHF1b3RpZW50IDogcXVvdGllbnQsIG1vZHVsdXMgOiBtb2R1bHVzIH07XG59XG5NbEludDY0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpIF4geS5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciBxID0geC51ZGl2bW9kKHkpLnF1b3RpZW50O1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgcSA9IHEubmVnKCk7XG4gIHJldHVybiBxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciByID0geC51ZGl2bW9kKHkpLm1vZHVsdXM7XG4gIGlmIChzaWduICYgMHg4MDAwKSByID0gci5uZWcoKTtcbiAgcmV0dXJuIHI7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAodGhpcy5taSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0Zsb2F0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLmhpIDw8IDE2KSAqIE1hdGgucG93KDIsIDMyKSArIHRoaXMubWkgKiBNYXRoLnBvdygyLCAyNCkpICsgdGhpcy5sbztcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbdGhpcy5oaSA+PiA4LFxuICAgICAgICAgIHRoaXMuaGkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgPj4gMTYsXG4gICAgICAgICAgKHRoaXMubWkgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gPj4gMTYsXG4gICAgICAgICAgKHRoaXMubG8gPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gJiAweGZmXTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxvMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKCh0aGlzLm1pICYgMHhmZikgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaGkzMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5taSA+Pj4gOCkgJiAweGZmZmYpIHwgKHRoaXMuaGkgPDwgMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VsdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bHQoeCx5KSB7IHJldHVybiB4LnVjb21wYXJlKHkpIDwgMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY29tcGFyZSh4LHksIHRvdGFsKSB7IHJldHVybiB4LmNvbXBhcmUoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X25lZyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9uZWcgKHgpIHsgcmV0dXJuIHgubmVnKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FkZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hZGQgKHgsIHkpIHsgcmV0dXJuIHguYWRkKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zdWIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc3ViICh4LCB5KSB7IHJldHVybiB4LnN1Yih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbXVsIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tdWwoeCx5KSB7IHJldHVybiB4Lm11bCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfemVybyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc196ZXJvKHgpIHsgcmV0dXJuICt4LmlzWmVybygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkgeyByZXR1cm4gK3guaXNOZWcoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FuZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hbmQgKHgsIHkpIHsgcmV0dXJuIHguYW5kKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb3IgKHgsIHkpIHsgcmV0dXJuIHgub3IoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF94b3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfeG9yICh4LCB5KSB7IHJldHVybiB4Lnhvcih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X2xlZnQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZGl2IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2RpdiAoeCwgeSkgeyByZXR1cm4geC5kaXYoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21vZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tb2QgKHgsIHkpIHsgcmV0dXJuIHgubW9kKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9pbnQzMiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoeCAmIDB4ZmZmZmZmLCAoeCA+PiAyNCkgJiAweGZmZmZmZiwgKHggPj4gMzEpICYgMHhmZmZmKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2ludDMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2ludDMyICh4KSB7IHJldHVybiB4LnRvSW50KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2Zsb2F0ICh4KSB7IHJldHVybiB4LnRvRmxvYXQgKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoeCkge1xuICBpZiAoeCA8IDApIHggPSBNYXRoLmNlaWwoeCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChcbiAgICB4ICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQgKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zvcm1hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mb3JtYXQgKGZtdCwgeCkge1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSkge1xuICAgIGYuc2lnbiA9IC0xOyB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIH1cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIHZhciB3YmFzZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZi5iYXNlKTtcbiAgdmFyIGN2dGJsID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIGRvIHtcbiAgICB2YXIgcCA9IHgudWRpdm1vZCh3YmFzZSk7XG4gICAgeCA9IHAucXVvdGllbnQ7XG4gICAgYnVmZmVyID0gY3Z0YmwuY2hhckF0KGNhbWxfaW50NjRfdG9faW50MzIocC5tb2R1bHVzKSkgKyBidWZmZXI7XG4gIH0gd2hpbGUgKCEgY2FtbF9pbnQ2NF9pc196ZXJvKHgpKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBidWZmZXIubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgYnVmZmVyID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgYnVmZmVyO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIGJ1ZmZlcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcGFyc2VfZGlnaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdWx0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgYmFzZTY0ID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihiYXNlKTtcbiAgdmFyIHRocmVzaG9sZCA9XG4gICAgICBuZXcgTWxJbnQ2NCgweGZmZmZmZiwgMHhmZmZmZmZmLCAweGZmZmYpLnVkaXZtb2QoYmFzZTY0KS5xdW90aWVudDtcbiAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgZm9yICg7Oykge1xuICAgIGkrKztcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIG11bHRpcGxpY2F0aW9uIGJhc2UgKiByZXMgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQodGhyZXNob2xkLCByZXMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgICBkID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgICByZXMgPSBjYW1sX2ludDY0X2FkZChjYW1sX2ludDY0X211bChiYXNlNjQsIHJlcyksIGQpO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBhZGRpdGlvbiAoYmFzZSAqIHJlcykgKyBkICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHJlcywgZCkpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChiYXNlID09IDEwICYmIGNhbWxfaW50NjRfdWx0KG5ldyBNbEludDY0KDAsIDAsIDB4ODAwMCksIHJlcykpXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChzaWduIDwgMCkgcmVzID0gY2FtbF9pbnQ2NF9uZWcocmVzKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKGxvLCBtaSwgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSlcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsbywgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgIGxvICYgMHhmZmZmZmYsXG4gICAgKChsbyA+Pj4gMjQpICYgMHhmZikgfCAoKGhpICYgMHhmZmZmKSA8PCA4KSxcbiAgICAoaGkgPj4+IDE2KSAmIDB4ZmZmZik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2xvMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbG8zMih2KXsgcmV0dXJuIHYubG8zMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oaTMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hpMzIodil7IHJldHVybiB2LmhpMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoYVs3XSA8PCAwIHwgKGFbNl0gPDwgOCkgfCAoYVs1XSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzRdIDw8IDAgfCAoYVszXSA8PCA4KSB8IChhWzJdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbMV0gPDwgMCB8IChhWzBdIDw8IDgpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fYnl0ZXMoeCkgeyByZXR1cm4geC50b0FycmF5KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hhc2ggY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGFzaCh2KXtcbiAgcmV0dXJuICh2LmxvMzIoKSkgXiAodi5oaTMyKCkpXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBBbiBPQ2FtbCBzdHJpbmcgaXMgYW4gb2JqZWN0IHdpdGggdGhyZWUgZmllbGRzOlxuLy8gLSB0YWcgJ3QnXG4vLyAtIGxlbmd0aCAnbCdcbi8vIC0gY29udGVudHMgJ2MnXG4vL1xuLy8gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcgY2FuIGJlIGVpdGhlciBhIEphdmFTY3JpcHQgYXJyYXkgb3Jcbi8vIGEgSmF2YVNjcmlwdCBzdHJpbmcuIFRoZSBsZW5ndGggb2YgdGhpcyBzdHJpbmcgY2FuIGJlIGxlc3MgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgT0NhbWwgc3RyaW5nLiBJbiB0aGlzIGNhc2UsIHJlbWFpbmluZyBieXRlcyBhcmVcbi8vIGFzc3VtZWQgdG8gYmUgemVyb2VzLiBBcnJheXMgYXJlIG11dGFibGUgYnV0IGNvbnN1bWVzIG1vcmUgbWVtb3J5XG4vLyB0aGFuIHN0cmluZ3MuIEEgY29tbW9uIHBhdHRlcm4gaXMgdG8gc3RhcnQgZnJvbSBhbiBlbXB0eSBzdHJpbmcgYW5kXG4vLyBwcm9ncmVzc2l2ZWx5IGZpbGwgaXQgZnJvbSB0aGUgc3RhcnQuIFBhcnRpYWwgc3RyaW5ncyBtYWtlcyBpdFxuLy8gcG9zc2libGUgdG8gaW1wbGVtZW50IHRoaXMgZWZmaWNpZW50bHkuXG4vL1xuLy8gV2hlbiBjb252ZXJ0aW5nIHRvIGFuZCBmcm9tIFVURi0xNiwgd2Uga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZVxuLy8gc3RyaW5nIGlzIGNvbXBvc2VkIG9ubHkgb2YgQVNDSUkgY2hhcmFjdGVycyAoaW4gd2hpY2ggY2FzZSwgbm9cbi8vIGNvbnZlcnNpb24gbmVlZHMgdG8gYmUgcGVyZm9ybWVkKSBvciBub3QuXG4vL1xuLy8gVGhlIHN0cmluZyB0YWcgY2FuIHRodXMgdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbi8vICAgZnVsbCBzdHJpbmcgICAgIEJZVEUgfCBVTktOT1dOOiAgICAgIDBcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBBU0NJSTogICAgICAgIDlcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBOT1RfQVNDSUk6ICAgIDhcbi8vICAgc3RyaW5nIHByZWZpeCAgIFBBUlRJQUw6ICAgICAgICAgICAgIDJcbi8vICAgYXJyYXkgICAgICAgICAgIEFSUkFZOiAgICAgICAgICAgICAgIDRcbi8vXG4vLyBPbmUgY2FuIHVzZSBiaXQgbWFza2luZyB0byBkaXNjcmltaW5hdGUgdGhlc2UgZGlmZmVyZW50IGNhc2VzOlxuLy8gICBrbm93bl9lbmNvZGluZyh4KSA9IHgmOFxuLy8gICBpc19hc2NpaSh4KSA9ICAgICAgIHgmMVxuLy8gICBraW5kKHgpID0gICAgICAgICAgIHgmNlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfc3RyX3JlcGVhdChuLCBzKSB7XG4gIGlmKG4gPT0gMCkgcmV0dXJuIFwiXCI7XG4gIGlmIChzLnJlcGVhdCkge3JldHVybiBzLnJlcGVhdChuKTt9IC8vIEVDTUFzY3JpcHQgNiBhbmQgRmlyZWZveCAyNCtcbiAgdmFyIHIgPSBcIlwiLCBsID0gMDtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKG4gJiAxKSByICs9IHM7XG4gICAgbiA+Pj0gMTtcbiAgICBpZiAobiA9PSAwKSByZXR1cm4gcjtcbiAgICBzICs9IHM7XG4gICAgbCsrO1xuICAgIGlmIChsID09IDkpIHtcbiAgICAgIHMuc2xpY2UoMCwxKTsgLy8gZmxhdHRlbiB0aGUgc3RyaW5nXG4gICAgICAvLyB0aGVuLCB0aGUgZmxhdHRlbmluZyBvZiB0aGUgd2hvbGUgc3RyaW5nIHdpbGwgYmUgZmFzdGVyLFxuICAgICAgLy8gYXMgaXQgd2lsbCBiZSBjb21wb3NlZCBvZiBsYXJnZXIgcGllY2VzXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuLy9XZWFrZGVmXG4vLyBQcmUgRUNNQVNjcmlwdCA1LCBbYXBwbHldIHdvdWxkIG5vdCBzdXBwb3J0IGFycmF5LWxpa2Ugb2JqZWN0LlxuLy8gSW4gc3VjaCBzZXR1cCwgVHlwZWRfYXJyYXkgd291bGQgYmUgaW1wbGVtZW50ZWQgYXMgcG9seWZpbGwsIGFuZCBbZi5hcHBseV0gd291bGRcbi8vIGZhaWwgaGVyZS4gTWFyayB0aGUgcHJpbWl0aXZlIGFzIFdlYWtkZWYsIHNvIHRoYXQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdCBlYXNpbHkuXG5mdW5jdGlvbiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKGEsIGksIGxlbikge1xuICB2YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIGlmIChpID09IDAgJiYgbGVuIDw9IDQwOTYgJiYgbGVuID09IGEubGVuZ3RoKSByZXR1cm4gZi5hcHBseSAobnVsbCwgYSk7XG4gIHZhciBzID0gXCJcIjtcbiAgZm9yICg7IDAgPCBsZW47IGkgKz0gMTAyNCxsZW4tPTEwMjQpXG4gICAgcyArPSBmLmFwcGx5IChudWxsLCBhLnNsaWNlKGksaSArIE1hdGgubWluKGxlbiwgMTAyNCkpKTtcbiAgcmV0dXJuIHM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmOF9vZl91dGYxNlxuZnVuY3Rpb24gY2FtbF91dGY4X29mX3V0ZjE2KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBiLCBjLCBkLCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYyA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IChjID4+IDYpKTtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhkZmZmKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlMCB8IChjID4+IDEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA+PSAweGRiZmYgfHwgaSArIDEgPT0gbCB8fFxuICAgICAgICAgICAgICAgKGQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBkID4gMHhkZmZmKSB7XG4gICAgICAvLyBVbm1hdGNoZWQgc3Vycm9nYXRlIHBhaXIsIHJlcGxhY2VkIGJ5IFxcdWZmZmQgKHJlcGxhY2VtZW50IGNoYXJhY3RlcilcbiAgICAgIHQgKz0gXCJcXHhlZlxceGJmXFx4YmRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgICAgYyA9IChjIDw8IDEwKSArIGQgLSAweDM1ZmRjMDA7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMCB8IChjID4+IDE4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDEyKSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfVxuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBjYW1sX3V0ZjE2X29mX3V0Zjgocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IFwiXCIsIGMsIGMxLCBjMiwgdiwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMxID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjMSA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYzEgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgdiA9IDE7XG4gICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgIGMgPSBjMiArIChjMSA8PCA2KTtcbiAgICAgIGlmIChjMSA8IDB4ZTApIHtcbiAgICAgICAgdiA9IGMgLSAweDMwODA7XG4gICAgICAgIGlmICh2IDwgMHg4MCkgdiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gMjtcbiAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgICAgICBjID0gYzIgKyAoYyA8PCA2KTtcbiAgICAgICAgICBpZiAoYzEgPCAweGYwKSB7XG4gICAgICAgICAgICB2ID0gYyAtIDB4ZTIwODA7XG4gICAgICAgICAgICBpZiAoKHYgPCAweDgwMCkgfHwgKCh2ID49IDB4ZDdmZikgJiYgKHYgPCAweGUwMDApKSkgdiA9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYgPSAzO1xuICAgICAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoYzEgPCAweGY1KSkge1xuICAgICAgICAgICAgICB2ID0gYzIgLSAweDNjODIwODAgKyAoYyA8PCA2KTtcbiAgICAgICAgICAgICAgaWYgKHYgPCAweDEwMDAwIHx8IHYgPiAweDEwZmZmZikgdiA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2IDwgNCkgeyAvLyBJbnZhbGlkIHNlcXVlbmNlXG4gICAgICBpIC09IHY7XG4gICAgICB0ICs9IFwiXFx1ZmZmZFwiO1xuICAgIH0gZWxzZSBpZiAodiA+IDB4ZmZmZilcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ3YzAgKyAodiA+PiAxMCksIDB4ZGMwMCArICh2ICYgMHgzRkYpKVxuICAgIGVsc2VcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2KTtcbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29faXNfYXNjaWlcbmZ1bmN0aW9uIGpzb29faXNfYXNjaWkgKHMpIHtcbiAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnZXRzIGJldHRlciBhdCBhcm91bmQgdGhpcyBwb2ludCBmb3IgYWxsIGJyb3dzZXJzXG4gIGlmIChzLmxlbmd0aCA8IDI0KSB7XG4gICAgLy8gU3BpZGVybW9ua2V5IGdldHMgbXVjaCBzbG93ZXIgd2hlbiBzLmxlbmd0aCA+PSAyNCAob24gNjQgYml0IGFyY2hzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykgaWYgKHMuY2hhckNvZGVBdChpKSA+IDEyNykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2VcbiAgICByZXR1cm4gIS9bXlxceDAwLVxceDdmXS8udGVzdChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgcmV0dXJuIHMuY1tpXVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgLy8gVGhlIE9DYW1sIGNvbXBpbGVyIHVzZXMgQ2hhci51bnNhZmVfY2hyIG9uIGludGVnZXJzIGxhcmdlciB0aGFuIDI1NSFcbiAgYyAmPSAweGZmO1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIHtcbiAgICBpZiAoaSA9PSBzLmMubGVuZ3RoKSB7XG4gICAgICBzLmMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICBpZiAoaSArIDEgPT0gcy5sKSBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpO1xuICB9XG4gIHMuY1tpXSA9IGM7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gNykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjIgPSAweEZGICYgaTE2ID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMTY7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MTZcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjQgPSAweEZGICYgaTMyID4+IDI0LFxuICAgICAgYjMgPSAweEZGICYgaTMyID4+IDE2LFxuICAgICAgYjIgPSAweEZGICYgaTMyID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMzI7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAyLCBiMyk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDMsIGI0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDMyXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQzMlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCl7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGk2NCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDY0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyAocykge1xuICB2YXIgdGFnID0gOSAvKiBCWVRFUyB8IEFTQ0lJICovO1xuICBpZiAoIWpzb29faXNfYXNjaWkocykpXG4gICAgdGFnID0gOCAvKiBCWVRFUyB8IE5PVF9BU0NJSSAqLywgcyA9IGNhbWxfdXRmOF9vZl91dGYxNihzKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRhZywgcywgcy5sZW5ndGgpO1xufVxuXG5cbi8vUHJvdmlkZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gTWxCeXRlcyAodGFnLCBjb250ZW50cywgbGVuZ3RoKSB7XG4gIHRoaXMudD10YWc7IHRoaXMuYz1jb250ZW50czsgdGhpcy5sPWxlbmd0aDtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgc3dpdGNoICh0aGlzLnQpIHtcbiAgY2FzZSA5OiAvKkJZVEVTIHwgQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyh0aGlzKTtcbiAgY2FzZSAwOiAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICBpZiAoanNvb19pc19hc2NpaSh0aGlzLmMpKSB7XG4gICAgICB0aGlzLnQgPSA5OyAvKkJZVEVTIHwgQVNDSUkqL1xuICAgICAgcmV0dXJuIHRoaXMuYztcbiAgICB9XG4gICAgdGhpcy50ID0gODsgLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gIGNhc2UgODogLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgfVxufTtcbk1sQnl0ZXMucHJvdG90eXBlLnRvVXRmMTYgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIHIgPSB0aGlzLnRvU3RyaW5nKCk7XG4gIGlmKHRoaXMudCA9PSA5KSByZXR1cm4gclxuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHIpO1xufVxuTWxCeXRlcy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIGNvbnRlbnQgPSB0aGlzLnQgPT0gNCA/IHRoaXMuYy5zbGljZSgpIDogdGhpcy5jO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGhpcy50LGNvbnRlbnQsdGhpcy5sKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQllURVMgKi9cbiAgaWYgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8pXG4gICAgcy5jICs9IGNhbWxfc3RyX3JlcGVhdChzLmwgLSBzLmMubGVuZ3RoLCAnXFwwJylcbiAgZWxzZVxuICAgIHMuYyA9IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAocy5jLCAwLCBzLmMubGVuZ3RoKTtcbiAgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEFSUkFZICovXG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkpIHtcbiAgICB2YXIgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KHMubCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkocy5sKTtcbiAgfVxuICB2YXIgYiA9IHMuYywgbCA9IGIubGVuZ3RoLCBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gIGZvciAobCA9IHMubDsgaSA8IGw7IGkrKykgYVtpXSA9IDA7XG4gIHMuYyA9IGE7XG4gIHMudCA9IDQ7IC8qIEFSUkFZICovXG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9ieXRlcyAocykge1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciBsID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGlmKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcyxjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2J5dGVzKGxlbikge1xuICBpZiAobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQnl0ZXMuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLDAsYS5sZW5ndGgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gbmV3IE1sQnl0ZXMoNCxhLGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfY29tcGFyZShzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/LTE6KHMxLmMgPiBzMi5jKT8xOjA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPT0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09IDAgJiYgKGwgPj0gcy5sIHx8IChzLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGwgPj0gcy5jLmxlbmd0aCkpKSB7XG4gICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdCAobCwgU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgIHMudCA9IChsID09IHMubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9maWxsX2J5dGVzXG52YXIgY2FtbF9maWxsX3N0cmluZyA9IGNhbWxfZmlsbF9ieXRlc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICBpZiAobGVuID09IDApIHJldHVybiAwO1xuICBpZiAoKGkyID09IDApICYmXG4gICAgICAobGVuID49IHMyLmwgfHwgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpKSB7XG4gICAgczIuYyA9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2UgaWYgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGkyID09IHMyLmMubGVuZ3RoKSB7XG4gICAgczIuYyArPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkoczIpO1xuICAgIHZhciBjMSA9IHMxLmMsIGMyID0gczIuYztcbiAgICBpZiAoczEudCA9PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICBpZiAoaTIgPD0gaTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGwgPSBNYXRoLm1pbiAobGVuLCBjMS5sZW5ndGggLSBpMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgYzIgW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2JsaXRfc3RyaW5nKGEsYixjLGQsZSkge1xuICAgIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhhKSxiLGMsZCxlKTtcbiAgICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBzLmNoYXJDb2RlQXQoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ191bnNhZmVfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIHMubGVuZ3RoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmUgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8tMTooczEgPiBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPD0gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW4gY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7XG4gICAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMuYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNhbWxfanNieXRlc19vZl9zdHJpbmcocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSB7XG4gIGlmKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIHM7XG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICBpZiAoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKVxuICBlbHNlIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfdXRmOF9vZl91dGYxNihzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIG5ldyBNbEJ5dGVzKDAscyxzLmxlbmd0aCk7IH1cblxuXG4vLyBUaGUgc2VjdGlvbiBiZWxvdyBzaG91bGQgYmUgdXNlZCB3aGVuIHVzZS1qcy1zdHJpbmc9ZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocyxpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocyxpLGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19jb21wYXJlXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19jb21wYXJlKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB7IHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIGlmICgocy50ICYgNikgIT0gMCAvKiBCWVRFUyAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIHMuYyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocyl7XG4gIHJldHVybiBzLnRvVXRmMTYoKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfYnl0ZXMocykge1xuICByZXR1cm4gKHMgaW5zdGFuY2VvZiBNbEJ5dGVzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWlcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gKHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmICEvW15cXHgwMC1cXHhmZl0vLnRlc3QocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9pc19tbF9ieXRlcyhzKTtcbn1cblxuLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgZGVwcmVjYXRlZFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbmV3X3N0cmluZyAocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19mcm9tX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RvX2pzX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3RvX2pzX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdG9fc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUmFpc2UgZXhjZXB0aW9uXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCAodGFnKSB7IHRocm93IHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50ICh0YWcpIHsgcmV0dXJuIHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGFyZykgeyB0aHJvdyBbMCwgdGFnLCBhcmddOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKHRhZywgbXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhtc2cpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYWlsd2l0aCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ZhaWx3aXRoIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsIG1zZyk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfaW52YWxpZF9hcmd1bWVudCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5JbnZhbGlkX2FyZ3VtZW50LCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkVuZF9vZl9maWxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5EaXZpc2lvbl9ieV96ZXJvKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLk5vdF9mb3VuZCk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgaWYoZi5mdW4pXG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5mdW4sIGFyZ3MpO1xuICAvL0ZJWE1FLCBjYW4gaGFwcGVuIHdpdGggdG9vIG1hbnkgYXJndW1lbnRzXG4gIGlmKHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmO1xuICB2YXIgbiA9IGYubGVuZ3RoIHwgMDtcbiAgaWYobiA9PT0gMCkgcmV0dXJuIGYuYXBwbHkobnVsbCxhcmdzKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aCB8IDA7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW4gfCAwO1xuICBpZiAoZCA9PSAwKVxuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICBlbHNlIGlmIChkIDwgMCkge1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuYXBwbHkobnVsbCxhcmdzLnNsaWNlKDAsbikpLGFyZ3Muc2xpY2UobikpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKXtcbiAgICAgIHZhciBleHRyYV9hcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT0gMCk/MTphcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoK2V4dHJhX2FyZ3MpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkgbmFyZ3NbYXJncy5sZW5ndGgraV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBuYXJncylcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZXNcbnZhciBjYW1sX25hbWVkX3ZhbHVlcyA9IHt9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIChjb25zdCxjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlKG5tLHYpIHtcbiAgY2FtbF9uYW1lZF92YWx1ZXNbY2FtbF9qc2J5dGVzX29mX3N0cmluZyhubSldID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG5mdW5jdGlvbiBjYW1sX25hbWVkX3ZhbHVlKG5tKSB7XG4gIHJldHVybiBjYW1sX25hbWVkX3ZhbHVlc1tubV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nbG9iYWxfZGF0YVxudmFyIGNhbWxfZ2xvYmFsX2RhdGEgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChjb25zdCwgc2hhbGxvdywgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAobiwgdiwgbmFtZV9vcHQpIHtcbiAgaWYobmFtZV9vcHQgJiYgam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYylcbiAgICBuID0gam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYyhuYW1lX29wdCk7XG4gIGNhbWxfZ2xvYmFsX2RhdGFbbiArIDFdID0gdjtcbiAgaWYobmFtZV9vcHQpIGNhbWxfZ2xvYmFsX2RhdGFbbmFtZV9vcHRdID0gdjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfZ2xvYmFsX2RhdGEgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9nZXRfZ2xvYmFsX2RhdGEgKCkgeyByZXR1cm4gY2FtbF9nbG9iYWxfZGF0YTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX3ByaW50YWJsZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2lzX3ByaW50YWJsZShjKSB7IHJldHVybiArKGMgPiAzMSAmJiBjIDwgMTI3KTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBGb3JtYXRcblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9mb3JtYXQgKGZtdCkge1xuICBmbXQgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCk7XG4gIHZhciBsZW4gPSBmbXQubGVuZ3RoO1xuICBpZiAobGVuID4gMzEpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImZvcm1hdF9pbnQ6IGZvcm1hdCB0b28gbG9uZ1wiKTtcbiAgdmFyIGYgPVxuICAgICAgeyBqdXN0aWZ5OicrJywgc2lnbnN0eWxlOictJywgZmlsbGVyOicgJywgYWx0ZXJuYXRlOmZhbHNlLFxuICAgICAgICBiYXNlOjAsIHNpZ25lZGNvbnY6ZmFsc2UsIHdpZHRoOjAsIHVwcGVyY2FzZTpmYWxzZSxcbiAgICAgICAgc2lnbjoxLCBwcmVjOi0xLCBjb252OidmJyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBmbXQuY2hhckF0KGkpO1xuICAgIHN3aXRjaCAoYykge1xuICAgIGNhc2UgJy0nOlxuICAgICAgZi5qdXN0aWZ5ID0gJy0nOyBicmVhaztcbiAgICBjYXNlICcrJzogY2FzZSAnICc6XG4gICAgICBmLnNpZ25zdHlsZSA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJzAnOlxuICAgICAgZi5maWxsZXIgPSAnMCc7IGJyZWFrO1xuICAgIGNhc2UgJyMnOlxuICAgICAgZi5hbHRlcm5hdGUgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzogY2FzZSAnNSc6XG4gICAgY2FzZSAnNic6IGNhc2UgJzcnOiBjYXNlICc4JzogY2FzZSAnOSc6XG4gICAgICBmLndpZHRoID0gMDtcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi53aWR0aCA9IGYud2lkdGggKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnLic6XG4gICAgICBmLnByZWMgPSAwO1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLnByZWMgPSBmLnByZWMgKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgIGNhc2UgJ2QnOiBjYXNlICdpJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAndSc6XG4gICAgICBmLmJhc2UgPSAxMDsgYnJlYWs7XG4gICAgY2FzZSAneCc6XG4gICAgICBmLmJhc2UgPSAxNjsgYnJlYWs7XG4gICAgY2FzZSAnWCc6XG4gICAgICBmLmJhc2UgPSAxNjsgZi51cHBlcmNhc2UgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICdvJzpcbiAgICAgIGYuYmFzZSA9IDg7IGJyZWFrO1xuICAgIGNhc2UgJ2UnOiBjYXNlICdmJzogY2FzZSAnZyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLmNvbnYgPSBjOyBicmVhaztcbiAgICBjYXNlICdFJzogY2FzZSAnRic6IGNhc2UgJ0cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi51cHBlcmNhc2UgPSB0cnVlO1xuICAgICAgZi5jb252ID0gYy50b0xvd2VyQ2FzZSAoKTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHJhd2J1ZmZlcikge1xuICBpZiAoZi51cHBlcmNhc2UpIHJhd2J1ZmZlciA9IHJhd2J1ZmZlci50b1VwcGVyQ2FzZSgpO1xuICB2YXIgbGVuID0gcmF3YnVmZmVyLmxlbmd0aDtcbiAgLyogQWRqdXN0IGxlbiB0byByZWZsZWN0IGFkZGl0aW9uYWwgY2hhcnMgKHNpZ24sIGV0YykgKi9cbiAgaWYgKGYuc2lnbmVkY29udiAmJiAoZi5zaWduIDwgMCB8fCBmLnNpZ25zdHlsZSAhPSAnLScpKSBsZW4rKztcbiAgaWYgKGYuYWx0ZXJuYXRlKSB7XG4gICAgaWYgKGYuYmFzZSA9PSA4KSBsZW4gKz0gMTtcbiAgICBpZiAoZi5iYXNlID09IDE2KSBsZW4gKz0gMjtcbiAgfVxuICAvKiBEbyB0aGUgZm9ybWF0dGluZyAqL1xuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJyAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIGlmIChmLnNpZ25lZGNvbnYpIHtcbiAgICBpZiAoZi5zaWduIDwgMCkgYnVmZmVyICs9ICctJztcbiAgICBlbHNlIGlmIChmLnNpZ25zdHlsZSAhPSAnLScpIGJ1ZmZlciArPSBmLnNpZ25zdHlsZTtcbiAgfVxuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDgpIGJ1ZmZlciArPSAnMCc7XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gMTYpIGJ1ZmZlciArPSBcIjB4XCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcwJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJzAnO1xuICBidWZmZXIgKz0gcmF3YnVmZmVyO1xuICBpZiAoZi5qdXN0aWZ5ID09ICctJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhidWZmZXIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGpzb29fZmxvb3JfbG9nMlxudmFyIGxvZzJfb2sgPSBNYXRoLmxvZzIgJiYgTWF0aC5sb2cyKDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3KSA9PSAxMDIwXG5mdW5jdGlvbiBqc29vX2Zsb29yX2xvZzIoeCkge1xuICBpZihsb2cyX29rKSByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZzIoeCkpXG4gIHZhciBpID0gMDtcbiAgaWYgKHggPT0gMCkgcmV0dXJuIC1JbmZpbml0eTtcbiAgaWYoeD49MSkge3doaWxlICh4Pj0yKSB7eC89MjsgaSsrfSB9XG4gIGVsc2Uge3doaWxlICh4IDwgMSkge3gqPTI7IGktLX0gfTtcbiAgcmV0dXJuIGk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyLCBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMSwgMCwgMHg3ZmYwKTtcbiAgICBpZiAoeCA+IDApXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHg3ZmYwKVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweGZmZjApXG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8weDgwMDA6KHg+PTApPzA6MHg4MDAwO1xuICBpZiAoc2lnbikgeCA9IC14O1xuICAvLyBJbnQ2NC5iaXRzX29mX2Zsb2F0IDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3ID0gMHg3ZmIwMDAwMDAwMDAwMDAwTFxuICAvLyB1c2luZyBNYXRoLkxPRzJFKk1hdGgubG9nKHgpIGluIHBsYWNlIG9mIE1hdGgubG9nMiByZXN1bHQgaW4gcHJlY2lzaW9uIGxvc3RcbiAgdmFyIGV4cCA9IGpzb29fZmxvb3JfbG9nMih4KSArIDEwMjM7XG4gIGlmIChleHAgPD0gMCkge1xuICAgIGV4cCA9IDA7XG4gICAgeCAvPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgfSBlbHNlIHtcbiAgICB4IC89IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICAgIGlmICh4IDwgMTYpIHtcbiAgICAgIHggKj0gMjsgZXhwIC09MTsgfVxuICAgIGlmIChleHAgPT0gMCkge1xuICAgICAgeCAvPSAyOyB9XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLDI0KTtcbiAgdmFyIHIzID0geHwwO1xuICB4ID0gKHggLSByMykgKiBrO1xuICB2YXIgcjIgPSB4fDA7XG4gIHggPSAoeCAtIHIyKSAqIGs7XG4gIHZhciByMSA9IHh8MDtcbiAgcjMgPSAocjMgJjB4ZikgfCBzaWduIHwgZXhwIDw8IDQ7XG4gIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShyMSwgcjIsIHIzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCAoeCkge1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQzMkFycmF5KDEpO1xuICBmbG9hdDMyYVswXSA9IHg7XG4gIHZhciBpbnQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheShmbG9hdDMyYS5idWZmZXIpO1xuICByZXR1cm4gaW50MzJhWzBdIHwgMDtcbn1cblxuLy9GUCBsaXRlcmFscyBjYW4gYmUgd3JpdHRlbiB1c2luZyB0aGUgaGV4YWRlY2ltYWxcbi8vbm90YXRpb24gMHg8bWFudGlzc2EgaW4gaGV4PnA8ZXhwb25lbnQ+IGZyb20gSVNPIEM5OS5cbi8vaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWhleGZsb2F0L2Jsb2IvbWFzdGVyL2hleGZsb2F0LmpzXG4vL1Byb3ZpZGVzOiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgKHgsIHByZWMsIHN0eWxlKSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhcIm5hblwiKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKCh4ID4gMCk/XCJpbmZpbml0eVwiOlwiLWluZmluaXR5XCIpO1xuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MTooeD49MCk/MDoxO1xuICBpZihzaWduKSB4ID0gLXg7XG4gIHZhciBleHAgPSAwO1xuICBpZiAoeCA9PSAwKSB7IH1cbiAgZWxzZSBpZiAoeCA8IDEpIHtcbiAgICB3aGlsZSAoeCA8IDEgJiYgZXhwID4gLTEwMjIpICB7IHggKj0gMjsgZXhwLS0gfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICh4ID49IDIpIHsgeCAvPSAyOyBleHArKyB9XG4gIH1cbiAgdmFyIGV4cF9zaWduID0gZXhwIDwgMCA/ICcnIDogJysnO1xuICB2YXIgc2lnbl9zdHIgPSAnJztcbiAgaWYgKHNpZ24pIHNpZ25fc3RyID0gJy0nXG4gIGVsc2Uge1xuICAgIHN3aXRjaChzdHlsZSl7XG4gICAgY2FzZSA0MyAvKiAnKycgKi86IHNpZ25fc3RyID0gJysnOyBicmVhaztcbiAgICBjYXNlIDMyIC8qICcgJyAqLzogc2lnbl9zdHIgPSAnICc7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAocHJlYyA+PSAwICYmIHByZWMgPCAxMykge1xuICAgIC8qIElmIGEgcHJlY2lzaW9uIGlzIGdpdmVuLCBhbmQgaXMgc21hbGwsIHJvdW5kIG1hbnRpc3NhIGFjY29yZGluZ2x5ICovXG4gICAgdmFyIGNzdCA9IE1hdGgucG93KDIscHJlYyAqIDQpO1xuICAgIHggPSBNYXRoLnJvdW5kKHggKiBjc3QpIC8gY3N0O1xuICB9XG4gIHZhciB4X3N0ciA9IHgudG9TdHJpbmcoMTYpO1xuICBpZihwcmVjID49IDApe1xuICAgIHZhciBpZHggPSB4X3N0ci5pbmRleE9mKCcuJyk7XG4gICAgaWYoaWR4PDApIHtcbiAgICAgIHhfc3RyICs9ICcuJyArIGNhbWxfc3RyX3JlcGVhdChwcmVjLCAnMCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gaWR4KzErcHJlYztcbiAgICAgIGlmKHhfc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgICAgIHhfc3RyICs9IGNhbWxfc3RyX3JlcGVhdChzaXplIC0geF9zdHIubGVuZ3RoLCAnMCcpO1xuICAgICAgZWxzZVxuICAgICAgICB4X3N0ciA9IHhfc3RyLnN1YnN0cigwLHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHNpZ25fc3RyICsgJzB4JyArIHhfc3RyICsgJ3AnICsgZXhwX3NpZ24gKyBleHAudG9TdHJpbmcoMTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGxvID0geC5sbztcbiAgdmFyIG1pID0geC5taTtcbiAgdmFyIGhpID0geC5oaTtcbiAgdmFyIGV4cCA9IChoaSAmIDB4N2ZmZikgPj4gNDtcbiAgaWYgKGV4cCA9PSAyMDQ3KSB7XG4gICAgaWYgKChsb3xtaXwoaGkmMHhmKSkgPT0gMClcbiAgICAgIHJldHVybiAoaGkgJiAweDgwMDApPygtSW5maW5pdHkpOkluZmluaXR5O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBOYU47XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLC0yNCk7XG4gIHZhciByZXMgPSAobG8qayttaSkqaysoaGkmMHhmKTtcbiAgaWYgKGV4cCA+IDApIHtcbiAgICByZXMgKz0gMTY7XG4gICAgcmVzICo9IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICB9IGVsc2VcbiAgICByZXMgKj0gTWF0aC5wb3coMiwtMTAyNik7XG4gIGlmIChoaSAmIDB4ODAwMCkgcmVzID0gLSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV4dGFmdGVyX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfc3ViLGNhbWxfaW50NjRfb2ZfaW50MzJcbmZ1bmN0aW9uIGNhbWxfbmV4dGFmdGVyX2Zsb2F0ICh4LHkpIHtcbiAgaWYoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiBOYU47XG4gIGlmKHg9PXkpIHJldHVybiB5O1xuICBpZih4PT0wKXtcbiAgICBpZih5IDwgMClcbiAgICAgIHJldHVybiAtTWF0aC5wb3coMiwgLTEwNzQpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMDc0KVxuICB9XG4gIHZhciBiaXRzID0gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHgpO1xuICB2YXIgb25lID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxKTtcbiAgaWYgKCh4PHkpID09ICh4PjApKVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X2FkZChiaXRzLCBvbmUpXG4gIGVsc2VcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9zdWIoYml0cywgb25lKVxuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGJpdHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RydW5jX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX3RydW5jX2Zsb2F0KHgpe1xuICByZXR1cm4gTWF0aC50cnVuYyh4KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGludDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KDEpO1xuICBpbnQzMmFbMF0gPSB4O1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQzMkFycmF5KGludDMyYS5idWZmZXIpO1xuICByZXR1cm4gZmxvYXQzMmFbMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2xhc3NpZnlfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2xhc3NpZnlfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIGlmIChNYXRoLmFicyh4KSA+PSAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgcmV0dXJuIDA7XG4gICAgaWYgKHggIT0gMCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgcmV0dXJuIGlzTmFOKHgpPzQ6Mztcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbW9kZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tb2RmX2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICB2YXIgbmVnID0gKDEveCkgPCAwO1xuICAgIHggPSBNYXRoLmFicyh4KTtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IgKHgpO1xuICAgIHZhciBmID0geCAtIGk7XG4gICAgaWYgKG5lZykgeyBpID0gLWk7IGYgPSAtZjsgfVxuICAgIHJldHVybiBbMCwgZiwgaV07XG4gIH1cbiAgaWYgKGlzTmFOICh4KSkgcmV0dXJuIFswLCBOYU4sIE5hTl07XG4gIHJldHVybiBbMCwgMS94LCB4XTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbGRleHBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbGRleHBfZmxvYXQgKHgsZXhwKSB7XG4gIGV4cCB8PSAwO1xuICBpZiAoZXhwID4gMTAyMykge1xuICAgIGV4cCAtPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgaWYgKGV4cCA+IDEwMjMpIHsgIC8vIGluIGNhc2UgeCBpcyBzdWJub3JtYWxcbiAgICAgIGV4cCAtPSAxMDIzO1xuICAgICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4cCA8IC0xMDIzKSB7XG4gICAgZXhwICs9IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAtMTAyMyk7XG4gIH1cbiAgeCAqPSBNYXRoLnBvdygyLCBleHApO1xuICByZXR1cm4geDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZnJleHBfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9mcmV4cF9mbG9hdCAoeCkge1xuICBpZiAoKHggPT0gMCkgfHwgIWlzRmluaXRlKHgpKSByZXR1cm4gWzAsIHgsIDBdO1xuICB2YXIgbmVnID0geCA8IDA7XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHZhciBleHAgPSBNYXRoLm1heCgtMTAyMywganNvb19mbG9vcl9sb2cyKHgpICsgMSk7XG4gIHggKj0gTWF0aC5wb3coMiwtZXhwKTtcbiAgd2hpbGUgKHggPCAwLjUpIHtcbiAgICB4ICo9IDI7XG4gICAgZXhwLS07XG4gIH1cbiAgd2hpbGUgKHggPj0gMSkge1xuICAgIHggKj0gMC41O1xuICAgIGV4cCsrO1xuICB9XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHJldHVybiBbMCwgeCwgZXhwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Zsb2F0X2NvbXBhcmUgKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHJldHVybiAwO1xuICBpZiAoeCA8IHkpIHJldHVybiAtMTtcbiAgaWYgKHggPiB5KSByZXR1cm4gMTtcbiAgaWYgKHggPT09IHgpIHJldHVybiAxO1xuICBpZiAoeSA9PT0geSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb3B5c2lnbl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3B5c2lnbl9mbG9hdCAoeCwgeSkge1xuICBpZiAoeSA9PSAwKSB5ID0gMSAvIHk7XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgcmV0dXJuICh5IDwgMCk/KC14KTp4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NpZ25iaXRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2lnbmJpdF9mbG9hdCh4KSB7XG4gIGlmICh4ID09IDApIHggPSAxIC8geDtcbiAgcmV0dXJuICh4IDwgMCk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4cG0xX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cG0xX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gTWF0aC5leHAoeCksIHogPSB5IC0gMTtcbiAgcmV0dXJuIChNYXRoLmFicyh4KT4xP3o6KHo9PTA/eDp4KnovTWF0aC5sb2coeSkpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sb2cxcF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxcF9mbG9hdCAoeCkge1xuICB2YXIgeSA9IDEgKyB4LCB6ID0geSAtIDE7XG4gIHJldHVybiAoej09MD94OngqTWF0aC5sb2coeSkveik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaHlwb3RfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaHlwb3RfZmxvYXQgKHgsIHkpIHtcbiAgdmFyIHggPSBNYXRoLmFicyh4KSwgeSA9IE1hdGguYWJzKHkpO1xuICB2YXIgYSA9IE1hdGgubWF4KHgsIHkpLCBiID0gTWF0aC5taW4oeCx5KSAvIChhP2E6MSk7XG4gIHJldHVybiAoYSAqIE1hdGguc3FydCgxICsgYipiKSk7XG59XG5cbi8vIEZJWDogdGhlc2UgZml2ZSBmdW5jdGlvbnMgb25seSBnaXZlIGFwcHJveGltYXRlIHJlc3VsdHMuXG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzEwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzEwX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLkxPRzEwRSAqIE1hdGgubG9nKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2Nvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKSAvIDI7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaW5oX2Zsb2F0ICh4KSB7IHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gMjsgfVxuLy9Qcm92aWRlczogY2FtbF90YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3RhbmhfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSBNYXRoLmV4cCh4KSwgeiA9IE1hdGguZXhwKC14KTtcbiAgcmV0dXJuICh5IC0geikgLyAoeSArIHopO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JvdW5kX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX3JvdW5kX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfZmxvYXQgKGZtdCwgeCkge1xuICBmdW5jdGlvbiB0b0ZpeGVkKHgsZHApIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPCAxLjApIHtcbiAgICAgIHJldHVybiB4LnRvRml4ZWQoZHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZSA9IHBhcnNlSW50KHgudG9TdHJpbmcoKS5zcGxpdCgnKycpWzFdKTtcbiAgICAgIGlmIChlID4gMjApIHtcbiAgICAgICAgZSAtPSAyMDtcbiAgICAgICAgeCAvPSBNYXRoLnBvdygxMCxlKTtcbiAgICAgICAgeCArPSAobmV3IEFycmF5KGUrMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgaWYoZHAgPiAwKSB7XG4gICAgICAgICAgeCA9IHggKyAnLicgKyAobmV3IEFycmF5KGRwKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBlbHNlIHJldHVybiB4LnRvRml4ZWQoZHApXG4gICAgfVxuICB9XG4gIHZhciBzLCBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgdmFyIHByZWMgPSAoZi5wcmVjIDwgMCk/NjpmLnByZWM7XG4gIGlmICh4IDwgMCB8fCAoeCA9PSAwICYmIDEveCA9PSAtSW5maW5pdHkpKSB7IGYuc2lnbiA9IC0xOyB4ID0gLXg7IH1cbiAgaWYgKGlzTmFOKHgpKSB7IHMgPSBcIm5hblwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlIGlmICghaXNGaW5pdGUoeCkpIHsgcyA9IFwiaW5mXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2VcbiAgICBzd2l0Y2ggKGYuY29udikge1xuICAgIGNhc2UgJ2UnOlxuICAgICAgdmFyIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyk7XG4gICAgICAvLyBleHBvbmVudCBzaG91bGQgYmUgYXQgbGVhc3QgdHdvIGRpZ2l0c1xuICAgICAgdmFyIGkgPSBzLmxlbmd0aDtcbiAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZic6XG4gICAgICBzID0gdG9GaXhlZCh4LCBwcmVjKTsgYnJlYWs7XG4gICAgY2FzZSAnZyc6XG4gICAgICBwcmVjID0gcHJlYz9wcmVjOjE7XG4gICAgICBzID0geC50b0V4cG9uZW50aWFsKHByZWMgLSAxKTtcbiAgICAgIHZhciBqID0gcy5pbmRleE9mKCdlJyk7XG4gICAgICB2YXIgZXhwID0gK3Muc2xpY2UoaiArIDEpO1xuICAgICAgaWYgKGV4cCA8IC00IHx8IHggPj0gMWUyMSB8fCB4LnRvRml4ZWQoMCkubGVuZ3RoID4gcHJlYykge1xuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgIHZhciBpID0gaiAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSkgKyBzLnNsaWNlKGopO1xuICAgICAgICBpID0gcy5sZW5ndGg7XG4gICAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHAgPSBwcmVjO1xuICAgICAgICBpZiAoZXhwIDwgMCkgeyBwIC09IGV4cCArIDE7IHMgPSB4LnRvRml4ZWQocCk7IH1cbiAgICAgICAgZWxzZSB3aGlsZSAocyA9IHgudG9GaXhlZChwKSwgcy5sZW5ndGggPiBwcmVjICsgMSkgcC0tO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgICB2YXIgaSA9IHMubGVuZ3RoIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHJlcztcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocylcbiAgcmVzID0gK3M7XG4gIGlmICgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSByZXR1cm4gcmVzO1xuICBzID0gcy5yZXBsYWNlKC9fL2csXCJcIik7XG4gIHJlcyA9ICtzO1xuICBpZiAoKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHx8IC9eWystXT9uYW4kL2kudGVzdChzKSkgcmV0dXJuIHJlcztcbiAgdmFyIG0gPSAvXiAqKFsrLV0/KTB4KFswLTlhLWZdKylcXC4/KFswLTlhLWZdKilwKFsrLV0/WzAtOV0rKS9pLmV4ZWMocyk7XG4gIC8vICAgICAgICAgIDEgICAgICAgIDIgICAgICAgICAgICAgMyAgICAgICAgICAgNFxuICBpZihtKXtcbiAgICB2YXIgbTMgPSBtWzNdLnJlcGxhY2UoLzArJC8sJycpO1xuICAgIHZhciBtYW50aXNzYSA9IHBhcnNlSW50KG1bMV0gKyBtWzJdICsgbTMsIDE2KTtcbiAgICB2YXIgZXhwb25lbnQgPSAobVs0XXwwKSAtIDQqbTMubGVuZ3RoO1xuICAgIHJlcyA9IG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYoL15cXCs/aW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIEluZmluaXR5O1xuICBpZigvXi1pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gLUluZmluaXR5O1xuICBjYW1sX2ZhaWx3aXRoKFwiZmxvYXRfb2Zfc3RyaW5nXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBEdW1teSBmaWxlc3lzdGVtXG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9kaXJcbmlmKGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MgJiYgam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5jd2QpXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5jd2QoKS5yZXBsYWNlKC9cXFxcL2csJy8nKTtcbmVsc2VcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSAgXCIvc3RhdGljXCI7XG5pZihjYW1sX2N1cnJlbnRfZGlyLnNsaWNlKC0xKSAhPT0gXCIvXCIpIGNhbWxfY3VycmVudF9kaXIgKz0gXCIvXCJcblxuLy9Qcm92aWRlczogY2FtbF9yb290XG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG52YXIgY2FtbF9yb290ID0gY2FtbF9jdXJyZW50X2Rpci5tYXRjaCgvW15cXC9dKlxcLy8pWzBdO1xuXG5cbi8vUHJvdmlkZXM6IE1sRmlsZVxuZnVuY3Rpb24gTWxGaWxlKCl7ICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9wYXRoXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGggKG5hbWUpIHtcbiAgbmFtZT1jYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYobmFtZS5jaGFyQ29kZUF0KDApICE9IDQ3KVxuICAgIG5hbWUgPSBjYW1sX2N1cnJlbnRfZGlyICsgbmFtZTtcbiAgdmFyIGNvbXAgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgdmFyIG5jb21wID0gW11cbiAgZm9yKHZhciBpID0gMDsgaTxjb21wLmxlbmd0aDsgaSsrKXtcbiAgICBzd2l0Y2goY29tcFtpXSl7XG4gICAgY2FzZSBcIi4uXCI6IGlmKG5jb21wLmxlbmd0aD4xKSBuY29tcC5wb3AoKTsgYnJlYWs7XG4gICAgY2FzZSBcIi5cIjogYnJlYWs7XG4gICAgY2FzZSBcIlwiOiBpZihuY29tcC5sZW5ndGggPT0gMCkgbmNvbXAucHVzaChcIlwiKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogbmNvbXAucHVzaChjb21wW2ldKTticmVha1xuICAgIH1cbiAgfVxuICBuY29tcC5vcmlnID0gbmFtZTtcbiAgcmV0dXJuIG5jb21wO1xufVxuXG4vL1Byb3ZpZGVzOmpzb29fbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgTWxOb2RlRGV2aWNlLCBjYW1sX3Jvb3QsIGZzX25vZGVfc3VwcG9ydGVkXG52YXIganNvb19tb3VudF9wb2ludCA9IFtdXG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn0gZWxzZSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KX0pO1xufVxuanNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCtcInN0YXRpYy9cIiwgZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290K1wic3RhdGljL1wiKX0pO1xuXG4vL1Byb3ZpZGVzOmNhbWxfbGlzdF9tb3VudF9wb2ludFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCl7XG4gIHZhciBwcmV2ID0gMFxuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIG9sZCA9IHByZXY7XG4gICAgcHJldiA9IFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCksIG9sZF1cbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50XG5mdW5jdGlvbiByZXNvbHZlX2ZzX2RldmljZShuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpO1xuICB2YXIgbmFtZV9zbGFzaCA9IG5hbWUgKyBcIi9cIjtcbiAgdmFyIHJlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IGpzb29fbW91bnRfcG9pbnRbaV07XG4gICAgaWYobmFtZV9zbGFzaC5zZWFyY2gobS5wYXRoKSA9PSAwXG4gICAgICAgJiYgKCFyZXMgfHwgcmVzLnBhdGgubGVuZ3RoIDwgbS5wYXRoLmxlbmd0aCkpXG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW91bnRfYXV0b2xvYWRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnRcbmZ1bmN0aW9uIGNhbWxfbW91bnRfYXV0b2xvYWQobmFtZSxmKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpuYW1lLGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKG5hbWUsZil9KVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bm1vdW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX21ha2VfcGF0aFxuZnVuY3Rpb24gY2FtbF91bm1vdW50KG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIikgKyBcIi9cIjtcbiAgdmFyIGlkeCA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKylcbiAgICBpZihqc29vX21vdW50X3BvaW50W2ldLnBhdGggPT0gbmFtZSkgaWR4ID0gaTtcbiAgaWYoaWR4ID4gLTEpIGpzb29fbW91bnRfcG9pbnQuc3BsaWNlKGlkeCwxKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0Y3dkXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRjd2QoKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19jaGRpcihkaXIpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkaXIpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGlmKHJvb3QucmVzdCkgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aCArIHJvb3QucmVzdCArIFwiL1wiO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShkaXIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSl7XG4gIG5hbWUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBuYW1lID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKTtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19maWxlX2V4aXN0c1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2ZpbGVfZXhpc3RzIChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVhZF9kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UucmVhZGRpcihyb290LnJlc3QpO1xuICB2YXIgbCA9IG5ldyBBcnJheShhLmxlbmd0aCArIDEpO1xuICBsWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxhLmxlbmd0aDtpKyspXG4gICAgbFtpKzFdID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhhW2ldKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbW92ZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW1vdmUobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBvayA9IHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QpO1xuICBpZihvayA9PSAwKSBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIGE/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW5hbWVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW5hbWUobyxuKXtcbiAgdmFyIG9fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG8pO1xuICB2YXIgbl9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobik7XG4gIGlmKG9fcm9vdC5kZXZpY2UgIT0gbl9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBjYW5ub3QgbW92ZSBmaWxlIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1cIik7XG4gIGlmKCFvX3Jvb3QuZGV2aWNlLnJlbmFtZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBubyBpbXBsZW1lbnRlZFwiKTtcbiAgb19yb290LmRldmljZS5yZW5hbWUob19yb290LnJlc3QsIG5fcm9vdC5yZXN0KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlKHZmZCwga2luZCwgbGF5b3V0LCBzaGFyZWQsIGRpbXMsIHBvcykge1xuICAvLyB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW3ZmZF07XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2JhX21hcF9maWxlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZVxuLy9SZXF1aXJlczogY2FtbF9iYV9tYXBfZmlsZVxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZShhcmd2LGFyZ24pe1xuICByZXR1cm4gY2FtbF9iYV9tYXBfZmlsZShhcmd2WzBdLGFyZ3ZbMV0sYXJndlsyXSxhcmd2WzNdLGFyZ3ZbNF0sYXJndls1XSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlX2V4dGVybihuYW1lLGNvbnRlbnQpe1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlKVxuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KTtcbiAgZWxzZSB7XG4gICAgaWYoIWpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wKSBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCA9IFtdO1xuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wLnB1c2goe25hbWU6bmFtZSxjb250ZW50OmNvbnRlbnR9KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mc19pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9maWxlXG5mdW5jdGlvbiBjYW1sX2ZzX2luaXQgKCl7XG4gIHZhciB0bXA9am9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXBcbiAgaWYodG1wKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNhbWxfY3JlYXRlX2ZpbGUodG1wW2ldLm5hbWUsdG1wW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlID0gY2FtbF9jcmVhdGVfZmlsZTtcbiAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAgPSBbXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciBjb250ZW50ID0gKHR5cGVvZiBjb250ZW50ID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY29udGVudCk6Y29udGVudDtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYoISByb290LmRldmljZS5yZWdpc3RlcikgY2FtbF9mYWlsd2l0aChcImNhbm5vdCByZWdpc3RlciBmaWxlXCIpO1xuICByb290LmRldmljZS5yZWdpc3Rlcihyb290LnJlc3QsY29udGVudCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlYWRfZmlsZV9jb250ZW50XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9yZWFkX2ZpbGVfY29udGVudCAobmFtZSkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCx7cmRvbmx5OjF9KTtcbiAgICB2YXIgbGVuICA9IGZpbGUubGVuZ3RoKCk7XG4gICAgdmFyIGJ1ZiAgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGZpbGUucmVhZCgwLGJ1ZiwwLGxlbik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZilcbiAgfVxuICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gU3lzXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLlN5c19lcnJvciwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N5c19leGl0IChjb2RlKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmKGcucXVpdCkgZy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLmV4aXQpXG4gICAgZy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3N0YXRpY19lbnZcbmZ1bmN0aW9uIGNhbWxfc2V0X3N0YXRpY19lbnYoayx2KXtcbiAgaWYoIWpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudilcbiAgICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnYgPSB7fVxuICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZba10gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGVudiAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIG4gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgLy9ub2RlanMgZW52XG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuZW52XG4gICAgICYmIGcucHJvY2Vzcy5lbnZbbl0gIT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhnLnByb2Nlc3MuZW52W25dKTtcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52XG4gICAgICYmIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltuXSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdW5zYWZlX2dldGVudlxuLy9SZXF1aXJlczogY2FtbF9zeXNfZ2V0ZW52XG5mdW5jdGlvbiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52KG5hbWUpe1xuICByZXR1cm4gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfYXJndiA9ICgoZnVuY3Rpb24gKCkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgbWFpbiA9IFwiYS5vdXRcIjtcbiAgdmFyIGFyZ3MgPSBbXVxuXG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuYXJndlxuICAgICAmJiBnLnByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGFyZ3YgPSBnLnByb2Nlc3MuYXJndlxuICAgIC8vbm9kZWpzXG4gICAgbWFpbiA9IGFyZ3ZbMV07XG4gICAgYXJncyA9IGFyZ3Yuc2xpY2UoMik7XG4gIH1cblxuICB2YXIgcCA9IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKG1haW4pO1xuICB2YXIgYXJnczIgPSBbMCwgcF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKVxuICAgIGFyZ3MyLnB1c2goY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoYXJnc1tpXSkpO1xuICByZXR1cm4gYXJnczI7XG59KSgpKVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG52YXIgY2FtbF9leGVjdXRhYmxlX25hbWUgPSBjYW1sX2FyZ3ZbMV1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2FyZ3YgKGEpIHtcbiAgcmV0dXJuIFswLCBjYW1sX2FyZ3ZbMV0sIGNhbWxfYXJndl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfYXJndiAoYSkge1xuICByZXR1cm4gY2FtbF9hcmd2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19tb2RpZnlfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19tb2RpZnlfYXJndihhcmcpe1xuICBjYW1sX2FyZ3YgPSBhcmc7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG5mdW5jdGlvbiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUoYSl7XG4gIHJldHVybiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kKGNtZCl7XG4gIHZhciBjbWQgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhjbWQpO1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT0gXCJ1bmRlZmluZWRcIlxuICAgICAgJiYgcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmMpIHtcbiAgICB0cnkge3JlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYyhjbWQse3N0ZGlvOiAnaW5oZXJpdCd9KTsgcmV0dXJuIDB9XG4gICAgY2F0Y2ggKGUpIHtyZXR1cm4gMX1cbiAgfVxuICBlbHNlIHJldHVybiAxMjc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWUgbXV0YWJsZVxudmFyIGNhbWxfaW5pdGlhbF90aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICByZXR1cm4gbm93ICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuXG4vL1JlcXVpcmVzOiBjYW1sX3N5c190aW1lXG5mdW5jdGlvbiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4oYikge1xuICByZXR1cm4gY2FtbF9zeXNfdGltZSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICB2YXIgeCA9IG5vd14weGZmZmZmZmZmKk1hdGgucmFuZG9tKCk7XG4gIHJldHVybiBbMCx4XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2ludF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIGNvbnN0XG4vLyBtYXhfaW50IC8gNCBzbyB0aGF0IHRoZSBmb2xsb3dpbmcgZG9lcyBub3Qgb3ZlcmZsb3dcbi8vbGV0IG1heF9zdHJpbmdfbGVuZ3RoID0gd29yZF9zaXplIC8gOCAqIG1heF9hcnJheV9sZW5ndGggLSAxOztcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgKCkgeyByZXR1cm4gKDB4N0ZGRkZGRkYvNCkgfCAwO31cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4ICgpIHsgcmV0dXJuIDE7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImpzX29mX29jYW1sXCIpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2NvbmZpZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2NvbmZpZyAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlVuaXhcIiksIDMyLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNhdHR5XG5mdW5jdGlvbiBjYW1sX3N5c19pc2F0dHkoX2NoYW4pIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV92YXJpYW50XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfdmFyaWFudChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyhfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIoKXtyZXR1cm4gMH1cblxuLy9Qcm92aWRlczogdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nXG5mdW5jdGlvbiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmcgKCkge3JldHVybiAwO31cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xudmFyIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyAoYm9vbCkge1xuICBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSBib29sO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3J1bnRpbWVfd2FybmluZ3M7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9lbmFibGVkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZShfY2hhbm5lbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiU3BhY2V0aW1lIHByb2ZpbGluZyBvbmx5IHdvcmtzIGZvciBuYXRpdmUgY29kZVwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZURldmljZVxuLy9SZXF1aXJlczogTWxGYWtlRmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXksIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5sb29rdXBGdW4oY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnJvb3QpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpKTtcbiAgICBpZihyZXMgIT09IDApIHRoaXMuY29udGVudFtuYW1lXT1uZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhyZXNbMV0pKTtcbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIC8vIFRoZSByb290IG9mIHRoZSBkZXZpY2UgZXhpc3RzXG4gIGlmKG5hbWUgPT0gXCJcIikgcmV0dXJuIDE7XG4gIC8vIENoZWNrIGlmIGEgZGlyZWN0b3J5IGV4aXN0c1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoKTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmIChuLm1hdGNoKHIpKSByZXR1cm4gMVxuICB9XG4gIC8vIENoZWNrIGlmIGEgZmlsZSBleGlzdHNcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV0/MTowO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSkgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBvayA9IHRoaXMuY29udGVudFtuYW1lXT90cnVlOmZhbHNlO1xuICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVdO1xuICByZXR1cm4gb2s7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgdmFyIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgaWYoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICAgIHJldHVybiBmaWxlO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVnaXN0ZXI9IGZ1bmN0aW9uIChuYW1lLGNvbnRlbnQpe1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV0pIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gIGlmKGNhbWxfaXNfbWxfYnl0ZXMoY29udGVudCkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY29udGVudCk7XG4gIGlmKGNhbWxfaXNfbWxfc3RyaW5nKGNvbnRlbnQpKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9hcnJheShjb250ZW50KSk7XG4gIGVsc2UgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50LnRvU3RyaW5nKSB7XG4gICAgdmFyIGJ5dGVzID0gY2FtbF9ieXRlc19vZl9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoY29udGVudC50b1N0cmluZygpKSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoYnl0ZXMpO1xuICB9XG4gIGVsc2UgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogcmVnaXN0ZXJpbmcgZmlsZSB3aXRoIGludmFsaWQgY29udGVudCB0eXBlXCIpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZ2V0XG5mdW5jdGlvbiBNbEZha2VGaWxlKGNvbnRlbnQpe1xuICB0aGlzLmRhdGEgPSBjb250ZW50O1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuTWxGYWtlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB2YXIgb2xkID0gdGhpcy5kYXRhO1xuICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gIGNhbWxfYmxpdF9ieXRlcyhvbGQsIDAsIHRoaXMuZGF0YSwgMCwgbGVuKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICB2YXIgbmV3X3N0ciA9IGNhbWxfY3JlYXRlX2J5dGVzKG9mZnNldCArIGxlbik7XG4gICAgdmFyIG9sZF9kYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IG5ld19zdHI7XG4gICAgY2FtbF9ibGl0X2J5dGVzKG9sZF9kYXRhLCAwLCB0aGlzLmRhdGEsIDAsIGNsZW4pO1xuICB9XG4gIGNhbWxfYmxpdF9zdHJpbmcoYnVmLCBwb3MsIHRoaXMuZGF0YSwgb2Zmc2V0LCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgY2FtbF9ibGl0X2J5dGVzKHRoaXMuZGF0YSwgb2Zmc2V0LCBidWYsIHBvcywgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWRfb25lID0gZnVuY3Rpb24ob2Zmc2V0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZ2V0KHRoaXMuZGF0YSwgb2Zmc2V0KTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcblxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VGaWxlXG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MudmVyc2lvbnMgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5wbGF0Zm9ybSAhPT0gXCJicm93c2VyXCIpXG59XG5cblxuLy9Qcm92aWRlczogTWxOb2RlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbE5vZGVGaWxlLCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKHJvb3QpIHtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnJlYWRkaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzRGlyZWN0b3J5KCk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHZhciBiID0gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gYlxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICB2YXIgY29uc3RzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGtleSBpbiBmKXtcbiAgICBzd2l0Y2goa2V5KXtcbiAgICBjYXNlIFwicmRvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1JET05MWTsgYnJlYWs7XG4gICAgY2FzZSBcIndyb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19XUk9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJhcHBlbmRcIiAgOlxuICAgICAgcmVzIHw9IGNvbnN0cy5PX1dST05MWSB8IGNvbnN0cy5PX0FQUEVORDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjcmVhdGVcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0NSRUFUOyAgICBicmVhaztcbiAgICBjYXNlIFwidHJ1bmNhdGVcIiA6IHJlcyB8PSBjb25zdHMuT19UUlVOQzsgICAgYnJlYWs7XG4gICAgY2FzZSBcImV4Y2xcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fRVhDTDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiaW5hcnlcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0JJTkFSWTsgICBicmVhaztcbiAgICBjYXNlIFwidGV4dFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19URVhUOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vbmJsb2NrXCIgOiByZXMgfD0gY29uc3RzLk9fTk9OQkxPQ0s7IGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgICByZXR1cm4gbmV3IE1sTm9kZUZpbGUoZmQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihvLG4pIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZSwgY2FtbF9hcnJheV9vZl9zdHJpbmcsIGNhbWxfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfYnl0ZXNfc2V0LCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxOb2RlRmlsZShmZCl7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLmZkID0gZmQ7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmZ0cnVuY2F0ZVN5bmModGhpcy5mZCxsZW58MClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpLnNpemU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gam9vX2dsb2JhbF9vYmplY3QuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy53cml0ZVN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX2J5dGVzKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBjYW1sX2J5dGVzX3NldChidWYsYnVmX29mZnNldCArIGksYnVmZmVyW2J1Zl9vZmZzZXQraV0pO1xuICB9XG4gIHJldHVybiAwXG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoMSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgMCwgMSwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBidWZmZXJbMF07XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5jbG9zZVN5bmModGhpcy5mZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZpbGU7XG4iLCIvL1Byb3ZpZGVzOiBpbml0aWFsaXplX25hdFxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBzZXJpYWxpemVfbmF0LCBkZXNlcmlhbGl6ZV9uYXQsIGNhbWxfaGFzaF9uYXRcbmZ1bmN0aW9uIGluaXRpYWxpemVfbmF0KCkge1xuICBjYW1sX2N1c3RvbV9vcHNbXCJfbmF0XCJdID1cbiAgICB7IGRlc2VyaWFsaXplIDogZGVzZXJpYWxpemVfbmF0LFxuICAgICAgc2VyaWFsaXplIDogc2VyaWFsaXplX25hdCxcbiAgICAgIGhhc2ggOiBjYW1sX2hhc2hfbmF0XG4gICAgfVxufVxuXG4vL1Byb3ZpZGVzOiBNbE5hdFxuZnVuY3Rpb24gTWxOYXQoeCl7XG4gIHRoaXMuZGF0YSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KHgpO1xuICAvLyBsZW5ndGhfbmF0IGlzbid0IGV4dGVybmFsLCBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhlIE9iai5zaXplXG4gIC8vIHdvcmsgb3V0IHJpZ2h0LiBUaGUgKzIgdG8gYXJyYXkgbGVuZ3RoIHNlZW1zIHRvIHdvcmsuXG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCArIDJcbn1cblxuTWxOYXQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfbmF0XCI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX25hdCh4KSB7XG4gIHZhciBsZW4gPSBudW1fZGlnaXRzX25hdCh4LCAwLCB4LmRhdGEubGVuZ3RoKTtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHguZGF0YVtpXSk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cblxuLy9Qcm92aWRlczogbmF0X29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gbmF0X29mX2FycmF5KGwpe1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBhcnIuZGF0YVtpXSA9IC0xO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vUHJvdmlkZXM6IHNldF90b196ZXJvX25hdFxuZnVuY3Rpb24gc2V0X3RvX3plcm9fbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmxpdF9uYXRcbmZ1bmN0aW9uIGJsaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IG5hdDIuZGF0YVtvZnMyK2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZihuYXQuZGF0YVtvZnMraV0gIT0gMCkgcmV0dXJuIGkrMTtcbiAgfVxuICByZXR1cm4gMTsgLy8gMCBjb3VudHMgYXMgMSBkaWdpdFxufVxuXG4vL1Byb3ZpZGVzOiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXRcbmZ1bmN0aW9uIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQsIG9mcykge1xuICB2YXIgYSA9IG5hdC5kYXRhW29mc107XG4gIHZhciBiID0gMDtcbiAgaWYoYSAmIDB4RkZGRjAwMDApIHsgYiArPTE2OyBhID4+Pj0xNjsgfVxuICBpZihhICYgMHhGRjAwKSAgICAgeyBiICs9IDg7IGEgPj4+PSA4OyB9XG4gIGlmKGEgJiAweEYwKSAgICAgICB7IGIgKz0gNDsgYSA+Pj49IDQ7IH1cbiAgaWYoYSAmIDEyKSAgICAgICAgIHsgYiArPSAyOyBhID4+Pj0gMjsgfVxuICBpZihhICYgMikgICAgICAgICAgeyBiICs9IDE7IGEgPj4+PSAxOyB9XG4gIGlmKGEgJiAxKSAgICAgICAgICB7IGIgKz0gMTsgfVxuICByZXR1cm4gMzIgLSBiO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9pbnRcbmZ1bmN0aW9uIGlzX2RpZ2l0X2ludChuYXQsIG9mcykge1xuICBpZiAobmF0LmRhdGFbb2ZzXSA+PSAwKSByZXR1cm4gMVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfemVyb1xuZnVuY3Rpb24gaXNfZGlnaXRfemVybyhuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdID09IDApIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfb2RkXG5mdW5jdGlvbiBpc19kaWdpdF9vZGQobmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSAmIDEpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGluY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKHggfCAwKTtcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IGFkZF9uYXRcbi8vUmVxdWlyZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geFxuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBjYXJyeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBsZW1lbnRfbmF0XG5mdW5jdGlvbiBjb21wbGVtZW50X25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICgtMSA+Pj4gMCkgLSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKTtcbiAgfVxufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy9Qcm92aWRlczogZGVjcl9uYXRcbmZ1bmN0aW9uIGRlY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PjApIC0gYm9ycm93O1xuICAgIG5hdC5kYXRhW29mcytpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGJvcnJvdyA9PSAxKSA/IDAgOiAxO1xufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBzdWJfbmF0XG4vL1JlcXVpcmVzOiBkZWNyX25hdFxuZnVuY3Rpb24gc3ViX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgLSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIChib3Jyb3c9PTEpPzA6MSk7XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNbb2ZzM11cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogbXVsdF9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGFkZF9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMykge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgYSA9IChuYXQzLmRhdGFbb2ZzM10gPj4+IDApO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHgxID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSAmIDB4MDAwMEZGRkYpICsgY2Fycnk7XG4gICAgdmFyIHgyID0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhID4+PiAxNik7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHgyLzY1NTM2KTtcbiAgICB2YXIgeDMgPSB4MSArICh4MiAlIDY1NTM2KSAqIDY1NTM2O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDM7XG4gICAgY2FycnkgKz0gTWF0aC5mbG9vcih4My80Mjk0OTY3Mjk2KTtcbiAgfVxuXG4gIGlmKGxlbjIgPCBsZW4xICYmIGNhcnJ5KSB7XG4gICAgcmV0dXJuIGFkZF9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIG5hdF9vZl9hcnJheShbY2FycnldKSwgMCwgMSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNcbi8vIGxlbjEgPj0gbGVuMiArIGxlbjMuXG4vL1Byb3ZpZGVzOiBtdWx0X25hdFxuLy9SZXF1aXJlczogbXVsdF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMsIGxlbjMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjM7IGkrKykge1xuICAgIGNhcnJ5ICs9IG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEraSwgbGVuMS1pLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzK2kpO1xuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbmF0MSA9IDIgKiBuYXQxICsgbmF0MiAqIG5hdDJcbi8vIGxlbjEgPj0gMiAqIGxlbjJcbi8vUHJvdmlkZXM6IHNxdWFyZV9uYXRcbi8vUmVxdWlyZXM6IG11bHRfbmF0LCBhZGRfbmF0XG5mdW5jdGlvbiBzcXVhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgY2FycnkgKz0gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQxLCBvZnMxLCBsZW4xLCAwKTtcbiAgY2FycnkgKz0gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMik7XG4gIHJldHVybiBjYXJyeTtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X2xlZnRfbmF0XG5mdW5jdGlvbiBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICB2YXIgYSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA8PCBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhID4+PiAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIEFzc3VtaW5nIGMgPiBhLCByZXR1cm5zIFtxdW90aWVudCwgcmVtYWluZGVyXSBvZiAoYTw8MzIgKyBiKS9jXG4vL1Byb3ZpZGVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfaGVscGVyKGEsIGIsIGMpIHtcbiAgdmFyIHggPSBhICogNjU1MzYgKyAoYj4+PjE2KTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHgvYykgKiA2NTUzNjtcbiAgdmFyIHogPSAoeCAlIGMpICogNjU1MzY7XG4gIHZhciB3ID0geiArIChiICYgMHgwMDAwRkZGRik7XG4gIHJldHVybiBbeSArIE1hdGguZmxvb3Iody9jKSwgdyAlIGNdO1xufVxuXG4vLyBuYXQxW29mczErbGVuXSA8IG5hdDJbb2ZzMl1cbi8vUHJvdmlkZXM6IGRpdl9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9kaWdpdF9uYXQobmF0cSwgb2ZzcSwgbmF0ciwgb2ZzciwgbmF0MSwgb2ZzMSwgbGVuLCBuYXQyLCBvZnMyKSB7XG4gIHZhciByZW0gPSAobmF0MS5kYXRhW29mczErbGVuLTFdID4+PjApO1xuICAvLyBuYXRxW29mc3ErbGVuLTFdIGlzIGd1YXJhbnRlZWQgdG8gYmUgemVybyAoZHVlIHRvIHRoZSBNU0QgcmVxdWlyZW1lbnQpLFxuICAvLyBhbmQgc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvLlxuICBmb3IodmFyIGkgPSBsZW4tMjsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgeCA9IGRpdl9oZWxwZXIocmVtLCAobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0Mi5kYXRhW29mczJdID4+PiAwKSk7XG4gICAgbmF0cS5kYXRhW29mc3EraV0gPSB4WzBdO1xuICAgIHJlbSA9IHhbMV07XG4gIH1cbiAgbmF0ci5kYXRhW29mc3JdID0gcmVtO1xuICByZXR1cm4gMDtcbn1cblxuLy8gbmF0MVtuYXQyOl0gOj0gbmF0MSAvIG5hdDJcbi8vIG5hdDFbOm5hdDJdIDo9IG5hdDEgJSBuYXQyXG4vLyBsZW4xID4gbGVuMiwgbmF0MltvZnMyK2xlbjItMV0gPiBuYXQxW29mczErbGVuMS0xXVxuLy9Qcm92aWRlczogZGl2X25hdFxuLy9SZXF1aXJlczogZGl2X2RpZ2l0X25hdCwgZGl2X2hlbHBlciwgbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0LCBzaGlmdF9sZWZ0X25hdCwgc2hpZnRfcmlnaHRfbmF0LCBjcmVhdGVfbmF0LCBzZXRfdG9femVyb19uYXQsIG11bHRfZGlnaXRfbmF0LCBzdWJfbmF0LCBjb21wYXJlX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBkaXZfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgaWYobGVuMiA9PSAxKSB7XG4gICAgZGl2X2RpZ2l0X25hdChuYXQxLCBvZnMxKzEsIG5hdDEsIG9mczEsIG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHMgPSBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0Miwgb2ZzMitsZW4yLTEpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcblxuICB2YXIgZCA9IChuYXQyLmRhdGFbb2ZzMitsZW4yLTFdID4+PiAwKSArIDE7XG4gIHZhciBhID0gY3JlYXRlX25hdChsZW4yKzEpO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gbGVuMjsgaS0tKSB7XG4gICAgLy8gRGVjZW50IGxvd2VyIGJvdW5kIG9uIHF1b1xuICAgIHZhciBxdW8gPSBkID09IDQyOTQ5NjcyOTYgPyAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDogZGl2X2hlbHBlcigobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0MS5kYXRhW29mczEraS0xXSA+Pj4wKSwgZClbMF07XG4gICAgc2V0X3RvX3plcm9fbmF0KGEsIDAsIGxlbjIrMSk7XG4gICAgbXVsdF9kaWdpdF9uYXQoYSwgMCwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoW3F1b10pLCAwKTtcbiAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIGEsIDAsIGxlbjIrMSwgMSk7XG5cbiAgICB3aGlsZSAobmF0MS5kYXRhW29mczEraV0gIT0gMCB8fCBjb21wYXJlX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMikgPj0gMCkge1xuICAgICAgcXVvID0gcXVvICsgMTtcbiAgICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgMSk7XG4gICAgfVxuXG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBxdW87XG4gIH1cblxuICBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyBzaGlmdCByZW1haW5kZXJcbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gcmVzdG9yZVxuICByZXR1cm4gMDtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X3JpZ2h0X25hdFxuZnVuY3Rpb24gc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gbGVuMS0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gbmF0MS5kYXRhW29mczEraV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA+Pj4gbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA8PCAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgaWYobmF0MS5kYXRhW29mczFdID4gbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gMTtcbiAgaWYobmF0MS5kYXRhW29mczFdIDwgbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdFxuLy9SZXF1aXJlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGEgPSBudW1fZGlnaXRzX25hdChuYXQxLCBvZnMxLCBsZW4xKTtcbiAgdmFyIGIgPSBudW1fZGlnaXRzX25hdChuYXQyLCBvZnMyLCBsZW4yKTtcbiAgaWYoYSA+IGIpIHJldHVybiAxO1xuICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICBmb3IodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA+IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAxO1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDwgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdF9yZWFsXG4vL1JlcXVpcmVzOiBjb21wYXJlX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXRfcmVhbChuYXQxLG5hdDIpe1xuICByZXR1cm4gY29tcGFyZV9uYXQobmF0MSwwLG5hdDEuZGF0YS5sZW5ndGgsbmF0MiwwLG5hdDIuZGF0YS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBsYW5kX2RpZ2l0X25hdFxuZnVuY3Rpb24gbGFuZF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gJj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSB8PSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBseG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbHhvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gXj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBzZXJpYWxpemVfbmF0XG5mdW5jdGlvbiBzZXJpYWxpemVfbmF0KHdyaXRlciwgbmF0LCBzeil7XG4gIHZhciBsZW4gPSBuYXQuZGF0YS5sZW5ndGg7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICB3cml0ZXIud3JpdGUoMzIsIG5hdC5kYXRhW2ldKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHN6WzFdID0gbGVuICogODtcbn1cblxuLy9Qcm92aWRlczogZGVzZXJpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gZGVzZXJpYWxpemVfbmF0KHJlYWRlciwgc3ope1xuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIG5hdCA9IG5ldyBNbE5hdChsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIG5hdC5kYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHJldHVybiBuYXQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSHVnbyBIZXV6YXJkXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlXG52YXIgY2FtbF9ncl9zdGF0ZTtcblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfZ2V0KCkge1xuICBpZihjYW1sX2dyX3N0YXRlKSB7XG4gICAgcmV0dXJuIGNhbWxfZ3Jfc3RhdGU7XG4gIH1cbiAgdGhyb3cgWzAsY2FtbF9uYW1lZF92YWx1ZShcIkdyYXBoaWNzLkdyYXBoaWNfZmFpbHVyZVwiKSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIk5vdCBpbml0aWFsaXplZFwiKV1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlLGNhbWxfZ3Jfc3RhdGVfaW5pdFxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KSB7XG4gIGNhbWxfZ3Jfc3RhdGU9Y3R4O1xuICBjYW1sX2dyX3N0YXRlX2luaXQoKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fZ3JhcGgoaW5mbyl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBpbmZvID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoaW5mbyk7XG4gIGZ1bmN0aW9uIGdldChuYW1lKXtcbiAgICB2YXIgcmVzID0gaW5mby5tYXRjaChcIihefCwpICpcIituYW1lK1wiICo9ICooW2EtekEtWjAtOV9dKykgKigsfCQpXCIpO1xuICAgIGlmKHJlcykgcmV0dXJuIHJlc1syXTtcbiAgfVxuICB2YXIgc3BlY3MgPSBbXTtcbiAgaWYoIShpbmZvPT1cIlwiKSkgc3BlY3MucHVzaChpbmZvKTtcbiAgdmFyIHRhcmdldCA9IGdldChcInRhcmdldFwiKTtcbiAgaWYoIXRhcmdldCkgdGFyZ2V0PVwiXCI7XG4gIHZhciBzdGF0dXMgPSBnZXQoXCJzdGF0dXNcIik7XG4gIGlmKCFzdGF0dXMpIHNwZWNzLnB1c2goXCJzdGF0dXM9MVwiKVxuXG4gIHZhciB3ID0gZ2V0KFwid2lkdGhcIik7XG4gIHcgPSB3P3BhcnNlSW50KHcpOjIwMDtcbiAgc3BlY3MucHVzaChcIndpZHRoPVwiK3cpO1xuXG4gIHZhciBoID0gZ2V0KFwiaGVpZ2h0XCIpO1xuICBoID0gaD9wYXJzZUludChoKToyMDA7XG4gIHNwZWNzLnB1c2goXCJoZWlnaHQ9XCIraCk7XG5cbiAgdmFyIHdpbiA9IGcub3BlbihcImFib3V0OmJsYW5rXCIsdGFyZ2V0LHNwZWNzLmpvaW4oXCIsXCIpKTtcbiAgaWYoIXdpbikge2NhbWxfZmFpbHdpdGgoXCJHcmFwaGljcy5vcGVuX2dyYXBoOiBjYW5ub3Qgb3BlbiB0aGUgd2luZG93XCIpfVxuICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICB2YXIgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB2YXIgY3R4ID0gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCk7XG4gIGN0eC5zZXRfdGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICBkb2MudGl0bGUgPSB0aXRsZTtcbiAgfTtcbiAgY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgYm9keS5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yLGNhbWxfZ3JfbW92ZXRvLGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aCxjYW1sX2dyX3NldF90ZXh0X3NpemUsY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2luaXQoKXtcbiAgY2FtbF9ncl9tb3ZldG8oY2FtbF9ncl9zdGF0ZS54LGNhbWxfZ3Jfc3RhdGUueSk7XG4gIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyhjYW1sX2dyX3N0YXRlLndpZHRoLGNhbWxfZ3Jfc3RhdGUuaGVpZ2h0KTtcbiAgY2FtbF9ncl9zZXRfbGluZV93aWR0aChjYW1sX2dyX3N0YXRlLmxpbmVfd2lkdGgpO1xuICBjYW1sX2dyX3NldF90ZXh0X3NpemUoY2FtbF9ncl9zdGF0ZS50ZXh0X3NpemUpO1xuICBjYW1sX2dyX3NldF9mb250KGNhbWxfZ3Jfc3RhdGUuZm9udCk7XG4gIGNhbWxfZ3Jfc2V0X2NvbG9yKGNhbWxfZ3Jfc3RhdGUuY29sb3IpO1xuICBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUoY2FtbF9ncl9zdGF0ZS50aXRsZSk7XG4gIC8vY2FtbF9ncl9yZXNpemVfd2luZG93IG1pZ2h0IHJlc2V0IHNvbWUgY2FudmFzJyBwcm9wZXJ0aWVzXG4gIGNhbWxfZ3Jfc3RhdGUuY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpe1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHJldHVybiB7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBjYW52YXMgOiBjYW52YXMsXG4gICAgeCA6IDAsXG4gICAgeSA6IDAsXG4gICAgd2lkdGggOiB3LFxuICAgIGhlaWdodCA6IGgsXG4gICAgbGluZV93aWR0aCA6IDEsXG4gICAgZm9udCA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJmaXhlZFwiKSxcbiAgICB0ZXh0X3NpemUgOiAyNixcbiAgICBjb2xvciA6IDB4MDAwMDAwLFxuICAgIHRpdGxlIDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKVxuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RvY19vZl9zdGF0ZVxuZnVuY3Rpb24gY2FtbF9ncl9kb2Nfb2Zfc3RhdGUoc3RhdGUpIHtcbiAgaWYoc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQpXG4gICAgcmV0dXJuIHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gMDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUobmFtZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50aXRsZSA9IG5hbWU7XG4gIHZhciBqc25hbWUgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYocy5zZXRfdGl0bGUpIHMuc2V0X3RpdGxlKGpzbmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3codyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpXG4gIHMud2lkdGggPSB3O1xuICBzLmhlaWdodCA9IGg7XG4gIHMuY2FudmFzLndpZHRoID0gdztcbiAgcy5jYW52YXMuaGVpZ2h0ID0gaDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xlYXJfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NsZWFyX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSBzLndpZHRoO1xuICBzLmNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgLy8gIHMuY29udGV4dC5zdHJva2VSZWN0ICgwLiwgMC4sIHMud2lkdGgsIHMuaGVpZ2h0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy53aWR0aDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5oZWlnaHQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9jb2xvcihjb2xvcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgZnVuY3Rpb24gY29udmVydChudW1iZXIpIHtcbiAgICB2YXIgc3RyID0gJycgKyBudW1iZXIudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgMikgc3RyID0gJzAnICsgc3RyO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyXG4gIHIgPSAoY29sb3IgPj4gMTYpICYgMHhmZixcbiAgZyA9IChjb2xvciA+PiA4KSAgJiAweGZmLFxuICBiID0gKGNvbG9yID4+IDApICAmIDB4ZmY7XG4gIHMuY29sb3I9Y29sb3I7XG4gIHZhciBjX3N0ciA9ICcjJyArIGNvbnZlcnQocikgKyBjb252ZXJ0KGcpICsgY29udmVydChiKTtcbiAgcy5jb250ZXh0LmZpbGxTdHlsZSA9ICAgY19zdHI7XG4gIHMuY29udGV4dC5zdHJva2VTdHlsZSA9IGNfc3RyO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcGxvdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcGxvdCh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgdmFyIGNvbG9yID0gcy5jb2xvcjtcbiAgZFswXSA9IChjb2xvciA+PiAxNikgJiAweGZmOyAvL3JcbiAgZFsxXSA9IChjb2xvciA+PiA4KSAgJiAweGZmLCAvL2dcbiAgZFsyXSA9IChjb2xvciA+PiAwKSAgJiAweGZmOyAvL2JcbiAgZFszXSA9IDB4RkY7IC8vYVxuICBzLng9eDtcbiAgcy55PXk7XG4gIHMuY29udGV4dC5wdXRJbWFnZURhdGEoaW0seCxzLmhlaWdodCAtIHkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9wb2ludF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcG9pbnRfY29sb3IoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0geSwxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHJldHVybiAoZFswXSA8PCAxNikgKyAoZFsxXSA8PCA4KSArIGRbMl07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21vdmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbW92ZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnhcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy55XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2xpbmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbGluZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMuY29udGV4dC5saW5lVG8oeCxzLmhlaWdodCAtIHkpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5zdHJva2VSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2FyY19hdXgoY3R4LGN4LGN5LHJ5LHJ4LGExLGEyKXtcbiAgd2hpbGUoYTE+YTIpIGEyKz0zNjA7XG4gIGExIC89IDE4MDtcbiAgYTIgLz0gMTgwO1xuICB2YXIgcm90ID0gMCx4UG9zLHlQb3MseFBvc19wcmV2LHlQb3NfcHJldjtcbiAgdmFyIHNwYWNlID0gMjtcbiAgdmFyIG51bSA9ICgoKGEyIC0gYTEpICogTWF0aC5QSSAqICgocngrcnkpLzIpKSAvIHNwYWNlKSB8IDA7XG4gIHZhciBkZWx0YSA9IChhMiAtIGExKSAqIE1hdGguUEkgLyBudW07XG4gIHZhciBpID0gYTEgKiBNYXRoLlBJO1xuICBmb3IgKHZhciBqPTA7ajw9bnVtO2orKyl7XG4gICAgeFBvcyA9IGN4IC0gKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB4UG9zID0geFBvcy50b0ZpeGVkKDIpO1xuICAgIHlQb3MgPSBjeSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeVBvcyA9IHlQb3MudG9GaXhlZCgyKTtcbiAgICBpZiAoaj09MCkge1xuICAgICAgY3R4Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9IGVsc2UgaWYgKHhQb3NfcHJldiE9eFBvcyB8fCB5UG9zX3ByZXYhPXlQb3Mpe1xuICAgICAgY3R4LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9XG4gICAgeFBvc19wcmV2PXhQb3M7XG4gICAgeVBvc19wcmV2PXlQb3M7XG4gICAgaS09IGRlbHRhOy8vY2N3XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9saW5lX3dpZHRoKHcpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMubGluZV93aWR0aCA9IHc7XG4gIHMuY29udGV4dC5saW5lV2lkdGggPSB3XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5maWxsUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcG9seVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9wb2x5KGFyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIGZvcih2YXIgaSA9IDI7IGkgPCBhci5sZW5ndGg7IGkrKylcbiAgICBzLmNvbnRleHQubGluZVRvKGFyW2ldWzFdLHMuaGVpZ2h0IC0gYXJbaV1bMl0pO1xuICBzLmNvbnRleHQubGluZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cihzdHIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBtID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHN0cik7XG4gIHZhciBkeCA9IG0ud2lkdGg7XG4gIHMuY29udGV4dC5maWxsVGV4dChzdHIscy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy54ICs9IGR4IHwgMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfY2hhcihjKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyaW5nKHN0cil7XG4gIGNhbWxfZ3JfZHJhd19zdHIoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoc3RyKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2ZvbnQoZil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5mb250ID0gZjtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShzaXplKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRleHRfc2l6ZSA9IHNpemU7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfdGV4dF9zaXplKHR4dCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIHcgPSBzLmNvbnRleHQubWVhc3VyZVRleHQoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcodHh0KSkud2lkdGg7XG4gIHJldHVybiBbMCx3LHMudGV4dF9zaXplXTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21ha2VfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21ha2VfaW1hZ2UoYXJyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaCA9IGFyci5sZW5ndGggLSAxIDtcbiAgdmFyIHcgPSBhcnJbMV0ubGVuZ3RoIC0gMTtcbiAgdmFyIGltID0gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3LGgpO1xuICBmb3IodmFyIGk9MDtpPGg7aSsrKXtcbiAgICBmb3IodmFyIGo9MDtqPHc7aisrKXtcbiAgICAgIHZhciBjID0gYXJyW2krMV1baisxXTtcbiAgICAgIHZhciBvID0gaSoodyo0KSArIChqICogNCk7XG4gICAgICBpZihjID09IC0xKSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gYyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gYyA+PiAgOCAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gYyA+PiAgMCAmIDBYZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMHhmZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGltXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2R1bXBfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2R1bXBfaW1hZ2UoaW0pe1xuICB2YXIgZGF0YSA9IFswXVxuICBmb3IodmFyIGk9MDsgaTxpbS5oZWlnaHQ7aSsrKXtcbiAgICBkYXRhW2krMV0gPSBbMF1cbiAgICBmb3IodmFyIGo9MDsgajxpbS53aWR0aDtqKyspe1xuICAgICAgdmFyIG8gPSBpKihpbS53aWR0aCo0KSArIChqICogNCksXG4gICAgICAgICAgciA9IGltLmRhdGFbbyswXSxcbiAgICAgICAgICBnID0gaW0uZGF0YVtvKzFdLFxuICAgICAgICAgIGIgPSBpbS5kYXRhW28rMl07XG4gICAgICBkYXRhW2krMV1baisxXSA9IChyIDw8IDE2KSArIChnIDw8IDgpICsgYlxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgaWYoIWltLmltYWdlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5wdXRJbWFnZURhdGEoaW0sMCwwKTtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgICAgIGltLmltYWdlID0gaW1hZ2U7XG4gICAgfVxuICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gIH0gZWxzZSB7XG4gICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbS5pbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NyZWF0ZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3JlYXRlX2ltYWdlKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoeCx5KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYmxpdF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfYmxpdF9pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbTIgPSBzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5LGltLndpZHRoLGltLmhlaWdodCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW0yLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICBpbS5kYXRhW2ldID0gaW0yLmRhdGFbaV07XG4gICAgaW0uZGF0YVtpKzFdID0gaW0yLmRhdGFbaSsxXTtcbiAgICBpbS5kYXRhW2krMl0gPSBpbTIuZGF0YVtpKzJdO1xuICAgIGltLmRhdGFbaSszXSA9IGltMi5kYXRhW2krM107XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXJcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9faGFuZGxlcigpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19zaWduYWxcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9fc2lnbmFsKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dhaXRfZXZlbnRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2FpdF9ldmVudChfZXZsKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2FpdF9ldmVudCBub3QgSW1wbGVtZW50ZWQ6IHVzZSBHcmFwaGljc19qcyBpbnN0ZWFkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N5bmNocm9uaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3N5bmNocm9uaXplICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfc3luY2hyb25pemUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9yZW1lbWJlcl9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3JlbWVtYmVyX21vZGUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZGlzcGxheV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Rpc3BsYXlfbW9kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfZGlzcGxheV9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl93aW5kb3dfaWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2luZG93X2lkKGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2luZG93X2lkIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX3N1YndpbmRvdyhhLGIsYyxkKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX29wZW5fc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93KGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfY29uc3RhbnRzXG52YXIgY2FtbF9tYXJzaGFsX2NvbnN0YW50cyA9IHtcbiAgUFJFRklYX1NNQUxMX0JMT0NLOiAgICAgICAgIDB4ODAsXG4gIFBSRUZJWF9TTUFMTF9JTlQ6ICAgICAgICAgICAweDQwLFxuICBQUkVGSVhfU01BTExfU1RSSU5HOiAgICAgICAgMHgyMCxcbiAgQ09ERV9JTlQ4OiAgICAgICAgICAgICAgICAgIDB4MDAsXG4gIENPREVfSU5UMTY6ICAgICAgICAgICAgICAgICAweDAxLFxuICBDT0RFX0lOVDMyOiAgICAgICAgICAgICAgICAgMHgwMixcbiAgQ09ERV9JTlQ2NDogICAgICAgICAgICAgICAgIDB4MDMsXG4gIENPREVfU0hBUkVEODogICAgICAgICAgICAgICAweDA0LFxuICBDT0RFX1NIQVJFRDE2OiAgICAgICAgICAgICAgMHgwNSxcbiAgQ09ERV9TSEFSRUQzMjogICAgICAgICAgICAgIDB4MDYsXG4gIENPREVfQkxPQ0szMjogICAgICAgICAgICAgICAweDA4LFxuICBDT0RFX0JMT0NLNjQ6ICAgICAgICAgICAgICAgMHgxMyxcbiAgQ09ERV9TVFJJTkc4OiAgICAgICAgICAgICAgIDB4MDksXG4gIENPREVfU1RSSU5HMzI6ICAgICAgICAgICAgICAweDBBLFxuICBDT0RFX0RPVUJMRV9CSUc6ICAgICAgICAgICAgMHgwQixcbiAgQ09ERV9ET1VCTEVfTElUVExFOiAgICAgICAgIDB4MEMsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9CSUc6ICAgICAweDBELFxuICBDT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOiAgMHgwRSxcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6ICAgIDB4MEYsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOiAweDA3LFxuICBDT0RFX0NPREVQT0lOVEVSOiAgICAgICAgICAgMHgxMCxcbiAgQ09ERV9JTkZJWFBPSU5URVI6ICAgICAgICAgIDB4MTEsXG4gIENPREVfQ1VTVE9NOiAgICAgICAgICAgICAgICAweDEyLFxuICBDT0RFX0NVU1RPTV9MRU46ICAgICAgICAgICAgMHgxOCxcbiAgQ09ERV9DVVNUT01fRklYRUQ6ICAgICAgICAgIDB4MTlcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbFN0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gTWxTdHJpbmdSZWFkZXIgKHMsIGkpIHsgdGhpcy5zID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTsgdGhpcy5pID0gaTsgfVxuTWxTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQgPj4gMTYpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMykpID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucy5zdWJzdHJpbmcoaSwgaSArIGxlbikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IEJpZ1N0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIEJpZ1N0cmluZ1JlYWRlciAoYnMsIGkpIHsgdGhpcy5zID0gYnM7IHRoaXMuaSA9IGk7IH1cbkJpZ1N0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDgpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCAyNCA+PiAxNikgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKSAgICAgICAgICkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBsZW47IGorKyl7XG4gICAgICBhcnJbal0gPSBjYW1sX2JhX2dldF8xKHRoaXMucywgaStqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgfVxufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX2J5dGVzIChhKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKGNhbWxfaW50NjRfb2ZfYnl0ZXMgKGEpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChzLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIgKGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICBzaXplWzBdID0gODtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMgKHQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbWFyc2hhbCh3cml0ZXIsIHYsIHNpemVzKSB7XG4gIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyAodik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB3cml0ZXIud3JpdGUgKDgsIGJbaV0pO1xuICBzaXplc1swXSA9IDg7IHNpemVzWzFdID0gODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl91bm1hcnNoYWxcbmZ1bmN0aW9uIGNhbWxfaW50MzJfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHNpemVbMF0gPSA0O1xuICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHN3aXRjaCAocmVhZGVyLnJlYWQ4dSAoKSkge1xuICBjYXNlIDE6XG4gICAgc2l6ZVswXSA9IDQ7XG4gICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICBjYXNlIDI6XG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBuYXRpdmUgaW50ZWdlciB2YWx1ZSB0b28gbGFyZ2VcIik7XG4gIGRlZmF1bHQ6IGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBuYXRpdmUgaW50ZWdlclwiKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsLCBjYW1sX2ludDY0X21hcnNoYWwsIGNhbWxfaW50NjRfY29tcGFyZSwgY2FtbF9pbnQ2NF9oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX3VubWFyc2hhbCwgY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NlcmlhbGl6ZSwgY2FtbF9iYV9kZXNlcmlhbGl6ZSwgY2FtbF9iYV9jb21wYXJlLCBjYW1sX2JhX2hhc2hcbnZhciBjYW1sX2N1c3RvbV9vcHMgPVxuICAgIHtcIl9qXCI6IHtcbiAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQ2NF91bm1hcnNoYWwsXG4gICAgICBzZXJpYWxpemUgIDogY2FtbF9pbnQ2NF9tYXJzaGFsLFxuICAgICAgZml4ZWRfbGVuZ3RoIDogOCxcbiAgICAgIGNvbXBhcmUgOiBjYW1sX2ludDY0X2NvbXBhcmUsXG4gICAgICBoYXNoIDogY2FtbF9pbnQ2NF9oYXNoXG4gICAgfSxcbiAgICAgXCJfaVwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDMyX3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9uXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9iaWdhcnJheVwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IChmdW5jdGlvbiAocmVhZGVyLCBzeikge3JldHVybiBjYW1sX2JhX2Rlc2VyaWFsaXplIChyZWFkZXIsc3osXCJfYmlnYXJyYXlcIil9KSxcbiAgICAgICBzZXJpYWxpemUgOiBjYW1sX2JhX3NlcmlhbGl6ZSxcbiAgICAgICBjb21wYXJlIDogY2FtbF9iYV9jb21wYXJlLFxuICAgICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyMDJcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycjAyXCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH1cbiAgICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9mbG9hdF9vZl9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG5cbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpIHtcbiAgdmFyIF9tYWdpYyA9IHJlYWRlci5yZWFkMzJ1ICgpXG4gIHZhciBfYmxvY2tfbGVuID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBudW1fb2JqZWN0cyA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgX3NpemVfMzIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzY0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgaW50ZXJuX29ial90YWJsZSA9IChudW1fb2JqZWN0cyA+IDApP1tdOm51bGw7XG4gIHZhciBvYmpfY291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIGludGVybl9yZWMgKCkge1xuICAgIHZhciBjb2RlID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICBpZiAoY29kZSA+PSAweDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLykge1xuICAgICAgaWYgKGNvZGUgPj0gMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLykge1xuICAgICAgICB2YXIgdGFnID0gY29kZSAmIDB4RjtcbiAgICAgICAgdmFyIHNpemUgPSAoY29kZSA+PiA0KSAmIDB4NztcbiAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIChjb2RlICYgMHgzRik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb2RlID49IDB4MjAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HICovKSB7XG4gICAgICAgIHZhciBsZW4gPSBjb2RlICYgMHgxRjtcbiAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChjb2RlKSB7XG4gICAgICAgIGNhc2UgMHgwMDogLy9jc3QuQ09ERV9JTlQ4OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDhzICgpO1xuICAgICAgICBjYXNlIDB4MDE6IC8vY3N0LkNPREVfSU5UMTY6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMTZzICgpO1xuICAgICAgICBjYXNlIDB4MDI6IC8vY3N0LkNPREVfSU5UMzI6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICAgICAgICBjYXNlIDB4MDM6IC8vY3N0LkNPREVfSU5UNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbnRlZ2VyIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA0OiAvL2NzdC5DT0RFX1NIQVJFRDg6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDU6IC8vY3N0LkNPREVfU0hBUkVEMTY6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMTZ1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA2OiAvL2NzdC5DT0RFX1NIQVJFRDMyOlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwODogLy9jc3QuQ09ERV9CTE9DSzMyOlxuICAgICAgICAgIHZhciBoZWFkZXIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICB2YXIgdGFnID0gaGVhZGVyICYgMHhGRjtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGhlYWRlciA+PiAxMDtcbiAgICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTM6IC8vY3N0LkNPREVfQkxPQ0s2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBkYXRhIGJsb2NrIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA5OiAvL2NzdC5DT0RFX1NUUklORzg6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBBOiAvL2NzdC5DT0RFX1NUUklORzMyOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEM6IC8vY3N0LkNPREVfRE9VQkxFX0xJVFRMRTpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0WzcgLSBpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQjogLy9jc3QuQ09ERV9ET1VCTEVfQklHOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEU6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRDogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDA3OiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRjogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMDogLy9jc3QuQ09ERV9DT0RFUE9JTlRFUjpcbiAgICAgICAgY2FzZSAweDExOiAvL2NzdC5DT0RFX0lORklYUE9JTlRFUjpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBjb2RlIHBvaW50ZXJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMjogLy9jc3QuQ09ERV9DVVNUT006XG4gICAgICAgIGNhc2UgMHgxODogLy9jc3QuQ09ERV9DVVNUT01fTEVOOlxuICAgICAgICBjYXNlIDB4MTk6IC8vY3N0LkNPREVfQ1VTVE9NX0ZJWEVEOlxuICAgICAgICAgIHZhciBjLCBzID0gXCJcIjtcbiAgICAgICAgICB3aGlsZSAoKGMgPSByZWFkZXIucmVhZDh1ICgpKSAhPSAwKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbc107XG4gICAgICAgICAgdmFyIGV4cGVjdGVkX3NpemU7XG4gICAgICAgICAgaWYoIW9wcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdW5rbm93biBjdXN0b20gYmxvY2sgaWRlbnRpZmllclwiKTtcbiAgICAgICAgICBzd2l0Y2goY29kZSl7XG4gICAgICAgICAgY2FzZSAweDEyOiAvLyBjc3QuQ09ERV9DVVNUT00gKGRlcHJlY2F0ZWQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTk6IC8vIGNzdC5DT0RFX0NVU1RPTV9GSVhFRFxuICAgICAgICAgICAgaWYoIW9wcy5maXhlZF9sZW5ndGgpXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogZXhwZWN0ZWQgYSBmaXhlZC1zaXplIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSBvcHMuZml4ZWRfbGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE4OiAvLyBjc3QuQ09ERV9DVVNUT01fTEVOXG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgICAvLyBTa2lwIHNpemU2NFxuICAgICAgICAgICAgcmVhZGVyLnJlYWQzMnMoKTsgcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHJlYWRlci5pO1xuICAgICAgICAgIHZhciBzaXplID0gWzBdO1xuICAgICAgICAgIHZhciB2ID0gb3BzLmRlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSk7XG4gICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSBzaXplWzBdKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGluY29ycmVjdCBsZW5ndGggb2Ygc2VyaWFsaXplZCBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IGludGVybl9yZWMgKCk7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHNpemUgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBkID0gdi5sZW5ndGg7XG4gICAgaWYgKGQgPCBzaXplKSBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgIHZbZF0gPSBpbnRlcm5fcmVjICgpO1xuICB9XG4gIGlmICh0eXBlb2Ygb2ZzIT1cIm51bWJlclwiKSBvZnNbMF0gPSByZWFkZXIuaTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKHMsIG9mcykge1xuICBmdW5jdGlvbiBnZXQzMihzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpKSA8PCAyNCkgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDIpIDw8IDgpIHxcbiAgICAgIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMyk7XG4gIH1cbiAgaWYgKGdldDMyKHMsIG9mcykgIT0gKDB4ODQ5NUE2QkV8MCkpXG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICByZXR1cm4gKGdldDMyKHMsIG9mcyArIDQpKTtcbn1cblxuLy9Qcm92aWRlczogTWxPYmplY3RUYWJsZVxudmFyIE1sT2JqZWN0VGFibGU7XG5pZiAodHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LldlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBwb2x5ZmlsbCAodXNpbmcgbGluZWFyIHNlYXJjaCkgKi9cbiAgICBmdW5jdGlvbiBOYWl2ZUxvb2t1cChvYmpzKSB7IHRoaXMub2JqcyA9IG9ianM7IH1cbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGhlcmUuIFtNbE9iamVjdFRhYmxlLnN0b3JlXSB3aWxsIHB1c2ggdG8gW3RoaXMub2Jqc10gZGlyZWN0bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IE5haXZlTG9va3VwKHRoaXMub2Jqcyk7XG4gICAgfTtcbiAgfSgpO1xufVxuZWxzZSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5XZWFrTWFwKCk7XG4gIH07XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24odikge1xuICB0aGlzLmxvb2t1cC5zZXQodiwgdGhpcy5vYmpzLmxlbmd0aCk7XG4gIHRoaXMub2Jqcy5wdXNoKHYpO1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5yZWNhbGwgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBpID0gdGhpcy5sb29rdXAuZ2V0KHYpO1xuICByZXR1cm4gKGkgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZCA6IHRoaXMub2Jqcy5sZW5ndGggLSBpOyAgIC8qIGluZGV4IGlzIHJlbGF0aXZlICovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246ID49IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IGZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246IDwgNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gdHJ1ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogTWxPYmplY3RUYWJsZSwgY2FtbF9saXN0X3RvX2pzX2FycmF5LCBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xudmFyIGNhbWxfb3V0cHV0X3ZhbCA9IGZ1bmN0aW9uICgpe1xuICBmdW5jdGlvbiBXcml0ZXIgKCkgeyB0aGlzLmNodW5rID0gW107IH1cbiAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua19pZHg6MjAsIGJsb2NrX2xlbjowLCBvYmpfY291bnRlcjowLCBzaXplXzMyOjAsIHNpemVfNjQ6MCxcbiAgICB3cml0ZTpmdW5jdGlvbiAoc2l6ZSwgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2F0OmZ1bmN0aW9uIChwb3MsIHNpemUsIHZhbHVlKSB7XG4gICAgICB2YXIgcG9zID0gcG9zO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbcG9zKytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2NvZGU6ZnVuY3Rpb24gKHNpemUsIGNvZGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gY29kZTtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX3NoYXJlZDpmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0IDwgKDEgPDwgOCkpIHRoaXMud3JpdGVfY29kZSg4LCAweDA0IC8qY3N0LkNPREVfU0hBUkVEOCovLCBvZmZzZXQpO1xuICAgICAgZWxzZSBpZiAob2Zmc2V0IDwgKDEgPDwgMTYpKSB0aGlzLndyaXRlX2NvZGUoMTYsIDB4MDUgLypjc3QuQ09ERV9TSEFSRUQxNiovLCBvZmZzZXQpO1xuICAgICAgZWxzZSB0aGlzLndyaXRlX2NvZGUoMzIsIDB4MDYgLypjc3QuQ09ERV9TSEFSRUQzMiovLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgcG9zOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2h1bmtfaWR4IH0sXG4gICAgZmluYWxpemU6ZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ibG9ja19sZW4gPSB0aGlzLmNodW5rX2lkeCAtIDIwO1xuICAgICAgdGhpcy5jaHVua19pZHggPSAwO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIDB4ODQ5NUE2QkUpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuYmxvY2tfbGVuKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLm9ial9jb3VudGVyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfMzIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV82NCk7XG4gICAgICByZXR1cm4gdGhpcy5jaHVuaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICh2LCBmbGFncykge1xuICAgIGZsYWdzID0gY2FtbF9saXN0X3RvX2pzX2FycmF5KGZsYWdzKTtcblxuICAgIHZhciBub19zaGFyaW5nID0gKGZsYWdzLmluZGV4T2YoMCAvKk1hcnNoYWwuTm9fc2hhcmluZyovKSAhPT0gLTEpLFxuICAgICAgICBjbG9zdXJlcyA9ICAoZmxhZ3MuaW5kZXhPZigxIC8qTWFyc2hhbC5DbG9zdXJlcyovKSAhPT0gLTEpO1xuICAgICAgICAvKiBNYXJzaGFsLkNvbXBhdF8zMiBpcyByZWR1bmRhbnQgc2luY2UgaW50ZWdlcnMgYXJlIDMyLWJpdCBhbnl3YXkgKi9cblxuICAgIGlmIChjbG9zdXJlcylcbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUud2FybihcImluIGNhbWxfb3V0cHV0X3ZhbDogZmxhZyBNYXJzaGFsLkNsb3N1cmVzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIgKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7IHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgeyBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpOyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlcm5fcmVjICh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b207XG4gICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbbmFtZV07XG4gICAgICAgIHZhciBzel8zMl82NCA9IFswLDBdO1xuICAgICAgICBpZighb3BzLnNlcmlhbGl6ZSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChDdXN0b20pXCIpO1xuICAgICAgICBpZihjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxMiAvKmNzdC5DT0RFX0NVU1RPTSovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgIH0gZWxzZSBpZihvcHMuZml4ZWRfbGVuZ3RoID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE4IC8qY3N0LkNPREVfQ1VTVE9NX0xFTiovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBoZWFkZXJfcG9zID0gd3JpdGVyLnBvcyAoKTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zLCAzMiwgc3pfMzJfNjRbMF0pO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgNCwgMzIsIDApOyAvLyB6ZXJvXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA4LCAzMiwgc3pfMzJfNjRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOSAvKmNzdC5DT0RFX0NVU1RPTV9GSVhFRCovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBvbGRfcG9zID0gd3JpdGVyLnBvcygpO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgaWYgKG9wcy5maXhlZF9sZW5ndGggIT0gd3JpdGVyLnBvcygpIC0gb2xkX3BvcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGluY29ycmVjdCBmaXhlZCBzaXplcyBzcGVjaWZpZWQgYnkgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAyICsgKChzel8zMl82NFswXSArIDMpID4+IDIpO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyICsgKChzel8zMl82NFsxXSArIDcpID4+IDMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICAgIGlmICh2WzBdID09IDI1MSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChBYnN0cmFjdClcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSAmJiBtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpPDw0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLywgKCh2Lmxlbmd0aC0xKSA8PCAxMCkgfCB2WzBdKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoICh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgICBpZighKGNhbWxfaXNfbWxfYnl0ZXMoY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKSkpKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogW0J5dGVzLnRdIGNhbm5vdCBzYWZlbHkgYmUgbWFyc2hhbGVkIHdpdGggWy0tZW5hYmxlIHVzZS1qcy1zdHJpbmddXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX2J5dGVzX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT0gKHZ8MCkpe1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuIEl0IHNlZW1zIGJldHRlciB0b1xuICAgICAgICAgIC8vIHN5c3RlbWF0aWNhbGx5IGZhaWwgb24gbWFyc2hhbGxpbmcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgICAgICBpZih0eXBlX29mX3YgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICAvLyAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEIgLypjc3QuQ09ERV9ET1VCTEVfQklHKi8pO1xuICAgICAgICAgIC8vICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8ODsgaSsrKXt3cml0ZXIud3JpdGUoOCx0W2ldKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDBYNDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovICsgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgPj0gLSgxIDw8IDcpICYmIHYgPCAoMSA8PCA3KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgKDEgPDwgMTUpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWMgKHYpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wICgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2ggKHYsIGkgKyAxKTtcbiAgICAgIGV4dGVybl9yZWMgKHZbaV0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgd3JpdGVyLm9ial9jb3VudGVyID0gaW50ZXJuX29ial90YWJsZS5vYmpzLmxlbmd0aDtcbiAgICB3cml0ZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gd3JpdGVyLmNodW5rO1xuICB9XG59ICgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2J5dGVzX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfYmxpdF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIChzLCBvZnMsIGxlbiwgdiwgZmxhZ3MpIHtcbiAgdmFyIHQgPSBjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKTtcbiAgaWYgKHQubGVuZ3RoID4gbGVuKSBjYW1sX2ZhaWx3aXRoIChcIk1hcnNoYWwudG9fYnVmZmVyOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gIGNhbWxfYmxpdF9ieXRlcyh0LCAwLCBzLCBvZnMsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIElvXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Nsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3N5c19jbG9zZShmZCkge1xuICBkZWxldGUgY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfc3RkX291dHB1dChjaGFuaWQscyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgc3RyID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKTtcbiAgdmFyIHNsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyKTtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4ub2Zmc2V0LCBzdHIsIDAsIHNsZW4pO1xuICBjaGFuLm9mZnNldCArPSBzbGVuO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3BlblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyciwganNfcHJpbnRfc3Rkb3V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGlkeCxvdXRwdXQsZmlsZSxmbGFncykge1xuICBpZihjYW1sX2dsb2JhbF9kYXRhLmZkcyA9PT0gdW5kZWZpbmVkKSBjYW1sX2dsb2JhbF9kYXRhLmZkcyA9IG5ldyBBcnJheSgpO1xuICBmbGFncz1mbGFncz9mbGFnczp7fTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby5maWxlID0gZmlsZTtcbiAgaW5mby5vZmZzZXQgPSBmbGFncy5hcHBlbmQ/ZmlsZS5sZW5ndGgoKTowO1xuICBpbmZvLmZsYWdzID0gZmxhZ3M7XG4gIGluZm8ub3V0cHV0ID0gb3V0cHV0O1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tpZHhdID0gaW5mbztcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHggfHwgaWR4ID4gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeClcbiAgICBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4ID0gaWR4O1xuICByZXR1cm4gaWR4O1xufVxuZnVuY3Rpb24gY2FtbF9zeXNfb3BlbiAobmFtZSwgZmxhZ3MsIF9wZXJtcykge1xuICB2YXIgZiA9IHt9O1xuICB3aGlsZShmbGFncyl7XG4gICAgc3dpdGNoKGZsYWdzWzFdKXtcbiAgICBjYXNlIDA6IGYucmRvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDE6IGYud3Jvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDI6IGYuYXBwZW5kID0gMTticmVhaztcbiAgICBjYXNlIDM6IGYuY3JlYXRlID0gMTticmVhaztcbiAgICBjYXNlIDQ6IGYudHJ1bmNhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNTogZi5leGNsID0gMTsgYnJlYWs7XG4gICAgY2FzZSA2OiBmLmJpbmFyeSA9IDE7YnJlYWs7XG4gICAgY2FzZSA3OiBmLnRleHQgPSAxO2JyZWFrO1xuICAgIGNhc2UgODogZi5ub25ibG9jayA9IDE7YnJlYWs7XG4gICAgfVxuICAgIGZsYWdzPWZsYWdzWzJdO1xuICB9XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCxmKTtcbiAgdmFyIGlkeCA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg/Y2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeDowO1xuICByZXR1cm4gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCAoaWR4KzEsY2FtbF9zdGRfb3V0cHV0LGZpbGUsZik7XG59XG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDAsY2FtbF9zdGRfb3V0cHV0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZGluXG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDEsanNfcHJpbnRfc3Rkb3V0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZG91dFxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgyLGpzX3ByaW50X3N0ZGVyciwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRlcnJcblxuXG4vLyBvY2FtbCBDaGFubmVsc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX25hbWVcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSgpIHtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsc1xudmFyIGNhbWxfbWxfY2hhbm5lbHMgPSBuZXcgQXJyYXkoKTtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCAoKSB7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBjID0gMDsgYyA8IGNhbWxfbWxfY2hhbm5lbHMubGVuZ3RoOyBjKyspe1xuICAgIGlmKGNhbWxfbWxfY2hhbm5lbHNbY10gJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vcGVuZWQgJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vdXQpXG4gICAgICBsPVswLGNhbWxfbWxfY2hhbm5lbHNbY10uZmQsbF07XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IChmZCkge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy5yZG9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgcmVhZG9ubHlcIik7XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6dHJ1ZSxcbiAgICBidWZmZXI6XCJcIlxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N5c19vcGVuLGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiAoZmQpICB7XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICBpZihkYXRhLmZsYWdzLndyb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyB3cml0ZW9ubHlcIik7XG5cbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpkYXRhLmZpbGUsXG4gICAgb2Zmc2V0OmRhdGEub2Zmc2V0LFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDogZmFsc2UsXG4gICAgcmVmaWxsOm51bGxcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvclxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3IoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZShjaGFuaWQsbW9kZSl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdO1xuICBkYXRhLmZsYWdzLnRleHQgPSAhbW9kZVxuICBkYXRhLmZsYWdzLmJpbmFyeSA9IG1vZGVcbiAgcmV0dXJuIDA7XG59XG5cbi8vSW5wdXQgZnJvbSBpbl9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2xvc2VfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9zeXNfY2xvc2VcbmZ1bmN0aW9uIGNhbWxfbWxfY2xvc2VfY2hhbm5lbCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNoYW4ub3BlbmVkID0gZmFsc2U7XG4gIGNoYW4uZmlsZS5jbG9zZSgpO1xuICBjYW1sX3N5c19jbG9zZShjaGFuLmZkKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmlsZS5sZW5ndGgoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemVfNjQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjaGFuLmZpbGUubGVuZ3RoICgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0KGNoYW5pZCxmKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsKGNoYW5pZCxmKSB7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5yZWZpbGwgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9tbF9yZWZpbGxfaW5wdXQgKGNoYW4pIHtcbiAgdmFyIHN0ciA9IGNoYW4ucmVmaWxsKCk7XG4gIHZhciBzdHJfbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGlmIChzdHJfbGVuID09IDApIGNoYW4ucmVmaWxsID0gbnVsbDtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4uZmlsZS5sZW5ndGgoKSwgc3RyLCAwLCBzdHJfbGVuKTtcbiAgcmV0dXJuIHN0cl9sZW47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgPT0gbnVsbCkgcmV0dXJuO1xuICBpZiAoY2hhbi5maWxlLmxlbmd0aCgpICE9IGNoYW4ub2Zmc2V0KSByZXR1cm47XG4gIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXQgKGNoYW5pZCwgcywgaSwgbCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGwyID0gY2hhbi5maWxlLmxlbmd0aCgpIC0gY2hhbi5vZmZzZXQ7XG4gIGlmIChsMiA9PSAwICYmIGNoYW4ucmVmaWxsICE9IG51bGwpIGwyID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gIGlmIChsMiA8IGwpIGwgPSBsMjtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsIHMsIGksIGwpO1xuICBjaGFuLm9mZnNldCArPSBsO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZSAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyg4KTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsOCk7XG5cbiAgLy8gSGVhZGVyIGlzIDIwIGJ5dGVzXG4gIHZhciBsZW4gPSBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChidWYsIDApICsgMjA7XG5cbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG5cbiAgdmFyIG9mZnNldCA9IFswXTtcbiAgdmFyIHJlcyA9IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhidWYsIG9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0ID0gY2hhbi5vZmZzZXQgKyBvZmZzZXRbMF07XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2NoYXIgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIGlmIChjaGFuLm9mZnNldCA+PSBjaGFuLmZpbGUubGVuZ3RoKCkpXG4gICAgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB2YXIgcmVzID0gY2hhbi5maWxlLnJlYWRfb25lKGNoYW4ub2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQrKztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2ludCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZmlsZSA9IGNoYW4uZmlsZTtcbiAgd2hpbGUgKChjaGFuLm9mZnNldCArIDMpID49IGZpbGUubGVuZ3RoKCkpIHtcbiAgICB2YXIgbCA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICAgIGlmIChsID09IDApIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgfVxuICB2YXIgbyA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgciA9KGZpbGUucmVhZF9vbmUobyAgKSA8PCAyNClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMSkgPDwgMTYpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzIpIDw8IDgpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzMpKTtcbiAgY2hhbi5vZmZzZXQrPTQ7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW4oY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luXzY0KGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbihjaGFuaWQpIHtyZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luXzY0KGNoYW5pZCkge3JldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQpfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X3NjYW5fbGluZVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X3NjYW5fbGluZShjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIHZhciBwID0gY2hhbi5vZmZzZXQ7XG4gIHZhciBsZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKHAgPj0gbGVuKSB7IHJldHVybiAwO31cbiAgd2hpbGUodHJ1ZSkge1xuICAgIGlmKHAgPj0gbGVuKSByZXR1cm4gLSAocCAtIGNoYW4ub2Zmc2V0KTtcbiAgICBpZihjaGFuLmZpbGUucmVhZF9vbmUocCkgPT0gMTApIHJldHVybiBwIC0gY2hhbi5vZmZzZXQgKyAxO1xuICAgIHArKztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2ZsdXNoXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9mbHVzaCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBmbHVzaCBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICBpZighY2hhbi5idWZmZXIgfHwgY2hhbi5idWZmZXIgPT0gXCJcIikgcmV0dXJuIDA7XG4gIGlmKGNoYW4uZmRcbiAgICAgJiYgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF1cbiAgICAgJiYgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dDtcbiAgICBzd2l0Y2gob3V0cHV0Lmxlbmd0aCl7XG4gICAgY2FzZSAyOiBvdXRwdXQoY2hhbmlkLGNoYW4uYnVmZmVyKTticmVhaztcbiAgICBkZWZhdWx0OiBvdXRwdXQoY2hhbi5idWZmZXIpXG4gICAgfTtcbiAgfVxuICBjaGFuLmJ1ZmZlciA9IFwiXCI7XG4gIHJldHVybiAwO1xufVxuXG4vL291dHB1dCB0byBvdXRfY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCxjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IG91dHB1dCB0byBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICB2YXIgYnl0ZXM7XG4gIGlmKG9mZnNldCA9PSAwICYmIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ1ZmZlcikgPT0gbGVuKVxuICAgIGJ5dGVzID0gYnVmZmVyO1xuICBlbHNlIHtcbiAgICBieXRlcyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgY2FtbF9ibGl0X2J5dGVzKGJ1ZmZlcixvZmZzZXQsYnl0ZXMsMCxsZW4pO1xuICB9XG4gIHZhciBzdHJpbmcgPSBjYW1sX3N0cmluZ19vZl9ieXRlcyhieXRlcyk7XG4gIHZhciBqc3N0cmluZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoc3RyaW5nKTtcbiAgdmFyIGlkID0ganNzdHJpbmcubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gIGlmKGlkIDwgMClcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmc7XG4gIGVsc2Uge1xuICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZy5zdWJzdHIoMCxpZCsxKTtcbiAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIGNoYW4uYnVmZmVyICs9IGpzc3RyaW5nLnN1YnN0cihpZCsxKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXQoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxjYW1sX2J5dGVzX29mX3N0cmluZyhidWZmZXIpLG9mZnNldCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfY2hhciAoY2hhbmlkLGMpIHtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZywgY2FtbF9tbF9vdXRwdXQsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZSAoY2hhbmlkLHYsZmxhZ3MpIHtcbiAgdmFyIHMgPSBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodiwgZmxhZ3MpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0KGNoYW5pZCkge1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0XzY0KGNoYW5pZCkge1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0IChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2ludCAoY2hhbmlkLGkpIHtcbiAgdmFyIGFyciA9IFsoaT4+MjQpICYgMHhGRiwoaT4+MTYpICYgMHhGRiwoaT4+OCkgJiAweEZGLGkgJiAweEZGIF07XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCw0KTtcbiAgcmV0dXJuIDBcbn1cbiIsIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZnVsbF9tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19mdWxsX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb21wYWN0aW9uXG5mdW5jdGlvbiBjYW1sX2djX2NvbXBhY3Rpb24oKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvdW50ZXJzXG5mdW5jdGlvbiBjYW1sX2djX2NvdW50ZXJzKCkgeyByZXR1cm4gWzI1NCwwLDAsMF0gfVxuLy9Qcm92aWRlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3F1aWNrX3N0YXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc3RhdCgpIHtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc2V0XG5mdW5jdGlvbiBjYW1sX2djX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19nZXRcbmZ1bmN0aW9uIGNhbWxfZ2NfZ2V0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zZXRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXIgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlbGVhc2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVsZWFzZSAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdGFydFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0YXJ0KHJhdGUsc3RhY2tfc2l6ZSx0cmFja2VyKXtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdG9wXG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RvcCh1bml0KSB7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpe1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgNzogY2FzZSAxMDogY2FzZSAxMTogcmV0dXJuIDI7XG4gIGRlZmF1bHQ6IHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciB2aWV3O1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMDogIHZpZXcgPSBnLkZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTogIHZpZXcgPSBnLkZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMjogIHZpZXcgPSBnLkludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgMzogIHZpZXcgPSBnLlVpbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDQ6ICB2aWV3ID0gZy5JbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA1OiAgdmlldyA9IGcuVWludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDY6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA3OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgODogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDk6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMDogdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMTogdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAxMjogdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIH1cbiAgaWYgKCF2aWV3KSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHZhciBkYXRhID0gbmV3IHZpZXcoc2l6ZSAqIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA8IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyYXlcIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246ID49IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyMDJcIlxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSwgY2FtbF9pbnQ2NF9oaTMyLCBjYW1sX2ludDY0X2xvMzJcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5IChraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuXG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gY2FtbF9iYV9jdXN0b21fbmFtZTtcblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIG9mcyA9IDA7XG4gIGlmKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIGFyZyA9IFthcmddO1xuICBpZiAoISAoYXJnIGluc3RhbmNlb2YgQXJyYXkpKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdhcnJheS5qczogaW52YWxpZCBvZmZzZXRcIik7XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGFyZy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZ2V0L3NldDogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICBpZih0aGlzLmxheW91dCA9PSAwIC8qIGNfbGF5b3V0ICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcmdbaV0gPCAwIHx8IGFyZ1tpXSA+PSB0aGlzLmRpbXNbaV0pXG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgYXJnW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5kaW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMSB8fCBhcmdbaV0gPiB0aGlzLmRpbXNbaV0pe1xuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICB9XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIChhcmdbaV0gLSAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mcztcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBsID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGwsaCk7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgciA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGkgPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBbMjU0LCByLCBpXTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdGhpcy5kYXRhW29mc11cbiAgfVxufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gdlsxXTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gdlsyXTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgYSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB2YXIgYiA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBpZihhID09IGIpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gYSA6IGI7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIGltID0gdlsxXTtcbiAgICB2YXIgcmUgPSB2WzJdO1xuICAgIGlmKGltID09IHJlKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGltKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBpbSA6IHJlO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIsIHRvdGFsKSB7XG4gIGlmICh0aGlzLmxheW91dCAhPSBiLmxheW91dCB8fCB0aGlzLmtpbmQgIT0gYi5raW5kKSB7XG4gICAgdmFyIGsxID0gdGhpcy5raW5kIHwgKHRoaXMubGF5b3V0IDw8IDgpO1xuICAgIHZhciBrMiA9ICAgIGIua2luZCB8IChiLmxheW91dCA8PCA4KTtcbiAgICByZXR1cm4gazIgLSBrMTtcbiAgfVxuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBiLmRpbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGIuZGltcy5sZW5ndGggLSB0aGlzLmRpbXMubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmICh0aGlzLmRpbXNbaV0gIT0gYi5kaW1zW2ldKVxuICAgICAgcmV0dXJuICh0aGlzLmRpbXNbaV0gPCBiLmRpbXNbaV0pID8gLTEgOiAxO1xuICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgY2FzZSAxMDpcbiAgY2FzZSAxMTpcbiAgICAvLyBGbG9hdHNcbiAgICB2YXIgeCwgeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgeCA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHkgPSBiLmRhdGFbaV07XG4gICAgICBpZiAoeCA8IHkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh4ID4geSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgIGlmICh4ID09IHgpIHJldHVybiAxO1xuICAgICAgICBpZiAoeSA9PSB5KSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrPTIpIHtcbiAgICAgIC8vIENoZWNrIGhpZ2hlc3QgYml0cyBmaXJzdFxuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdIDwgYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA+IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA8IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPiAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDI6XG4gIGNhc2UgMzpcbiAgY2FzZSA0OlxuICBjYXNlIDU6XG4gIGNhc2UgNjpcbiAgY2FzZSA4OlxuICBjYXNlIDk6XG4gIGNhc2UgMTI6XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPCBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPiBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlfY18xXzFcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSAgID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUgPSBuZXcgTWxfQmlnYXJyYXkoKVxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgaWYodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIil7XG4gICAgaWYoKGFyZyBpbnN0YW5jZW9mIEFycmF5KSAmJiBhcmcubGVuZ3RoID09IDEpXG4gICAgICBhcmcgPSBhcmdbMF07XG4gICAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJNbF9CaWdhcnJheV9jXzFfMS5vZmZzZXRcIik7XG4gIH1cbiAgaWYgKGFyZyA8IDAgfHwgYXJnID49IHRoaXMuZGltc1swXSlcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcmc7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHJldHVybiB0aGlzLmRhdGFbb2ZzXTtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gIHJldHVybiAwXG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5kYXRhLmZpbGwodik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY29tcGFyZVxuZnVuY3Rpb24gY2FtbF9iYV9jb21wYXJlKGEsYix0b3RhbCl7XG4gIHJldHVybiBhLmNvbXBhcmUoYix0b3RhbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgTWxfQmlnYXJyYXlfY18xXzEsIGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSl7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKTtcbiAgaWYoY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSAqIHNpemVfcGVyX2VsZW1lbnQgIT0gZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJsZW5ndGggZG9lc24ndCBtYXRjaCBkaW1zXCIpO1xuICB9XG4gIGlmKGxheW91dCA9PSAwICYmIC8vIGNfbGF5b3V0XG4gICAgIGRpbXMubGVuZ3RoID09IDEgJiYgLy8gQXJyYXkxXG4gICAgIHNpemVfcGVyX2VsZW1lbnQgPT0gMSkgLy8gMS10by0xIG1hcHBpbmdcbiAgICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHJldHVybiBuZXcgTWxfQmlnYXJyYXkoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcblxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZShraW5kLCBsYXlvdXQsIGRpbXNfbWwpIHtcbiAgdmFyIGRpbXMgPSBjYW1sX2pzX2Zyb21fYXJyYXkoZGltc19tbCk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIGNhbWxfYmFfZ2V0X3NpemUoZGltcykpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY2hhbmdlX2xheW91dFxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZihiYS5sYXlvdXQgPT0gbGF5b3V0KSByZXR1cm4gYmE7XG4gIHZhciBuZXdfZGltcyA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSBuZXdfZGltc1tpXSA9IGJhLmRpbXNbYmEuZGltcy5sZW5ndGggLSBpIC0gMV07XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgbGF5b3V0LCBuZXdfZGltcywgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kKGJhKSB7XG4gIHJldHVybiBiYS5raW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2xheW91dFxuZnVuY3Rpb24gY2FtbF9iYV9sYXlvdXQoYmEpIHtcbiAgcmV0dXJuIGJhLmxheW91dDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9udW1fZGltc1xuZnVuY3Rpb24gY2FtbF9iYV9udW1fZGltcyhiYSkge1xuICByZXR1cm4gYmEuZGltcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZGltKGJhLCBpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmRpbVwiKTtcbiAgcmV0dXJuIGJhLmRpbXNbaV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzFcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8xKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8yKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8zKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfZ2VuZXJpYyhiYSwgaSkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSk7XG4gIHJldHVybiBiYS5nZXQob2ZzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQxNihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMgKyAxKTtcbiAgcmV0dXJuIChiMSB8IChiMiA8PCA4KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MzIoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHJldHVybiAoIChiMSA8PCAwKSAgfFxuICAgICAgICAgICAoYjIgPDwgOCkgIHxcbiAgICAgICAgICAgKGIzIDw8IDE2KSB8XG4gICAgICAgICAgIChiNCA8PCAyNCkgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQ2NChiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgdmFyIGI1ID0gYmEuZ2V0KG9mcys0KTtcbiAgdmFyIGI2ID0gYmEuZ2V0KG9mcys1KTtcbiAgdmFyIGI3ID0gYmEuZ2V0KG9mcys2KTtcbiAgdmFyIGI4ID0gYmEuZ2V0KG9mcys3KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW2I4LGI3LGI2LGI1LGI0LGIzLGIyLGIxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzEoYmEsIGkwKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KGkwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTFdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzMoYmEsIGkwLCBpMSwgaTIpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxLGkyXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0X2dlbmVyaWMoYmEsIGksIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQxNihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MzIoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysyLCAodiA+Pj4gMTYpICYgMHhmZik7XG4gIGJhLnNldChvZnMrMywgKHYgPj4+IDI0KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQ2NChiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIHYgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBiYS5zZXQob2ZzK2ksIHZbNy1pXSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzEoYmEsIGkwLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoaTApLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMihiYSwgaTAsIGkxLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMyhiYSwgaTAsIGkxLCBpMiwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZmlsbFxuZnVuY3Rpb24gY2FtbF9iYV9maWxsKGJhLCB2KSB7XG4gIGJhLmZpbGwodik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9ibGl0KHNyYywgZHN0KSB7XG4gIGlmIChkc3QuZGltcy5sZW5ndGggIT0gc3JjLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkc3QuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAoZHN0LmRpbXNbaV0gIT0gc3JjLmRpbXNbaV0pXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGRzdC5kYXRhLnNldChzcmMuZGF0YSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3N1YlxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc3ViKGJhLCBvZnMsIGxlbikge1xuICB2YXIgY2hhbmdlZF9kaW07XG4gIHZhciBtdWwgPSAxO1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gMDtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IChiYS5kaW1zLmxlbmd0aCAtIDEpOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gYmEuZGltcy5sZW5ndGggLSAxO1xuICAgIG9mcyA9IG9mcyAtIDE7XG4gIH1cbiAgaWYgKG9mcyA8IDAgfHwgbGVuIDwgMCB8fCAob2ZzICsgbGVuKSA+IGJhLmRpbXNbY2hhbmdlZF9kaW1dKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zdWI6IGJhZCBzdWItYXJyYXlcIik7XG4gIH1cbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICBuZXdfZGltc1tpXSA9IGJhLmRpbXNbaV07XG4gIG5ld19kaW1zW2NoYW5nZWRfZGltXSA9IGxlbjtcbiAgbXVsICo9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogbXVsLCAob2ZzICsgbGVuKSAqIG11bCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NsaWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3NsaWNlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBudW1faW5kcyA9IHZpbmQubGVuZ3RoO1xuICB2YXIgaW5kZXggPSBbXTtcbiAgdmFyIHN1Yl9kaW1zID0gW107XG4gIHZhciBvZnM7XG5cbiAgaWYgKG51bV9pbmRzID4gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc2xpY2U6IHRvbyBtYW55IGluZGljZXNcIik7XG5cbiAgLy8gQ29tcHV0ZSBvZmZzZXQgYW5kIGNoZWNrIGJvdW5kc1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IHZpbmRbaV07XG4gICAgZm9yICg7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAwO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZShudW1faW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyArIGldID0gdmluZFtpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMTtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UoMCwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyk7XG4gIH1cbiAgb2ZzID0gYmEub2Zmc2V0KGluZGV4KTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKHN1Yl9kaW1zKTtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIHNpemVfcGVyX2VsZW1lbnQsIChvZnMgKyBzaXplKSAqIHNpemVfcGVyX2VsZW1lbnQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgc3ViX2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9yZXNoYXBlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG5mdW5jdGlvbiBjYW1sX2JhX3Jlc2hhcGUoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG5ld19kaW0gPSBbXTtcbiAgdmFyIG51bV9kaW1zID0gdmluZC5sZW5ndGg7XG5cbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIH1cbiAgdmFyIG51bV9lbHRzID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgbmV3X2RpbVtpXSA9IHZpbmRbaV07XG4gICAgaWYgKG5ld19kaW1baV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIG51bV9lbHRzID0gbnVtX2VsdHMgKiBuZXdfZGltW2ldO1xuICB9XG5cbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICAvLyBDaGVjayB0aGF0IHNpemVzIGFncmVlXG4gIGlmIChudW1fZWx0cyAhPSBzaXplKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IHNpemUgbWlzbWF0Y2hcIik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX3NlcmlhbGl6ZSh3cml0ZXIsIGJhLCBzeikge1xuICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXMubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKDMyLCAoYmEua2luZCB8IChiYS5sYXlvdXQgPDwgOCkpKTtcbiAgaWYoYmEuY2FtbF9jdXN0b20gPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoYmEuZGltc1tpXSA8IDB4ZmZmZilcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kaW1zW2ldKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIDB4ZmZmZik7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgMCk7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGltc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICBlbHNlXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHdyaXRlci53cml0ZSgzMixiYS5kaW1zW2ldKVxuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoOCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB3cml0ZXIud3JpdGUoOCwwKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhiYS5nZXQoaSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgaiA9IGJhLmdldChpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMV0pKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMl0pKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgY29tcGxleCA9IGJhLmdldChpKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsxXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMl0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICBzelswXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogNDtcbiAgc3pbMV0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGVzZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlcywgY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9kZXNlcmlhbGl6ZShyZWFkZXIsIHN6LCBuYW1lKXtcbiAgdmFyIG51bV9kaW1zID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogd3JvbmcgbnVtYmVyIG9mIGJpZ2FycmF5IGRpbWVuc2lvbnNcIik7XG4gIHZhciB0YWcgPSByZWFkZXIucmVhZDMycygpO1xuICB2YXIga2luZCA9IHRhZyAmIDB4ZmZcbiAgdmFyIGxheW91dCA9ICh0YWcgPj4gOCkgJiAxO1xuICB2YXIgZGltcyA9IFtdXG4gIGlmKG5hbWUgPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICAgIHZhciBzaXplX2RpbSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgICBpZihzaXplX2RpbSA9PSAweGZmZmYpe1xuICAgICAgICB2YXIgc2l6ZV9kaW1faGkgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICB2YXIgc2l6ZV9kaW1fbG8gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICBpZihzaXplX2RpbV9oaSAhPSAwKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogYmlnYXJyYXkgZGltZW5zaW9uIG92ZXJmbG93IGluIDMyYml0XCIpO1xuICAgICAgICBzaXplX2RpbSA9IHNpemVfZGltX2xvO1xuICAgICAgfVxuICAgICAgZGltcy5wdXNoKHNpemVfZGltKTtcbiAgICB9XG4gIGVsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIGRpbXMucHVzaChyZWFkZXIucmVhZDMydSgpKTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGRpbXMpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKTtcbiAgdmFyIGJhID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDhzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgdmFyIHNpeHR5ID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIGlmKHNpeHR5KSBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGNhbm5vdCByZWFkIGJpZ2FycmF5IHdpdGggNjQtYml0IE9DYW1sIGludHNcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogLy8gKGludDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbnQ2NCA9IGNhbWxfaW50NjRfb2ZfYnl0ZXModCk7XG4gICAgICBiYS5zZXQoaSxpbnQ2NCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgc3pbMF0gPSAoNCArIG51bV9kaW1zKSAqIDQ7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9EZXByZWNhdGVkXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfZnJvbShkYXRhMSwgZGF0YTIsIGpzdHlwLCBraW5kLCBsYXlvdXQsIGRpbXMpe1xuICBpZihkYXRhMiB8fCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpID09IDIpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfY3JlYXRlX2Zyb206IHVzZSByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlXCIpO1xuICB9XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaGFzaCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfaGFzaChiYSl7XG4gIHZhciBudW1fZWx0cyA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIHZhciBoID0gMDtcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAyNTYpIG51bV9lbHRzID0gMjU2O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyA0IDw9IGJhLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDgpIHwgKGJhLmRhdGFbaSsyXSA8PCAxNikgfCAoYmEuZGF0YVtpKzNdIDw8IDI0KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICB3ID0gMDtcbiAgICBzd2l0Y2ggKG51bV9lbHRzICYgMykge1xuICAgIGNhc2UgMzogdyAgPSBiYS5kYXRhW2krMl0gPDwgMTY7ICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAyOiB3IHw9IGJhLmRhdGFbaSsxXSA8PCA4OyAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDE6IHcgfD0gYmEuZGF0YVtpKzBdO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMTI4KSBudW1fZWx0cyA9IDEyODtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgMiA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9Mil7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCAxNik7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgaWYgKChudW1fZWx0cyAmIDEpICE9IDApXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgbnVtX2VsdHMgKj0gMlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9iYV90b190eXBlZF9hcnJheShiYSl7XG4gIHJldHVybiBiYS5kYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIga2luZDtcbiAgaWYgKHRhIGluc3RhbmNlb2YgZy5GbG9hdDMyQXJyYXkpIGtpbmQgPSAwO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQ2NEFycmF5KSBraW5kID0gMTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDhBcnJheSkga2luZCA9IDI7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50OEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDE2QXJyYXkpIGtpbmQgPSA0O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDE2QXJyYXkpIGtpbmQgPSA1O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuSW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5OiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICByZXR1cm4ga2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkodGEpe1xuICB2YXIga2luZCA9IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3B1cmVfZXhwciBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19wdXJlX2V4cHIgKGYpIHsgcmV0dXJuIGYoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19zZXQobyxmLHYpIHsgb1tmXT12O3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19nZXQobyxmKSB7IHJldHVybiBvW2ZdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2RlbGV0ZSAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2RlbGV0ZShvLGYpIHsgZGVsZXRlIG9bZl07IHJldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2luc3RhbmNlb2YgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfaW5zdGFuY2VvZihvLGMpIHsgcmV0dXJuIG8gaW5zdGFuY2VvZiBjOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdHlwZW9mIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdHlwZW9mKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb25faWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfb25faWUgKCkge1xuICB2YXIgdWEgPVxuICAgICAgam9vX2dsb2JhbF9vYmplY3QubmF2aWdhdG9yP2pvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvXG4gIGlmKHMubWF0Y2goZW50aXR5KSlcbiAge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJJbnZhbGlkIGVudGl0eSBcIiArIHMpO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vIERlYnVnZ2luZyBjb25zb2xlXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldF9jb25zb2xlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX2dldF9jb25zb2xlICgpIHtcbiAgdmFyIGMgPSBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlP2pvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGU6e307XG4gIHZhciBtID0gW1wibG9nXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiYXNzZXJ0XCIsIFwiZGlyXCIsIFwiZGlyeG1sXCIsXG4gICAgICAgICAgIFwidHJhY2VcIiwgXCJncm91cFwiLCBcImdyb3VwQ29sbGFwc2VkXCIsIFwiZ3JvdXBFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiXTtcbiAgZnVuY3Rpb24gZiAoKSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIGlmICghY1ttW2ldXSkgY1ttW2ldXT1mO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVcbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZShyZXMpIHtcbiAgdmFyIGMgPSAxO1xuICB3aGlsZShyZXMgJiYgcmVzLmpvb190cmFtcCl7XG4gICAgcmVzID0gcmVzLmpvb190cmFtcC5hcHBseShudWxsLCByZXMuam9vX2FyZ3MpO1xuICAgIGMrKztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZixhcmdzKSB7XG4gIHJldHVybiB7am9vX3RyYW1wOmYsam9vX2FyZ3M6YXJnc307XG59XG5cbi8vUHJvdmlkZXM6IGpzX3ByaW50X3N0ZG91dCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZG91dChzKSB7XG4gIHZhciBzID0gY2FtbF91dGYxNl9vZl91dGY4KHMpO1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZiAoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5zdGRvdXQgJiYgZy5wcm9jZXNzLnN0ZG91dC53cml0ZSkge1xuICAgIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUocylcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgb3V0cHV0IHRoZSBsYXN0IFxcbiBpZiBwcmVzZW50XG4gICAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICBpZihzLmNoYXJDb2RlQXQocy5sZW5ndGggLSAxKSA9PSAxMClcbiAgICAgIHMgPSBzLnN1YnN0cigwLHMubGVuZ3RoIC0gMSApO1xuICAgIHZhciB2ID0gZy5jb25zb2xlO1xuICAgIHYgICYmIHYubG9nICYmIHYubG9nKHMpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRlcnIgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRlcnIocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3RkZXJyLndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICYmIHYuZXJyb3IgJiYgdi5lcnJvcihzKTtcbiAgfVxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfanNcbmZ1bmN0aW9uIGNhbWxfaXNfanMoKSB7XG4gIHJldHVybiAxO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF93cmFwX2V4Y2VwdGlvbiBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudFxuZnVuY3Rpb24gY2FtbF93cmFwX2V4Y2VwdGlvbihlKSB7XG4gIGlmKGUgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGU7XG4gIC8vU3RhY2tfb3ZlcmZsb3c6IGNocm9tZSwgc2FmYXJpXG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LlJhbmdlRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LlJhbmdlRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvbWF4aW11bSBjYWxsIHN0YWNrL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vU3RhY2tfb3ZlcmZsb3c6IGZpcmVmb3hcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuSW50ZXJuYWxFcnJvclxuICAgICAmJiBlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuSW50ZXJuYWxFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC90b28gbXVjaCByZWN1cnNpb24vaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9XcmFwIEVycm9yIGluIEpzLkVycm9yIGV4Y2VwdGlvblxuICBpZihlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuRXJyb3IgJiYgY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIikpXG4gICAgcmV0dXJuIFswLGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpLGVdO1xuICAvL2ZhbGxiYWNrOiB3cmFwcGVkIGluIEZhaWx1cmVcbiAgcmV0dXJuIFswLGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoU3RyaW5nKGUpKV07XG59XG5cbi8vIEV4cGVyaW1lbnRhbFxuLy9Qcm92aWRlczogY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpIHtcbiAgLy9uZXZlciByZXJhaXNlIGZvciBjb25zdGFudCBleG5cbiAgaWYoIWV4bi5qc19lcnJvciB8fCBmb3JjZSB8fCBleG5bMF0gPT0gMjQ4KSBleG4uanNfZXJyb3IgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRXJyb3IoXCJKcyBleGNlcHRpb24gY29udGFpbmluZyBiYWNrdHJhY2VcIik7XG4gIHJldHVybiBleG47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBleG4uanNfZXJyb3I7IH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogcGFyc2luZy5jIDg5ODMgMjAwOC0wOC0wNiAwOTozODoyNVogeGxlcm95ICQgKi9cblxuLyogVGhlIFBEQSBhdXRvbWF0b24gZm9yIHBhcnNlcnMgZ2VuZXJhdGVkIGJ5IGNhbWx5YWNjICovXG5cbi8qIFRoZSBwdXNoZG93biBhdXRvbWF0YSAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9sZXhfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZW5naW5lKHRhYmxlcywgZW52LCBjbWQsIGFyZylcbntcbiAgdmFyIEVSUkNPREUgPSAyNTY7XG5cbiAgLy92YXIgU1RBUlQgPSAwO1xuICAvL3ZhciBUT0tFTl9SRUFEID0gMTtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzEgPSAyO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMiA9IDM7XG4gIC8vdmFyIFNFTUFOVElDX0FDVElPTl9DT01QVVRFRCA9IDQ7XG4gIC8vdmFyIEVSUk9SX0RFVEVDVEVEID0gNTtcbiAgdmFyIGxvb3AgPSA2O1xuICB2YXIgdGVzdHNoaWZ0ID0gNztcbiAgdmFyIHNoaWZ0ID0gODtcbiAgdmFyIHNoaWZ0X3JlY292ZXIgPSA5O1xuICB2YXIgcmVkdWNlID0gMTA7XG5cbiAgdmFyIFJFQURfVE9LRU4gPSAwO1xuICB2YXIgUkFJU0VfUEFSU0VfRVJST1IgPSAxO1xuICB2YXIgR1JPV19TVEFDS1NfMSA9IDI7XG4gIHZhciBHUk9XX1NUQUNLU18yID0gMztcbiAgdmFyIENPTVBVVEVfU0VNQU5USUNfQUNUSU9OID0gNDtcbiAgdmFyIENBTExfRVJST1JfRlVOQ1RJT04gPSA1O1xuXG4gIHZhciBlbnZfc19zdGFjayA9IDE7XG4gIHZhciBlbnZfdl9zdGFjayA9IDI7XG4gIHZhciBlbnZfc3ltYl9zdGFydF9zdGFjayA9IDM7XG4gIHZhciBlbnZfc3ltYl9lbmRfc3RhY2sgPSA0O1xuICB2YXIgZW52X3N0YWNrc2l6ZSA9IDU7XG4gIHZhciBlbnZfc3RhY2tiYXNlID0gNjtcbiAgdmFyIGVudl9jdXJyX2NoYXIgPSA3O1xuICB2YXIgZW52X2x2YWwgPSA4O1xuICB2YXIgZW52X3N5bWJfc3RhcnQgPSA5O1xuICB2YXIgZW52X3N5bWJfZW5kID0gMTA7XG4gIHZhciBlbnZfYXNwID0gMTE7XG4gIHZhciBlbnZfcnVsZV9sZW4gPSAxMjtcbiAgdmFyIGVudl9ydWxlX251bWJlciA9IDEzO1xuICB2YXIgZW52X3NwID0gMTQ7XG4gIHZhciBlbnZfc3RhdGUgPSAxNTtcbiAgdmFyIGVudl9lcnJmbGFnID0gMTY7XG5cbiAgLy8gdmFyIF90YmxfYWN0aW9ucyA9IDE7XG4gIHZhciB0YmxfdHJhbnNsX2NvbnN0ID0gMjtcbiAgdmFyIHRibF90cmFuc2xfYmxvY2sgPSAzO1xuICB2YXIgdGJsX2xocyA9IDQ7XG4gIHZhciB0YmxfbGVuID0gNTtcbiAgdmFyIHRibF9kZWZyZWQgPSA2O1xuICB2YXIgdGJsX2Rnb3RvID0gNztcbiAgdmFyIHRibF9zaW5kZXggPSA4O1xuICB2YXIgdGJsX3JpbmRleCA9IDk7XG4gIHZhciB0YmxfZ2luZGV4ID0gMTA7XG4gIHZhciB0YmxfdGFibGVzaXplID0gMTE7XG4gIHZhciB0YmxfdGFibGUgPSAxMjtcbiAgdmFyIHRibF9jaGVjayA9IDEzO1xuICAvLyB2YXIgX3RibF9lcnJvcl9mdW5jdGlvbiA9IDE0O1xuICAvLyB2YXIgX3RibF9uYW1lc19jb25zdCA9IDE1O1xuICAvLyB2YXIgX3RibF9uYW1lc19ibG9jayA9IDE2O1xuXG4gIGlmICghdGFibGVzLmRnb3RvKSB7XG4gICAgdGFibGVzLmRlZnJlZCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2RlZnJlZF0pO1xuICAgIHRhYmxlcy5zaW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9zaW5kZXhdKTtcbiAgICB0YWJsZXMuY2hlY2sgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfY2hlY2tdKTtcbiAgICB0YWJsZXMucmluZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfcmluZGV4XSk7XG4gICAgdGFibGVzLnRhYmxlICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3RhYmxlXSk7XG4gICAgdGFibGVzLmxlbiAgICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2xlbl0pO1xuICAgIHRhYmxlcy5saHMgICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9saHNdKTtcbiAgICB0YWJsZXMuZ2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZ2luZGV4XSk7XG4gICAgdGFibGVzLmRnb3RvICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2Rnb3RvXSk7XG4gIH1cblxuICB2YXIgcmVzID0gMCwgbiwgbjEsIG4yLCBzdGF0ZTE7XG5cbiAgLy8gUkVTVE9SRVxuICB2YXIgc3AgPSBlbnZbZW52X3NwXTtcbiAgdmFyIHN0YXRlID0gZW52W2Vudl9zdGF0ZV07XG4gIHZhciBlcnJmbGFnID0gZW52W2Vudl9lcnJmbGFnXTtcblxuICBleGl0OmZvciAoOzspIHtcbiAgICBzd2l0Y2goY21kKSB7XG4gICAgY2FzZSAwOi8vU1RBUlQ6XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBlcnJmbGFnID0gMDtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA2Oi8vbG9vcDpcbiAgICAgIG4gPSB0YWJsZXMuZGVmcmVkW3N0YXRlXTtcbiAgICAgIGlmIChuICE9IDApIHsgY21kID0gcmVkdWNlOyBicmVhazsgfVxuICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA+PSAwKSB7IGNtZCA9IHRlc3RzaGlmdDsgYnJlYWs7IH1cbiAgICAgIHJlcyA9IFJFQURfVE9LRU47XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGxleGVyIGFuZCB1cGRhdGVzICovXG4gICAgICAvKiBzeW1iX3N0YXJ0IGFuZCBzeW1iX2VuZCAqL1xuICAgIGNhc2UgMTovL1RPS0VOX1JFQUQ6XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfYmxvY2tdW2FyZ1swXSArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gYXJnWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfY29uc3RdW2FyZyArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA3Oi8vdGVzdHNoaWZ0OlxuICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIGNtZCA9IHNoaWZ0OyBicmVhaztcbiAgICAgIH1cbiAgICAgIG4xID0gdGFibGVzLnJpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBuID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgICAgY21kID0gcmVkdWNlOyBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChlcnJmbGFnIDw9IDApIHtcbiAgICAgICAgcmVzID0gQ0FMTF9FUlJPUl9GVU5DVElPTjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGVycm9yIGZ1bmN0aW9uICovXG4gICAgY2FzZSA1Oi8vRVJST1JfREVURUNURUQ6XG4gICAgICBpZiAoZXJyZmxhZyA8IDMpIHtcbiAgICAgICAgZXJyZmxhZyA9IDM7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV07XG4gICAgICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlMV07XG4gICAgICAgICAgbjIgPSBuMSArIEVSUkNPREU7XG4gICAgICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBFUlJDT0RFKSB7XG4gICAgICAgICAgICBjbWQgPSBzaGlmdF9yZWNvdmVyOyBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNwIDw9IGVudltlbnZfc3RhY2tiYXNlXSkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgICAgICBzcC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA9PSAwKSByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICBjYXNlIDg6Ly9zaGlmdDpcbiAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgaWYgKGVycmZsYWcgPiAwKSBlcnJmbGFnLS07XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICBjYXNlIDk6Ly9zaGlmdF9yZWNvdmVyOlxuICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgc3ArKztcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMTtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAyOi8vU1RBQ0tTX0dST1dOXzE6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfbHZhbF07XG4gICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfc3RhcnRdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRdO1xuICAgICAgY21kID0gbG9vcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxMDovL3JlZHVjZTpcbiAgICAgIHZhciBtID0gdGFibGVzLmxlbltuXTtcbiAgICAgIGVudltlbnZfYXNwXSA9IHNwO1xuICAgICAgZW52W2Vudl9ydWxlX251bWJlcl0gPSBuO1xuICAgICAgZW52W2Vudl9ydWxlX2xlbl0gPSBtO1xuICAgICAgc3AgPSBzcCAtIG0gKyAxO1xuICAgICAgbSA9IHRhYmxlcy5saHNbbl07XG4gICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwXTtcbiAgICAgIG4xID0gdGFibGVzLmdpbmRleFttXTtcbiAgICAgIG4yID0gbjEgKyBzdGF0ZTE7XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gc3RhdGUxKVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXRlID0gdGFibGVzLmRnb3RvW21dO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18yO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICBjYXNlIDM6Ly9TVEFDS1NfR1JPV05fMjpcbiAgICAgIHJlcyA9IENPTVBVVEVfU0VNQU5USUNfQUNUSU9OO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBzZW1hbnRpYyBhY3Rpb24gKi9cbiAgICBjYXNlIDQ6Ly9TRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQ6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGFyZztcbiAgICAgIHZhciBhc3AgPSBlbnZbZW52X2FzcF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICBpZiAoc3AgPiBhc3ApIHtcbiAgICAgICAgLyogVGhpcyBpcyBhbiBlcHNpbG9uIHByb2R1Y3Rpb24uIFRha2Ugc3ltYl9zdGFydCBlcXVhbCB0byBzeW1iX2VuZC4gKi9cbiAgICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICB9XG4gICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIC8qIFNob3VsZCBub3QgaGFwcGVuICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLy8gU0FWRVxuICBlbnZbZW52X3NwXSA9IHNwO1xuICBlbnZbZW52X3N0YXRlXSA9IHN0YXRlO1xuICBlbnZbZW52X2VycmZsYWddID0gZXJyZmxhZztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfcGFyc2VyX3RyYWNlIGNvbnN0XG4vL0R1bW15IGZ1bmN0aW9uIVxuZnVuY3Rpb24gY2FtbF9zZXRfcGFyc2VyX3RyYWNlKCkgeyByZXR1cm4gMDsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliOiBjb2RlIHNwZWNpZmljIHRvIEpzX29mX29jYW1sXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9ib29sKHgpIHsgcmV0dXJuICEheDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYm9vbCh4KSB7IHJldHVybiAreDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9mbG9hdCh4KSB7IHJldHVybiB4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9hcnJheShhKSB7XG4gIHJldHVybiBhLnNsaWNlKDEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc190b19hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc190b19hcnJheShhKSB7XG4gIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBiWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxsZW47aSsrKSBiW2krMV0gPSBhW2ldO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X29mX2pzX2FycmF5IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGlzdF9vZl9qc19hcnJheShhKXtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGk9YS5sZW5ndGggLSAxOyBpPj0wOyBpLS0pe1xuICAgIHZhciBlID0gYVtpXTtcbiAgICBsID0gWzAsZSxsXTtcbiAgfVxuICByZXR1cm4gbFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3RfdG9fanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X3RvX2pzX2FycmF5KGwpe1xuICB2YXIgYSA9IFtdO1xuICBmb3IoOyBsICE9PSAwOyBsID0gbFsyXSkge1xuICAgIGEucHVzaChsWzFdKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc192YXIgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3Zhcih4KSB7XG4gIHZhciB4ID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoeCk7XG4gIC8vQ2hlY2tzIHRoYXQgeCBoYXMgdGhlIGZvcm0gaWRlbnRbLmlkZW50XSpcbiAgaWYoIXgubWF0Y2goL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSooXFwuW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKSokLykpe1xuICAgIGpzX3ByaW50X3N0ZGVycihcImNhbWxfanNfdmFyOiBcXFwiXCIgKyB4ICsgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIEphdmFTY3JpcHQgdmFyaWFibGUuIGNvbnRpbnVpbmcgLi5cIik7XG4gICAgLy9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLmVycm9yKFwiSnMuVW5zYWZlLmV2YWxfc3RyaW5nXCIpXG4gIH1cbiAgcmV0dXJuIGV2YWwoeCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2NhbGwgKGNvbnN0LCBtdXRhYmxlLCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2NhbGwoZiwgbywgYXJncykgeyByZXR1cm4gZi5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bl9jYWxsIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19mdW5fY2FsbChmLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gZigpO1xuICBjYXNlIDI6IHJldHVybiBmIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gZiAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICByZXR1cm4gZi5hcHBseShudWxsLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19tZXRoX2NhbGwgKG11dGFibGUsIGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19tZXRoX2NhbGwobywgZiwgYXJncykge1xuICByZXR1cm4gb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhmKV0uYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbmV3IChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19uZXcoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgY2FtbF9qc19mcm9tX2FycmF5KGEpKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX29qc19uZXdfYXJyIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9vanNfbmV3X2FycihjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAwOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjIChhWzBdKTtcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBhKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihsZW4gPiAwKXtcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFt1bmRlZmluZWRdKTtcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50c1xuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgW2FyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihuID09IGFyaXR5ICYmIGYubGVuZ3RoID09IGFyaXR5KSByZXR1cm4gZi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5KTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZixhcmdzKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsW3RoaXMsYXJnc10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5ICsgMSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTsgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc19lcXVhbHMgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19lcXVhbHMgKHgsIHkpIHsgcmV0dXJuICsoeCA9PSB5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V2YWxfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V2YWxfc3RyaW5nIChzKSB7cmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHByIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXhwcihzKSB7XG4gIGpzX3ByaW50X3N0ZGVycihcImNhbWxfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3B1cmVfanNfZXhwciBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3B1cmVfanNfZXhwciAocyl7XG4gIGpzX3ByaW50X3N0ZGVycihcImNhbWxfcHVyZV9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb2JqZWN0IChvYmplY3RfbGl0ZXJhbClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX29iamVjdCAoYSkge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IGFbaV07XG4gICAgb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwWzFdKV0gPSBwWzJdO1xuICB9XG4gIHJldHVybiBvO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwb3J0X3ZhclxuZnVuY3Rpb24gY2FtbF9qc19leHBvcnRfdmFyICgpe1xuICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzXG4gIGVsc2VcbiAgICByZXR1cm4gam9vX2dsb2JhbF9vYmplY3Q7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUodW5pdCl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmKHR5cGVvZiBnLlhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5YTUxIdHRwUmVxdWVzdCB9IGNhdGNoIChlKSB7IH07XG4gIH1cbiAgaWYodHlwZW9mIGcuYWN0aXZlWE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNc3htbDMuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgfVxuICBjYW1sX2ZhaWx3aXRoKFwiQ2Fubm90IGNyZWF0ZSBhIFhNTEh0dHBSZXF1ZXN0XCIpO1xufVxuIiwiLy9Qcm92aWRlczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIHVuaXhfZ2V0dGltZW9mZGF5ICgpIHtcbiAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3RpbWVcbi8vUmVxdWlyZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X3RpbWUgKCkge1xuICByZXR1cm4gTWF0aC5mbG9vcih1bml4X2dldHRpbWVvZmRheSAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfZ210aW1lXG5mdW5jdGlvbiB1bml4X2dtdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICBkLmdldFVUQ0RhdGUoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgIGQuZ2V0VVRDRGF5KCksIGRveSxcbiAgICAgICAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X2xvY2FsdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgdmFyIGphbiA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIHZhciBqdWwgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldEhvdXJzKCksXG4gICAgICAgICAgZC5nZXREYXRlKCksIGQuZ2V0TW9udGgoKSwgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICBkLmdldERheSgpLCBkb3ksXG4gICAgICAgICAgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IHN0ZFRpbWV6b25lT2Zmc2V0KSB8IDAgLyogZGF5bGlnaHQgc2F2aW5ncyB0aW1lICBmaWVsZC4gKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbWt0aW1lXG4vL1JlcXVpcmVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9ta3RpbWUodG0pe1xuICB2YXIgZCA9IChuZXcgRGF0ZSh0bVs2XSsxOTAwLHRtWzVdLHRtWzRdLHRtWzNdLHRtWzJdLHRtWzFdKSkuZ2V0VGltZSgpO1xuICB2YXIgdCA9IE1hdGguZmxvb3IoZCAvIDEwMDApO1xuICB2YXIgdG0yID0gdW5peF9sb2NhbHRpbWUodCk7XG4gIHJldHVybiBCTE9DSygwLHQsdG0yKTtcbn1cblxuLy9Qcm92aWRlczogd2luX3N0YXJ0dXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9zdGFydHVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2NsZWFudXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9jbGVhbnVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2hhbmRsZV9mZCBjb25zdFxuZnVuY3Rpb24gd2luX2hhbmRsZV9mZCh4KSB7cmV0dXJuIHg7fVxuXG4vL1Byb3ZpZGVzOiB1bml4X2lzYXR0eSBcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiB1bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuICAgIHJldHVybiB0dHkuaXNhdHR5KGZpbGVEZXNjcmlwdG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2ludCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcsIGNhbWxfc3RyX3JlcGVhdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfaW50KGZtdCwgaSkge1xuICBpZiAoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpID09IFwiJWRcIikgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIitpKTtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoaSA8IDApIHsgaWYgKGYuc2lnbmVkY29udikgeyBmLnNpZ24gPSAtMTsgaSA9IC1pOyB9IGVsc2UgaSA+Pj49IDA7IH1cbiAgdmFyIHMgPSBpLnRvU3RyaW5nKGYuYmFzZSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gcy5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBzID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgcztcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocykge1xuICB2YXIgaSA9IDAsIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSwgYmFzZSA9IDEwLCBzaWduID0gMTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKSkge1xuICAgIGNhc2UgNDU6IGkrKzsgc2lnbiA9IC0xOyBicmVhaztcbiAgICBjYXNlIDQzOiBpKys7IHNpZ24gPSAxOyBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGkgKyAxIDwgbGVuICYmIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSkgPT0gNDgpXG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAxKSkge1xuICAgIGNhc2UgMTIwOiBjYXNlIDg4OiBiYXNlID0gMTY7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTE6IGNhc2UgNzk6IGJhc2UgPSAgODsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlICA5ODogY2FzZSA2NjogYmFzZSA9ICAyOyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTE3OiBjYXNlIDg1OiBpICs9IDI7IGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFtpLCBzaWduLCBiYXNlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9kaWdpdFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9kaWdpdChjKSB7XG4gIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpICByZXR1cm4gYyAtIDQ4O1xuICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSAgcmV0dXJuIGMgLSA1NTtcbiAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHJldHVybiBjIC0gODc7XG4gIHJldHVybiAtMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2ludF9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIHRocmVzaG9sZCA9IC0xID4+PiAwO1xuICB2YXIgYyA9IChpIDwgbGVuKT9jYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpOjA7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBkO1xuICBmb3IgKGkrKztpPGxlbjtpKyspIHtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgcmVzID0gYmFzZSAqIHJlcyArIGQ7XG4gICAgaWYgKHJlcyA+IHRocmVzaG9sZCkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgLy8gRm9yIGJhc2UgZGlmZmVyZW50IGZyb20gMTAsIHdlIGV4cGVjdCBhbiB1bnNpZ25lZCByZXByZXNlbnRhdGlvbixcbiAgLy8gaGVuY2UgYW55IHZhbHVlIG9mICdyZXMnIChsZXNzIHRoYW4gJ3RocmVzaG9sZCcpIGlzIGFjY2VwdGFibGUuXG4gIC8vIEJ1dCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gIHJlcyA9IHNpZ24gKiByZXM7XG4gIGlmICgoYmFzZSA9PSAxMCkgJiYgKChyZXMgfCAwKSAhPSByZXMpKVxuICAgIC8qIFNpZ25lZCByZXByZXNlbnRhdGlvbiBleHBlY3RlZCwgYWxsb3cgLTJeKG5iaXRzLTEpIHRvIDJeKG5iaXRzLTEpIC0gMSAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tdWwgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbXVsKGEsYil7XG4gIHJldHVybiBNYXRoLmltdWwoYSxiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfZGl2KHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4gKHgveSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfbW9kKHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4geCV5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Jzd2FwMTZcbmZ1bmN0aW9uIGNhbWxfYnN3YXAxNih4KSB7XG4gIHJldHVybiAoKCgoeCAmIDB4MDBGRikgPDwgOCkgfFxuICAgICAgICAgICAoKHggJiAweEZGMDApID4+IDgpKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuICgoKHggJiAweDAwMDAwMEZGKSA8PCAyNCkgfFxuICAgICAgICAgICgoeCAmIDB4MDAwMEZGMDApIDw8IDgpIHxcbiAgICAgICAgICAoKHggJiAweDAwRkYwMDAwKSA+Pj4gOCkgfFxuICAgICAgICAgICgoeCAmIDB4RkYwMDAwMDApID4+PiAyNCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9ic3dhcFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9ic3dhcCh4KSB7XG4gIHZhciB5ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh4KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW3lbN10sIHlbNl0sIHlbNV0sIHlbNF0sIHlbM10sIHlbMl0sIHlbMV0sIHlbMF1dKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSGFzaHRibFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfdW5pdl9wYXJhbSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfdW5pdl9wYXJhbSAoY291bnQsIGxpbWl0LCBvYmopIHtcbiAgdmFyIGhhc2hfYWNjdSA9IDA7XG4gIGZ1bmN0aW9uIGhhc2hfYXV4IChvYmopIHtcbiAgICBsaW1pdCAtLTtcbiAgICBpZiAoY291bnQgPCAwIHx8IGxpbWl0IDwgMCkgcmV0dXJuO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSAmJiBvYmpbMF0gPT09IChvYmpbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAob2JqWzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmpbMl0pIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBsaW1pdCsrOyBoYXNoX2F1eChvYmopOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBvYmpbMF0pIHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG9iai5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSBoYXNoX2F1eCAob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMob2JqKSkge1xuICAgICAgY291bnQgLS07XG4gICAgICBzd2l0Y2ggKG9iai50ICYgNikge1xuICAgICAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKG9iaik7XG4gICAgICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgICAgIGZvciAodmFyIGIgPSBvYmouYywgbCA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKG9iaiksIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IG9iai5jLCBsID0gY2FtbF9tbF9ieXRlc19sZW5ndGgob2JqKSwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYVtpXSkgfCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcob2JqKSkge1xuICAgICAgICB2YXIganNieXRlcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob2JqKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IGpzYnl0ZXMsIGwgPSBqc2J5dGVzLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSBvYmosIGwgPSBvYmoubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gKG9ianwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgY291bnQgLS07XG4gICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmopIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gK29iaikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGNvdW50LS07XG4gICAgICB2YXIgcCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAob2JqKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIHBbaV0pIHwgMDtcbiAgICB9IGVsc2UgaWYob2JqICYmIG9iai5jYW1sX2N1c3RvbSkge1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaCA9IGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gob2JqKSB8IDA7XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIGgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzaF9hdXggKG9iaik7XG4gIHJldHVybiBoYXNoX2FjY3UgJiAweDNGRkZGRkZGO1xufVxuXG4vL2Z1bmN0aW9uIFJPVEwzMih4LG4pIHsgcmV0dXJuICgoeCA8PCBuKSB8ICh4ID4+PiAoMzItbikpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludChoLGQpIHtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4Y2M5ZTJkNTF8MCk7XG4gIGQgPSAoKGQgPDwgMTUpIHwgKGQgPj4+ICgzMi0xNSkpKTsgLy8gUk9UTDMyKGQsIDE1KTtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4MWI4NzM1OTMpO1xuICBoIF49IGQ7XG4gIGggPSAoKGggPDwgMTMpIHwgKGggPj4+ICgzMi0xMykpKTsgICAvL1JPVEwzMihoLCAxMyk7XG4gIHJldHVybiAoKChoICsgKGggPDwgMikpfDApICsgKDB4ZTY1NDZiNjR8MCkpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpIHtcbiAgaCBePSBoID4+PiAxNjtcbiAgaCA9IGNhbWxfbXVsIChoLCAweDg1ZWJjYTZifDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwgKGgsIDB4YzJiMmFlMzV8MCk7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaGFzaF9taXhfaW50NjRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmxvYXQgKGgsIHYwKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAodjApKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2xvMzIsIGNhbWxfaW50NjRfaGkzMlxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQ2NCAoaCwgdikge1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9sbzMyKHYpKTtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfaGkzMih2KSk7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHMuY2hhckNvZGVBdChpKVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgOClcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzIpIDw8IDE2KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHMuY2hhckNvZGVBdChpKzEpIDw8IDg7XG4gIGNhc2UgMTpcbiAgICB3IHw9IHMuY2hhckNvZGVBdChpKTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzW2ldXG4gICAgICB8IChzW2krMV0gPDwgOClcbiAgICAgIHwgKHNbaSsyXSA8PCAxNilcbiAgICAgIHwgKHNbaSszXSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHNbaSsyXSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHNbaSsxXSA8PCA4O1xuICBjYXNlIDE6IHcgfD0gc1tpXTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzKGgsIHYpIHtcbiAgc3dpdGNoICh2LnQgJiA2KSB7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAodik7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHYuYyk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgdi5jKTtcbiAgfVxuICByZXR1cm4gaFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZyh2KSk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9mbG9hdCwgY2FtbF9oYXNoX21peF9zdHJpbmcsIGNhbWxfaGFzaF9taXhfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2hhc2ggKGNvdW50LCBsaW1pdCwgc2VlZCwgb2JqKSB7XG4gIHZhciBxdWV1ZSwgcmQsIHdyLCBzeiwgbnVtLCBoLCB2LCBpLCBsZW47XG4gIHN6ID0gbGltaXQ7XG4gIGlmIChzeiA8IDAgfHwgc3ogPiAyNTYpIHN6ID0gMjU2O1xuICBudW0gPSBjb3VudDtcbiAgaCA9IHNlZWQ7XG4gIHF1ZXVlID0gW29ial07IHJkID0gMDsgd3IgPSAxO1xuICB3aGlsZSAocmQgPCB3ciAmJiBudW0gPiAwKSB7XG4gICAgdiA9IHF1ZXVlW3JkKytdO1xuICAgIGlmICh2ICYmIHYuY2FtbF9jdXN0b20pe1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoaCA9IGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKHYpO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQgKGgsIGhoKTtcbiAgICAgICAgbnVtIC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAodlswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdlsyXSk7XG4gICAgICAgIG51bS0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIHF1ZXVlWy0tcmRdID0gdlsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgdGFnID0gKCh2Lmxlbmd0aCAtIDEpIDw8IDEwKSB8IHZbMF07XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB0YWcpO1xuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSB2Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHdyID49IHN6KSBicmVhaztcbiAgICAgICAgICBxdWV1ZVt3cisrXSA9IHZbaV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9ieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmcoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfanNieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICh2fDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdit2KzEpO1xuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSArdikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsdik7XG4gICAgICBudW0tLTtcbiAgICB9XG4gIH1cbiAgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoaCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSl7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoYSkpIHJldHVybiAyNTI7IC8vIHN0cmluZ190YWdcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoYSkpIHJldHVybiAxMjUyOyAvLyBvY2FtbCBzdHJpbmcgKGlmIGRpZmZlcmVudCBmcm9tIGJ5dGVzKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkgJiYgYVswXSA9PT0gKGFbMF0+Pj4wKSAmJiBhWzBdIDw9IDI1NSkge1xuICAgIC8vIExvb2sgbGlrZSBhbiBvY2FtbCBibG9ja1xuICAgIHZhciB0YWcgPSBhWzBdIHwgMDtcbiAgICAvLyBpZ25vcmUgZG91YmxlX2FycmF5X3RhZyBiZWNhdXNlIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IHNldFxuICAgIC8vIHRoaXMgdGFnIHdoZW4gd2UgY3JlYXRlIGFuIGFycmF5IG9mIGZsb2F0LlxuICAgIHJldHVybiAodGFnID09IDI1NCk/MDp0YWdcbiAgfVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChhICYmIGEuY2FtbF9jdXN0b20pIHJldHVybiAxMjU1OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAoYSAmJiBhLmNvbXBhcmUpIHJldHVybiAxMjU2OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gMTI0NzsgLy8gbGlrZSBjbG9zdXJlX3RhZyAoMjQ3KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN5bWJvbFwiKSByZXR1cm4gMTI1MTtcbiAgcmV0dXJuIDEwMDE7IC8vb3V0X29mX2hlYXBfdGFnXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSl7XG4gIHJldHVybiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dLmNvbXBhcmU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20obnVtLCBjdXN0b20sIHN3YXAsIHRvdGFsKSB7XG4gIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGN1c3RvbSk7XG4gIGlmKGNvbXApIHtcbiAgICB2YXIgeCA9IChzd2FwID4gMCk/Y29tcChjdXN0b20sbnVtLHRvdGFsKTpjb21wKG51bSxjdXN0b20sdG90YWwpO1xuICAgIGlmKHRvdGFsICYmIHggIT0geCkgcmV0dXJuIHN3YXA7IC8vIHRvdGFsICYmIG5hblxuICAgIGlmKCt4ICE9ICt4KSByZXR1cm4gK3g7IC8vIG5hblxuICAgIGlmKCh4IHwgMCkgIT0gMCkgcmV0dXJuICh4IHwgMCk7IC8vICFuYW5cbiAgfVxuICByZXR1cm4gc3dhcFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsIChjb25zdCwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnRfY29tcGFyZSwgY2FtbF9zdHJpbmdfY29tcGFyZSwgY2FtbF9ieXRlc19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSwgY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpO1xuICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEN1c3RvbV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gb2NhbWwgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAoYS5sZW5ndGggPCBiLmxlbmd0aCk/LTE6MTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID4gMSkgc3RhY2sucHVzaChhLCBiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGkgPSBzdGFjay5wb3AoKTtcbiAgICBiID0gc3RhY2sucG9wKCk7XG4gICAgYSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmIChpICsgMSA8IGEubGVuZ3RoKSBzdGFjay5wdXNoKGEsIGIsIGkgKyAxKTtcbiAgICBhID0gYVtpXTtcbiAgICBiID0gYltpXTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmUgKGEsIGIpIHsgcmV0dXJuIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRydWUpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9jb21wYXJlIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfaW50X2NvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gKC0xKTsgaWYgKGEgPT0gYikgcmV0dXJuIDA7IHJldHVybiAxO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA9PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX25vdGVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSAhPSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVyZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVyZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID49IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJ0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcnRoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID4gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzdGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3N0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8IDApOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2QobG9jLHNoYXBlKSB7XG4gIGZ1bmN0aW9uIHVuZGVmX21vZHVsZSAoX3gpIHtcbiAgICBjYW1sX3JhaXNlX3dpdGhfYXJnKGNhbWxfZ2xvYmFsX2RhdGEuVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUsIGxvYyk7XG4gIH1cbiAgZnVuY3Rpb24gbG9vcCAoc2hhcGUsc3RydWN0LGlkeCl7XG4gICAgaWYodHlwZW9mIHNoYXBlID09PSBcIm51bWJlclwiKVxuICAgICAgc3dpdGNoKHNoYXBlKXtcbiAgICAgIGNhc2UgMDovL2Z1bmN0aW9uXG4gICAgICAgIHN0cnVjdFtpZHhdPXtmdW46dW5kZWZfbW9kdWxlfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6Ly9sYXp5XG4gICAgICAgIHN0cnVjdFtpZHhdPVsyNDYsIHVuZGVmX21vZHVsZV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDovL2Nhc2UgMjovL2NsYXNzXG4gICAgICAgIHN0cnVjdFtpZHhdPVtdO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHN3aXRjaChzaGFwZVswXSl7XG4gICAgICBjYXNlIDA6Ly9tb2R1bGVcbiAgICAgICAgc3RydWN0W2lkeF0gPSBbMF07XG4gICAgICAgIGZvcih2YXIgaT0xO2k8c2hhcGVbMV0ubGVuZ3RoO2krKylcbiAgICAgICAgICBsb29wKHNoYXBlWzFdW2ldLHN0cnVjdFtpZHhdLGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6Ly9jYXNlIDE6Ly9WYWx1ZVxuICAgICAgICBzdHJ1Y3RbaWR4XSA9IHNoYXBlWzFdO1xuICAgICAgfVxuICB9XG4gIHZhciByZXMgPSBbXTtcbiAgbG9vcChzaGFwZSxyZXMsMCk7XG4gIHJldHVybiByZXNbMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kKHNoYXBlLHJlYWwseCkge1xuICBpZih0eXBlb2Ygc2hhcGUgPT09IFwibnVtYmVyXCIpXG4gICAgc3dpdGNoKHNoYXBlKXtcbiAgICBjYXNlIDA6Ly9mdW5jdGlvblxuICAgIGNhc2UgMTovL2xhenlcbiAgICBjYXNlIDI6Ly9jbGFzc1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW1sX3VwZGF0ZV9kdW1teShyZWFsLHgpO1xuICAgIH1cbiAgZWxzZVxuICAgIHN3aXRjaChzaGFwZVswXSl7XG4gICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgIGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Qoc2hhcGVbMV1baV0scmVhbFtpXSx4W2ldKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy9jYXNlIDE6Ly9WYWx1ZVxuICAgIGRlZmF1bHQ6XG4gICAgfTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX3VwZGF0ZV9kdW1teSAoeCwgeSkge1xuICBpZiggdHlwZW9mIHk9PT1cImZ1bmN0aW9uXCIgKSB7IHguZnVuID0geTsgcmV0dXJuIDA7IH1cbiAgaWYoIHkuZnVuICkgeyB4LmZ1biA9IHkuZnVuOyByZXR1cm4gMDsgfVxuICB2YXIgaSA9IHkubGVuZ3RoOyB3aGlsZSAoaS0tKSB4W2ldID0geVtpXTsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2lzX2Jsb2NrIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2lzX2Jsb2NrICh4KSB7IHJldHVybiArKHggaW5zdGFuY2VvZiBBcnJheSk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29ial90YWcgKHgpIHtcbiAgaWYgKCh4IGluc3RhbmNlb2YgQXJyYXkpICYmIHhbMF0gPT0gKHhbMF0gPj4+IDApKVxuICAgIHJldHVybiB4WzBdXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKCh4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8IHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMjQ3XG4gIGVsc2UgaWYgKHggJiYgeC5jYW1sX2N1c3RvbSlcbiAgICByZXR1cm4gMjU1XG4gIGVsc2VcbiAgICByZXR1cm4gMTAwMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfdGFnIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF90YWcgKHgsIHRhZykgeyB4WzBdID0gdGFnOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfYmxvY2sgY29uc3QgKGNvbnN0LGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfYmxvY2sgKHRhZywgc2l6ZSkge1xuICB2YXIgbyA9IG5ldyBBcnJheShzaXplKzEpO1xuICBvWzBdPXRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSBvW2ldID0gMDtcbiAgcmV0dXJuIG87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3dpdGhfdGFnXG5mdW5jdGlvbiBjYW1sX29ial93aXRoX3RhZyh0YWcseCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yKHZhciBpID0gMTsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfZHVwICh4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90cnVuY2F0ZSAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfb2JqX3RydW5jYXRlICh4LCBzKSB7XG4gIGlmIChzPD0wIHx8IHMgKyAxID4geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIk9iai50cnVuY2F0ZVwiKTtcbiAgaWYgKHgubGVuZ3RoICE9IHMgKyAxKSB4Lmxlbmd0aCA9IHMgKyAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfbWFrZV9mb3J3YXJkXG5mdW5jdGlvbiBjYW1sX29ial9tYWtlX2ZvcndhcmQgKGIsdikge1xuICBiWzBdPTI1MDtcbiAgYlsxXT12O1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgKHYpIHsgcmV0dXJuIFsyNTAsIHZdOyB9XG5cbi8vLy8vLy8vLy8vLy8gQ2FtbGludGVybmFsT09cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgY29uc3RcbnZhciBjYW1sX21ldGhvZF9jYWNoZSA9IFtdO1xuZnVuY3Rpb24gY2FtbF9nZXRfcHVibGljX21ldGhvZCAob2JqLCB0YWcsIGNhY2hlaWQpIHtcbiAgdmFyIG1ldGhzID0gb2JqWzFdO1xuICB2YXIgb2ZzID0gY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF07XG4gIGlmIChvZnMgPT09IG51bGwpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29vX2xhc3RfaWRcbnZhciBjYW1sX29vX2xhc3RfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX3NldF9vb19pZCAoYikge1xuICBiWzJdPWNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsYnMuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlcihicykge1xuICByZXR1cm4gYnMuZGF0YS5idWZmZXJcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShhYik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShiYSkge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShiYS5idWZmZXIsIGJhLmJ5dGVPZmZzZXQsIGJhLmxlbmd0aCAqIGJhLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfbWVtY21wXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19tZW1jbXAoczEsIHBvczEsIHMyLCBwb3MyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHMxLHBvczEgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEoczIscG9zMiArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShiYTEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLG9mczErbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLHBvczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF9hcnJheV9vZl9ieXRlcyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhiYTEsIHBvczEsIGJ5dGVzMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYocG9zMiArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ5dGVzMikpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zbGljZShvZnMxLCBvZnMxK2xlbik7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KHNsaWNlKSwgMCwgYnl0ZXMyLCBwb3MyLCBsZW4pO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVjb3JkX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3QgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZV9zbG90OiBpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlKGV4biwgYnQpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrICgpIHsgcmV0dXJuIFswXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90KCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCIpO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IGxleGluZy5jIDYwNDUgMjAwNC0wMS0wMSAxNjo0Mjo0M1ogZG9saWdleiAkICovXG5cbi8qIFRoZSB0YWJsZS1kcml2ZW4gYXV0b21hdG9uIGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXguICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9hcnJheShzKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICB2YXIgbCA9IHMubGVuZ3RoIC8gMjtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgIGFbaV0gPSAocy5jaGFyQ29kZUF0KDIgKiBpKSB8IChzLmNoYXJDb2RlQXQoMiAqIGkgKyAxKSA8PCA4KSkgPDwgMTYgPj4gMTY7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5LCBjYW1sX2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHJldHVybiAtYmFzZS0xO1xuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogTmV3IGxleGVyIGVuZ2luZSwgd2l0aCBtZW1vcnkgb2YgcG9zaXRpb25zICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX21lbShzLCBpLCBtZW0sIGN1cnJfcG9zKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm47XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBjdXJyX3BvcztcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fdGFnKHMsIGksIG1lbSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuIDtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IC0xO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbmV3X2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9tZW0gPSAxMDtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuICB2YXIgbGV4X2Jhc2VfY29kZSA9IDY7XG4gIHZhciBsZXhfYmFja3Rya19jb2RlID0gNztcbiAgdmFyIGxleF9kZWZhdWx0X2NvZGUgPSA4O1xuICB2YXIgbGV4X3RyYW5zX2NvZGUgPSA5O1xuICB2YXIgbGV4X2NoZWNrX2NvZGUgPSAxMDtcbiAgdmFyIGxleF9jb2RlID0gMTE7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHRfY29kZSkge1xuICAgIHRibC5sZXhfYmFzZV9jb2RlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV9jb2RlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrX2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrX2NvZGVdKTtcbiAgICB0YmwubGV4X2NoZWNrX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrX2NvZGVdKTtcbiAgICB0YmwubGV4X3RyYW5zX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zX2NvZGVdKTtcbiAgICB0YmwubGV4X2RlZmF1bHRfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRfY29kZV0pO1xuICB9XG4gIGlmICh0YmwubGV4X2NvZGUgPT0gbnVsbCkgdGJsLmxleF9jb2RlID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0YmxbbGV4X2NvZGVdKTtcblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFzZV9jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICByZXR1cm4gLWJhc2UtMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZSA7XG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLCBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09IHBzdGF0ZSlcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF90cmFuc19jb2RlW2Jhc2VfY29kZSArIGNdO1xuICAgICAgZWxzZVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X2RlZmF1bHRfY29kZVtwc3RhdGVdO1xuICAgICAgaWYgKHBjX29mZiA+IDApXG4gICAgICAgIGNhbWxfbGV4X3J1bl9tZW1cbiAgICAgICh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dLCBsZXhidWZbbGV4X2N1cnJfcG9zXSk7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gQXJyYXlcblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zdWIgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9zdWIgKGEsIGksIGxlbikge1xuICB2YXIgYTIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBhMlswXT0wO1xuICBmb3IodmFyIGkyID0gMSwgaTE9IGkrMTsgaTIgPD0gbGVuOyBpMisrLGkxKysgKXtcbiAgICBhMltpMl09YVtpMV07XG4gIH1cbiAgcmV0dXJuIGEyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2FwcGVuZCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2FwcGVuZChhMSwgYTIpIHtcbiAgdmFyIGwxID0gYTEubGVuZ3RoLCBsMiA9IGEyLmxlbmd0aDtcbiAgdmFyIGwgPSBsMStsMi0xXG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gMDtcbiAgdmFyIGkgPSAxLGogPSAxO1xuICBmb3IoO2k8bDE7aSsrKSBhW2ldPWExW2ldO1xuICBmb3IoO2k8bDtpKyssaisrKSBhW2ldPWEyW2pdO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9jb25jYXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9zZXQgKGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYXJyYXlbaW5kZXgrMV09bmV3dmFsOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9maWxsXG5mdW5jdGlvbiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBhcnJheVtvZnMraSsxXSA9IHY7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hlY2tfYm91bmQgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfdmVjdCAobGVuLCBpbml0KSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0wO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gaW5pdDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9mbG9hdF92ZWN0IGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV9mbG9hdF92ZWN0KGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlKGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJLCBidXQgd2l0aG91dCB0aGUgd2VhayBzZW1hbnRpY3NcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vVmVyc2lvbjogPCA0LjAzXG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfZGF0YV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jcmVhdGUgKG4pIHtcbiAgaWYgKG4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5jcmVhdGVcIik7XG4gIHZhciB4ID0gWzI1MSxcImNhbWxfZXBoZV9saXN0X2hlYWRcIl07XG4gIHgubGVuZ3RoID0gY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBuO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX3NldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX3NldCh4LCBpLCB2KSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5zZXRcIik7XG4gIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldCh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfa2V5XCIpO1xuICByZXR1cm4gKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpIF09PT11bmRlZmluZWQpPzA6eFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldF9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0LGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXAsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldF9jb3B5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9jb3B5XCIpO1xuICB2YXIgeSA9IGNhbWxfd2Vha19nZXQoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoeiBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY2hlY2sgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jaGVjayh4LCBpKSB7XG4gIGlmKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSE9PXVuZGVmaW5lZCAmJiB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gIT09MClcbiAgICByZXR1cm4gMTtcbiAgZWxzZVxuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF93ZWFrX2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICAvLyBtaW51cyBvbmUgYmVjYXVzZSBjYW1sX2FycmF5X2JsaXQgd29ya3Mgb24gb2NhbWwgYXJyYXlcbiAgY2FtbF9hcnJheV9ibGl0KGExLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkxIC0gMSxcbiAgICAgICAgICAgICAgICAgIGEyLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkyIC0gMSxcbiAgICAgICAgICAgICAgICAgIGxlbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY3JlYXRlXG52YXIgY2FtbF9lcGhlX2NyZWF0ZSA9IGNhbWxfd2Vha19jcmVhdGVcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfYmxpdFxudmFyIGNhbWxfZXBoZV9ibGl0X2tleSA9IGNhbWxfd2Vha19ibGl0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0XG52YXIgY2FtbF9lcGhlX2dldF9rZXkgPSBjYW1sX3dlYWtfZ2V0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXRfY29weVxudmFyIGNhbWxfZXBoZV9nZXRfa2V5X2NvcHkgPSBjYW1sX3dlYWtfZ2V0X2NvcHlcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NoZWNrXG52YXIgY2FtbF9lcGhlX2NoZWNrX2tleSA9IGNhbWxfd2Vha19jaGVja1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX3NldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9rZXkoeCwgaSwgdikge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCBbMCwgdl0pXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9rZXkoeCwgaSkge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCAwKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2JsaXRfZGF0YShzcmMsIGRzdCl7XG4gIGRzdFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gc3JjW2NhbWxfZXBoZV9kYXRhX29mZnNldF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF1dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXBcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfZGF0YSh4LCBkYXRhKXtcbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gZGF0YTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIDE7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9jaGFuXG4vL1JlcXVpcmVzOiBjYW1sX21kNV9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2FycmF5LGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfY2hhbihjaGFuaWQsbGVuKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBjaGFuX2xlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYobGVuPDApIGxlbiA9IGNoYW5fbGVuIC0gY2hhbi5vZmZzZXQ7XG4gIGlmKGNoYW4ub2Zmc2V0ICsgbGVuID4gY2hhbl9sZW4pIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG4gIHJldHVybiBjYW1sX21kNV9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnVmKSwwLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfbWQ1X2J5dGVzXG5mdW5jdGlvbiBjYW1sX21kNV9zdHJpbmcocywgb2ZzLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfbWQ1X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpLG9mcyxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbnZhciBjYW1sX21kNV9ieXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkICh4LCB5KSB7IHJldHVybiAoeCArIHkpIHwgMDsgfVxuICBmdW5jdGlvbiB4eChxLGEsYix4LHMsdCkge1xuICAgIGEgPSBhZGQoYWRkKGEsIHEpLCBhZGQoeCwgdCkpO1xuICAgIHJldHVybiBhZGQoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBmZihhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpOyB9XG4gIGZ1bmN0aW9uIGlpKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTsgfVxuXG4gIGZ1bmN0aW9uIG1kNShidWZmZXIsIGxlbmd0aCkge1xuICAgIHZhciBpID0gbGVuZ3RoO1xuICAgIGJ1ZmZlcltpID4+IDJdIHw9IDB4ODAgPDwgKDggKiAoaSAmIDMpKTtcbiAgICBmb3IgKGkgPSAoaSAmIH4weDMpICsgODsoaSAmIDB4M0YpIDwgNjAgO2kgKz0gNClcbiAgICAgIGJ1ZmZlclsoaSA+PiAyKSAtIDFdID0gMDtcbiAgICBidWZmZXJbKGkgPj4gMikgLTFdID0gbGVuZ3RoIDw8IDM7XG4gICAgYnVmZmVyW2kgPj4gMl0gPSAobGVuZ3RoID4+IDI5KSAmIDB4MUZGRkZGRkY7XG5cbiAgICB2YXIgdyA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XTtcblxuICAgIGZvcihpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDFdLCAxMiwgMHhFOEM3Qjc1Nik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA3LCAweEY1N0MwRkFGKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgN10sIDIyLCAweEZENDY5NTAxKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTcsIDB4RkZGRjVCQjEpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krMTNdLCAxMiwgMHhGRDk4NzE5Myk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDUsIDB4RjYxRTI1NjIpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDBdLCAyMCwgMHhFOUI2QzdBQSk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTQsIDB4RDhBMUU2ODEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTRdLCA5LCAweEMzMzcwN0Q2KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDUsIDB4QTlFM0U5MDUpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krMTJdLCAyMCwgMHg4RDJBNEM4QSk7XG5cbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTYsIDB4NkQ5RDYxMjIpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDRdLCAxMSwgMHg0QkRFQ0ZBOSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA0LCAweDI4OUI3RUM2KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgNl0sIDIzLCAweDA0ODgxRDA1KTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTYsIDB4MUZBMjdDRjgpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgN10sIDEwLCAweDQzMkFGRjk3KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDYsIDB4NjU1QjU5QzMpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAxXSwgMjEsIDB4ODU4NDVERDEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNSwgMHhBMzAxNDMxNCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxMV0sIDEwLCAweEJEM0FGMjM1KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICAgIHdbMV0gPSBhZGQoYiwgd1sxXSk7XG4gICAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IG5ldyBBcnJheSgxNik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgdFtpICogNCArIGpdID0gKHdbaV0gPj4gKDggKiBqKSkgJiAweEZGO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzLCBvZnMsIGxlbikge1xuICAgIC8vIEZJWDogbWF5YmUgd2Ugc2hvdWxkIHBlcmZvcm0gdGhlIGNvbXB1dGF0aW9uIGJ5IGNodW5rIG9mIDY0IGJ5dGVzXG4gICAgLy8gYXMgaW4gaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUuanNcbiAgICB2YXIgYnVmID0gW107XG4gICAgc3dpdGNoIChzLnQgJiA2KSB7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gICAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgICAgdmFyIGIgPSBzLmM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgICB2YXIgaiA9IGkgKyBvZnM7XG4gICAgICAgIGJ1ZltpPj4yXSA9XG4gICAgICAgICAgYi5jaGFyQ29kZUF0KGopIHwgKGIuY2hhckNvZGVBdChqKzEpIDw8IDgpIHxcbiAgICAgICAgICAoYi5jaGFyQ29kZUF0KGorMikgPDwgMTYpIHwgKGIuY2hhckNvZGVBdChqKzMpIDw8IDI0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGJ1ZltpPj4yXSB8PSBiLmNoYXJDb2RlQXQoaSArIG9mcykgPDwgKDggKiAoaSAmIDMpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICAgIHZhciBhID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPSBhW2pdIHwgKGFbaisxXSA8PCA4KSB8IChhW2orMl0gPDwgMTYpIHwgKGFbaiszXSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYVtpICsgb2ZzXSA8PCAoOCAqIChpICYgMykpO1xuICAgIH1cbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkobWQ1KGJ1ZiwgbGVuKSk7XG4gIH1cbn0gKCk7XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBIdWdvIEhldXphcmRcbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIFNoYWNoYXIgSXR6aGFreVxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL29jYW1sL2Jsb2IvNC4wNy9vdGhlcmxpYnMvc3RyL3N0cnN0dWJzLmNcbi8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2NvcS9qc2NvcS9ibG9iL3Y4LjExL2NvcS1qcy9qc19zdHViL3N0ci5qc1xuXG4vL1Byb3ZpZGVzOiByZV9tYXRjaFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZ2V0XG5cbnZhciByZV9tYXRjaCA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZV93b3JkX2xldHRlcnMgPSBbXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHgwMC0weDFGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHhGRiwgMHgwMywgICAgICAgLyogMHgyMC0weDNGOiBkaWdpdHMgMC05ICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHg4NywgICAgICAgLyogMHg0MC0weDVGOiBBIHRvIFosIF8gKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDA3LCAgICAgICAvKiAweDYwLTB4N0Y6IGEgdG8geiAqL1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4ODAtMHg5Rjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4QTAtMHhCRjogbm9uZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYsICAgICAgIC8qIDB4QzAtMHhERjogTGF0aW4tMSBhY2NlbnRlZCB1cHBlcmNhc2UgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGICAgICAgICAvKiAweEUwLTB4RkY6IExhdGluLTEgYWNjZW50ZWQgbG93ZXJjYXNlICovXG4gIF07XG5cbiAgdmFyIG9wY29kZXMgPSB7XG4gICAgQ0hBUjogMCwgQ0hBUk5PUk06IDEsIFNUUklORzogMiwgU1RSSU5HTk9STTogMywgQ0hBUkNMQVNTOiA0LFxuICAgIEJPTDogNSwgRU9MOiA2LCBXT1JEQk9VTkRBUlk6IDcsXG4gICAgQkVHR1JPVVA6IDgsIEVOREdST1VQOiA5LCBSRUZHUk9VUDogMTAsXG4gICAgQUNDRVBUOiAxMSxcbiAgICBTSU1QTEVPUFQ6IDEyLCBTSU1QTEVTVEFSOiAxMywgU0lNUExFUExVUzogMTQsXG4gICAgR09UTzogMTUsIFBVU0hCQUNLOiAxNiwgU0VUTUFSSzogMTcsXG4gICAgQ0hFQ0tQUk9HUkVTUzogMThcbiAgfTtcblxuICBmdW5jdGlvbiBpc193b3JkX2xldHRlcihjKSB7XG4gICAgcmV0dXJuIChyZV93b3JkX2xldHRlcnNbICAoYyA+PiAzKV0gPj4gKGMgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fYml0c2V0KHMsaSkge1xuICAgIHJldHVybiAoY2FtbF9zdHJpbmdfZ2V0KHMsKGkgPj4gMykpID4+IChpICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlX21hdGNoX2ltcGwocmUsIHMsIHBvcywgcGFydGlhbCkge1xuXG4gICAgdmFyIHByb2cgICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMV0pLFxuICAgICAgICBjcG9vbCAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzJdKSxcbiAgICAgICAgbm9ybXRhYmxlICAgICA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVbM10pLFxuICAgICAgICBudW1ncm91cHMgICAgID0gcmVbNF0gfCAwLFxuICAgICAgICBudW1yZWdpc3RlcnMgID0gcmVbNV0gfCAwLFxuICAgICAgICBzdGFydGNoYXJzICAgID0gcmVbNl0gfCAwO1xuXG4gICAgdmFyIHMgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzKTtcblxuICAgIHZhciBwYyA9IDAsXG4gICAgICAgIHF1aXQgPSBmYWxzZSxcbiAgICAgICAgc3RhY2sgPSBbXSxcbiAgICAgICAgZ3JvdXBzID0gbmV3IEFycmF5KG51bWdyb3VwcyksXG4gICAgICAgIHJlX3JlZ2lzdGVyID0gbmV3IEFycmF5KG51bXJlZ2lzdGVycyk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGdyb3Vwc1tpXSA9IHtzdGFydDogLTEsIGVuZDotMX1cbiAgICB9XG4gICAgZ3JvdXBzWzBdLnN0YXJ0ID0gcG9zO1xuXG4gICAgdmFyIGJhY2t0cmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKGl0ZW0udW5kbykge1xuICAgICAgICAgIGl0ZW0udW5kby5vYmpbaXRlbS51bmRvLnByb3BdID0gaXRlbS51bmRvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoaXRlbS5wb3MpIHtcbiAgICAgICAgICBwYyA9IGl0ZW0ucG9zLnBjO1xuICAgICAgICAgIHBvcyA9IGl0ZW0ucG9zLnR4dDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1aXQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHsgc3RhY2sucHVzaChpdGVtKTsgfTtcblxuICAgIHZhciBhY2NlcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBncm91cHNbMF0uZW5kID0gcG9zO1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSgxICsgZ3JvdXBzLmxlbmd0aCoyKTtcbiAgICAgIHJlc3VsdFswXSA9IDA7IC8vIHRhZ1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBnID0gZ3JvdXBzW2ldO1xuICAgICAgICBpZihnLnN0YXJ0IDwgMCB8fCBnLmVuZCA8IDApIHtcbiAgICAgICAgICBnLnN0YXJ0ID0gZy5lbmQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbMippICsgMSBdID0gZy5zdGFydDtcbiAgICAgICAgcmVzdWx0WzIqaSArIDEgKyAxIF0gPSBnLmVuZDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIHZhciBwcmVmaXhfbWF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZihwYXJ0aWFsKSByZXR1cm4gYWNjZXB0ICgpO1xuICAgICAgZWxzZSBiYWNrdHJhY2sgKCk7XG4gICAgfVxuXG4gICAgLyogTWFpbiBERkEgaW50ZXJwcmV0ZXIgbG9vcCAqL1xuICAgIHdoaWxlICghcXVpdCkge1xuICAgICAgdmFyIG9wID0gcHJvZ1twY10gJiAweGZmLFxuICAgICAgICAgIHNhcmcgPSBwcm9nW3BjXSA+PiA4LFxuICAgICAgICAgIHVhcmcgPSBzYXJnICYgMHhmZixcbiAgICAgICAgICBjID0gc1twb3NdLFxuICAgICAgICAgIGdyb3VwO1xuXG4gICAgICBwYysrO1xuXG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUjpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAoYyA9PT0gdWFyZykgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVJOT1JNOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChub3JtdGFibGUuY2hhckNvZGVBdChjKSA9PT0gdWFyZykgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklORzpcbiAgICAgICAgZm9yICh2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmIChjID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HTk9STTpcbiAgICAgICAgZm9yICh2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmIChub3JtdGFibGUuY2hhckNvZGVBdChjKSA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVJDTEFTUzpcbiAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CT0w6XG4gICAgICAgIGlmKHBvcyA+IDAgJiYgc1twb3MgLSAxXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU9MOlxuICAgICAgICBpZihwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLldPUkRCT1VOREFSWTpcbiAgICAgICAgaWYocG9zID09IDApIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1swXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pICE9IGlzX3dvcmRfbGV0dGVyKHNbcG9zXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CRUdHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6Z3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuc3RhcnR9fSk7XG4gICAgICAgIGdyb3VwLnN0YXJ0ID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FTkRHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5lbmR9fSk7XG4gICAgICAgIGdyb3VwLmVuZCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUkVGR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBpZihncm91cC5zdGFydCA8IDAgfHwgZ3JvdXAuZW5kIDwgMCkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgIGZvciAodmFyIGkgPSBncm91cC5zdGFydDsgaSA8IGdyb3VwLmVuZDsgaSsrKXtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoc1tpXSAhPSBzW3Bvc10pIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRU9QVDpcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVTVEFSOlxuICAgICAgICB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSlcbiAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVBMVVM6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgfSB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQUNDRVBUOlxuICAgICAgICByZXR1cm4gYWNjZXB0KCk7XG4gICAgICBjYXNlIG9wY29kZXMuR09UTzpcbiAgICAgICAgcGMgPSBwYyArIHNhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlBVU0hCQUNLOlxuICAgICAgICBwdXNoKHtwb3M6IHtwYzogcGMgKyBzYXJnLCB0eHQ6IHBvc319KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0VUTUFSSzpcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpyZV9yZWdpc3RlcixcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6IHVhcmcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVfcmVnaXN0ZXJbdWFyZ119fSk7XG4gICAgICAgIHJlX3JlZ2lzdGVyW3VhcmddID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEVDS1BST0dSRVNTOlxuICAgICAgICBpZiAocmVfcmVnaXN0ZXJbdWFyZ10gPT09IHBvcykgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlY29kZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gcmVfbWF0Y2hfaW1wbDtcbn0oKTtcblxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfZm9yd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfZm9yd2FyZFwiKVxuICB3aGlsZSAocG9zIDw9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2JhY2t3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9iYWNrd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfYmFja3dhcmRcIilcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zLS07XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG5cbi8vUHJvdmlkZXM6IHJlX3N0cmluZ19tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zdHJpbmdfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc3RyaW5nX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9wYXJ0aWFsX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3BhcnRpYWxfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIucGFydGlhbF9tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMSk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcmVwbGFjZW1lbnRfdGV4dFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIGV4dGVybmFsIHJlX3JlcGxhY2VtZW50X3RleHQ6IHN0cmluZyAtPiBpbnQgYXJyYXkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuZnVuY3Rpb24gcmVfcmVwbGFjZW1lbnRfdGV4dChyZXBsLGdyb3VwcyxvcmlnKSB7XG4gIHZhciByZXBsID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZXBsKTtcbiAgdmFyIGxlbiA9IHJlcGwubGVuZ3RoO1xuICB2YXIgb3JpZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob3JpZyk7XG4gIHZhciByZXMgPSBcIlwiOyAvL3Jlc3VsdFxuICB2YXIgbiA9IDA7IC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgdmFyIGN1cjsgLy9jdXJyZW50IGNoYXJcbiAgdmFyIHN0YXJ0LCBlbmQsIGM7XG4gIHdoaWxlKG4gPCBsZW4pe1xuICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgaWYoY3VyICE9ICdcXFxcJyl7XG4gICAgICByZXMgKz0gY3VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKG4gPT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCIpO1xuICAgICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICAgIHN3aXRjaChjdXIpe1xuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIHJlcyArPSBjdXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICBjID0gK2N1cjtcbiAgICAgICAgaWYgKGMqMiA+PSBncm91cHMubGVuZ3RoIC0gMSApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIgKTtcbiAgICAgICAgc3RhcnQgPSBjYW1sX2FycmF5X2dldChncm91cHMsYyoyKTtcbiAgICAgICAgZW5kID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjKjIgKzEpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gLTEpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICByZXMrPW9yaWcuc2xpY2Uoc3RhcnQsZW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgKz0gKCdcXFxcJyAgKyBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhyZXMpOyB9XG4iLCIvL1RoZSBmb2xsb3dpbmcgYXJlIGRlZmluZWQgaW4gQ3N0cnVjdFxuLy9UaGVyZSBhcmUganVzdCBwcm92aWRlZCBoZXJlIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIERhbmllbCBDLiBCdWVuemxpICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcblxubGV0IGVycl9ub19wcmVkID0gXCJVKzAwMDAgaGFzIG5vIHByZWRlY2Vzc29yXCJcbmxldCBlcnJfbm9fc3VjYyA9IFwiVSsxMEZGRkYgaGFzIG5vIHN1Y2Nlc3NvclwiXG5sZXQgZXJyX25vdF9zdiBpID0gZm9ybWF0X2ludCBcIiVYXCIgaSBeIFwiIGlzIG5vdCBhbiBVbmljb2RlIHNjYWxhciB2YWx1ZVwiXG5sZXQgZXJyX25vdF9sYXRpbjEgdSA9IFwiVStcIiBeIGZvcm1hdF9pbnQgXCIlMDRYXCIgdSBeIFwiIGlzIG5vdCBhIGxhdGluMSBjaGFyYWN0ZXJcIlxuXG50eXBlIHQgPSBpbnRcblxubGV0IG1pbiA9IDB4MDAwMFxubGV0IG1heCA9IDB4MTBGRkZGXG5sZXQgbG9fYm91bmQgPSAweEQ3RkZcbmxldCBoaV9ib3VuZCA9IDB4RTAwMFxuXG5sZXQgYm9tID0gMHhGRUZGXG5sZXQgcmVwID0gMHhGRkZEXG5cbmxldCBzdWNjIHUgPVxuICBpZiB1ID0gbG9fYm91bmQgdGhlbiBoaV9ib3VuZCBlbHNlXG4gIGlmIHUgPSBtYXggdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fc3VjYyBlbHNlXG4gIHUgKyAxXG5cbmxldCBwcmVkIHUgPVxuICBpZiB1ID0gaGlfYm91bmQgdGhlbiBsb19ib3VuZCBlbHNlXG4gIGlmIHUgPSBtaW4gdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fcHJlZCBlbHNlXG4gIHUgLSAxXG5cbmxldCBpc192YWxpZCBpID0gKG1pbiA8PSBpICYmIGkgPD0gbG9fYm91bmQpIHx8IChoaV9ib3VuZCA8PSBpICYmIGkgPD0gbWF4KVxubGV0IG9mX2ludCBpID0gaWYgaXNfdmFsaWQgaSB0aGVuIGkgZWxzZSBpbnZhbGlkX2FyZyAoZXJyX25vdF9zdiBpKVxuZXh0ZXJuYWwgdW5zYWZlX29mX2ludCA6IGludCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdG9faW50IDogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19jaGFyIHUgPSB1IDwgMjU2XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcbmxldCB0b19jaGFyIHUgPVxuICBpZiB1ID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgKGVycl9ub3RfbGF0aW4xIHUpIGVsc2VcbiAgQ2hhci51bnNhZmVfY2hyIHVcblxubGV0IHVuc2FmZV90b19jaGFyID0gQ2hhci51bnNhZmVfY2hyXG5cbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXggKilcblxudHlwZSBwb3NpdGlvbiA9IHtcbiAgcG9zX2ZuYW1lIDogc3RyaW5nO1xuICBwb3NfbG51bSA6IGludDtcbiAgcG9zX2JvbCA6IGludDtcbiAgcG9zX2NudW0gOiBpbnQ7XG59XG5cbmxldCBkdW1teV9wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMDtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gLTE7XG59XG5cbnR5cGUgbGV4YnVmID1cbiAgeyByZWZpbGxfYnVmZiA6IGxleGJ1ZiAtPiB1bml0O1xuICAgIG11dGFibGUgbGV4X2J1ZmZlciA6IGJ5dGVzO1xuICAgIG11dGFibGUgbGV4X2J1ZmZlcl9sZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfYWJzX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9hY3Rpb24gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfZW9mX3JlYWNoZWQgOiBib29sO1xuICAgIG11dGFibGUgbGV4X21lbSA6IGludCBhcnJheTtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wIDogcG9zaXRpb247XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wIDogcG9zaXRpb247XG4gIH1cblxudHlwZSBsZXhfdGFibGVzID1cbiAgeyBsZXhfYmFzZTogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHQ6IHN0cmluZztcbiAgICBsZXhfdHJhbnM6IHN0cmluZztcbiAgICBsZXhfY2hlY2s6IHN0cmluZztcbiAgICBsZXhfYmFzZV9jb2RlIDogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHRfY29kZSA6IHN0cmluZztcbiAgICBsZXhfdHJhbnNfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY2hlY2tfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY29kZTogc3RyaW5nO31cblxuZXh0ZXJuYWwgY19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50ID0gXCJjYW1sX2xleF9lbmdpbmVcIlxuZXh0ZXJuYWwgY19uZXdfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX25ld19sZXhfZW5naW5lXCJcblxubGV0IGVuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgJiYgYnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxuXG5sZXQgbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IGxleF9yZWZpbGwgcmVhZF9mdW4gYXV4X2J1ZmZlciBsZXhidWYgPVxuICBsZXQgcmVhZCA9XG4gICAgcmVhZF9mdW4gYXV4X2J1ZmZlciAoQnl0ZXMubGVuZ3RoIGF1eF9idWZmZXIpIGluXG4gIGxldCBuID1cbiAgICBpZiByZWFkID4gMFxuICAgIHRoZW4gcmVhZFxuICAgIGVsc2UgKGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZTsgMCkgaW5cbiAgKCogQ3VycmVudCBzdGF0ZSBvZiB0aGUgYnVmZmVyOlxuICAgICAgICA8LS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0+XG4gICAgICAgIHwgIGp1bmsgfCAgICAgIHZhbGlkIGRhdGEgICAgIHwgICBqdW5rICAgIHxcbiAgICAgICAgXiAgICAgICBeICAgICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgXlxuICAgICAgICAwICAgIHN0YXJ0X3BvcyAgICAgICAgICAgICBidWZmZXJfZW5kICAgIEJ5dGVzLmxlbmd0aCBidWZmZXJcbiAgKilcbiAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuICsgbiA+IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlciB0aGVuIGJlZ2luXG4gICAgKCogVGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG5cbiAgICAgICA8PSBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXJcbiAgICB0aGVuIGJlZ2luXG4gICAgICAoKiBCdXQgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGlmIHdlIHJlY2xhaW0gdGhlIGp1bmsgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgb2YgdGhlIGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbGV4YnVmLmxleF9idWZmZXIgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKVxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAoKiBXZSBtdXN0IGdyb3cgdGhlIGJ1ZmZlci4gIERvdWJsaW5nIGl0cyBzaXplIHdpbGwgcHJvdmlkZSBlbm91Z2hcbiAgICAgICAgIHNwYWNlIHNpbmNlIG4gPD0gU3RyaW5nLmxlbmd0aCBhdXhfYnVmZmVyIDw9IFN0cmluZy5sZW5ndGggYnVmZmVyLlxuICAgICAgICAgV2F0Y2ggb3V0IGZvciBzdHJpbmcgbGVuZ3RoIG92ZXJmbG93LCB0aG91Z2guICopXG4gICAgICBsZXQgbmV3bGVuID1cbiAgICAgICAgbWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgP3dpdGhfcG9zaXRpb25zIGljID1cbiAgZnJvbV9mdW5jdGlvbiA/d2l0aF9wb3NpdGlvbnMgKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCB3aXRoX3Bvc2l0aW9ucyBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3NcblxubGV0IGxleGVtZSBsZXhidWYgPVxuICBsZXQgbGVuID0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3MgbGVuXG5cbmxldCBzdWJfbGV4ZW1lIGxleGJ1ZiBpMSBpMiA9XG4gIGxldCBsZW4gPSBpMi1pMSBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlblxuXG5sZXQgc3ViX2xleGVtZV9vcHQgbGV4YnVmIGkxIGkyID1cbiAgaWYgaTEgPj0gMCB0aGVuIGJlZ2luXG4gICAgbGV0IGxlbiA9IGkyLWkxIGluXG4gICAgU29tZSAoQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW4pXG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgTm9uZVxuICBlbmRcblxubGV0IHN1Yl9sZXhlbWVfY2hhciBsZXhidWYgaSA9IEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXJfb3B0IGxleGJ1ZiBpID1cbiAgaWYgaSA+PSAwIHRoZW5cbiAgICBTb21lIChCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaSlcbiAgZWxzZVxuICAgIE5vbmVcblxuXG5sZXQgbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPVxuICBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgKGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgaSlcblxubGV0IGxleGVtZV9zdGFydCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3AucG9zX2NudW1cbmxldCBsZXhlbWVfZW5kIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19jbnVtXG5cbmxldCBsZXhlbWVfc3RhcnRfcCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3BcbmxldCBsZXhlbWVfZW5kX3AgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3BcblxubGV0IG5ld19saW5lIGxleGJ1ZiA9XG4gIGxldCBsY3AgPSBsZXhidWYubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsZXhidWYubGV4X2N1cnJfcCA8LVxuICAgICAgeyBsY3Agd2l0aFxuICAgICAgICBwb3NfbG51bSA9IGxjcC5wb3NfbG51bSArIDE7XG4gICAgICAgIHBvc19ib2wgPSBsY3AucG9zX2NudW07XG4gICAgICB9XG5cblxuXG4oKiBEaXNjYXJkIGRhdGEgbGVmdCBpbiBsZXhlciBidWZmZXIuICopXG5cbmxldCBmbHVzaF9pbnB1dCBsYiA9XG4gIGxiLmxleF9jdXJyX3BvcyA8LSAwO1xuICBsYi5sZXhfYWJzX3BvcyA8LSAwO1xuICBsZXQgbGNwID0gbGIubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsYi5sZXhfY3Vycl9wIDwtIHt6ZXJvX3BvcyB3aXRoIHBvc19mbmFtZSA9IGxjcC5wb3NfZm5hbWV9O1xuICBsYi5sZXhfYnVmZmVyX2xlbiA8LSAwO1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAoKiBUb29scyB0byBtYW5pcHVsYXRlIHNjYW5uaW5nIHNldCBvZiBjaGFycyAoc2VlICVbLi4uXSkgKilcblxudHlwZSBtdXRhYmxlX2NoYXJfc2V0ID0gYnl0ZXNcblxuKCogQ3JlYXRlIGEgZnJlc2gsIGVtcHR5LCBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGNyZWF0ZV9jaGFyX3NldCAoKSA9IEJ5dGVzLm1ha2UgMzIgJ1xcMDAwJ1xuXG4oKiBBZGQgYSBjaGFyIGluIGEgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICBCeXRlcy5zZXQgY2hhcl9zZXQgc3RyX2luZFxuICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKEJ5dGVzLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsb3IgbWFzaykpXG5cbmxldCBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBCeXRlcy50b19zdHJpbmcgY2hhcl9zZXRcblxuKCogQ29tcHV0ZSB0aGUgY29tcGxlbWVudCBvZiBhIGNoYXIgc2V0LiAqKVxubGV0IHJldl9jaGFyX3NldCBjaGFyX3NldCA9XG4gIGxldCBjaGFyX3NldCcgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIDMxIGRvXG4gICAgQnl0ZXMuc2V0IGNoYXJfc2V0JyBpXG4gICAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IGkpIGx4b3IgMHhGRikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGNoYXJfc2V0J1xuXG4oKiBSZXR1cm4gdHJ1ZSBpZiBhIGBjJyBpcyBpbiBgY2hhcl9zZXQnLiAqKVxubGV0IGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxhbmQgbWFzaykgPD4gMFxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogSWdub3JlZCBwYXJhbSBjb252ZXJzaW9uICopXG5cbigqIEdBRFQgdXNlZCB0byBhYnN0cmFjdCBhbiBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlci4gKilcbigqIFNlZSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiID0gUGFyYW1fZm9ybWF0X0VCQiA6XG4gICAgKCd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiXG5cbigqIENvbXB1dGUgYSBwYWRkaW5nIGFzc29jaWF0ZWQgdG8gYSBwYWRfb3B0aW9uIChzZWUgXCIlXzQyZFwiKS4gKilcbmxldCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wYWRkaW5nXG4gIHwgU29tZSB3aWR0aCAtPiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuXG4oKiBDb21wdXRlIGEgcHJlY2lzaW9uIGFzc29jaWF0ZWQgdG8gYSBwcmVjX29wdGlvbiAoc2VlIFwiJV8uNDJmXCIpLiAqKVxubGV0IHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQgPSBtYXRjaCBwcmVjX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wcmVjaXNpb25cbiAgfCBTb21lIG5kZWMgLT4gTGl0X3ByZWNpc2lvbiBuZGVjXG5cbigqIFR1cm4gYW4gaWdub3JlZCBwYXJhbSBpbnRvIGl0cyBlcXVpdmFsZW50IG5vdC1pZ25vcmVkIGZvcm1hdCBub2RlLiAqKVxuKCogVXNlZCBmb3IgZm9ybWF0IHByZXR0eS1wcmludGluZyBhbmQgU2NhbmYuICopXG5sZXQgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+ICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYXJhbV9mb3JtYXRfZWJiID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2hhciBmbXQpXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX2NoYXIgZm10KVxuICB8IElnbm9yZWRfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDMyIChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50MzIgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChOYXRpdmVpbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQ2NCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDY0IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfZmxvYXQgKHBhZF9vcHQsIHByZWNfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGbG9hdCAoKEZsb2F0X2ZsYWdfLCBGbG9hdF9mKSxcbiAgICAgICAgICAgICAgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Jvb2wgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEJvb2wgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChSZWFkZXIgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10KVxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlcyAqKVxuXG50eXBlICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlbiA9XG4gIHwgQWNjX29wZW5fdGFnIG9mICgnYiwgJ2MpIGFjY1xuICB8IEFjY19vcGVuX2JveCBvZiAoJ2IsICdjKSBhY2NcblxuKCogUmV2ZXJzZWQgbGlzdCBvZiBwcmludGluZyBhdG9tcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBwcmludGYgYXJndW1lbnRzLiAqKVxuYW5kICgnYiwgJ2MpIGFjYyA9XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IG9mICgnYiwgJ2MpIGFjYyAqIGZvcm1hdHRpbmdfbGl0XG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gb2YgKCdiLCAnYykgYWNjICogKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuXG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBMaXRlcmFsIHN0cmluZyAqKVxuICB8IEFjY19jaGFyX2xpdGVyYWwgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIExpdGVyYWwgY2hhciAqKVxuICB8IEFjY19kYXRhX3N0cmluZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIEdlbmVyYXRlZCBzdHJpbmcgKilcbiAgfCBBY2NfZGF0YV9jaGFyICAgICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBHZW5lcmF0ZWQgY2hhciAqKVxuICB8IEFjY19kZWxheSAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IgLT4gJ2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBEZWxheWVkIHByaW50aW5nICglYSwgJXQpICopXG4gIHwgQWNjX2ZsdXNoICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAgICAgICAgICAgICAgKCogRmx1c2ggKilcbiAgfCBBY2NfaW52YWxpZF9hcmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nXG4gICAgICAoKiBSYWlzZSBJbnZhbGlkX2FyZ3VtZW50IG1zZyAqKVxuICB8IEVuZF9vZl9hY2NcblxuKCogTGlzdCBvZiBoZXRlcm9nZW5lb3VzIHZhbHVlcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBzY2FuZiBjYWxsYmFjayBhcmd1bWVudHMuICopXG50eXBlICgnYSwgJ2IpIGhldGVyX2xpc3QgPVxuICB8IENvbnMgOiAnYyAqICgnYSwgJ2IpIGhldGVyX2xpc3QgLT4gKCdjIC0+ICdhLCAnYikgaGV0ZXJfbGlzdFxuICB8IE5pbCA6ICgnYiwgJ2IpIGhldGVyX2xpc3RcblxuKCogRXhpc3RlbnRpYWwgQmxhY2sgQm94ZXMuICopXG4oKiBVc2VkIHRvIGFic3RyYWN0IHNvbWUgZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRkaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmIgPSBQYWRkaW5nX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRwcmVjIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmIgPSBQYWRwcmVjX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICd6KSBwcmVjaXNpb24gKiAoJ3osICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZGRpbmdfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiID0gUGFkZGluZ19mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwYWRkaW5nICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wcmVjaXNpb25fZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmIgPSBQcmVjaXNpb25fZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkcHJlY19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmIgPSBQYWRwcmVjX2ZtdF9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAncCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgdGhlICdhIGFuZCAnZCBwYXJhbWV0ZXJzIG9mIGFuIGZtdC4gKilcbigqIE91dHB1dCB0eXBlIG9mIHRoZSBmb3JtYXQgcGFyc2luZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiID0gRm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2Zvcm1hdF9nZW4gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiID0gRm10X2ZtdHR5X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXQgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYiA9IEZtdHR5X2ZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10dHkgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10X2ZtdHR5X2ViYiAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgZm10dHkgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIGZvcm1hdCB0eXBlcy4gKilcbnR5cGUgZm10dHlfZWJiID0gRm10dHlfRUJCIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+IGZtdHR5X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcGFkZGluZyB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcGFkZGluZ3MuICopXG50eXBlIHBhZGRpbmdfZWJiID0gUGFkZGluZ19FQkIgOiAoJ2EsICdiKSBwYWRkaW5nIC0+IHBhZGRpbmdfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwcmVjaXNpb24gdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHByZWNpc2lvbnMuICopXG50eXBlIHByZWNpc2lvbl9lYmIgPSBQcmVjaXNpb25fRUJCIDogKCdhLCAnYikgcHJlY2lzaW9uIC0+IHByZWNpc2lvbl9lYmJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb25zdGFudHMgKilcblxuKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIGZsb2F0IHByaW50aW5nLiAqKVxubGV0IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252ID1cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRyB8IEZsb2F0X2ggfCBGbG9hdF9IIC0+IC02XG4gICgqIEZvciAlaCBhbmQgJUggZm9ybWF0cywgYSBuZWdhdGl2ZSBwcmVjaXNpb24gbWVhbnMgXCJhcyBtYW55IGRpZ2l0cyBhc1xuICAgICBuZWNlc3NhcnlcIi4gIEZvciB0aGUgb3RoZXIgRlAgZm9ybWF0cywgd2UgdGFrZSB0aGUgYWJzb2x1dGUgdmFsdWVcbiAgICAgb2YgdGhlIHByZWNpc2lvbiwgaGVuY2UgNiBkaWdpdHMgYnkgZGVmYXVsdC4gKilcbiAgfCBGbG9hdF9GIC0+IDEyXG4gICgqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBPQ2FtbCBmbG9hdCBwcmludGluZyAoJUYpLiAqKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEV4dGVybmFscyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQ6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDMyOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfbmF0aXZlaW50OiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ2NDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxuZXh0ZXJuYWwgaGV4c3RyaW5nX29mX2Zsb2F0OiBmbG9hdCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0XCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICgqIFRvb2xzIHRvIHByZXR0eS1wcmludCBmb3JtYXRzICopXG5cbigqIFR5cGUgb2YgZXh0ZW5zaWJsZSBjaGFyYWN0ZXIgYnVmZmVycy4gKilcbnR5cGUgYnVmZmVyID0ge1xuICBtdXRhYmxlIGluZCA6IGludDtcbiAgbXV0YWJsZSBieXRlcyA6IGJ5dGVzO1xufVxuXG4oKiBDcmVhdGUgYSBmcmVzaCBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NyZWF0ZSBpbml0X3NpemUgPSB7IGluZCA9IDA7IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGluaXRfc2l6ZSB9XG5cbigqIENoZWNrIHNpemUgb2YgdGhlIGJ1ZmZlciBhbmQgZ3JvdyBpdCBpZiBuZWVkZWQuICopXG5sZXQgYnVmZmVyX2NoZWNrX3NpemUgYnVmIG92ZXJoZWFkID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBidWYuYnl0ZXMgaW5cbiAgbGV0IG1pbl9sZW4gPSBidWYuaW5kICsgb3ZlcmhlYWQgaW5cbiAgaWYgbWluX2xlbiA+IGxlbiB0aGVuIChcbiAgICBsZXQgbmV3X2xlbiA9IG1heCAobGVuICogMikgbWluX2xlbiBpblxuICAgIGxldCBuZXdfc3RyID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1Zi5ieXRlcyAwIG5ld19zdHIgMCBsZW47XG4gICAgYnVmLmJ5dGVzIDwtIG5ld19zdHI7XG4gIClcblxuKCogQWRkIHRoZSBjaGFyYWN0ZXIgYGMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjID1cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIDE7XG4gIEJ5dGVzLnNldCBidWYuYnl0ZXMgYnVmLmluZCBjO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyAxXG5cbigqIEFkZCB0aGUgc3RyaW5nIGBzJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzID1cbiAgbGV0IHN0cl9sZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIHN0cl9sZW47XG4gIFN0cmluZy5ibGl0IHMgMCBidWYuYnl0ZXMgYnVmLmluZCBzdHJfbGVuO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyBzdHJfbGVuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiB0aGUgYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jb250ZW50cyBidWYgPVxuICBCeXRlcy5zdWJfc3RyaW5nIGJ1Zi5ieXRlcyAwIGJ1Zi5pbmRcblxuKCoqKilcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIGNvbnZlcnNpb24gdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2ljb252IGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkIHwgSW50X0NkIC0+ICdkJyB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpXG4gIHwgSW50X0NpIC0+ICdpJyB8IEludF94IHwgSW50X0N4IC0+ICd4JyB8IEludF9YIHwgSW50X0NYIC0+ICdYJyB8IEludF9vXG4gIHwgSW50X0NvIC0+ICdvJyB8IEludF91IHwgSW50X0N1IC0+ICd1J1xuXG4oKiBDb252ZXJ0IGEgZmxvYXQgY29udmVyc2lvbiB0byBjaGFyLiAqKVxuKCogYGNGJyB3aWxsIGJlICdGJyBmb3IgZGlzcGxheWluZyBmb3JtYXQgYW5kICdnJyB0byBjYWxsIGxpYmMgcHJpbnRmICopXG5sZXQgY2hhcl9vZl9mY29udiA/KGNGPSdGJykgZmNvbnYgPSBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgLT4gJ2YnIHwgRmxvYXRfZSAtPiAnZSdcbiAgfCBGbG9hdF9FIC0+ICdFJyB8IEZsb2F0X2cgLT4gJ2cnXG4gIHwgRmxvYXRfRyAtPiAnRycgfCBGbG9hdF9GIC0+IGNGXG4gIHwgRmxvYXRfaCAtPiAnaCcgfCBGbG9hdF9IIC0+ICdIJ1xuXG5cbigqIENvbnZlcnQgYSBzY2FubmluZyBjb3VudGVyIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIgPSBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgIC0+ICdsJ1xuICB8IENoYXJfY291bnRlciAgLT4gJ24nXG4gIHwgVG9rZW5fY291bnRlciAtPiAnTidcblxuKCoqKilcblxuKCogUHJpbnQgYSBjaGFyX3NldCBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBPQ2FtbCBmb3JtYXQgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQgPVxuICBsZXQgcmVjIHByaW50X3N0YXJ0IHNldCA9XG4gICAgbGV0IGlzX2Fsb25lIGMgPVxuICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIgPSBDaGFyLihjaHIgKGNvZGUgYyAtIDEpLCBjaHIgKGNvZGUgYyArIDEpKSBpblxuICAgICAgaXNfaW5fY2hhcl9zZXQgc2V0IGNcbiAgICAgICYmIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IGJlZm9yZSAmJiBpc19pbl9jaGFyX3NldCBzZXQgYWZ0ZXIpIGluXG4gICAgaWYgaXNfYWxvbmUgJ10nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSc7XG4gICAgcHJpbnRfb3V0IHNldCAxO1xuICAgIGlmIGlzX2Fsb25lICctJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nO1xuICBhbmQgcHJpbnRfb3V0IHNldCBpID1cbiAgICBpZiBpIDwgMjU2IHRoZW5cbiAgICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlbiBwcmludF9maXJzdCBzZXQgaVxuICAgICAgZWxzZSBwcmludF9vdXQgc2V0IChpICsgMSlcbiAgYW5kIHByaW50X2ZpcnN0IHNldCBpID1cbiAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICdcXDI1NScgLT4gcHJpbnRfY2hhciBidWYgMjU1O1xuICAgIHwgJ10nIHwgJy0nIC0+IHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICB8IF8gLT4gcHJpbnRfc2Vjb25kIHNldCAoaSArIDEpO1xuICBhbmQgcHJpbnRfc2Vjb25kIHNldCBpID1cbiAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW5cbiAgICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgICAgfCAnXFwyNTUnIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NDtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU1O1xuICAgICAgfCAnXScgfCAnLScgd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICAgIHwgXyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDIpO1xuICAgICAgfCBfIC0+XG4gICAgICAgIHByaW50X2luIHNldCAoaSAtIDEpIChpICsgMik7XG4gICAgZWxzZSAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIClcbiAgYW5kIHByaW50X2luIHNldCBpIGogPVxuICAgIGlmIGogPSAyNTYgfHwgbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGopKSB0aGVuIChcbiAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaW50X29mX2NoYXIgJy0nKTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChqIC0gMSk7XG4gICAgICBpZiBqIDwgMjU2IHRoZW4gcHJpbnRfb3V0IHNldCAoaiArIDEpO1xuICAgICkgZWxzZVxuICAgICAgcHJpbnRfaW4gc2V0IGkgKGogKyAxKTtcbiAgYW5kIHByaW50X2NoYXIgYnVmIGkgPSBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICclJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgfCAnQCcgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0AnO1xuICAgIHwgYyAgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgaW5cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnWyc7XG4gIHByaW50X3N0YXJ0IChcbiAgICBpZiBpc19pbl9jaGFyX3NldCBjaGFyX3NldCAnXFwwMDAnXG4gICAgdGhlbiAoIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ14nOyByZXZfY2hhcl9zZXQgY2hhcl9zZXQgKVxuICAgIGVsc2UgY2hhcl9zZXRcbiAgKTtcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSdcblxuKCoqKilcblxuKCogUHJpbnQgYSBwYWR0eSBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eSA9IG1hdGNoIHBhZHR5IHdpdGhcbiAgfCBMZWZ0ICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICctJ1xuICB8IFJpZ2h0IC0+ICgpXG4gIHwgWmVyb3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnMCdcblxuKCogUHJpbnQgdGhlICdfJyBvZiBhbiBpZ25vcmVkIGZsYWcgaWYgbmVlZGVkLiAqKVxubGV0IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnID1cbiAgaWYgaWduX2ZsYWcgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICdfJ1xuXG4oKioqKVxuXG5sZXQgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSB3aWR0aCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgd2lkdGgpXG5cbigqKiopXG5cbigqIFByaW50IHBhZGRpbmcgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWRkaW5nIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHBhZGRpbmcgLT4gdW5pdCA9XG5mdW4gYnVmIHBhZCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT4gKClcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIG4pIC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyonXG5cbigqIFByaW50IHByZWNpc2lvbiBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3ByZWNpc2lvbiA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwcmVjaXNpb24gLT4gdW5pdCA9XG4gIGZ1biBidWYgcHJlYyAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gLT4gKClcbiAgfCBMaXRfcHJlY2lzaW9uIG4gLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIi4qXCJcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIG9yICcjJyBhc3NvY2lhdGVkIHRvIGFuIGludCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfcGQgfCBJbnRfcGkgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBJbnRfc2QgfCBJbnRfc2kgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBJbnRfQ3ggfCBJbnRfQ1ggfCBJbnRfQ28gfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgSW50X2QgfCBJbnRfaSB8IEludF94IHwgSW50X1ggfCBJbnRfbyB8IEludF91IC0+ICgpXG5cbigqIFByaW50IGFuIGNvbXBsZXRlIGludCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUzLipkXCIpLiAqKVxubGV0IGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyBjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJyBhc3NvY2lhdGVkIHRvIGEgZmxvYXQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnYgPSBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ZsYWdfcCAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEZsb2F0X2ZsYWdfcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEZsb2F0X2ZsYWdfIC0+ICgpXG5cbigqIFByaW50IGEgY29tcGxldGUgZmxvYXQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlKyouM2ZcIikuICopXG5sZXQgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9mY29udiBmY29udilcblxuKCogQ29tcHV0ZSB0aGUgbGl0ZXJhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBmb3JtYXR0aW5nX2xpdC4gKilcbigqIEFsc28gdXNlZCBieSBQcmludGYgYW5kIFNjYW5mIHdoZXJlIGZvcm1hdHRpbmcgaXMgbm90IGludGVycHJldGVkLiAqKVxubGV0IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCA9IG1hdGNoIGZvcm1hdHRpbmdfbGl0IHdpdGhcbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAtPiBcIkBdXCJcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAtPiBcIkB9XCJcbiAgfCBCcmVhayAoc3RyLCBfLCBfKSAgICAtPiBzdHJcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAtPiBcIkA/XCJcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAtPiBcIkBcXG5cIlxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgIC0+IFwiQC5cIlxuICB8IE1hZ2ljX3NpemUgKHN0ciwgXykgIC0+IHN0clxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgIC0+IFwiQEBcIlxuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgIC0+IFwiQCVcIlxuICB8IFNjYW5faW5kaWMgYyAtPiBcIkBcIiBeIChTdHJpbmcubWFrZSAxIGMpXG5cbigqIENvbXB1dGUgdGhlIGxpdGVyYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZm9ybWF0dGluZy4gKilcbigqIEFsc28gdXNlZCBieSBQcmludGYgYW5kIFNjYW5mIHdoZXJlIGZvcm1hdHRpbmcgaXMgbm90IGludGVycHJldGVkLiAqKVxubGV0IHN0cmluZ19vZl9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmb3JtYXR0aW5nX2dlbiAtPiBzdHJpbmcgPVxuICBmdW4gZm9ybWF0dGluZ19nZW4gLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKF8sIHN0cikpIC0+IHN0clxuICB8IE9wZW5fYm94IChGb3JtYXQgKF8sIHN0cikpIC0+IHN0clxuXG4oKioqKVxuXG4oKiBQcmludCBhIGxpdGVyYWwgY2hhciBpbiBhIGJ1ZmZlciwgZXNjYXBlICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyID0gbWF0Y2ggY2hyIHdpdGhcbiAgfCAnJScgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSVcIlxuICB8IF8gLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjaHJcblxuKCogUHJpbnQgYSBsaXRlcmFsIHN0cmluZyBpbiBhIGJ1ZmZlciwgZXNjYXBlIGFsbCAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyID1cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3RyIC0gMSBkb1xuICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIHN0ci5baV1cbiAgZG9uZVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcHJldHR5LXByaW50aW5nICopXG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IHR5cGUgKGFuIGZtdHR5KSBpbiBhIGJ1ZmZlci4gKilcbmxldCByZWMgYnByaW50X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gICAgYnVmZmVyIC0+IChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gdW5pdCA9XG5mdW4gYnVmIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlY1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFN0cmluZ190eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVzXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWlcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQzMl90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVuaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGbG9hdF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlZlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEJvb2xfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVCXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWFcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBUaGV0YV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIldFwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFueV90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiU/XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgUmVhZGVyX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlX3JcIjtcbiAgICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXtcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJX1cIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5LCBfLCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUoXCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEVuZF9vZl9mbXR0eSAtPiAoKVxuXG4oKioqKVxuXG5sZXQgcmVjIGludF9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIGEgYiBjIC5cbiAgKGEsIGIsIGMpIGN1c3RvbV9hcml0eSAtPiBpbnQgPVxuICBmdW5jdGlvblxuICB8IEN1c3RvbV96ZXJvIC0+IDBcbiAgfCBDdXN0b21fc3VjYyB4IC0+IDEgKyBpbnRfb2ZfY3VzdG9tX2FyaXR5IHhcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2ZtdCBidWYgZm10ID1cbiAgbGV0IHJlYyBmbXRpdGVyIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGJvb2wgLT4gdW5pdCA9XG4gIGZ1biBmbXQgaWduX2ZsYWcgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnUyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdsJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnTCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0InO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYSc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3QnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgZm9yIF9pID0gMSB0byBpbnRfb2ZfY3VzdG9tX2FyaXR5IGFyaXR5IGRvXG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnPyc7XG4gICAgICBkb25lO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgUmVhZGVyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3InOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlIVwiO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNocjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAneyc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnfSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJygnO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyknO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHdpZHRoX29wdDsgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2NvdW50ZXIgY291bnRlcik7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIFwiMGNcIjsgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgICBmbXRpdGVyIGZtdCcgdHJ1ZTtcblxuICAgIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCk7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgXCJAe1wiO1xuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfZ2VuIGZtdGluZ19nZW4pO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+ICgpXG5cbiAgaW4gZm10aXRlciBmbXQgZmFsc2VcblxuKCoqKilcblxuKCogQ29udmVydCBhIGZvcm1hdCB0byBzdHJpbmcuICopXG5sZXQgc3RyaW5nX29mX2ZtdCBmbXQgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10IGJ1ZiBmbXQ7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZSBleHRyYWN0aW9uICopXG5cbnR5cGUgKF8sIF8pIGVxID0gUmVmbCA6ICgnYSwgJ2EpIGVxXG5cbigqIEludmFyaWFudDogdGhpcyBmdW5jdGlvbiBpcyB0aGUgaWRlbnRpdHkgb24gdmFsdWVzLlxuXG4gICBJbiBwYXJ0aWN1bGFyLCBpZiAodHkxLCB0eTIpIGhhdmUgZXF1YWwgdmFsdWVzLCB0aGVuXG4gICAodHJhbnMgKHN5bW0gdHkxKSB0eTIpIHJlc3BlY3RzIHRoZSAndHJhbnMnIHByZWNvbmRpdGlvbi4gKilcbmxldCByZWMgc3ltbSA6IHR5cGUgYTEgYjEgYzEgZDEgZTEgZjEgYTIgYjIgYzIgZDIgZTIgZjIgLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXR0eV9yZWxcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT4gQ2hhcl90eSAoc3ltbSByZXN0KVxuICB8IEludF90eSByZXN0IC0+IEludF90eSAoc3ltbSByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT4gSW50MzJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+IEludDY0X3R5IChzeW1tIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gTmF0aXZlaW50X3R5IChzeW1tIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPiBGbG9hdF90eSAoc3ltbSByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPiBCb29sX3R5IChzeW1tIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT4gU3RyaW5nX3R5IChzeW1tIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPiBUaGV0YV90eSAoc3ltbSByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT4gQWxwaGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPiBBbnlfdHkgKHN5bW0gcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPiBSZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+IElnbm9yZWRfcmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyLCB0eTEsIHN5bW0gcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbmxldCByZWMgZm10dHlfcmVsX2RldCA6IHR5cGUgYTEgYiBjIGQxIGUxIGYxIGEyIGQyIGUyIGYyIC5cbiAgKGExLCBiLCBjLCBkMSwgZTEsIGYxLFxuICAgYTIsIGIsIGMsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoZjEsIGYyKSBlcSAtPiAoYTEsIGEyKSBlcSlcbiAgKiAoKGExLCBhMikgZXEgLT4gKGYxLCBmMikgZXEpXG4gICogKChlMSwgZTIpIGVxIC0+IChkMSwgZDIpIGVxKVxuICAqICgoZDEsIGQyKSBlcSAtPiAoZTEsIGUyKSBlcSlcbj0gZnVuY3Rpb25cbiAgfCBFbmRfb2ZfZm10dHkgLT5cbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbClcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgRm9ybWF0X2FyZ190eSAoX3R5LCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgbGV0IGFnLCBnYSwgZGosIGpkID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZyBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGdhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gbGV0IFJlZmwgPSBkaiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGpkIFJlZmwgaW4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG5cbigqIFByZWNvbmRpdGlvbjogd2UgYXNzdW1lIHRoYXQgdGhlIHR3byBmbXR0eV9yZWwgYXJndW1lbnRzIGhhdmUgZXF1YWxcbiAgIHZhbHVlcyAoYXQgcG9zc2libHkgZGlzdGluY3QgdHlwZXMpOyB0aGlzIGludmFyaWFudCBjb21lcyBmcm9tIHRoZSB3YXlcbiAgIGZtdHR5X3JlbCB3aXRuZXNzZXMgYXJlIHByb2R1Y2VkIGJ5IHRoZSB0eXBlLWNoZWNrZXJcblxuICAgVGhlIGNvZGUgYmVsb3cgdXNlcyAoYXNzZXJ0IGZhbHNlKSB3aGVuIHRoaXMgYXNzdW1wdGlvbiBpcyBicm9rZW4uIFRoZVxuICAgY29kZSBwYXR0ZXJuIGlzIHRoZSBmb2xsb3dpbmc6XG5cbiAgICAgfCBGb28geCwgRm9vIHkgLT5cbiAgICAgICAoKiBjYXNlIHdoZXJlIGluZGVlZCBib3RoIHZhbHVlc1xuICAgICAgICAgIHN0YXJ0IHdpdGggY29uc3RydWN0b3IgRm9vICopXG4gICAgIHwgRm9vIF8sIF9cbiAgICAgfCBfLCBGb28gXyAtPlxuICAgICAgICgqIGRpZmZlcmVudCBoZWFkIGNvbnN0cnVjdG9yczogYnJva2VuIHByZWNvbmRpdGlvbiAqKVxuICAgICAgIGFzc2VydCBmYWxzZVxuKilcbmFuZCB0cmFucyA6IHR5cGVcbiAgYTEgYjEgYzEgZDEgZTEgZjFcbiAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgYTMgYjMgYzMgZDMgZTMgZjNcbi5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG4tPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbj0gZnVuIHR5MSB0eTIgLT4gbWF0Y2ggdHkxLCB0eTIgd2l0aFxuICB8IENoYXJfdHkgcmVzdDEsIENoYXJfdHkgcmVzdDIgLT4gQ2hhcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgU3RyaW5nX3R5IHJlc3QxLCBTdHJpbmdfdHkgcmVzdDIgLT4gU3RyaW5nX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBCb29sX3R5IHJlc3QxLCBCb29sX3R5IHJlc3QyIC0+IEJvb2xfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludF90eSByZXN0MSwgSW50X3R5IHJlc3QyIC0+IEludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50MzJfdHkgcmVzdDEsIEludDMyX3R5IHJlc3QyIC0+IEludDMyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQ2NF90eSByZXN0MSwgSW50NjRfdHkgcmVzdDIgLT4gSW50NjRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IE5hdGl2ZWludF90eSByZXN0MSwgTmF0aXZlaW50X3R5IHJlc3QyIC0+IE5hdGl2ZWludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRmxvYXRfdHkgcmVzdDEsIEZsb2F0X3R5IHJlc3QyIC0+IEZsb2F0X3R5ICh0cmFucyByZXN0MSByZXN0MilcblxuICB8IEFscGhhX3R5IHJlc3QxLCBBbHBoYV90eSByZXN0MiAtPiBBbHBoYV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQWxwaGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbHBoYV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgVGhldGFfdHkgcmVzdDEsIFRoZXRhX3R5IHJlc3QyIC0+IFRoZXRhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBUaGV0YV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFRoZXRhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBBbnlfdHkgcmVzdDEsIEFueV90eSByZXN0MiAtPiBBbnlfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFueV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFueV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgUmVhZGVyX3R5IHJlc3QxLCBSZWFkZXJfdHkgcmVzdDIgLT4gUmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBSZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBSZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QxLCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MiAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIElnbm9yZWRfcmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfYXJnX3R5ICh0eTEsIHJlc3QxKSwgRm9ybWF0X2FyZ190eSAodHkyLCByZXN0MikgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0cmFucyB0eTEgdHkyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfYXJnX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X2FyZ190eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTEyLCByZXN0MSksXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIxLCB0eTIyLCByZXN0MikgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEyKSB0eTIxIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MjIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9zdWJzdF90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9zdWJzdF90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRW5kX29mX2ZtdHR5LCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG4gIHwgRW5kX29mX2ZtdHR5LCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEVuZF9vZl9mbXR0eSAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHJlYyBmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBFeHRyYWN0IHRoZSB0eXBlIHJlcHJlc2VudGF0aW9uIChhbiBmbXR0eSkgb2YgYSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfZm10IDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuXG4gIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQzMl90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoTmF0aXZlaW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDY0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEZsb2F0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuXG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAgICAgICAgICAgLT5cbiAgICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChCb29sX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gQWxwaGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgIC0+IFRoZXRhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAgICAtPiBmbXR0eV9vZl9jdXN0b20gYXJpdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFJlYWRlciByZXN0ICAgICAgICAgICAgICAgIC0+IFJlYWRlcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGb3JtYXRfYXJnIChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5LCB0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGbHVzaCByZXN0ICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+IFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT4gSW50X3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAtPiBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdFxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpICAtPlxuICAgIGNvbmNhdF9mbXR0eSAoZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gZm10aW5nX2dlbikgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgLT4gRW5kX29mX2ZtdHR5XG5cbmFuZCBmbXR0eV9vZl9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICh5LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gYXJpdHkgZm10dHkgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IGZtdHR5XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT4gQW55X3R5IChmbXR0eV9vZl9jdXN0b20gYXJpdHkgZm10dHkpXG5cbigqIEV4dHJhY3QgdGhlIGZtdHR5IG9mIGFuIGlnbm9yZWQgcGFyYW1ldGVyIGZvbGxvd2VkIGJ5IHRoZSByZXN0IG9mXG4gICB0aGUgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gY29uY2F0X2ZtdHR5IGZtdHR5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gSWdub3JlZF9yZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwYWRkaW5nIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlKnNcIikuICopXG5hbmQgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAgLT4gZm10dHlcbiAgICB8IExpdF9wYWRkaW5nIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wYWRkaW5nIF8gLT4gSW50X3R5IGZtdHR5XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwcmVjaXNpb24gaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikuKilcbmFuZCBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMgd2l0aFxuICAgIHwgTm9fcHJlY2lzaW9uICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcHJlY2lzaW9uIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wcmVjaXNpb24gICAtPiBJbnRfdHkgZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwaW5nICopXG5cbigqIEV4Y2VwdGlvbiByYWlzZWQgd2hlbiBhIGZvcm1hdCBkb2VzIG5vdCBtYXRjaCBhIGdpdmVuIGZvcm1hdCB0eXBlLiAqKVxuZXhjZXB0aW9uIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIHBhZGRpbmcuICopXG4oKiBUYWtlIGFuIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiB0aGUgaW50ZWdlciBzaG91bGQgYmUga2VwdCBhcyBhcmd1bWVudC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkZGluZyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCwgZm10dHkgd2l0aFxuICB8IE5vX3BhZGRpbmcsIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKE5vX3BhZGRpbmcsIGZtdHR5KVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKExpdF9wYWRkaW5nIChwYWR0eSx3KSxmbXR0eSlcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgSW50X3R5IHJlc3QgLT4gUGFkZGluZ19mbXR0eV9FQkIgKEFyZ19wYWRkaW5nIHBhZHR5LHJlc3QpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIENvbnZlcnQgYSAodXBhZGRpbmcsIHVwcmVjaXNpb24pIHRvIGEgKHBhZGRpbmcsIHByZWNpc2lvbikuICopXG4oKiBUYWtlIG9uZSBvciB0d28gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIG5lZWRlZC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkcHJlYyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IHogLlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeikgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYywgdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIE5vX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAsIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTGl0X3ByZWNpc2lvbiBwLCByZXN0KVxuICB8IEFyZ19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEludF90eSByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIEFyZ19wcmVjaXNpb24sIHJlc3QpXG4gIHwgXywgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBJZiB0eXBpbmcgc3VjY2VlZCwgZ2VuZXJhdGUgYSBjb3B5IG9mIHRoZSBmb3JtYXQgd2l0aCB0aGUgc2FtZVxuICAgIHR5cGUgcGFyYW1ldGVycyBhcyB0aGUgZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCByZWMgdHlwZV9mb3JtYXQgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgd2l0aFxuICB8IEZtdF9mbXR0eV9FQkIgKGZtdCcsIEVuZF9vZl9mbXR0eSkgLT4gZm10J1xuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXRfZ2VuIDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggZm10LCBmbXR0eSB3aXRoXG4gIHwgQ2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXIgZm10JywgZm10dHknKVxuICB8IENhbWxfY2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfY2hhciBmbXQnLCBmbXR0eScpXG4gIHwgU3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfc3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50MzJfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDY0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgRmxvYXRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEJvb2wgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEJvb2xfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEJvb2wgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbHVzaCBmbXRfcmVzdCwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGbHVzaCBmbXQnLCBmbXR0eScpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10JyksIGZtdHR5JylcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXJfbGl0ZXJhbCAoY2hyLCBmbXQnKSwgZm10dHknKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5JywgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5MSwgX3N1Yl9mbXR0eTIsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkxKSB0aGVuXG4gICAgICByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID1cbiAgICAgIHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCAoZXJhc2VfcmVsIGZtdHR5X3Jlc3QpXG4gICAgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eTEsIGZtdCcpLCBmbXR0eScpXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBBbHBoYSBmbXRfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChBbHBoYSBmbXQnLCBmbXR0eScpXG4gIHwgVGhldGEgZm10X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoVGhldGEgZm10JywgZm10dHknKVxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nX2dlbiwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9mb3JtYXR0aW5nX2dlbiBmb3JtYXR0aW5nX2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciBmbXRfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoUmVhZGVyIGZtdCcsIGZtdHR5JylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXRfcmVzdCksIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpLCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQnKSwgZm10dHknKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW0gaWduIHJlc3QgZm10dHlfcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdCAtPiBGbXRfZm10dHlfRUJCIChFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0KVxuXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhMSBhMyBiMSBiMyBjMSBjMyBkMSBkMyBlMSBlMiBlMyBmMSBmMiBmMyAuXG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGYxLCBiMSwgYzEsIGUxLCBlMiwgZjIpIGZtdCAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eSAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXRfZm10dHlfZWJiID1cbmZ1biBmb3JtYXR0aW5nX2dlbiBmbXQwIGZtdHR5MCAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcblxuKCogVHlwZSBhbiBJZ25vcmVkX3BhcmFtIG5vZGUgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbSA6IHR5cGUgcCBxIHggeSB6IHQgdSB2IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgeSwgeiwgdCwgcSwgcCkgaWdub3JlZCAtPlxuICAgIChwLCB5LCB6LCBxLCB1LCB2KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10X2ZtdHR5X2ViYiA9XG5mdW4gaWduIGZtdCBmbXR0eSAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50IF8gICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50MzIgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfbmF0aXZlaW50IF8gICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50NjQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZmxvYXQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgKElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSkgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5JywgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSkgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5IGZtdCBmbXR0eSBpblxuICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXQnKSxcbiAgICAgICAgICAgICAgICAgICBmbXR0eScpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT4gKFxuICAgIG1hdGNoIGZtdHR5IHdpdGhcbiAgICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10JyksIGZtdHR5JylcbiAgICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG5cbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIDogdHlwZSBhMSBhMiBiMSBiMiBjMSBjMiBkMSBkMiBlMSBlMiBmMSBmMiAuXG4gICAgKGEyLCBiMiwgYzIsIGQyLCBkMiwgYTIpIGlnbm9yZWQgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGlnbiBmbXQgZm10dHkgLT5cbiAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IGluXG4gIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbiwgZm10JyksIGZtdHR5JylcblxuKCogVHlwaW5nIG9mIHRoZSBjb21wbGV4IGNhc2U6IFwiJV8oLi4uJSlcIi4gKilcbmFuZCB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiA6IHR5cGUgdyB4IHkgeiBwIHMgdCB1IGEgYiBjIGQgZSBmIC5cbiAgICAodywgeCwgeSwgeiwgcywgcCkgZm10dHkgLT5cbiAgICAocCwgeCwgeSwgcywgdCwgdSkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eV9mbXRfZWJiID1cbmZ1biBzdWJfZm10dHkgZm10IGZtdHR5IC0+IG1hdGNoIHN1Yl9mbXR0eSwgZm10dHkgd2l0aFxuICB8IENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQ2hhcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0LCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQzMl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQzMl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCwgSW50NjRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0LCBGbG9hdF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGbG9hdF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQm9vbF90eSBzdWJfZm10dHlfcmVzdCwgQm9vbF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChCb29sX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBBbHBoYV90eSBzdWJfZm10dHlfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChUaGV0YV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eSwgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWIyX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWIyX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5Jywgc3ViX2ZtdHR5X3Jlc3QnKSwgZm10JylcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHksICBzdWIyX2ZtdHR5LCAgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgICgqIFRPRE8gZGVmaW5lIEZtdHR5X3JlbF9FQkIgdG8gcmVtb3ZlIHRob3NlIGVyYXNlX3JlbCAqKVxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IHN1Yl9mbXR0eScgPSB0cmFucyAoc3ltbSBzdWIxX2ZtdHR5Jykgc3ViMl9mbXR0eScgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCBzdWJfZm10dHknIGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gKGVyYXNlX3JlbCBzdWJfZm10dHlfcmVzdCkgZm10IGZtdHR5X3Jlc3RcbiAgICBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltbSBzdWJfZm10dHlfcmVzdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdCcpXG4gIHwgRW5kX29mX2ZtdHR5LCBmbXR0eSAtPlxuICAgIEZtdHR5X2ZtdF9FQkIgKEVuZF9vZl9mbXR0eSwgdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSlcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBgcmVjYXN0YCBpcyBhIGJpdCBkaXNhcHBvaW50aW5nLiBUaGVcbiAgIGludmFyaWFudCBwcm92aWRlZCBieSB0aGUgdHlwZSBhcmUgdmVyeSBzdHJvbmc6IHRoZSBpbnB1dCBmb3JtYXQnc1xuICAgdHlwZSBpcyBpbiByZWxhdGlvbiB0byB0aGUgb3V0cHV0IHR5cGUncyBhcyB3aXRuZXNzZWQgYnkgdGhlXG4gICBmbXR0eV9yZWwgYXJndW1lbnQuIE9uZSB3b3VsZCBhdCBmaXJzdCBleHBlY3QgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgdG90YWwsIGFuZCBpbXBsZW1lbnRhYmxlIGJ5IGV4aGF1c3RpdmUgcGF0dGVybiBtYXRjaGluZy4gSW5zdGVhZCxcbiAgIHdlIHJldXNlIHRoZSBoaWdobHkgcGFydGlhbCBhbmQgbXVjaCBsZXNzIHdlbGwtZGVmaW5lZCBmdW5jdGlvblxuICAgYHR5cGVfZm9ybWF0YCB0aGF0IGhhcyBsb3N0IGFsbCBrbm93bGVkZ2Ugb2YgdGhlIGNvcnJlc3BvbmRlbmNlXG4gICBiZXR3ZWVuIHRoZSBhcmd1bWVudCdzIHR5cGVzLlxuXG4gICBCZXNpZGVzIHRoZSBmYWN0IHRoYXQgdGhpcyBmdW5jdGlvbiByZXVzZXMgYSBsb3Qgb2YgdGhlXG4gICBgdHlwZV9mb3JtYXRgIGxvZ2ljIChlZy46IHNlZWluZyBJbnRfdHkgaW4gdGhlIGZtdHR5IHBhcmFtZXRlciBkb2VzXG4gICBub3QgbGV0IHlvdSBtYXRjaCBvbiBJbnQgb25seSwgYXMgeW91IG1heSBpbiBmYWN0IGhhdmUgRmxvYXRcbiAgIChBcmdfcGFkZGluZywgLi4uKSAoXCIlLipkXCIpIGJlZ2lubmluZyB3aXRoIGFuIEludF90eSksIGl0IGlzIGFsc29cbiAgIGEgcGFydGlhbCBmdW5jdGlvbiwgYmVjYXVzZSB0aGUgdHlwaW5nIGluZm9ybWF0aW9uIGluIGEgZm9ybWF0IGlzXG4gICBub3QgcXVpdGUgZW5vdWdoIHRvIHJlY29uc3RydWN0IGl0IHVuYW1iaWd1b3VzbHkuIEZvciBleGFtcGxlLCB0aGVcbiAgIGZvcm1hdCB0eXBlcyBvZiBcIiVkJV9yXCIgYW5kIFwiJV9yJWRcIiBoYXZlIHRoZSBzYW1lIGZvcm1hdDZcbiAgIHBhcmFtZXRlcnMsIGJ1dCB0aGV5IGFyZSBub3QgYXQgYWxsIGV4Y2hhbmdlYWJsZSwgYW5kIHB1dHRpbmcgb25lXG4gICBpbiBwbGFjZSBvZiB0aGUgb3RoZXIgbXVzdCByZXN1bHQgaW4gYSBkeW5hbWljIGZhaWx1cmUuXG5cbiAgIEdpdmVuIHRoYXQ6XG4gICAtIHdlJ2QgaGF2ZSB0byBkdXBsaWNhdGUgYSBsb3Qgb2Ygbm9uLXRyaXZpYWwgdHlwaW5nIGxvZ2ljIGZyb20gdHlwZV9mb3JtYXRcbiAgIC0gdGhpcyB3b3VsZG4ndCBldmVuIGVsaW1pbmF0ZSAoYWxsKSB0aGUgZHluYW1pYyBmYWlsdXJlc1xuICAgd2UgZGVjaWRlZCB0byBqdXN0IHJldXNlIHR5cGVfZm9ybWF0IGRpcmVjdGx5IGZvciBub3cuXG4qKVxubGV0IHJlY2FzdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+XG4gIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUHJpbnRpbmcgdG9vbHMgKilcblxuKCogQWRkIHBhZGRpbmcgc3BhY2VzIGFyb3VuZCBhIHN0cmluZy4gKilcbmxldCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCBzdHIgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHdpZHRoLCBwYWR0eSA9XG4gICAgYWJzIHdpZHRoLFxuICAgICgqIHdoaWxlIGxpdGVyYWwgcGFkZGluZyB3aWR0aHMgYXJlIGFsd2F5cyBub24tbmVnYXRpdmUsXG4gICAgICAgZHluYW1pY2FsbHktc2V0IHdpZHRocyAoQXJnX3BhZGRpbmcsIGVnLiAlKmQpIG1heSBiZSBuZWdhdGl2ZTtcbiAgICAgICB3ZSBpbnRlcnByZXQgdGhvc2UgYXMgc3BlY2lmeWluZyBhIHBhZGRpbmctdG8tdGhlLWxlZnQ7IHRoaXNcbiAgICAgICBtZWFucyB0aGF0ICcwJyBtYXkgZ2V0IGRyb3BwZWQgZXZlbiBpZiBpdCB3YXMgZXhwbGljaXRseSBzZXQsXG4gICAgICAgYnV0OlxuICAgICAgIC0gdGhpcyBpcyB3aGF0IHRoZSBsZWdhY3kgaW1wbGVtZW50YXRpb24gZG9lcywgYW5kXG4gICAgICAgICB3ZSBwcmVzZXJ2ZSBjb21wYXRpYmlsaXR5IGlmIHBvc3NpYmxlXG4gICAgICAgLSB3ZSBjb3VsZCBvbmx5IHNpZ25hbCB0aGlzIGlzc3VlIGJ5IGZhaWxpbmcgYXQgcnVudGltZSxcbiAgICAgICAgIHdoaWNoIGlzIG5vdCB2ZXJ5IG5pY2UuLi4gKilcbiAgICBpZiB3aWR0aCA8IDAgdGhlbiBMZWZ0IGVsc2UgcGFkdHkgaW5cbiAgaWYgd2lkdGggPD0gbGVuIHRoZW4gc3RyIGVsc2VcbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSB3aWR0aCAoaWYgcGFkdHkgPSBaZXJvcyB0aGVuICcwJyBlbHNlICcgJykgaW5cbiAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgfCBMZWZ0ICAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgMCBsZW5cbiAgICB8IFJpZ2h0IC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAwICYmIChzdHIuWzBdID0gJysnIHx8IHN0ci5bMF0gPSAnLScgfHwgc3RyLlswXSA9ICcgJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMCBzdHIuWzBdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzICh3aWR0aCAtIGxlbiArIDEpIChsZW4gLSAxKVxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAxICYmIHN0ci5bMF0gPSAnMCcgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzICh3aWR0aCAtIGxlbiArIDIpIChsZW4gLSAyKVxuICAgIHwgWmVyb3MgLT5cbiAgICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIGVuZDtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBBZGQgJzAnIHBhZGRpbmcgdG8gaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbmxldCBmaXhfaW50X3ByZWNpc2lvbiBwcmVjIHN0ciA9XG4gIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIG1hdGNoIHN0ci5bMF0gd2l0aFxuICB8ICgnKycgfCAnLScgfCAnICcpIGFzIGMgd2hlbiBwcmVjICsgMSA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMSkgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAwIGM7XG4gICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzIChwcmVjIC0gbGVuICsgMikgKGxlbiAtIDEpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIHdoZW4gcHJlYyArIDIgPiBsZW4gJiYgbGVuID4gMSAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMikgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzIChwcmVjIC0gbGVuICsgNCkgKGxlbiAtIDIpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIHdoZW4gcHJlYyA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHByZWMgJzAnIGluXG4gICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzIChwcmVjIC0gbGVuKSBsZW47XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCBfIC0+XG4gICAgc3RyXG5cbigqIEVzY2FwZSBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGluZyBjb252ZW50aW9uLiAqKVxubGV0IHN0cmluZ190b19jYW1sX3N0cmluZyBzdHIgPVxuICBsZXQgc3RyID0gU3RyaW5nLmVzY2FwZWQgc3RyIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFxcIicgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfaW50L2ludDMyL25hdGl2ZWludC9pbnQ2NCBmaXJzdCBhcmd1bWVudFxuICAgZnJvbSBhbiBpbnRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfaWNvbnYgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWRcIiB8IEludF9wZCAtPiBcIiUrZFwiIHwgSW50X3NkIC0+IFwiJSBkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVpXCIgfCBJbnRfcGkgLT4gXCIlK2lcIiB8IEludF9zaSAtPiBcIiUgaVwiXG4gIHwgSW50X3ggLT4gXCIleFwiIHwgSW50X0N4IC0+IFwiJSN4XCJcbiAgfCBJbnRfWCAtPiBcIiVYXCIgfCBJbnRfQ1ggLT4gXCIlI1hcIlxuICB8IEludF9vIC0+IFwiJW9cIiB8IEludF9DbyAtPiBcIiUjb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIldVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZMID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVMZFwiIHwgSW50X3BkIC0+IFwiJStMZFwiIHwgSW50X3NkIC0+IFwiJSBMZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlTGlcIiB8IEludF9waSAtPiBcIiUrTGlcIiB8IEludF9zaSAtPiBcIiUgTGlcIlxuICB8IEludF94IC0+IFwiJUx4XCIgfCBJbnRfQ3ggLT4gXCIlI0x4XCJcbiAgfCBJbnRfWCAtPiBcIiVMWFwiIHwgSW50X0NYIC0+IFwiJSNMWFwiXG4gIHwgSW50X28gLT4gXCIlTG9cIiB8IEludF9DbyAtPiBcIiUjTG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJUx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udmwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWxkXCIgfCBJbnRfcGQgLT4gXCIlK2xkXCIgfCBJbnRfc2QgLT4gXCIlIGxkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVsaVwiIHwgSW50X3BpIC0+IFwiJStsaVwiIHwgSW50X3NpIC0+IFwiJSBsaVwiXG4gIHwgSW50X3ggLT4gXCIlbHhcIiB8IEludF9DeCAtPiBcIiUjbHhcIlxuICB8IEludF9YIC0+IFwiJWxYXCIgfCBJbnRfQ1ggLT4gXCIlI2xYXCJcbiAgfCBJbnRfbyAtPiBcIiVsb1wiIHwgSW50X0NvIC0+IFwiJSNsb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252biA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbmRcIiB8IEludF9wZCAtPiBcIiUrbmRcIiB8IEludF9zZCAtPiBcIiUgbmRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJW5pXCIgfCBJbnRfcGkgLT4gXCIlK25pXCIgfCBJbnRfc2kgLT4gXCIlIG5pXCJcbiAgfCBJbnRfeCAtPiBcIiVueFwiIHwgSW50X0N4IC0+IFwiJSNueFwiXG4gIHwgSW50X1ggLT4gXCIlblhcIiB8IEludF9DWCAtPiBcIiUjblhcIlxuICB8IEludF9vIC0+IFwiJW5vXCIgfCBJbnRfQ28gLT4gXCIlI25vXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVudVwiXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfZmxvYXQgZmlyc3QgYXJndW1lbnQgZnJvbSBhIGZsb2F0X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMgPVxuICAgIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgICBsZXQgc3ltYiA9IGNoYXJfb2ZfZmNvbnYgfmNGOidnJyBmY29udiBpblxuICAgIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBwcmVjKTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmIHN5bWI7XG4gICAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG5sZXQgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgcyA9XG4gIG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICBsZXQgZGlnaXRzID1cbiAgICAgIGxldCBuID0gcmVmIDAgaW5cbiAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgIHwgJzAnLi4nOScgLT4gaW5jciBuXG4gICAgICAgIHwgXyAtPiAoKVxuICAgICAgZG9uZTtcbiAgICAgICFuXG4gICAgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAoZGlnaXRzIC0gMSkgLyAzKSBpblxuICAgIGxldCBwb3MgPSByZWYgMCBpblxuICAgIGxldCBwdXQgYyA9IEJ5dGVzLnNldCBidWYgIXBvcyBjOyBpbmNyIHBvcyBpblxuICAgIGxldCBsZWZ0ID0gcmVmICgoZGlnaXRzIC0gMSkgbW9kIDMgKyAxKSBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAnMCcuLic5JyBhcyBjIC0+XG4gICAgICAgICAgaWYgIWxlZnQgPSAwIHRoZW4gKHB1dCAnXyc7IGxlZnQgOj0gMyk7IGRlY3IgbGVmdDsgcHV0IGNcbiAgICAgIHwgYyAtPiBwdXQgY1xuICAgIGRvbmU7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcbiAgfCBfIC0+IHNcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byBhIGNvbnZlcnNpb24uICopXG5sZXQgY29udmVydF9pbnQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50IChmb3JtYXRfb2ZfaWNvbnYgaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQzMiBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQzMiAoZm9ybWF0X29mX2ljb252bCBpY29udikgbilcbmxldCBjb252ZXJ0X25hdGl2ZWludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9uYXRpdmVpbnQgKGZvcm1hdF9vZl9pY29udm4gaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQ2NCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQ2NCAoZm9ybWF0X29mX2ljb252TCBpY29udikgbilcblxuKCogQ29udmVydCBhIGZsb2F0IHRvIHN0cmluZy4gKilcbigqIEZpeCBzcGVjaWFsIGNhc2Ugb2YgXCJPQ2FtbCBmbG9hdCBmb3JtYXRcIi4gKilcbmxldCBjb252ZXJ0X2Zsb2F0IGZjb252IHByZWMgeCA9XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfaCB8IEZsb2F0X0ggLT5cbiAgICBsZXQgc2lnbiA9XG4gICAgICBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICAgICAgfCBGbG9hdF9mbGFnX3AgLT4gJysnXG4gICAgICB8IEZsb2F0X2ZsYWdfcyAtPiAnICdcbiAgICAgIHwgXyAtPiAnLScgaW5cbiAgICBsZXQgc3RyID0gaGV4c3RyaW5nX29mX2Zsb2F0IHggcHJlYyBzaWduIGluXG4gICAgYmVnaW4gbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgICB8IEZsb2F0X0ggLT4gU3RyaW5nLnVwcGVyY2FzZV9hc2NpaSBzdHJcbiAgICB8IF8gLT4gc3RyXG4gICAgZW5kXG4gIHwgXyAtPlxuICAgIGxldCBzdHIgPSBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4IGluXG4gICAgaWYgc25kIGZjb252IDw+IEZsb2F0X0YgdGhlbiBzdHIgZWxzZVxuICAgICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgICBsZXQgcmVjIGlzX3ZhbGlkIGkgPVxuICAgICAgICBpZiBpID0gbGVuIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICAgIHwgJy4nIHwgJ2UnIHwgJ0UnIC0+IHRydWVcbiAgICAgICAgICB8IF8gLT4gaXNfdmFsaWQgKGkgKyAxKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHggd2l0aFxuICAgICAgfCBGUF9ub3JtYWwgfCBGUF9zdWJub3JtYWwgfCBGUF96ZXJvIC0+XG4gICAgICAgIGlmIGlzX3ZhbGlkIDAgdGhlbiBzdHIgZWxzZSBzdHIgXiBcIi5cIlxuICAgICAgfCBGUF9pbmZpbml0ZSAtPlxuICAgICAgICBpZiB4IDwgMC4wIHRoZW4gXCJuZWdfaW5maW5pdHlcIiBlbHNlIFwiaW5maW5pdHlcIlxuICAgICAgfCBGUF9uYW4gLT4gXCJuYW5cIlxuXG4oKiBDb252ZXJ0IGEgY2hhciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBmb3JtYXRfY2FtbF9jaGFyIGMgPVxuICBsZXQgc3RyID0gQ2hhci5lc2NhcGVkIGMgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXCcnIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHR5cGUgdG8gc3RyaW5nICopXG5sZXQgc3RyaW5nX29mX2ZtdHR5IGZtdHR5ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBwcmludGluZyBmdW5jdGlvbiAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBwcmludGluZyBmdW5jdGlvbi4gKilcbigqIFVzZWQgdG8gZ2VuZXJhdGUgUHJpbnRmIGFuZCBGb3JtYXQgcHJpbnRpbmcgZnVuY3Rpb25zLiAqKVxuKCogUGFyYW1ldGVyczpcbiAgICAgazogYSBjb250aW51YXRpb24gZmluYWxseSBhcHBsaWVkIHRvIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gICAgIG86IHRoZSBvdXRwdXQgc3RyZWFtIChzZWUgaywgJWEgYW5kICV0KS5cbiAgICAgYWNjOiByZXYgbGlzdCBvZiBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzaCwgZm9ybWF0dGluZywgLi4uKS5cbiAgICAgZm10OiB0aGUgZm9ybWF0LiAqKVxubGV0IHJlYyBtYWtlX3ByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2NhbWxfY2hhciBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgKGZ1biBzdHIgLT4gc3RyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ190b19jYW1sX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50IGljb252XG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDMyIGljb252XG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9uYXRpdmVpbnQgaWNvbnZcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50NjQgaWNvbnZcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgZmNvbnZcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ19vZl9ib29sXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIGZ1biBmIHggLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGZ1biBvIC0+IGYgbyB4KSkgcmVzdFxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBmdW4gZiAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgKCkpXG4gIHwgUmVhZGVyIF8gLT5cbiAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICopXG4gICAgKCogSW5kZWVkLCBzaW5jZSBwcmludGYgYW5kIGNvLiB0YWtlIGEgZm9ybWF0NCBhcyBhcmd1bWVudCwgdGhlICdkIGFuZCAnZVxuICAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiBmbXQgYXJlIG9idmlvdXNseSBlcXVhbHMuIFRoZSBSZWFkZXIgaXMgdGhlXG4gICAgICAgb25seSBjb25zdHJ1Y3RvciB3aGljaCB0b3VjaCAnZCBhbmQgJ2UgdHlwZSBwYXJhbWV0ZXJzIG9mIHRoZSBmb3JtYXRcbiAgICAgICB0eXBlLCBpdCBhZGRzIGFuICgtPikgdG8gdGhlICdkIHBhcmFtZXRlcnMuIENvbnNlcXVlbnRseSwgYSBmb3JtYXQ0XG4gICAgICAgY2Fubm90IGNvbnRhaW4gYSBSZWFkZXIgbm9kZSwgZXhjZXB0IGluIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG9cbiAgICAgICBhbiAley4uLiV9LiBJdCdzIG5vdCBhIHByb2JsZW0gYmVjYXVzZSBtYWtlX3ByaW50ZiBkbyBub3QgY2FsbFxuICAgICAgIGl0c2VsZiByZWN1cnNpdmVseSBvbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvICV7Li4uJX0uICopXG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mbHVzaCBhY2MpIHJlc3RcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX3N0cmluZ19saXRlcmFsIChhY2MsIHN0cikpIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfY2hhcl9saXRlcmFsIChhY2MsIGNocikpIHJlc3RcblxuICB8IEZvcm1hdF9hcmcgKF8sIHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSBzdHJpbmdfb2ZfZm10dHkgc3ViX2ZtdHR5IGluXG4gICAgKGZ1biBzdHIgLT5cbiAgICAgIGlnbm9yZSBzdHI7XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHkpKSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+IG1ha2VfcHJpbnRmIGsgYWNjXG4gICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgbGV0IG5ld19hY2MgPSBBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVbXCIpIGluXG4gICAgZnVuIF8gLT4gbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICgqIFRoaXMgY2FzZSBzaG91bGQgYmUgcmVmdXNlZCBmb3IgUHJpbnRmLiAqKVxuICAgICgqIEFjY2VwdGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiAqKVxuICAgICgqIEludGVycHJldCAlbCwgJW4gYW5kICVMIGFzICV1LiAqKVxuICAgIGZ1biBuIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfaW50IFwiJXVcIiBuKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbWFrZV9pZ25vcmVkX3BhcmFtIGsgYWNjIGlnbiByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19saXQgKGFjYywgZm10aW5nX2xpdCkpIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl90YWcga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl9ib3gga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBrIGFjY1xuXG4oKiBEZWxheSB0aGUgZXJyb3IgKEludmFsaWRfYXJndW1lbnQgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpLiAqKVxuKCogR2VuZXJhdGUgZnVuY3Rpb25zIHRvIHRha2UgcmVtYWluaW5nIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIFwiJV9cIikuICopXG5hbmQgbWFrZV9pZ25vcmVkX3BhcmFtIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgZm10dHkgZm10XG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcblxuXG4oKiBTcGVjaWFsIGNhc2Ugb2YgcHJpbnRmIFwiJV8oXCIuICopXG5hbmQgbWFrZV9mcm9tX2ZtdHR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgZm10dHkgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBSZWFkZXJfdHkgXyAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogSW5zZXJ0IGFuIEFjY19pbnZhbGlkX2FyZyBpbiB0aGUgYWNjdW11bGF0b3IgYW5kIGNvbnRpbnVlIHRvIGdlbmVyYXRlXG4gICBjbG9zdXJlcyB0byBnZXQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG5hbmQgbWFrZV9pbnZhbGlkX2FyZyA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPlxuICBtYWtlX3ByaW50ZiBrIChBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpKSBmbXRcblxuKCogRml4IHBhZGRpbmcsIHRha2UgaXQgYXMgYW4gZXh0cmEgaW50ZWdlciBhcmd1bWVudCBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9wYWRkaW5nIDogdHlwZSB4IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHogLT4gYSkgcGFkZGluZyAtPiAoeiAtPiBzdHJpbmcpIC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCB0cmFucyAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHJhbnMgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcblxuKCogRml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBmb3IgaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0LiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IChpbnRfY29udiAtPiB6IC0+IHN0cmluZykgLT5cbiAgICBpbnRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyB0cmFucyBpY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gdHJhbnMgaWNvbnYgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuXG4oKiBDb252ZXJ0IGEgZmxvYXQsIGZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gaWYgbmVlZGVkLiAqKVxuKCogVGFrZSB0aGUgZmxvYXQgYXJndW1lbnQgYW5kIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgZmxvYXQgLT4gYSkgcHJlY2lzaW9uIC0+IGZsb2F0X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgZmNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbmFuZCBtYWtlX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geCAtPiB5ID1cbiAgZnVuIGsgYWNjIHJlc3QgYXJpdHkgZiAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiB4KVxuXG5sZXQgY29uc3QgeCBfID0geFxuXG5sZXQgcmVjIG1ha2VfaXByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuICBmdW4gayBvIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBDYW1sX3N0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBCb29sIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyByZXN0IGFyaXR5XG4gICAgfCBSZWFkZXIgXyAtPlxuICAgICAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICBTZWUgdGhlXG4gICAgICAgICAgIG5vdGUgaW4gdGhlIGNvcnJlc3BvbmRpbmcgY2FzZSBmb3IgbWFrZV9wcmludGYuICopXG4gICAgICAgIGFzc2VydCBmYWxzZVxuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+XG4gICAgICAgICAgbWFrZV9pcHJpbnRmIGsgb1xuICAgICAgICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG4gICAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pZ25vcmVkX3BhcmFtIChmdW4gXyAtPiBrIG8pIChFbmRfb2ZfYWNjKSBpZ24gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgICAgIGsgb1xuYW5kIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIDpcbiAgdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IHggPVxuICBmdW4gayBvIGZtdCBwYWQgcHJlYyAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICwgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpKVxuYW5kIGZuX29mX2N1c3RvbV9hcml0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT5cbiAgc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHkgPVxuICBmdW4gayBvIGZtdCAtPiBmdW5jdGlvblxuICAgIHwgQ3VzdG9tX3plcm8gLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyBmbXRcbiAgICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgICAgIGNvbnN0IChmbl9vZl9jdXN0b21fYXJpdHkgayBvIGZtdCBhcml0eSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29udGludWF0aW9ucyBmb3IgbWFrZV9wcmludGYgKilcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBvIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQHtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQFtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X2NoYXIgbyBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmIG9cbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGZsdXNoIG9cbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBvIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIGJ1ZnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBmIGJcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IGJ1ZnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBidWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiAlYSBhbmQgJXQuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiAoZiAoKSlcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEVycm9yIG1hbmFnZW1lbnQgKilcblxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBwcmV0dHktcHJpbnRlZCBlcnJvciBtZXNzYWdlLiAqKVxubGV0IGZhaWx3aXRoX21lc3NhZ2UgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IGsgYWNjID0gc3RycHV0X2FjYyBidWYgYWNjOyBmYWlsd2l0aCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdHRpbmcgdG9vbHMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhbiBvcGVuIGJsb2NrIGRlc2NyaXB0aW9uIChpbmRlbnQsIGJsb2NrX3R5cGUpICopXG5sZXQgb3Blbl9ib3hfb2Zfc3RyaW5nIHN0ciA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiAoMCwgUHBfYm94KSBlbHNlXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IGludmFsaWRfYm94ICgpID0gZmFpbHdpdGhfbWVzc2FnZSBcImludmFsaWQgYm94IGRlc2NyaXB0aW9uICVTXCIgc3RyIGluXG4gICAgbGV0IHJlYyBwYXJzZV9zcGFjZXMgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gaSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIC0+IHBhcnNlX3NwYWNlcyAoaSArIDEpXG4gICAgICAgIHwgXyAtPiBpXG4gICAgYW5kIHBhcnNlX2x3b3JkIGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICdhJyAuLiAneicgLT4gcGFyc2VfbHdvcmQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqXG4gICAgYW5kIHBhcnNlX2ludCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IHBhcnNlX2ludCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGogaW5cbiAgICBsZXQgd3N0YXJ0ID0gcGFyc2Vfc3BhY2VzIDAgaW5cbiAgICBsZXQgd2VuZCA9IHBhcnNlX2x3b3JkIHdzdGFydCB3c3RhcnQgaW5cbiAgICBsZXQgYm94X25hbWUgPSBTdHJpbmcuc3ViIHN0ciB3c3RhcnQgKHdlbmQgLSB3c3RhcnQpIGluXG4gICAgbGV0IG5zdGFydCA9IHBhcnNlX3NwYWNlcyB3ZW5kIGluXG4gICAgbGV0IG5lbmQgPSBwYXJzZV9pbnQgbnN0YXJ0IG5zdGFydCBpblxuICAgIGxldCBpbmRlbnQgPVxuICAgICAgaWYgbnN0YXJ0ID0gbmVuZCB0aGVuIDAgZWxzZVxuICAgICAgICB0cnkgaW50X29mX3N0cmluZyAoU3RyaW5nLnN1YiBzdHIgbnN0YXJ0IChuZW5kIC0gbnN0YXJ0KSlcbiAgICAgICAgd2l0aCBGYWlsdXJlIF8gLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICBsZXQgZXhwX2VuZCA9IHBhcnNlX3NwYWNlcyBuZW5kIGluXG4gICAgaWYgZXhwX2VuZCA8PiBsZW4gdGhlbiBpbnZhbGlkX2JveCAoKTtcbiAgICBsZXQgYm94X3R5cGUgPSBtYXRjaCBib3hfbmFtZSB3aXRoXG4gICAgICB8IFwiXCIgfCBcImJcIiAtPiBQcF9ib3hcbiAgICAgIHwgXCJoXCIgICAgICAtPiBQcF9oYm94XG4gICAgICB8IFwidlwiICAgICAgLT4gUHBfdmJveFxuICAgICAgfCBcImh2XCIgICAgIC0+IFBwX2h2Ym94XG4gICAgICB8IFwiaG92XCIgICAgLT4gUHBfaG92Ym94XG4gICAgICB8IF8gICAgICAgIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgKGluZGVudCwgYm94X3R5cGUpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUGFyc2luZyB0b29scyAqKVxuXG4oKiBDcmVhdGUgYSBwYWRkaW5nX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcgYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZGRpbmdfZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcGFkZGluZ19mbXRfZWJiID1cbmZ1biBwYWQgZm10IC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoTm9fcGFkZGluZywgZm10KVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRkaW5nX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgZm10KVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIGZtdClcblxuKCogQ3JlYXRlIGEgcHJlY2lzaW9uX2ZtdF9lYmIgZnJvbSBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wcmVjaXNpb25fZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcHJlY2lzaW9uIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwcmVjaXNpb25fZm10X2ViYiA9XG5mdW4gcHJlYyBmbXQgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uICAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChOb19wcmVjaXNpb24sIGZtdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKExpdF9wcmVjaXNpb24gcCwgZm10KVxuICB8IEFyZ19wcmVjaXNpb24gICAtPiBQcmVjaXNpb25fZm10X0VCQiAoQXJnX3ByZWNpc2lvbiwgZm10KVxuXG4oKiBDcmVhdGUgYSBwYWRwcmVjX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgYW5kIHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnRzXG4gICBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkcHJlY19mbXRfZWJiIDogdHlwZSB4IHkgeiB0IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+XG4gICAgKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgIChfLCBfLCBfLCBfLCBfKSBwYWRwcmVjX2ZtdF9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdCAtPlxuICBsZXQgUHJlY2lzaW9uX2ZtdF9FQkIgKHByZWMsIGZtdCcpID0gbWFrZV9wcmVjaXNpb25fZm10X2ViYiBwcmVjIGZtdCBpblxuICBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIHByZWMsIGZtdCcpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZHByZWNfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBwcmVjLCBmbXQnKVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIHByZWMsIGZtdCcpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwYXJzaW5nICopXG5cbigqIFBhcnNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGZvcm1hdCBhbmQgY3JlYXRlIGEgZm10X2ViYi4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSBpbiBjYXNlIG9mIGludmFsaWQgZm9ybWF0LiAqKVxubGV0IGZtdF9lYmJfb2Zfc3RyaW5nID9sZWdhY3lfYmVoYXZpb3Igc3RyID1cbiAgKCogUGFyYW1ldGVycyBuYW1pbmcgY29udmVudGlvbjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gbGl0X3N0YXJ0OiBzdGFydCBvZiB0aGUgbGl0ZXJhbCBzZXF1ZW5jZS4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzdHJfaW5kOiBjdXJyZW50IGluZGV4IGluIHRoZSBzdHJpbmcuICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGVuZF9pbmQ6IGVuZCBvZiB0aGUgY3VycmVudCAoc3ViLSlmb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcGN0X2luZDogaW5kZXggb2YgdGhlICclJyBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICopXG4gICgqICAgLSB6ZXJvOiAgaXMgdGhlICcwJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIG1pbnVzOiBpcyB0aGUgJy0nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGx1czogIGlzIHRoZSAnKycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBoYXNoOiAgaXMgdGhlICcjJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHNwYWNlOiBpcyB0aGUgJyAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaWduOiAgIGlzIHRoZSAnXycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwYWQ6IHBhZGRpbmcgb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHByZWM6IHByZWNpc2lvbiBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3ltYjogY2hhciByZXByZXNlbnRpbmcgdGhlIGNvbnZlcnNpb24gKCdjJywgJ3MnLCAnZCcsIC4uLikuICopXG4gICgqICAgLSBjaGFyX3NldDogc2V0IG9mIGNoYXJhY3RlcnMgYXMgYml0bWFwIChzZWUgc2NhbmYgJVsuLi5dKS4gICAgKilcblxuICBsZXQgbGVnYWN5X2JlaGF2aW9yID0gbWF0Y2ggbGVnYWN5X2JlaGF2aW9yIHdpdGhcbiAgICB8IFNvbWUgZmxhZyAtPiBmbGFnXG4gICAgfCBOb25lIC0+IHRydWVcbiAgKCogIFdoZW4gdGhpcyBmbGFnIGlzIGVuYWJsZWQsIHRoZSBmb3JtYXQgcGFyc2VyIHRyaWVzIHRvIGJlaGF2ZSBhc1xuICAgICAgdGhlIDw0LjAyIGltcGxlbWVudGF0aW9ucywgaW4gcGFydGljdWxhciBpdCBpZ25vcmVzIG1vc3QgYmVuaW5lXG4gICAgICBub25zZW5zaWNhbCBmb3JtYXQuIFdoZW4gdGhlIGZsYWcgaXMgZGlzYWJsZWQsIGl0IHdpbGwgcmVqZWN0IGFueVxuICAgICAgZm9ybWF0IHRoYXQgaXMgbm90IGFjY2VwdGVkIGJ5IHRoZSBzcGVjaWZpY2F0aW9uLlxuXG4gICAgICBBIHR5cGljYWwgZXhhbXBsZSB3b3VsZCBiZSBcIiUrIGRcIjogc3BlY2lmeWluZyBib3RoICcrJyAoaWYgdGhlXG4gICAgICBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoIGEgJysnIHRvIGdldCB0aGUgc2FtZSB3aWR0aCBhc1xuICAgICAgbmVnYXRpdmUgbnVtYmVycykgYW5kICcgJyAoaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGhcbiAgICAgIGEgc3BhY2UpIGRvZXMgbm90IG1ha2Ugc2Vuc2UsIGJ1dCB0aGUgbGVnYWN5ICg8IDQuMDIpXG4gICAgICBpbXBsZW1lbnRhdGlvbiB3YXMgaGFwcHkgdG8ganVzdCBpZ25vcmUgdGhlIHNwYWNlLlxuICAqKVxuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZCBtc2cgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIG1zZ1xuICBpblxuXG4gICgqIFVzZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBmb3JtYXQgKG9yIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXQpIHdhcyBlbmNvdW50ZXJlZFxuICAgICAgdW5leHBlY3RlZGx5LiAqKVxuICBsZXQgdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2UgZW5kX2luZFxuICAgICAgXCJ1bmV4cGVjdGVkIGVuZCBvZiBmb3JtYXRcIlxuICBpblxuXG4gICgqIFVzZWQgZm9yICUwYzogbm8gb3RoZXIgd2lkdGhzIGFyZSBpbXBsZW1lbnRlZCAqKVxuICBsZXQgaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kXG4gICAgICBcIm5vbi16ZXJvIHdpZHRocyBhcmUgdW5zdXBwb3J0ZWQgZm9yICVjIGNvbnZlcnNpb25zXCJcbiAgaW5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIG9wdGlvbiBkZXBlbmRlbmN5XG4gICAgIHByb2JsZW0uICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IHN0cl9pbmQgYyBzID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAnJWMnIHdpdGhvdXQgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgYyBzXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIHVuZXhwZWN0ZWRcbiAgICAgY2hhcmFjdGVyLiAqKVxuICBsZXQgZXhwZWN0ZWRfY2hhcmFjdGVyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZCA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlcyBleHBlY3RlZCwgcmVhZCAlQ1wiXG4gICAgICBzdHIgc3RyX2luZCBleHBlY3RlZCByZWFkXG4gIGluXG5cbiAgKCogUGFyc2UgdGhlIHN0cmluZyBmcm9tIGJlZ19pbmQgKGluY2x1ZGVkKSB0byBlbmRfaW5kIChleGNsdWRlZCkuICopXG4gIGxldCByZWMgcGFyc2UgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gYmVnX2luZCBlbmRfaW5kIC0+IHBhcnNlX2xpdGVyYWwgYmVnX2luZCBiZWdfaW5kIGVuZF9pbmRcblxuICAoKiBSZWFkIGxpdGVyYWwgY2hhcmFjdGVycyB1cCB0byAnJScgb3IgJ0AnIHNwZWNpYWwgY2hhcmFjdGVycy4gKilcbiAgYW5kIHBhcnNlX2xpdGVyYWwgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIEVuZF9vZl9mb3JtYXQgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2Zvcm1hdCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgJ0AnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfYWZ0ZXJfYXQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfbGl0ZXJhbCBsaXRfc3RhcnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgKCogUGFyc2UgYSBmb3JtYXQgYWZ0ZXIgJyUnICopXG4gIGFuZCBwYXJzZV9mb3JtYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBlbmRfaW5kIC0+IHBhcnNlX2lnbiBwY3RfaW5kIChwY3RfaW5kICsgMSkgZW5kX2luZFxuXG4gIGFuZCBwYXJzZV9pZ24gOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ18nIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgKHN0cl9pbmQrMSkgZW5kX2luZCB0cnVlXG4gICAgICB8IF8gLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgZmFsc2VcblxuICBhbmQgcGFyc2VfZmxhZ3MgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmJcbiAgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgaWduIC0+XG4gICAgbGV0IHplcm8gPSByZWYgZmFsc2UgYW5kIG1pbnVzID0gcmVmIGZhbHNlXG4gICAgYW5kIHBsdXMgPSByZWYgZmFsc2UgYW5kIHNwYWNlID0gcmVmIGZhbHNlXG4gICAgYW5kIGhhc2ggPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgc2V0X2ZsYWcgc3RyX2luZCBmbGFnID1cbiAgICAgICgqIGluIGxlZ2FjeSBtb2RlLCBkdXBsaWNhdGUgZmxhZ3MgYXJlIGFjY2VwdGVkICopXG4gICAgICBpZiAhZmxhZyAmJiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIGR1cGxpY2F0ZSBmbGFnICVDXCJcbiAgICAgICAgICBzdHIgc3RyX2luZCBzdHIuW3N0cl9pbmRdO1xuICAgICAgZmxhZyA6PSB0cnVlO1xuICAgIGluXG4gICAgbGV0IHJlYyByZWFkX2ZsYWdzIHN0cl9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnMCcgLT4gc2V0X2ZsYWcgc3RyX2luZCB6ZXJvOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICctJyAtPiBzZXRfZmxhZyBzdHJfaW5kIG1pbnVzOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJysnIC0+IHNldF9mbGFnIHN0cl9pbmQgcGx1czsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnIycgLT4gc2V0X2ZsYWcgc3RyX2luZCBoYXNoOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyAnIC0+IHNldF9mbGFnIHN0cl9pbmQgc3BhY2U7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmRcbiAgICAgICAgICAhemVybyAhbWludXMgIXBsdXMgIWhhc2ggIXNwYWNlIGlnblxuICAgICAgZW5kXG4gICAgaW5cbiAgICByZWFkX2ZsYWdzIHN0cl9pbmRcblxuICAoKiBUcnkgdG8gcmVhZCBhIGRpZ2l0YWwgb3IgYSAnKicgcGFkZGluZy4gKilcbiAgYW5kIHBhcnNlX3BhZGRpbmcgOiB0eXBlIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCB6ZXJvIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYWR0eSA9IG1hdGNoIHplcm8sIG1pbnVzIHdpdGhcbiAgICAgIHwgZmFsc2UsIGZhbHNlIC0+IFJpZ2h0XG4gICAgICB8IGZhbHNlLCB0cnVlICAtPiBMZWZ0XG4gICAgICB8ICB0cnVlLCBmYWxzZSAtPiBaZXJvc1xuICAgICAgfCAgdHJ1ZSwgdHJ1ZSAgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGVmdFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnLScgXCIwXCIgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgIGxldCBuZXdfaW5kLCB3aWR0aCA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgKExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gKEFyZ19wYWRkaW5nIHBhZHR5KVxuICAgIHwgXyAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgICAgfCBMZWZ0ICAtPlxuICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy0nIFwicGFkZGluZ1wiO1xuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICB8IFplcm9zIC0+XG4gICAgICAgICAoKiBhICcwJyBwYWRkaW5nIGluZGljYXRpb24gbm90IGZvbGxvd2VkIGJ5IGFueXRoaW5nIHNob3VsZFxuICAgICAgICAgICBiZSBpbnRlcnByZXRlZCBhcyBhIFJpZ2h0IHBhZGRpbmcgb2Ygd2lkdGggMC4gVGhpcyBpcyB1c2VkXG4gICAgICAgICAgIGJ5IHNjYW5uaW5nIGNvbnZlcnNpb25zICUwcyBhbmQgJTBjICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIChMaXRfcGFkZGluZyAoUmlnaHQsIDApKVxuICAgICAgfCBSaWdodCAtPlxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICBlbmRcblxuICAoKiBJcyBwcmVjaXNpb24gZGVmaW5lZD8gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3BhZGRpbmcgOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnLicgLT5cbiAgICAgIHBhcnNlX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZFxuICAgIHwgc3ltYiAtPlxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBOb19wcmVjaXNpb24gcGFkIHN5bWJcblxuICAoKiBSZWFkIHRoZSBkaWdpdGFsIG9yICcqJyBwcmVjaXNpb24uICopXG4gIGFuZCBwYXJzZV9wcmVjaXNpb24gOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZCA9XG4gICAgICBsZXQgbmV3X2luZCwgcHJlYyA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gcHJlYykgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT4gcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kXG4gICAgfCAoJysnIHwgJy0nKSBhcyBzeW1iIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+XG4gICAgICAoKiBMZWdhY3kgbW9kZSB3b3VsZCBhY2NlcHQgYW5kIGlnbm9yZSAnKycgb3IgJy0nIGJlZm9yZSB0aGVcbiAgICAgICAgIGludGVnZXIgZGVzY3JpYmluZyB0aGUgZGVzaXJlZCBwcmVjaXNpb247IG5vdGUgdGhhdCB0aGlzXG4gICAgICAgICBjYW5ub3QgaGFwcGVuIGZvciBwYWRkaW5nIHdpZHRoLCBhcyAnKycgYW5kICctJyBhbHJlYWR5IGhhdmVcbiAgICAgICAgIGEgc2VtYW50aWNzIHRoZXJlLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHRoZSBpZGVhIChzdXBwb3J0ZWQgYnkgdGhpcyB0d2VhaykgdGhhdCB3aWR0aCBhbmRcbiAgICAgICAgIHByZWNpc2lvbiBsaXRlcmFscyBhcmUgXCJpbnRlZ2VyIGxpdGVyYWxzXCIgaW4gdGhlIE9DYW1sIHNlbnNlIGlzXG4gICAgICAgICBzdGlsbCBibGF0YW50bHkgd3JvbmcsIGFzIDEyM180NTYgb3IgMHhGRiBhcmUgcmVqZWN0ZWQuICopXG4gICAgICBwYXJzZV9saXRlcmFsIChtaW51cyB8fCBzeW1iID0gJy0nKSAoc3RyX2luZCArIDEpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIHBhZCBBcmdfcHJlY2lzaW9uXG4gICAgfCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBub3RlIHRoYXQgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRpZCBub3QgaWdub3JlICcuJyB3aXRob3V0XG4gICAgICAgICAgIGEgbnVtYmVyIChhcyBpdCBkb2VzIGZvciBwYWRkaW5nIGluZGljYXRpb25zKSwgYnV0XG4gICAgICAgICAgIGludGVycHJldHMgaXQgYXMgJy4wJyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiAwKVxuICAgICAgZWxzZVxuICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy4nIFwicHJlY2lzaW9uXCJcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogdCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2NvbnYgKHR5cGUgdSkgKHR5cGUgdikgKHBhZHByZWMgOiAodSwgdikgcGFkZGluZykgPVxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBwcmVjIHBhZHByZWMgc3RyLltzdHJfaW5kXSBpblxuICAgICgqIGluIGxlZ2FjeSBtb2RlLCBzb21lIGZvcm1hdHMgKCVzIGFuZCAlUykgYWNjZXB0IGEgd2VpcmQgbWl4IG9mXG4gICAgICAgcGFkZGluZyBhbmQgcHJlY2lzaW9uLCB3aGljaCBpcyBtZXJnZWQgYXMgYSBzaW5nbGUgcGFkZGluZ1xuICAgICAgIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZSwgaW4gJS4xMHMgdGhlIHByZWNpc2lvbiBpcyBpbXBsaWNpdGx5XG4gICAgICAgdW5kZXJzdG9vZCBhcyBwYWRkaW5nICUxMHMsIGJ1dCB0aGUgbGVmdC1wYWRkaW5nIGNvbXBvbmVudCBtYXlcbiAgICAgICBiZSBzcGVjaWZpZWQgZWl0aGVyIGFzIGEgbGVmdCBwYWRkaW5nIG9yIGEgbmVnYXRpdmUgcHJlY2lzaW9uOlxuICAgICAgICUtLjNzIGFuZCAlLi0zcyBhcmUgZXF1aXZhbGVudCB0byAlLTNzICopXG4gICAgbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgLT4gKFxuICAgICAgbWF0Y2ggbWludXMsIHByZWMgd2l0aFxuICAgICAgICB8IF8sIE5vX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IE5vX3BhZGRpbmdcbiAgICAgICAgfCBmYWxzZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChSaWdodCwgbikpXG4gICAgICAgIHwgdHJ1ZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChMZWZ0LCBuKSlcbiAgICAgICAgfCBmYWxzZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBSaWdodClcbiAgICAgICAgfCB0cnVlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIExlZnQpXG4gICAgKVxuICAgIHwgcGFkIC0+IHBhcnNlX2NvbnYgcGFkXG5cbiAgKCogQ2FzZSBhbmFseXNpcyBvbiBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfY29udmVyc2lvbiA6IHR5cGUgeCB5IHogdCB1IHYgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gKHgsIHkpIHBhZGRpbmcgLT5cbiAgICAgICAgKHosIHQpIHByZWNpc2lvbiAtPiAodSwgdikgcGFkZGluZyAtPiBjaGFyIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgcGFkcHJlYyBzeW1iIC0+XG4gICAgKCogRmxhZ3MgdXNlZCB0byBjaGVjayBvcHRpb24gdXNhZ2VzL2NvbXBhdGliaWxpdGllcy4gKilcbiAgICBsZXQgcGx1c191c2VkICA9IHJlZiBmYWxzZSBhbmQgaGFzaF91c2VkID0gcmVmIGZhbHNlXG4gICAgYW5kIHNwYWNlX3VzZWQgPSByZWYgZmFsc2UgYW5kIGlnbl91c2VkICAgPSByZWYgZmFsc2VcbiAgICBhbmQgcGFkX3VzZWQgICA9IHJlZiBmYWxzZSBhbmQgcHJlY191c2VkICA9IHJlZiBmYWxzZSBpblxuXG4gICAgKCogQWNjZXNzIHRvIG9wdGlvbnMsIHVwZGF0ZSBmbGFncy4gKilcbiAgICBsZXQgZ2V0X3BsdXMgICAgKCkgPSBwbHVzX3VzZWQgIDo9IHRydWU7IHBsdXNcbiAgICBhbmQgZ2V0X2hhc2ggICAoKSA9IGhhc2hfdXNlZCA6PSB0cnVlOyBoYXNoXG4gICAgYW5kIGdldF9zcGFjZSAgICgpID0gc3BhY2VfdXNlZCA6PSB0cnVlOyBzcGFjZVxuICAgIGFuZCBnZXRfaWduICAgICAoKSA9IGlnbl91c2VkICAgOj0gdHJ1ZTsgaWduXG4gICAgYW5kIGdldF9wYWQgICAgICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRcbiAgICBhbmQgZ2V0X3ByZWMgICAgKCkgPSBwcmVjX3VzZWQgIDo9IHRydWU7IHByZWNcbiAgICBhbmQgZ2V0X3BhZHByZWMgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZHByZWMgaW5cblxuICAgIGxldCBnZXRfaW50X3BhZCAoKSA9XG4gICAgICAoKiAlNS4zZCBpcyBhY2NlcHRlZCBhbmQgbWVhbmluZ2Z1bDogcGFkIHRvIGxlbmd0aCA1IHdpdGhcbiAgICAgICAgIHNwYWNlcywgYnV0IGZpcnN0IHBhZCB3aXRoIHplcm9zIHVwdG8gbGVuZ3RoIDMgKDAtcGFkZGluZ1xuICAgICAgICAgaXMgdGhlIGludGVycHJldGF0aW9uIG9mIFwicHJlY2lzaW9uXCIgZm9yIGludGVnZXIgZm9ybWF0cykuXG5cbiAgICAgICAgICUwNS4zZCBpcyByZWR1bmRhbnQ6IHBhZCB0byBsZW5ndGggNSAqd2l0aCB6ZXJvcyosIGJ1dFxuICAgICAgICAgZmlyc3QgcGFkIHdpdGggemVyb3MuLi4gVG8gYWRkIGluc3VsdCB0byB0aGUgaW5qdXJ5LCB0aGVcbiAgICAgICAgIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBpZ25vcmVzIHRoZSAwLXBhZGRpbmcgaW5kaWNhdGlvbiBhbmRcbiAgICAgICAgIGRvZXMgdGhlIDUgcGFkZGluZyB3aXRoIHNwYWNlcyBpbnN0ZWFkLiBXZSByZXVzZSB0aGlzXG4gICAgICAgICBpbnRlcnByZXRhdGlvbiBmb3IgY29tcGF0aWJpbGl0eSwgYnV0IHN0YXRpY2FsbHkgcmVqZWN0IHRoaXNcbiAgICAgICAgIGZvcm1hdCB3aGVuIHRoZSBsZWdhY3kgbW9kZSBpcyBkaXNhYmxlZCwgdG8gcHJvdGVjdCBzdHJpY3RcbiAgICAgICAgIHVzZXJzIGZyb20gdGhpcyBjb3JuZXIgY2FzZS4gKilcbiAgICAgICBtYXRjaCBnZXRfcGFkICgpLCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICAgICB8IHBhZCwgTm9fcHJlY2lzaW9uIC0+IHBhZFxuICAgICAgICAgfCBOb19wYWRkaW5nLCBfICAgICAtPiBOb19wYWRkaW5nXG4gICAgICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgbiksIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKVxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcywgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBMaXRfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWRcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkIGluXG5cbiAgICAoKiBDaGVjayB0aGF0IHBhZHR5IDw+IFplcm9zLiAqKVxuICAgIGxldCBjaGVja19ub18wIHN5bWIgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9XG4gICAgICBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoKExlZnQgfCBSaWdodCksIF8pIC0+IHBhZFxuICAgICAgfCBBcmdfcGFkZGluZyAoTGVmdCB8IFJpZ2h0KSAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcyAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgaW5cblxuICAgICgqIEdldCBwYWRkaW5nIGFzIGEgcGFkX29wdGlvbiAoc2VlIFwiJV9cIiwgXCIle1wiLCBcIiUoXCIgYW5kIFwiJVtcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgb3B0X29mX3BhZCBjICh0eXBlIGEpICh0eXBlIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgPSBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IE5vbmVcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aCkgLT4gU29tZSB3aWR0aFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInMCdcIlxuICAgICAgfCBMaXRfcGFkZGluZyAoTGVmdCwgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIictJ1wiXG4gICAgICB8IEFyZ19wYWRkaW5nIF8gLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInKidcIlxuICAgIGluXG4gICAgbGV0IGdldF9wYWRfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWQgKCkpIGluXG4gICAgbGV0IGdldF9wYWRwcmVjX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkcHJlYyAoKSkgaW5cblxuICAgICgqIEdldCBwcmVjaXNpb24gYXMgYSBwcmVjX29wdGlvbiAoc2VlIFwiJV9mXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IGdldF9wcmVjX29wdCAoKSA9IG1hdGNoIGdldF9wcmVjICgpIHdpdGhcbiAgICAgIHwgTm9fcHJlY2lzaW9uICAgICAgIC0+IE5vbmVcbiAgICAgIHwgTGl0X3ByZWNpc2lvbiBuZGVjIC0+IFNvbWUgbmRlY1xuICAgICAgfCBBcmdfcHJlY2lzaW9uICAgICAgLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicqJ1wiXG4gICAgaW5cblxuICAgIGxldCBmbXRfcmVzdWx0ID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnLCcgLT5cbiAgICAgIHBhcnNlIHN0cl9pbmQgZW5kX2luZFxuICAgIHwgJ2MnIC0+XG4gICAgICBsZXQgY2hhcl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoQ2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgc2Nhbl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlMGMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChTY2FuX25leHRfY2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgYmVnaW4gbWF0Y2ggZ2V0X3BhZF9vcHQgJ2MnIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSAwIC0+IHNjYW5fZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSBfbiAtPlxuICAgICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yXG4gICAgICAgICAgIHRoZW4gaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZFxuICAgICAgICAgICBlbHNlICgqIGxlZ2FjeSBpZ25vcmVzICVjIHdpZHRocyAqKSBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgZW5kXG4gICAgfCAnQycgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jYW1sX2NoYXIsZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChDYW1sX2NoYXIgZm10X3Jlc3QpXG4gICAgfCAncycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChTdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnUycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfY2FtbF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKENhbWxfc3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+XG4gICAgICBsZXQgaWNvbnYgPSBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IFRva2VuX2NvdW50ZXIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIHwgJ24nIHwgJ0wnIHdoZW4gc3RyX2luZD1lbmRfaW5kIHx8IG5vdCAoaXNfaW50X2Jhc2Ugc3RyLltzdHJfaW5kXSkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJfb2ZfY2hhciBzeW1iIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50MzIgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ24nIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpXG4gICAgICAgICAgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdMJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50NjQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2YnIHwgJ2UnIHwgJ0UnIHwgJ2cnIHwgJ0cnIHwgJ0YnIHwgJ2gnIHwgJ0gnIC0+XG4gICAgICBsZXQgZmNvbnYgPSBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZmxvYXQgKGdldF9wYWRfb3B0ICdfJywgZ2V0X3ByZWNfb3B0ICgpKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2InIHwgJ0InIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Jvb2wgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEJvb2wgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnYScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChBbHBoYSBmbXRfcmVzdClcbiAgICB8ICd0JyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKFRoZXRhIGZtdF9yZXN0KVxuICAgIHwgJ3InIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKFJlYWRlciBmbXRfcmVzdClcbiAgICB8ICchJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZsdXNoIGZtdF9yZXN0KVxuICAgIHwgKCclJyB8ICdAJykgYXMgYyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoYywgZm10X3Jlc3QpKVxuICAgIHwgJ3snIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnfScgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ3snLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICcoJyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJyknIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnKCcsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJ1snIC0+XG4gICAgICBsZXQgbmV4dF9pbmQsIGNoYXJfc2V0ID0gcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ18nLCBjaGFyX3NldCkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnWycsIGNoYXJfc2V0LCBmbXRfcmVzdCkpXG4gICAgfCAnLScgfCAnKycgfCAnIycgfCAnICcgfCAnXycgLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGZsYWcgJUMgaXMgb25seSBhbGxvd2VkIGFmdGVyIHRoZSAnJSUnLCBiZWZvcmUgcGFkZGluZyBhbmQgcHJlY2lzaW9uXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgc3ltYlxuICAgIHwgXyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgaW52YWxpZCBjb252ZXJzaW9uIFxcXCIlJSVjXFxcIlwiIHN0ciAoc3RyX2luZCAtIDEpIHN5bWJcbiAgICBpblxuICAgICgqIENoZWNrIGZvciB1bnVzZWQgb3B0aW9ucywgYW5kIHJlamVjdCB0aGVtIGFzIGluY29tcGF0aWJsZS5cblxuICAgICAgIFN1Y2ggY2hlY2tzIG5lZWQgdG8gYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsIGFzIHRoZSBsZWdhY3lcbiAgICAgICBwYXJzZXIgc2lsZW50bHkgaWdub3JlZCBpbmNvbXBhdGlibGUgZmxhZ3MuICopXG4gICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuIGJlZ2luXG4gICAgaWYgbm90ICFwbHVzX3VzZWQgJiYgcGx1cyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiO1xuICAgIGlmIG5vdCAhaGFzaF91c2VkICYmIGhhc2ggdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIjtcbiAgICBpZiBub3QgIXNwYWNlX3VzZWQgJiYgc3BhY2UgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIjtcbiAgICBpZiBub3QgIXBhZF91c2VkICAmJiBQYWRkaW5nX0VCQiBwYWQgPD4gUGFkZGluZ19FQkIgTm9fcGFkZGluZyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcImBwYWRkaW5nJ1wiO1xuICAgIGlmIG5vdCAhcHJlY191c2VkICYmIFByZWNpc2lvbl9FQkIgcHJlYyA8PiBQcmVjaXNpb25fRUJCIE5vX3ByZWNpc2lvbiB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgKGlmIGlnbiB0aGVuICdfJyBlbHNlIHN5bWIpXG4gICAgICAgIFwiYHByZWNpc2lvbidcIjtcbiAgICBpZiBpZ24gJiYgcGx1cyB0aGVuIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKydcIjtcbiAgICBlbmQ7XG4gICAgKCogdGhpcyBsYXN0IHRlc3QgbXVzdCBub3QgYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsXG4gICAgICAgYXMgaWdub3JpbmcgaXQgd291bGQgdHlwaWNhbGx5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0eXBpbmdcbiAgICAgICB0aGFuIHdoYXQgdGhlIGxlZ2FjeSBwYXJzZXIgdXNlZCAqKVxuICAgIGlmIG5vdCAhaWduX3VzZWQgJiYgaWduIHRoZW5cbiAgICAgIGJlZ2luIG1hdGNoIHN5bWIgd2l0aFxuICAgICAgICAoKiBhcmd1bWVudC1sZXNzIGZvcm1hdHMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIGluIGxlZ2FjeSBtb2RlICopXG4gICAgICAgIHwgKCdAJyB8ICclJyB8ICchJyB8ICcsJykgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gKClcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInXydcIlxuICAgICAgZW5kO1xuICAgIGZtdF9yZXN1bHRcblxuICAoKiBQYXJzZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgYW5kIGNoZWNrX29wZW5fYm94IDogdHlwZSBhIGIgYyBkIGUgZiAuIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gdW5pdCA9XG4gIGZ1biBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIEVuZF9vZl9mb3JtYXQpIC0+IChcbiAgICAgIHRyeSBpZ25vcmUgKG9wZW5fYm94X29mX3N0cmluZyBzdHIpIHdpdGggRmFpbHVyZSBfIC0+XG4gICAgICAgICgoKiBFbWl0IHdhcm5pbmc6IGludmFsaWQgb3BlbiBib3ggKikpXG4gICAgKVxuICAgIHwgXyAtPiAoKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8bmFtZT4gYWZ0ZXIgXCJAe1wiIG9yIFwiQFtcIi4gKilcbiAgYW5kIHBhcnNlX3RhZyA6IHR5cGUgZSBmIC4gYm9vbCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGlzX29wZW5fdGFnIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIHRyeVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIGxldCBpbmQgPSBTdHJpbmcuaW5kZXhfZnJvbSBzdHIgKHN0cl9pbmQgKyAxKSAnPicgaW5cbiAgICAgICAgaWYgaW5kID49IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgc3RyX2luZCAoaW5kIC0gc3RyX2luZCArIDEpIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKGluZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgKGluZCArIDEpIGluXG4gICAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChzdWJfZm10LCBzdWJfc3RyKSBpblxuICAgICAgICBsZXQgZm9ybWF0dGluZyA9IGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIChcbiAgICAgICAgICBjaGVja19vcGVuX2JveCBzdWJfZm10O1xuICAgICAgICAgIE9wZW5fYm94IHN1Yl9mb3JtYXQpIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2QnIC0+IEludF9DZFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2knIC0+IEludF9DaVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3UnIC0+IEludF9DdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzcGFjZSwgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgZmxvYXRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBzcGFjZSBzeW1iID1cbiAgICBsZXQgZmxhZyA9IG1hdGNoIHBsdXMsIHNwYWNlIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSAtPiBGbG9hdF9mbGFnX1xuICAgIHwgZmFsc2UsICB0cnVlIC0+IEZsb2F0X2ZsYWdfc1xuICAgIHwgIHRydWUsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfcFxuICAgIHwgIHRydWUsICB0cnVlIC0+XG4gICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gRmxvYXRfZmxhZ19wXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIiBpblxuICAgIGxldCBraW5kID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnZicgLT4gRmxvYXRfZlxuICAgIHwgJ2UnIC0+IEZsb2F0X2VcbiAgICB8ICdFJyAtPiBGbG9hdF9FXG4gICAgfCAnZycgLT4gRmxvYXRfZ1xuICAgIHwgJ0cnIC0+IEZsb2F0X0dcbiAgICB8ICdoJyAtPiBGbG9hdF9oXG4gICAgfCAnSCcgLT4gRmxvYXRfSFxuICAgIHwgJ0YnIC0+IEZsb2F0X0ZcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIGluXG4gICAgZmxhZywga2luZFxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBpbmNvbXBhdGlibGUgb3B0aW9ucy4qKVxuICBhbmQgaW5jb21wYXRpYmxlX2ZsYWcgOiB0eXBlIGEgLiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nIC0+IGEgPVxuICAgIGZ1biBwY3RfaW5kIHN0cl9pbmQgc3ltYiBvcHRpb24gLT5cbiAgICAgIGxldCBzdWJmbXQgPSBTdHJpbmcuc3ViIHN0ciBwY3RfaW5kIChzdHJfaW5kIC0gcGN0X2luZCkgaW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgICVzIGlzIGluY29tcGF0aWJsZSB3aXRoICclYycgaW4gc3ViLWZvcm1hdCAlU1wiXG4gICAgICAgIHN0ciBwY3RfaW5kIG9wdGlvbiBzeW1iIHN1YmZtdFxuXG4gIGluIHBhcnNlIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgKCogR3VhcmRlZCBzdHJpbmcgdG8gZm9ybWF0IGNvbnZlcnNpb25zICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzdHIgZm10dHkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IGZtdHR5LCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiXG4gICAgICBzdHIgKHN0cmluZ19vZl9mbXR0eSBmbXR0eSlcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggYW4gb3RoZXIgZm9ybWF0LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIChGb3JtYXQgKGZtdCcsIHN0cicpKSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgKGZtdHR5X29mX2ZtdCBmbXQnKSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIiBzdHIgc3RyJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIFByaW50ZlxuXG50eXBlIHQgPSBleG4gPSAuLlxuXG5sZXQgcHJpbnRlcnMgPSByZWYgW11cblxubGV0IGxvY2ZtdCA9IGZvcm1hdF9vZl9zdHJpbmcgXCJGaWxlIFxcXCIlc1xcXCIsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQ6ICVzXCJcblxubGV0IGZpZWxkIHggaSA9XG4gIGxldCBmID0gT2JqLmZpZWxkIHggaSBpblxuICBpZiBub3QgKE9iai5pc19ibG9jayBmKSB0aGVuXG4gICAgc3ByaW50ZiBcIiVkXCIgKE9iai5tYWdpYyBmIDogaW50KSAgICAgICAgICAgKCogY2FuIGFsc28gYmUgYSBjaGFyICopXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLnN0cmluZ190YWcgdGhlblxuICAgIHNwcmludGYgXCIlU1wiIChPYmoubWFnaWMgZiA6IHN0cmluZylcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouZG91YmxlX3RhZyB0aGVuXG4gICAgc3RyaW5nX29mX2Zsb2F0IChPYmoubWFnaWMgZiA6IGZsb2F0KVxuICBlbHNlXG4gICAgXCJfXCJcblxubGV0IHJlYyBvdGhlcl9maWVsZHMgeCBpID1cbiAgaWYgaSA+PSBPYmouc2l6ZSB4IHRoZW4gXCJcIlxuICBlbHNlIHNwcmludGYgXCIsICVzJXNcIiAoZmllbGQgeCBpKSAob3RoZXJfZmllbGRzIHggKGkrMSkpXG5cbmxldCBmaWVsZHMgeCA9XG4gIG1hdGNoIE9iai5zaXplIHggd2l0aFxuICB8IDAgLT4gXCJcIlxuICB8IDEgLT4gXCJcIlxuICB8IDIgLT4gc3ByaW50ZiBcIiglcylcIiAoZmllbGQgeCAxKVxuICB8IF8gLT4gc3ByaW50ZiBcIiglcyVzKVwiIChmaWVsZCB4IDEpIChvdGhlcl9maWVsZHMgeCAyKVxuXG5sZXQgdXNlX3ByaW50ZXJzIHggPVxuICBsZXQgcmVjIGNvbnYgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgKG1hdGNoIGhkIHggd2l0aFxuICAgICAgICAgfCBOb25lIHwgZXhjZXB0aW9uIF8gLT4gY29udiB0bFxuICAgICAgICAgfCBTb21lIHMgLT4gU29tZSBzKVxuICAgIHwgW10gLT4gTm9uZSBpblxuICBjb252ICFwcmludGVyc1xuXG5sZXQgdG9fc3RyaW5nX2RlZmF1bHQgPSBmdW5jdGlvblxuICB8IE91dF9vZl9tZW1vcnkgLT4gXCJPdXQgb2YgbWVtb3J5XCJcbiAgfCBTdGFja19vdmVyZmxvdyAtPiBcIlN0YWNrIG92ZXJmbG93XCJcbiAgfCBNYXRjaF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis1KSBcIlBhdHRlcm4gbWF0Y2hpbmcgZmFpbGVkXCJcbiAgfCBBc3NlcnRfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJBc3NlcnRpb24gZmFpbGVkXCJcbiAgfCBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJVbmRlZmluZWQgcmVjdXJzaXZlIG1vZHVsZVwiXG4gIHwgeCAtPlxuICAgICAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gICAgICBpZiBPYmoudGFnIHggPD4gMCB0aGVuXG4gICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCB4IDApIDogc3RyaW5nKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgY29uc3RydWN0b3IgPVxuICAgICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCAoT2JqLmZpZWxkIHggMCkgMCkgOiBzdHJpbmcpIGluXG4gICAgICAgIGNvbnN0cnVjdG9yIF4gKGZpZWxkcyB4KVxuXG5sZXQgdG9fc3RyaW5nIGUgPVxuICBtYXRjaCB1c2VfcHJpbnRlcnMgZSB3aXRoXG4gIHwgU29tZSBzIC0+IHNcbiAgfCBOb25lIC0+IHRvX3N0cmluZ19kZWZhdWx0IGVcblxubGV0IHByaW50IGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBmbHVzaCBzdGRlcnI7XG4gICAgcmFpc2UgeFxuXG5sZXQgY2F0Y2ggZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZmx1c2ggc3Rkb3V0O1xuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBleGl0IDJcblxudHlwZSByYXdfYmFja3RyYWNlX3Nsb3RcbnR5cGUgcmF3X2JhY2t0cmFjZVxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZTpcbiAgdW5pdCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZVwiXG5cbmV4dGVybmFsIHJhaXNlX3dpdGhfYmFja3RyYWNlOiBleG4gLT4gcmF3X2JhY2t0cmFjZSAtPiAnYVxuICA9IFwiJXJhaXNlX3dpdGhfYmFja3RyYWNlXCJcblxudHlwZSBiYWNrdHJhY2Vfc2xvdCA9XG4gIHwgS25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgICAgOiBib29sO1xuICAgICAgZmlsZW5hbWUgICAgOiBzdHJpbmc7XG4gICAgICBsaW5lX251bWJlciA6IGludDtcbiAgICAgIHN0YXJ0X2NoYXIgIDogaW50O1xuICAgICAgZW5kX2NoYXIgICAgOiBpbnQ7XG4gICAgICBpc19pbmxpbmUgICA6IGJvb2w7XG4gICAgfVxuICB8IFVua25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgOiBib29sXG4gICAgfVxuXG4oKiB0byBhdm9pZCB3YXJuaW5nICopXG5sZXQgXyA9IFtLbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2U7IGZpbGVuYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZV9udW1iZXIgPSAwOyBzdGFydF9jaGFyID0gMDsgZW5kX2NoYXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc19pbmxpbmUgPSBmYWxzZSB9O1xuICAgICAgICAgVW5rbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2UgfV1cblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Q6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiBiYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZTpcbiAgcmF3X2JhY2t0cmFjZSAtPiBiYWNrdHJhY2Vfc2xvdCBhcnJheSA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2VcIlxuXG5sZXQgY29udmVydF9yYXdfYmFja3RyYWNlIGJ0ID1cbiAgdHJ5IFNvbWUgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgZm9ybWF0X2JhY2t0cmFjZV9zbG90IHBvcyBzbG90ID1cbiAgbGV0IGluZm8gaXNfcmFpc2UgPVxuICAgIGlmIGlzX3JhaXNlIHRoZW5cbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBhdFwiIGVsc2UgXCJSZS1yYWlzZWQgYXRcIlxuICAgIGVsc2VcbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBieSBwcmltaXRpdmUgb3BlcmF0aW9uIGF0XCIgZWxzZSBcIkNhbGxlZCBmcm9tXCJcbiAgaW5cbiAgbWF0Y2ggc2xvdCB3aXRoXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBpZiBsLmlzX3JhaXNlIHRoZW5cbiAgICAgICAgKCogY29tcGlsZXItaW5zZXJ0ZWQgcmUtcmFpc2UsIHNraXBwZWQgKikgTm9uZVxuICAgICAgZWxzZVxuICAgICAgICBTb21lIChzcHJpbnRmIFwiJXMgdW5rbm93biBsb2NhdGlvblwiIChpbmZvIGZhbHNlKSlcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBTb21lIChzcHJpbnRmIFwiJXMgZmlsZSBcXFwiJXNcXFwiJXMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWRcIlxuICAgICAgICAgICAgICAoaW5mbyBsLmlzX3JhaXNlKSBsLmZpbGVuYW1lXG4gICAgICAgICAgICAgIChpZiBsLmlzX2lubGluZSB0aGVuIFwiIChpbmxpbmVkKVwiIGVsc2UgXCJcIilcbiAgICAgICAgICAgICAgbC5saW5lX251bWJlciBsLnN0YXJ0X2NoYXIgbC5lbmRfY2hhcilcblxubGV0IHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgIGZwcmludGYgb3V0Y2hhblxuICAgICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBmcHJpbnRmIG91dGNoYW4gXCIlc1xcblwiIHN0clxuICAgICAgZG9uZVxuXG5sZXQgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIHJhd19iYWNrdHJhY2UgPVxuICBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDogcHJpbnRzIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBwcmludF9iYWNrdHJhY2Ugb3V0Y2hhbiA9XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmxldCBiYWNrdHJhY2VfdG9fc3RyaW5nIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDEwMjQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gYnByaW50ZiBiIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmU7XG4gICAgICBCdWZmZXIuY29udGVudHMgYlxuXG5sZXQgcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgcmF3X2JhY2t0cmFjZSA9XG4gIGJhY2t0cmFjZV90b19zdHJpbmcgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19pbmxpbmVcbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcblxudHlwZSBsb2NhdGlvbiA9IHtcbiAgZmlsZW5hbWUgOiBzdHJpbmc7XG4gIGxpbmVfbnVtYmVyIDogaW50O1xuICBzdGFydF9jaGFyIDogaW50O1xuICBlbmRfY2hhciA6IGludDtcbn1cblxubGV0IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICBTb21lIHtcbiAgICAgIGZpbGVuYW1lICAgID0gbC5maWxlbmFtZTtcbiAgICAgIGxpbmVfbnVtYmVyID0gbC5saW5lX251bWJlcjtcbiAgICAgIHN0YXJ0X2NoYXIgID0gbC5zdGFydF9jaGFyO1xuICAgICAgZW5kX2NoYXIgICAgPSBsLmVuZF9jaGFyO1xuICAgIH1cblxubGV0IGJhY2t0cmFjZV9zbG90cyByYXdfYmFja3RyYWNlID1cbiAgKCogVGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHRoYXQgU29tZSBpc1xuICAgICByZXR1cm5lZCBvbmx5IGlmIGEgcGFydCBvZiB0aGUgdHJhY2UgaXMgdXNhYmxlLiBUaGlzIGdpdmVzIHVzXG4gICAgIGEgYml0IG1vcmUgd29yayB0aGFuIGp1c3QgY29udmVydF9yYXdfYmFja3RyYWNlLCBidXQgaXQgbWFrZXMgdGhlXG4gICAgIEFQSSBtb3JlIHVzZXItZnJpZW5kbHkgLS0gb3RoZXJ3aXNlIG1vc3QgdXNlcnMgd291bGQgaGF2ZSB0b1xuICAgICByZWltcGxlbWVudCB0aGUgXCJQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgc29ycnlcIiBsb2dpY1xuICAgICB0aGVtc2VsdmVzLiAqKVxuICBtYXRjaCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYmFja3RyYWNlIC0+XG4gICAgICBsZXQgdXNhYmxlX3Nsb3QgPSBmdW5jdGlvblxuICAgICAgICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuICAgICAgICB8IEtub3duX2xvY2F0aW9uIF8gLT4gdHJ1ZSBpblxuICAgICAgbGV0IHJlYyBleGlzdHNfdXNhYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCAoLTEpIC0+IGZhbHNlXG4gICAgICAgIHwgaSAtPiB1c2FibGVfc2xvdCBiYWNrdHJhY2UuKGkpIHx8IGV4aXN0c191c2FibGUgKGkgLSAxKSBpblxuICAgICAgaWYgZXhpc3RzX3VzYWJsZSAoQXJyYXkubGVuZ3RoIGJhY2t0cmFjZSAtIDEpXG4gICAgICB0aGVuIFNvbWUgYmFja3RyYWNlXG4gICAgICBlbHNlIE5vbmVcblxubW9kdWxlIFNsb3QgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGZvcm1hdCA9IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdFxuICBsZXQgaXNfcmFpc2UgPSBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZVxuICBsZXQgaXNfaW5saW5lID0gYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lXG4gIGxldCBsb2NhdGlvbiA9IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uXG5lbmRcblxuZXh0ZXJuYWwgcmF3X2JhY2t0cmFjZV9sZW5ndGggOlxuICByYXdfYmFja3RyYWNlIC0+IGludCA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aFwiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX3Nsb3QgOlxuICByYXdfYmFja3RyYWNlIC0+IGludCAtPiByYXdfYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCBvcHRpb25cbiAgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcIlxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDpcbiAgIHJldHVybnMgdGhlICpzdHJpbmcqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IGdldF9iYWNrdHJhY2UgKCkgPSByYXdfYmFja3RyYWNlX3RvX3N0cmluZyAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmV4dGVybmFsIHJlY29yZF9iYWNrdHJhY2U6IGJvb2wgLT4gdW5pdCA9IFwiY2FtbF9yZWNvcmRfYmFja3RyYWNlXCJcbmV4dGVybmFsIGJhY2t0cmFjZV9zdGF0dXM6IHVuaXQgLT4gYm9vbCA9IFwiY2FtbF9iYWNrdHJhY2Vfc3RhdHVzXCJcblxubGV0IHJlZ2lzdGVyX3ByaW50ZXIgZm4gPVxuICBwcmludGVycyA6PSBmbiA6OiAhcHJpbnRlcnNcblxuZXh0ZXJuYWwgZ2V0X2NhbGxzdGFjazogaW50IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrXCJcblxubGV0IGV4bl9zbG90IHggPVxuICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgaWYgT2JqLnRhZyB4ID0gMCB0aGVuIE9iai5maWVsZCB4IDAgZWxzZSB4XG5cbmxldCBleG5fc2xvdF9pZCB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAxKSA6IGludClcblxubGV0IGV4bl9zbG90X25hbWUgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMCkgOiBzdHJpbmcpXG5cblxubGV0IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyID0gcmVmIE5vbmVcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBmbiA9IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIDo9IFNvbWUgZm5cblxubGV0IGVtcHR5X2JhY2t0cmFjZSA6IHJhd19iYWNrdHJhY2UgPSBPYmoub2JqIChPYmoubmV3X2Jsb2NrIE9iai5hYnN0cmFjdF90YWcgMClcblxubGV0IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSA9XG4gIHRyeVxuICAgIGdldF9yYXdfYmFja3RyYWNlICgpXG4gIHdpdGggXyAoKiBPdXRfb2ZfbWVtb3J5PyAqKSAtPlxuICAgIGVtcHR5X2JhY2t0cmFjZVxuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgICgqIEdldCB0aGUgYmFja3RyYWNlIG5vdywgaW4gY2FzZSBvbmUgb2YgdGhlIFthdF9leGl0XSBmdW5jdGlvblxuICAgICAgIGRlc3Ryb3lzIGl0LiAqKVxuICAgIGxldCByYXdfYmFja3RyYWNlID1cbiAgICAgIGlmIGRlYnVnZ2VyX2luX3VzZSAoKiBTYW1lIHRlc3QgYXMgaW4gW3J1bnRpbWUvcHJpbnRleGMuY10gKikgdGhlblxuICAgICAgICBlbXB0eV9iYWNrdHJhY2VcbiAgICAgIGVsc2VcbiAgICAgICAgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpXG4gICAgaW5cbiAgICAodHJ5IFN0ZGxpYi5kb19hdF9leGl0ICgpIHdpdGggXyAtPiAoKSk7XG4gICAgbWF0Y2ggIXVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gICAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gICAgICAgIGZsdXNoIHN0ZGVyclxuICAgIHwgU29tZSBoYW5kbGVyIC0+XG4gICAgICAgIHRyeVxuICAgICAgICAgIGhhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2VcbiAgICAgICAgd2l0aCBleG4nIC0+XG4gICAgICAgICAgbGV0IHJhd19iYWNrdHJhY2UnID0gdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gICAgICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgICAgICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3IgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXI6IGV4Y2VwdGlvbiAlc1xcblwiXG4gICAgICAgICAgICAodG9fc3RyaW5nIGV4bicpO1xuICAgICAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2UnO1xuICAgICAgICAgIGZsdXNoIHN0ZGVyclxuICB3aXRoXG4gICAgfCBPdXRfb2ZfbWVtb3J5IC0+XG4gICAgICAgIHByZXJyX2VuZGxpbmVcbiAgICAgICAgICBcIkZhdGFsIGVycm9yOiBvdXQgb2YgbWVtb3J5IGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyXCJcblxuKCogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgW2NhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXSBpblxuICAgW3J1bnRpbWUvcHJpbnRleGMuY10gd2hpY2ggZXhwZWN0cyBubyBleGNlcHRpb24gaXMgcmFpc2VkLiAqKVxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24gZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2VcbiAgd2l0aCBfIC0+XG4gICAgKCogVGhlcmUgaXMgbm90IG11Y2ggd2UgY2FuIGRvIGF0IHRoaXMgcG9pbnQgKilcbiAgICAoKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0ICgpID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQcmludGV4Yy5oYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXCJcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgWGF2aWVyIExlcm95IGFuZCBEYW1pZW4gRG9saWdleiwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmxldCBnZW5lcmljX3F1b3RlIHF1b3RlcXVvdGUgcyA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgaWYgcy5baV0gPSAnXFwnJ1xuICAgIHRoZW4gQnVmZmVyLmFkZF9zdHJpbmcgYiBxdW90ZXF1b3RlXG4gICAgZWxzZSBCdWZmZXIuYWRkX2NoYXIgYiAgcy5baV1cbiAgZG9uZTtcbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcJyc7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cbigqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgT3BlbiBHcm91cCBzcGVjaWZpY2F0aW9uIGZvdW5kIGhlcmU6XG4gIFtbMV1dIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L3V0aWxpdGllcy9iYXNlbmFtZS5odG1sXG4gIEluIHN0ZXAgMSBvZiBbWzFdXSwgd2UgY2hvb3NlIHRvIHJldHVybiBcIi5cIiBmb3IgZW1wdHkgaW5wdXQuXG4gICAgKGZvciBjb21wYXRpYmlsaXR5IHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgT0NhbWwpXG4gIEluIHN0ZXAgMiwgd2UgY2hvb3NlIHRvIHByb2Nlc3MgXCIvL1wiIG5vcm1hbGx5LlxuICBTdGVwIDYgaXMgbm90IGltcGxlbWVudGVkOiB3ZSBjb25zaWRlciB0aGF0IHRoZSBbc3VmZml4XSBvcGVyYW5kIGlzXG4gICAgYWx3YXlzIGFic2VudC4gIFN1ZmZpeGVzIGFyZSBoYW5kbGVkIGJ5IFtjaG9wX3N1ZmZpeF0gYW5kIFtjaG9wX2V4dGVuc2lvbl0uXG4qKVxubGV0IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIG5hbWUgPVxuICBsZXQgcmVjIGZpbmRfZW5kIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBmaW5kX2VuZCAobiAtIDEpXG4gICAgZWxzZSBmaW5kX2JlZyBuIChuICsgMSlcbiAgYW5kIGZpbmRfYmVnIG4gcCA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCBwXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIFN0cmluZy5zdWIgbmFtZSAobiArIDEpIChwIC0gbiAtIDEpXG4gICAgZWxzZSBmaW5kX2JlZyAobiAtIDEpIHBcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgZmluZF9lbmQgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbigqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgT3BlbiBHcm91cCBzcGVjaWZpY2F0aW9uIGZvdW5kIGhlcmU6XG4gIFtbMl1dIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L3V0aWxpdGllcy9kaXJuYW1lLmh0bWxcbiAgSW4gc3RlcCA2IG9mIFtbMl1dLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4qKVxubGV0IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgdHJhaWxpbmdfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiB0cmFpbGluZ19zZXAgKG4gLSAxKVxuICAgIGVsc2UgYmFzZSBuXG4gIGFuZCBiYXNlIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIG5cbiAgICBlbHNlIGJhc2UgKG4gLSAxKVxuICBhbmQgaW50ZXJtZWRpYXRlX3NlcCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gaW50ZXJtZWRpYXRlX3NlcCAobiAtIDEpXG4gICAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAobiArIDEpXG4gIGluXG4gIGlmIG5hbWUgPSBcIlwiXG4gIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICBlbHNlIHRyYWlsaW5nX3NlcCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubW9kdWxlIFVuaXggPSBzdHJ1Y3RcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gcy5baV0gPSAnLydcbiAgbGV0IGlzX3JlbGF0aXZlIG4gPSBTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICcvJ1xuICBsZXQgaXNfaW1wbGljaXQgbiA9XG4gICAgaXNfcmVsYXRpdmUgblxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLi9cIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgIFN0cmluZy5sZW5ndGggbmFtZSA+PSBTdHJpbmcubGVuZ3RoIHN1ZmYgJiZcbiAgICBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgPSBzdWZmXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgciA9IHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVE1QRElSXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIvdG1wXCJcbiAgbGV0IHF1b3RlID0gZ2VuZXJpY19xdW90ZSBcIidcXFxcJydcIlxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgV2luMzIgPSBzdHJ1Y3RcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCJcXFxcXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gbGV0IGMgPSBzLltpXSBpbiBjID0gJy8nIHx8IGMgPSAnXFxcXCcgfHwgYyA9ICc6J1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9XG4gICAgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICdcXFxcJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBuLlsxXSA8PiAnOicpXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi5cXFxcXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLlxcXFxcIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgKGxldCBzID0gU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgaW5cbiAgICBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmYpXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSByID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVEVNUFwiIHdpdGggTm90X2ZvdW5kIC0+IFwiLlwiXG4gIGxldCBxdW90ZSBzID1cbiAgICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJyBlbHNlXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICdcXFwiJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCBjICAgIC0+IEJ1ZmZlci5hZGRfY2hhciBiIGM7IGxvb3AgKGkrMSk7XG4gICAgYW5kIGxvb3BfYnMgbiBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgICAgICBhZGRfYnMgbjtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgICAgfCAnXFxcIicgLT4gYWRkX2JzICgyKm4rMSk7IEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJzsgbG9vcCAoaSsxKTtcbiAgICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAobisxKSAoaSsxKTtcbiAgICAgICAgfCBfICAgIC0+IGFkZF9icyBuOyBsb29wIGlcbiAgICAgIGVuZFxuICAgIGFuZCBhZGRfYnMgbiA9IGZvciBfaiA9IDEgdG8gbiBkbyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcXCc7IGRvbmVcbiAgICBpblxuICAgIGxvb3AgMDtcbiAgICBCdWZmZXIuY29udGVudHMgYlxuICBsZXQgaGFzX2RyaXZlIHMgPVxuICAgIGxldCBpc19sZXR0ZXIgPSBmdW5jdGlvblxuICAgICAgfCAnQScgLi4gJ1onIHwgJ2EnIC4uICd6JyAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcbiAgICBpblxuICAgIFN0cmluZy5sZW5ndGggcyA+PSAyICYmIGlzX2xldHRlciBzLlswXSAmJiBzLlsxXSA9ICc6J1xuICBsZXQgZHJpdmVfYW5kX3BhdGggcyA9XG4gICAgaWYgaGFzX2RyaXZlIHNcbiAgICB0aGVuIChTdHJpbmcuc3ViIHMgMCAyLCBTdHJpbmcuc3ViIHMgMiAoU3RyaW5nLmxlbmd0aCBzIC0gMikpXG4gICAgZWxzZSAoXCJcIiwgcylcbiAgbGV0IGRpcm5hbWUgcyA9XG4gICAgbGV0IChkcml2ZSwgcGF0aCkgPSBkcml2ZV9hbmRfcGF0aCBzIGluXG4gICAgbGV0IGRpciA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgcGF0aCBpblxuICAgIGRyaXZlIF4gZGlyXG4gIGxldCBiYXNlbmFtZSBzID1cbiAgICBsZXQgKF9kcml2ZSwgcGF0aCkgPSBkcml2ZV9hbmRfcGF0aCBzIGluXG4gICAgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgcGF0aFxuZW5kXG5cbm1vZHVsZSBDeWd3aW4gPSBzdHJ1Y3RcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgPSBXaW4zMi5pc19kaXJfc2VwXG4gIGxldCBpc19yZWxhdGl2ZSA9IFdpbjMyLmlzX3JlbGF0aXZlXG4gIGxldCBpc19pbXBsaWNpdCA9IFdpbjMyLmlzX2ltcGxpY2l0XG4gIGxldCBjaGVja19zdWZmaXggPSBXaW4zMi5jaGVja19zdWZmaXhcbiAgbGV0IGNob3Bfc3VmZml4X29wdCA9IFdpbjMyLmNob3Bfc3VmZml4X29wdFxuICBsZXQgdGVtcF9kaXJfbmFtZSA9IFVuaXgudGVtcF9kaXJfbmFtZVxuICBsZXQgcXVvdGUgPSBVbml4LnF1b3RlXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbmxldCAoY3VycmVudF9kaXJfbmFtZSwgcGFyZW50X2Rpcl9uYW1lLCBkaXJfc2VwLCBpc19kaXJfc2VwLFxuICAgICBpc19yZWxhdGl2ZSwgaXNfaW1wbGljaXQsIGNoZWNrX3N1ZmZpeCwgY2hvcF9zdWZmaXhfb3B0LFxuICAgICB0ZW1wX2Rpcl9uYW1lLCBxdW90ZSwgYmFzZW5hbWUsXG4gICAgIGRpcm5hbWUpID1cbiAgbWF0Y2ggU3lzLm9zX3R5cGUgd2l0aFxuICB8IFwiV2luMzJcIiAtPlxuICAgICAgKFdpbjMyLmN1cnJlbnRfZGlyX25hbWUsIFdpbjMyLnBhcmVudF9kaXJfbmFtZSwgV2luMzIuZGlyX3NlcCxcbiAgICAgICBXaW4zMi5pc19kaXJfc2VwLFxuICAgICAgIFdpbjMyLmlzX3JlbGF0aXZlLCBXaW4zMi5pc19pbXBsaWNpdCwgV2luMzIuY2hlY2tfc3VmZml4LFxuICAgICAgIFdpbjMyLmNob3Bfc3VmZml4X29wdCxcbiAgICAgICBXaW4zMi50ZW1wX2Rpcl9uYW1lLCBXaW4zMi5xdW90ZSwgV2luMzIuYmFzZW5hbWUsIFdpbjMyLmRpcm5hbWUpXG4gIHwgXCJDeWd3aW5cIiAtPlxuICAgICAgKEN5Z3dpbi5jdXJyZW50X2Rpcl9uYW1lLCBDeWd3aW4ucGFyZW50X2Rpcl9uYW1lLCBDeWd3aW4uZGlyX3NlcCxcbiAgICAgICBDeWd3aW4uaXNfZGlyX3NlcCxcbiAgICAgICBDeWd3aW4uaXNfcmVsYXRpdmUsIEN5Z3dpbi5pc19pbXBsaWNpdCwgQ3lnd2luLmNoZWNrX3N1ZmZpeCxcbiAgICAgICBDeWd3aW4uY2hvcF9zdWZmaXhfb3B0LFxuICAgICAgIEN5Z3dpbi50ZW1wX2Rpcl9uYW1lLCBDeWd3aW4ucXVvdGUsIEN5Z3dpbi5iYXNlbmFtZSwgQ3lnd2luLmRpcm5hbWUpXG4gIHwgXyAtPiAoKiBub3JtYWxseSBcIlVuaXhcIiAqKVxuICAgICAgKFVuaXguY3VycmVudF9kaXJfbmFtZSwgVW5peC5wYXJlbnRfZGlyX25hbWUsIFVuaXguZGlyX3NlcCxcbiAgICAgICBVbml4LmlzX2Rpcl9zZXAsXG4gICAgICAgVW5peC5pc19yZWxhdGl2ZSwgVW5peC5pc19pbXBsaWNpdCwgVW5peC5jaGVja19zdWZmaXgsXG4gICAgICAgVW5peC5jaG9wX3N1ZmZpeF9vcHQsXG4gICAgICAgVW5peC50ZW1wX2Rpcl9uYW1lLCBVbml4LnF1b3RlLCBVbml4LmJhc2VuYW1lLCBVbml4LmRpcm5hbWUpXG5cbmxldCBjb25jYXQgZGlybmFtZSBmaWxlbmFtZSA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBkaXJuYW1lIGluXG4gIGlmIGwgPSAwIHx8IGlzX2Rpcl9zZXAgZGlybmFtZSAobC0xKVxuICB0aGVuIGRpcm5hbWUgXiBmaWxlbmFtZVxuICBlbHNlIGRpcm5hbWUgXiBkaXJfc2VwIF4gZmlsZW5hbWVcblxubGV0IGNob3Bfc3VmZml4IG5hbWUgc3VmZiA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmIGluXG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX3N1ZmZpeFwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgblxuXG5sZXQgZXh0ZW5zaW9uX2xlbiBuYW1lID1cbiAgbGV0IHJlYyBjaGVjayBpMCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaTAgKGkgLSAxKVxuICAgIGVsc2UgU3RyaW5nLmxlbmd0aCBuYW1lIC0gaTBcbiAgaW5cbiAgbGV0IHJlYyBzZWFyY2hfZG90IGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpIChpIC0gMSlcbiAgICBlbHNlIHNlYXJjaF9kb3QgKGkgLSAxKVxuICBpblxuICBzZWFyY2hfZG90IChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5sZXQgZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpIGxcblxubGV0IGNob3BfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9leHRlbnNpb25cIlxuICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5sZXQgcmVtb3ZlX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBuYW1lIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmV4dGVybmFsIG9wZW5fZGVzYzogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuZXh0ZXJuYWwgY2xvc2VfZGVzYzogaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX2Nsb3NlXCJcblxubGV0IHBybmcgPSBsYXp5KFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcm5kID0gKFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpKSBsYW5kIDB4RkZGRkZGIGluXG4gIGNvbmNhdCB0ZW1wX2RpciAoUHJpbnRmLnNwcmludGYgXCIlcyUwNnglc1wiIHByZWZpeCBybmQgc3VmZml4KVxuXG5cbmxldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgPSByZWYgdGVtcF9kaXJfbmFtZVxuXG5sZXQgc2V0X3RlbXBfZGlyX25hbWUgcyA9IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA6PSBzXG5sZXQgZ2V0X3RlbXBfZGlyX25hbWUgKCkgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lXG5cbmxldCB0ZW1wX2ZpbGUgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgY2xvc2VfZGVzYyhvcGVuX2Rlc2MgbmFtZSBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fZXhjbF0gMG82MDApO1xuICAgICAgbmFtZVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuXG5sZXQgb3Blbl90ZW1wX2ZpbGUgPyhtb2RlID0gW09wZW5fdGV4dF0pID8ocGVybXMgPSAwbzYwMClcbiAgICAgICAgICAgICAgICAgICA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENvbXBsZXggbnVtYmVycyAqKVxuXG50eXBlIHQgPSB7IHJlOiBmbG9hdDsgaW06IGZsb2F0IH1cblxubGV0IHplcm8gPSB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG5sZXQgb25lID0geyByZSA9IDEuMDsgaW0gPSAwLjAgfVxubGV0IGkgPSB7IHJlID0gMC4wOyBpbSA9IDEuMCB9XG5cbmxldCBhZGQgeCB5ID0geyByZSA9IHgucmUgKy4geS5yZTsgaW0gPSB4LmltICsuIHkuaW0gfVxuXG5sZXQgc3ViIHggeSA9IHsgcmUgPSB4LnJlIC0uIHkucmU7IGltID0geC5pbSAtLiB5LmltIH1cblxubGV0IG5lZyB4ID0geyByZSA9IC0uIHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBjb25qIHggPSB7IHJlID0geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IG11bCB4IHkgPSB7IHJlID0geC5yZSAqLiB5LnJlIC0uIHguaW0gKi4geS5pbTtcbiAgICAgICAgICAgICAgICBpbSA9IHgucmUgKi4geS5pbSArLiB4LmltICouIHkucmUgfVxuXG5sZXQgZGl2IHggeSA9XG4gIGlmIGFic19mbG9hdCB5LnJlID49IGFic19mbG9hdCB5LmltIHRoZW5cbiAgICBsZXQgciA9IHkuaW0gLy4geS5yZSBpblxuICAgIGxldCBkID0geS5yZSArLiByICouIHkuaW0gaW5cbiAgICB7IHJlID0gKHgucmUgKy4gciAqLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAoeC5pbSAtLiByICouIHgucmUpIC8uIGQgfVxuICBlbHNlXG4gICAgbGV0IHIgPSB5LnJlIC8uIHkuaW0gaW5cbiAgICBsZXQgZCA9IHkuaW0gKy4gciAqLiB5LnJlIGluXG4gICAgeyByZSA9IChyICouIHgucmUgKy4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHIgKi4geC5pbSAtLiB4LnJlKSAvLiBkIH1cblxubGV0IGludiB4ID0gZGl2IG9uZSB4XG5cbmxldCBub3JtMiB4ID0geC5yZSAqLiB4LnJlICsuIHguaW0gKi4geC5pbVxuXG5sZXQgbm9ybSB4ID1cbiAgKCogV2F0Y2ggb3V0IGZvciBvdmVyZmxvdyBpbiBjb21wdXRpbmcgcmVeMiArIGltXjIgKilcbiAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gIGlmIHIgPSAwLjAgdGhlbiBpXG4gIGVsc2UgaWYgaSA9IDAuMCB0aGVuIHJcbiAgZWxzZSBpZiByID49IGkgdGhlblxuICAgIGxldCBxID0gaSAvLiByIGluIHIgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuICBlbHNlXG4gICAgbGV0IHEgPSByIC8uIGkgaW4gaSAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG5cbmxldCBhcmcgeCA9IGF0YW4yIHguaW0geC5yZVxuXG5sZXQgcG9sYXIgbiBhID0geyByZSA9IGNvcyBhICouIG47IGltID0gc2luIGEgKi4gbiB9XG5cbmxldCBzcXJ0IHggPVxuICBpZiB4LnJlID0gMC4wICYmIHguaW0gPSAwLjAgdGhlbiB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgICBsZXQgdyA9XG4gICAgICBpZiByID49IGkgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcSA9IGkgLy4gciBpblxuICAgICAgICBzcXJ0KHIpICouIHNxcnQoMC41ICouICgxLjAgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgcSA9IHIgLy4gaSBpblxuICAgICAgICBzcXJ0KGkpICouIHNxcnQoMC41ICouIChxICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGluXG4gICAgaWYgeC5yZSA+PSAwLjBcbiAgICB0aGVuIHsgcmUgPSB3OyAgaW0gPSAwLjUgKi4geC5pbSAvLiB3IH1cbiAgICBlbHNlIHsgcmUgPSAwLjUgKi4gaSAvLiB3OyAgaW0gPSBpZiB4LmltID49IDAuMCB0aGVuIHcgZWxzZSAtLiB3IH1cbiAgZW5kXG5cbmxldCBleHAgeCA9XG4gIGxldCBlID0gZXhwIHgucmUgaW4geyByZSA9IGUgKi4gY29zIHguaW07IGltID0gZSAqLiBzaW4geC5pbSB9XG5cbmxldCBsb2cgeCA9IHsgcmUgPSBsb2cgKG5vcm0geCk7IGltID0gYXRhbjIgeC5pbSB4LnJlIH1cblxubGV0IHBvdyB4IHkgPSBleHAgKG11bCB5IChsb2cgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBhZGRpbmcgcG9zaXRpb24uICopXG50eXBlIHBhZHR5ID1cbiAgfCBMZWZ0ICAgKCogVGV4dCBpcyBsZWZ0IGp1c3RpZmllZCAoJy0nIG9wdGlvbikuICAgICAgICAgICAgICAgKilcbiAgfCBSaWdodCAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgKG5vICctJyBvcHRpb24pLiAgICAgICAgICAgKilcbiAgfCBaZXJvcyAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgYnkgemVyb3MgKHNlZSAnMCcgb3B0aW9uKS4gKilcblxuKCoqKilcblxuKCogSW50ZWdlciBjb252ZXJzaW9uLiAqKVxudHlwZSBpbnRfY29udiA9XG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgICAgICAgICgqICAlZCB8ICUrZCB8ICUgZCAgKilcbiAgfCBJbnRfaSB8IEludF9waSB8IEludF9zaSAgICAgICAgKCogICVpIHwgJStpIHwgJSBpICAqKVxuICB8IEludF94IHwgSW50X0N4ICAgICAgICAgICAgICAgICAoKiAgJXggfCAlI3ggICAgICAgICopXG4gIHwgSW50X1ggfCBJbnRfQ1ggICAgICAgICAgICAgICAgICgqICAlWCB8ICUjWCAgICAgICAgKilcbiAgfCBJbnRfbyB8IEludF9DbyAgICAgICAgICAgICAgICAgKCogICVvIHwgJSNvICAgICAgICAqKVxuICB8IEludF91ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJXUgICAgICAgICAgICAgICopXG4gIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1ICAgICAgICgqICAlI2QgfCAlI2kgfCAlI3UgKilcblxuKCogRmxvYXQgY29udmVyc2lvbi4gKilcbnR5cGUgZmxvYXRfZmxhZ19jb252ID1cbiAgfCBGbG9hdF9mbGFnXyAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZoSF0gKilcbiAgfCBGbG9hdF9mbGFnX3AgICAgICAgICAgICAgICAgICAgKCogJStbZmVFZ0dGaEhdICopXG4gIHwgRmxvYXRfZmxhZ19zICAgICAgICAgICAgICAgICAgICgqICUgW2ZlRWdHRmhIXSAqKVxudHlwZSBmbG9hdF9raW5kX2NvbnYgPVxuICB8IEZsb2F0X2YgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWYgfCAlK2YgfCAlIGYgICopXG4gIHwgRmxvYXRfZSAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZSB8ICUrZSB8ICUgZSAgKilcbiAgfCBGbG9hdF9FICAgICAgICAgICAgICAgICAgICAgICAgKCogICVFIHwgJStFIHwgJSBFICAqKVxuICB8IEZsb2F0X2cgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWcgfCAlK2cgfCAlIGcgICopXG4gIHwgRmxvYXRfRyAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRyB8ICUrRyB8ICUgRyAgKilcbiAgfCBGbG9hdF9GICAgICAgICAgICAgICAgICAgICAgICAgKCogICVGIHwgJStGIHwgJSBGICAqKVxuICB8IEZsb2F0X2ggICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWggfCAlK2ggfCAlIGggICopXG4gIHwgRmxvYXRfSCAgICAgICAgICAgICAgICAgICAgICAgICgqICAlSCB8ICUrSCB8ICUgSCAgKilcbnR5cGUgZmxvYXRfY29udiA9IGZsb2F0X2ZsYWdfY29udiAqIGZsb2F0X2tpbmRfY29udlxuXG4oKioqKVxuXG4oKiBDaGFyIHNldHMgKHNlZSAlWy4uLl0pIGFyZSBiaXRtYXBzIGltcGxlbWVudGVkIGFzIDMyLWNoYXIgc3RyaW5ncy4gKilcbnR5cGUgY2hhcl9zZXQgPSBzdHJpbmdcblxuKCoqKilcblxuKCogQ291bnRlciB1c2VkIGluIFNjYW5mLiAqKVxudHlwZSBjb3VudGVyID1cbiAgfCBMaW5lX2NvdW50ZXIgICAgICgqICAlbCAgICAgICopXG4gIHwgQ2hhcl9jb3VudGVyICAgICAoKiAgJW4gICAgICAqKVxuICB8IFRva2VuX2NvdW50ZXIgICAgKCogICVOLCAlTCAgKilcblxuKCoqKilcblxuKCogUGFkZGluZyBvZiBzdHJpbmdzIGFuZCBudW1iZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwYWRkaW5nID1cbiAgKCogTm8gcGFkZGluZyAoZXg6IFwiJWRcIikgKilcbiAgfCBOb19wYWRkaW5nICA6ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogTGl0ZXJhbCBwYWRkaW5nIChleDogXCIlOGRcIikgKilcbiAgfCBMaXRfcGFkZGluZyA6IHBhZHR5ICogaW50IC0+ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogUGFkZGluZyBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpkXCIpICopXG4gIHwgQXJnX3BhZGRpbmcgOiBwYWR0eSAtPiAoaW50IC0+ICdhLCAnYSkgcGFkZGluZ1xuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9kLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHBhZGRpbmcgb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcGFkX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogUHJlY2lzaW9uIG9mIGZsb2F0cyBhbmQgJzAnLXBhZGRpbmcgb2YgaW50ZWdlcnMuICopXG50eXBlICgnYSwgJ2IpIHByZWNpc2lvbiA9XG4gICgqIE5vIHByZWNpc2lvbiAoZXg6IFwiJWZcIikgKilcbiAgfCBOb19wcmVjaXNpb24gOiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogTGl0ZXJhbCBwcmVjaXNpb24gKGV4OiBcIiUuM2ZcIikgKilcbiAgfCBMaXRfcHJlY2lzaW9uIDogaW50IC0+ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBQcmVjaXNpb24gYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikgKilcbiAgfCBBcmdfcHJlY2lzaW9uIDogKGludCAtPiAnYSwgJ2EpIHByZWNpc2lvblxuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9mLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHByZWNpc2lvbiBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwcmVjX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogc2VlIHRoZSBDdXN0b20gZm9ybWF0IGNvbWJpbmF0b3IgKilcbnR5cGUgKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSA9XG4gIHwgQ3VzdG9tX3plcm8gOiAoJ2EsIHN0cmluZywgJ2EpIGN1c3RvbV9hcml0eVxuICB8IEN1c3RvbV9zdWNjIDogKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSAtPlxuICAgICgnYSwgJ3ggLT4gJ2IsICd4IC0+ICdjKSBjdXN0b21fYXJpdHlcblxuKCoqKilcblxuKCogICAgICAgIFJlbGF0aW9uYWwgZm9ybWF0IHR5cGVzXG5cbkluIHRoZSBmaXJzdCBmb3JtYXQrZ2FkdHMgaW1wbGVtZW50YXRpb24sIHRoZSB0eXBlIGZvciAlKC4uJSkgaW4gdGhlXG5mbXQgR0FEVCB3YXMgYXMgZm9sbG93czpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqICgnZDEsICdxMSwgJ2QyLCAncTIpIHJlYWRlcl9uYl91bmlmaWVyICpcbiAgICAoJ3gsICdiLCAnYywgJ2QxLCAncTEsICd1KSBmbXR0eSAqXG4gICAgKCd1LCAnYiwgJ2MsICdxMSwgJ2UxLCAnZikgZm10IC0+XG4gICAgICAoKCd4LCAnYiwgJ2MsICdkMiwgJ3EyLCAndSkgZm9ybWF0NiAtPiAneCwgJ2IsICdjLCAnZDEsICdlMSwgJ2YpIGZtdFxuXG5Ob3RpY2UgdGhhdCB0aGUgJ3UgcGFyYW1ldGVyIGluICdmIHBvc2l0aW9uIGluIHRoZSBmb3JtYXQgYXJndW1lbnRcbigoJ3gsIC4uLCAndSkgZm9ybWF0NiAtPiAuLikgaXMgZXF1YWwgdG8gdGhlICd1IHBhcmFtZXRlciBpbiAnYVxucG9zaXRpb24gaW4gdGhlIGZvcm1hdCB0YWlsICgoJ3UsIC4uLCAnZikgZm10KS4gVGhpcyBtZWFucyB0aGF0IHRoZVxudHlwZSBvZiB0aGUgZXhwZWN0ZWQgZm9ybWF0IHBhcmFtZXRlciBkZXBlbmRzIG9mIHdoZXJlIHRoZSAlKC4uLiUpXG5hcmUgaW4gdGhlIGZvcm1hdCBzdHJpbmc6XG5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKVwiXG4gIC0gOiAodW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gdW5pdFxuICA9IDxmdW4+XG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSklZFwiXG4gIC0gOiAoaW50IC0+IHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgaW50IC0+IHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiBpbnQgLT4gdW5pdFxuICA9IDxmdW4+XG5cbk9uIHRoZSBjb250cmFyeSwgdGhlIGxlZ2FjeSB0eXBlciBnaXZlcyBhIGNsZXZlciB0eXBlIHRoYXQgZG9lcyBub3RcbmRlcGVuZCBvbiB0aGUgcG9zaXRpb24gb2YgJSguLiUpIGluIHRoZSBmb3JtYXQgc3RyaW5nLiBGb3IgZXhhbXBsZSxcbiUoJSkgd2lsbCBoYXZlIHRoZSBwb2x5bW9ycGhpYyB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKTogaXQgY2FuXG5iZSBjb25jYXRlbmF0ZWQgdG8gYW55IGZvcm1hdCB0eXBlLCBhbmQgb25seSBlbmZvcmNlcyB0aGUgY29uc3RyYWludFxudGhhdCBpdHMgJ2EgYW5kICdmIHBhcmFtZXRlcnMgYXJlIGVxdWFsIChubyBmb3JtYXQgYXJndW1lbnRzKSBhbmQgJ2RcbmFuZCAnZSBhcmUgZXF1YWwgKG5vIHJlYWRlciBhcmd1bWVudCkuXG5cblRoZSB3ZWFrZW5pbmcgb2YgdGhpcyBwYXJhbWV0ZXIgdHlwZSBpbiB0aGUgR0FEVCB2ZXJzaW9uIGJyb2tlIHVzZXJcbmNvZGUgKGluIGZhY3QgaXQgZXNzZW50aWFsbHkgbWFkZSAlKC4uLiUpIHVudXNhYmxlIGV4Y2VwdCBhdCB0aGUgbGFzdFxucG9zaXRpb24gb2YgYSBmb3JtYXQpLiBJbiBwYXJ0aWN1bGFyLCB0aGUgZm9sbG93aW5nIHdvdWxkIG5vdCB3b3JrXG5hbnltb3JlOlxuXG4gIGZ1biBzZXAgLT5cbiAgICBGb3JtYXQucHJpbnRmIFwiZm9vJSglKWJhciUoJSliYXpcIiBzZXAgc2VwXG5cbkFzIHRoZSB0eXBlLWNoZWNrZXIgd291bGQgcmVxdWlyZSB0d28gKmluY29tcGF0aWJsZSogdHlwZXMgZm9yIHRoZSAlKCUpXG5pbiBkaWZmZXJlbnQgcG9zaXRpb25zLlxuXG5UaGUgc29sdXRpb24gdG8gcmVnYWluIGEgZ2VuZXJhbCB0eXBlIGZvciAlKC4uJSkgaXMgdG8gZ2VuZXJhbGl6ZSB0aGlzXG50ZWNobmlxdWUsIG5vdCBvbmx5IG9uIHRoZSAnZCwgJ2UgcGFyYW1ldGVycywgYnV0IG9uIGFsbCBzaXhcbnBhcmFtZXRlcnMgb2YgYSBmb3JtYXQ6IHdlIGludHJvZHVjZSBhIFwicmVsYXRpb25hbFwiIHR5cGVcbiAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbndob3NlIHZhbHVlcyBhcmUgcHJvb2ZzIHRoYXQgKCdhMSwgLi4sICdmMSkgYW5kICgnYTIsIC4uLCAnZjIpIG1vcmFsbHlcbmNvcnJlc3BvbmQgdG8gdGhlIHNhbWUgZm9ybWF0IHR5cGU6ICdhMSBpcyBvYnRhaW5lZCBmcm9tICdmMSwnYjEsJ2MxXG5pbiB0aGUgZXhhY3Qgc2FtZSB3YXkgdGhhdCAnYTIgaXMgb2J0YWluZWQgZnJvbSAnZjIsJ2IyLCdjMiwgZXRjLlxuXG5Gb3IgZXhhbXBsZSwgdGhlIHJlbGF0aW9uIGJldHdlZW4gdHdvIGZvcm1hdCB0eXBlcyBiZWdpbm5pbmcgd2l0aCBhIENoYXJcbnBhcmFtZXRlciBpcyBhcyBmb2xsb3dzOlxuXG58IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIHRlcm0gc3RydWN0dXJlIG9mIGZtdHR5X3JlbCBpcyAoYWxtb3N0WzFdKVxuaXNvbW9ycGhpYyB0byB0aGUgZm10dHkgb2YgdGhlIHByZXZpb3VzIGltcGxlbWVudGF0aW9uOiBldmVyeVxuY29uc3RydWN0b3IgaXMgcmUtcmVhZCB3aXRoIGEgYmluYXJ5LCByZWxhdGlvbmFsIHR5cGUsIGluc3RlYWQgb2YgdGhlXG5wcmV2aW91cyB1bmFyeSB0eXBpbmcuIGZtdHR5IGNhbiB0aGVuIGJlIHJlLWRlZmluZWQgYXMgdGhlIGRpYWdvbmFsIG9mXG5mbXR0eV9yZWw6XG5cbiAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcblxuT25jZSB3ZSBoYXZlIHRoaXMgZm10dHlfcmVsIHR5cGUgaW4gcGxhY2UsIHdlIGNhbiBnaXZlIHRoZSBtb3JlXG5nZW5lcmFsIHR5cGUgdG8gJSguLi4lKTpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbldlIGFjY2VwdCBhbnkgZm9ybWF0ICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NikgKHRoaXMgaXNcbmNvbXBsZXRlbHkgdW5yZWxhdGVkIHRvIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IGZvcm1hdCksIGJ1dCBhbHNvXG5yZXF1aXJlIGEgcHJvb2YgdGhhdCB0aGlzIGZvcm1hdCBpcyBpbiByZWxhdGlvbiB0byBhbm90aGVyIGZvcm1hdCB0aGF0XG5pcyBjb25jYXRlbmFibGUgdG8gdGhlIGZvcm1hdCB0YWlsLiBXaGVuIGV4ZWN1dGluZyBhICUoLi4uJSkgZm9ybWF0XG4oaW4gY2FtbGludGVybmFsRm9ybWF0Lm1sOm1ha2VfcHJpbnRmIG9yIHNjYW5mLm1sOm1ha2Vfc2NhbmYpLCB3ZVxudHJhbnN0eXBlIHRoZSBmb3JtYXQgYWxvbmcgdGhpcyByZWxhdGlvbiB1c2luZyB0aGUgJ3JlY2FzdCcgZnVuY3Rpb25cbnRvIHRyYW5zcG9zZSBiZXR3ZWVuIHJlbGF0ZWQgZm9ybWF0IHR5cGVzLlxuXG4gIHZhbCByZWNhc3QgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSkgZm10XG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXRcblxuTk9URSBbMV06IHRoZSB0eXBpbmcgb2YgRm9ybWF0X3N1YnN0X3R5IHJlcXVpcmVzIG5vdCBvbmUgZm9ybWF0IHR5cGUsIGJ1dFxudHdvLCBvbmUgdG8gZXN0YWJsaXNoIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdCBhcmd1bWVudCBhbmQgdGhlXG5maXJzdCBzaXggcGFyYW1ldGVycywgYW5kIHRoZSBvdGhlciBmb3IgdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0XG5hcmd1bWVudCBhbmQgdGhlIGxhc3Qgc2l4IHBhcmFtZXRlcnMuXG5cbnwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5XaGVuIHdlIGdlbmVyYXRlIGEgZm9ybWF0IEFTVCwgd2UgZ2VuZXJhdGUgZXhhY3RseSB0aGUgc2FtZSB3aXRuZXNzXG5mb3IgYm90aCByZWxhdGlvbnMsIGFuZCB0aGUgd2l0bmVzcy1jb252ZXJzaW9uIGZ1bmN0aW9ucyBpblxuY2FtbGludGVybmFsRm9ybWF0IGRvIHJlbHkgb24gdGhpcyBpbnZhcmlhbnQuIEZvciBleGFtcGxlLCB0aGVcbmZ1bmN0aW9uIHRoYXQgcHJvdmVzIHRoYXQgdGhlIHJlbGF0aW9uIGlzIHRyYW5zaXRpdmVcblxuICB2YWwgdHJhbnMgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMixcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuXG5kb2VzIGFzc3VtZSB0aGF0IHRoZSB0d28gaW5wdXRzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB0ZXJtIHN0cnVjdHVyZVxuKGFuZCBpcyBvbmx5IGV2ZXJ5IHVzZWQgZm9yIGFyZ3VtZW50IHdpdG5lc3NlcyBvZiB0aGVcbkZvcm1hdF9zdWJzdF90eSBjb25zdHJ1Y3RvcikuXG4qKVxuXG4oKiBUeXBlIG9mIGEgYmxvY2sgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBibG9ja190eXBlID1cbiAgfCBQcF9oYm94ICAgKCogSG9yaXpvbnRhbCBibG9jayBubyBsaW5lIGJyZWFraW5nICopXG4gIHwgUHBfdmJveCAgICgqIFZlcnRpY2FsIGJsb2NrIGVhY2ggYnJlYWsgbGVhZHMgdG8gYSBuZXcgbGluZSAqKVxuICB8IFBwX2h2Ym94ICAoKiBIb3Jpem9udGFsLXZlcnRpY2FsIGJsb2NrOiBzYW1lIGFzIHZib3gsIGV4Y2VwdCBpZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICAgICAgIGlzIHNtYWxsIGVub3VnaCB0byBmaXQgb24gYSBzaW5nbGUgbGluZSAqKVxuICB8IFBwX2hvdmJveCAoKiBIb3Jpem9udGFsIG9yIFZlcnRpY2FsIGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jayAqKVxuICB8IFBwX2JveCAgICAoKiBIb3Jpem9udGFsIG9yIEluZGVudCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2ssIG9yXG4gICAgICAgICAgICAgICAgIHdoZW4gaXQgbGVhZHMgdG8gYSBuZXcgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbGluZSAqKVxuICB8IFBwX2ZpdHMgICAoKiBJbnRlcm5hbCB1c2FnZTogd2hlbiBhIGJsb2NrIGZpdHMgb24gYSBzaW5nbGUgbGluZSAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBmb3JtYXR0aW5nX2xpdCA9XG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBdICAgKilcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQH0gICAqKVxuICB8IEJyZWFrIG9mIHN0cmluZyAqIGludCAqIGludCAgICAgICAgICAoKiBALCB8IEAgIHwgQDsgfCBAOzw+ICopXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA/ICAgKilcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFxcbiAgKilcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQC4gICAqKVxuICB8IE1hZ2ljX3NpemUgb2Ygc3RyaW5nICogaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPG4+ICopXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBAICAgKilcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQCUlICAqKVxuICB8IFNjYW5faW5kaWMgb2YgY2hhciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAWCAgICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlbiA9XG4gIHwgT3Blbl90YWcgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEB7ICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cbiAgfCBPcGVuX2JveCA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQFsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCB0eXBlIGVsZW1lbnRzLiAqKVxuKCogSW4gcGFydGljdWxhciB1c2VkIHRvIHJlcHJlc2VudCAlKC4uLiUpIGFuZCAley4uLiV9IGNvbnRlbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5hbmQgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCA9XG4gIHwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgU3RyaW5nX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoc3RyaW5nIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgc3RyaW5nIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQzMl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQzMiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDMyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IE5hdGl2ZWludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbmQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKG5hdGl2ZWludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIG5hdGl2ZWludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQ2NF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQ2NCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDY0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEZsb2F0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGZsb2F0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgZmxvYXQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQm9vbF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVCICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoYm9vbCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGJvb2wgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBGb3JtYXRfYXJnX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG4gIHwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnMuICopXG4gIHwgQWxwaGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAneCAtPiAnYzEpIC0+ICd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAneCAtPiAnYzIpIC0+ICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFRoZXRhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ2MxKSAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ2MyKSAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBBbnlfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFVzZWQgZm9yIGN1c3RvbSBmb3JtYXRzICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IFJlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBFbmRfb2ZfZm10dHkgOlxuICAgICAgKCdmMSwgJ2IxLCAnYzEsICdkMSwgJ2QxLCAnZjEsXG4gICAgICAgJ2YyLCAnYjIsICdjMiwgJ2QyLCAnZDIsICdmMikgZm10dHlfcmVsXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IGVsZW1lbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgPVxuICB8IENoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVDICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFN0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVTICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDMyIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgTmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5bZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBuYXRpdmVpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDY0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZoSF0gKilcbiAgICAgIGZsb2F0X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBmbG9hdCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEJvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbYkJdICopXG4gICAgICAoJ3gsIGJvb2wgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbHVzaCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlISAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBhYmMgKilcbiAgICAgIHN0cmluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENoYXJfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIHggKilcbiAgICAgIGNoYXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IEZvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBBbHBoYSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICd4IC0+ICdjKSAtPiAneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBUaGV0YSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICdjKSAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3I6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgIGZvcm1hdHRpbmdfbGl0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0dGluZ19nZW4gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UxLCAnZjEpIGZvcm1hdHRpbmdfZ2VuICpcbiAgICAgICgnZjEsICdiLCAnYywgJ2UxLCAnZTIsICdmMikgZm10IC0+ICgnYTEsICdiLCAnYywgJ2QxLCAnZTIsICdmMikgZm10XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCAtPiAnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoc3RyaW5nIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChpbnQgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJTBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJZ25vcmVkX3BhcmFtIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGlnbm9yZWQgKiAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBDdXN0b20gcHJpbnRpbmcgZm9ybWF0IChQUiM2NDUyLCBHUFIjMTQwKVxuXG4gICAgIFdlIGluY2x1ZGUgYSB0eXBlIEN1c3RvbSBvZiBcImN1c3RvbSBjb252ZXJ0ZXJzXCIsIHdoZXJlIGFuXG4gICAgIGFyYml0cmFyeSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjb252ZXJ0IG9uZSBvciBtb3JlXG4gICAgIGFyZ3VtZW50cy4gVGhlcmUgaXMgbm8gc3ludGF4IGZvciBjdXN0b20gY29udmVydGVycywgaXQgaXMgb25seVxuICAgICBpbnRlbmRlZCBmb3IgY3VzdG9tIHByb2Nlc3NvcnMgdGhhdCB3aXNoIHRvIHJlbHkgb24gdGhlXG4gICAgIHN0ZGxpYi1kZWZpbmVkIGZvcm1hdCBHQURUcy5cblxuICAgICBGb3IgaW5zdGFuY2UgYSBwcmUtcHJvY2Vzc29yIGNvdWxkIGNob29zZSB0byBpbnRlcnByZXQgc3RyaW5nc1xuICAgICBwcmVmaXhlZCB3aXRoIFtcIiFcIl0gYXMgZm9ybWF0IHN0cmluZ3Mgd2hlcmUgWyV7eyAuLi4gfX1dIGlzXG4gICAgIGEgc3BlY2lhbCBmb3JtIHRvIHBhc3MgYSB0b19zdHJpbmcgZnVuY3Rpb24sIHNvIHRoYXQgb25lIGNvdWxkXG4gICAgIHdyaXRlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50OyB5IDogaW50IH1cblxuICAgICAgIGxldCBzdHJpbmdfb2ZfdCB0ID0gUHJpbnRmLnNwcmludGYgXCJ7IHggPSAlZDsgeSA9ICVkIH1cIiB0LnggdC55XG5cbiAgICAgICBQcmludGYucHJpbnRmICFcInQgPSAle3tzdHJpbmdfb2ZfdH19XCIgeyB4ID0gNDI7IHkgPSA0MiB9XG4gICAgIF19XG4gICopXG4gIHwgQ3VzdG9tIDpcbiAgICAgICgnYSwgJ3gsICd5KSBjdXN0b21fYXJpdHkgKiAodW5pdCAtPiAneCkgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogZW5kIG9mIGEgZm9ybWF0IHNwZWNpZmljYXRpb24gKilcbiAgfCBFbmRfb2ZfZm9ybWF0IDpcbiAgICAgICAgKCdmLCAnYiwgJ2MsICdlLCAnZSwgJ2YpIGZtdFxuXG4oKioqKVxuXG4oKiBUeXBlIGZvciBpZ25vcmVkIHBhcmFtZXRlcnMgKHNlZSBcIiVfXCIpLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkID1cbiAgfCBJZ25vcmVkX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9DICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfcyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfUyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9sZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9uZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9MZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9mICopXG4gICAgICBwYWRfb3B0aW9uICogcHJlY19vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Jvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0IgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3suLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9yZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICopXG4gICAgICAoJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0IC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXzBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAqIHN0cmluZ1xuXG5sZXQgcmVjIGVyYXNlX3JlbCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAoYSwgYiwgYywgZCwgZSwgZixcbiAgIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIF90eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGUgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0IHR5cGVzLiAqKVxuKCogVXNlZCBieTpcbiAgICogcmVhZGVyX25iX3VuaWZpZXJfb2ZfZm10dHkgdG8gY291bnQgcmVhZGVycyBpbiBhbiBmbXR0eSxcbiAgICogU2NhbmYudGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyB0byBleHRyYWN0IHJlYWRlcnMgaW5zaWRlICUoLi4uJSksXG4gICAqIENhbWxpbnRlcm5hbEZvcm1hdC5mbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCB0byBleHRyYWN0IGZvcm1hdCB0eXBlLiAqKVxuXG4oKlxubGV0IHJlYyBjb25jYXRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdHR5ID1cbiopXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAgICAgIGcxIGoxIGcyIGoyXG4gIC5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGQxLCBhMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGQyLCBhMikgZm10dHlfcmVsIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZTEsIGYxLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZTIsIGYyKSBmbXR0eV9yZWwgPVxuZnVuIGZtdHR5MSBmbXR0eTIgLT4gbWF0Y2ggZm10dHkxIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEVuZF9vZl9mbXR0eSAtPiBmbXR0eTJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXRzLiAqKVxubGV0IHJlYyBjb25jYXRfZm10IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdCA9XG5mdW4gZm10MSBmbXQyIC0+IG1hdGNoIGZtdDEgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIFN0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIENhbWxfc3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDY0IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBDaGFyIChyZXN0KSAtPlxuICAgIENoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgQ2FtbF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgQm9vbCAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgQWxwaGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBUaGV0YSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBDdXN0b20gKGFyaXR5LCBmLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBSZWFkZXIgcmVzdCAtPlxuICAgIFJlYWRlciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIEZsdXNoIChjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nX2xpdGVyYWwgKHN0ciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgQ2hhcl9saXRlcmFsICAgKGNociwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmcgICAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgKHJlc3QpIC0+XG4gICAgU2Nhbl9uZXh0X2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBJZ25vcmVkX3BhcmFtIChpZ24sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBmbXQyXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4Y2VwdGlvbnMgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICAoKiBmb3IgcnVudGltZS9mYWlsX25hdC5jICopXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5hcnJheV9ib3VuZF9lcnJvclwiXG4gICAgKEludmFsaWRfYXJndW1lbnQgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxuXG5sZXQgZmFpbHdpdGggcyA9IHJhaXNlKEZhaWx1cmUgcylcbmxldCBpbnZhbGlkX2FyZyBzID0gcmFpc2UoSW52YWxpZF9hcmd1bWVudCBzKVxuXG5leGNlcHRpb24gRXhpdFxuZXhjZXB0aW9uIE1hdGNoX2ZhaWx1cmUgPSBNYXRjaF9mYWlsdXJlXG5leGNlcHRpb24gQXNzZXJ0X2ZhaWx1cmUgPSBBc3NlcnRfZmFpbHVyZVxuZXhjZXB0aW9uIEludmFsaWRfYXJndW1lbnQgPSBJbnZhbGlkX2FyZ3VtZW50XG5leGNlcHRpb24gRmFpbHVyZSA9IEZhaWx1cmVcbmV4Y2VwdGlvbiBOb3RfZm91bmQgPSBOb3RfZm91bmRcbmV4Y2VwdGlvbiBPdXRfb2ZfbWVtb3J5ID0gT3V0X29mX21lbW9yeVxuZXhjZXB0aW9uIFN0YWNrX292ZXJmbG93ID0gU3RhY2tfb3ZlcmZsb3dcbmV4Y2VwdGlvbiBTeXNfZXJyb3IgPSBTeXNfZXJyb3JcbmV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSA9IEVuZF9vZl9maWxlXG5leGNlcHRpb24gRGl2aXNpb25fYnlfemVybyA9IERpdmlzaW9uX2J5X3plcm9cbmV4Y2VwdGlvbiBTeXNfYmxvY2tlZF9pbyA9IFN5c19ibG9ja2VkX2lvXG5leGNlcHRpb24gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgPSBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZVxuXG4oKiBDb21wb3NpdGlvbiBvcGVyYXRvcnMgKilcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5cbigqIERlYnVnZ2luZyAqKVxuXG5leHRlcm5hbCBfX0xPQ19fIDogc3RyaW5nID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0ZJTEVfXyA6IHN0cmluZyA9IFwiJWxvY19GSUxFXCJcbmV4dGVybmFsIF9fTElORV9fIDogaW50ID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19NT0RVTEVfXyA6IHN0cmluZyA9IFwiJWxvY19NT0RVTEVcIlxuZXh0ZXJuYWwgX19QT1NfXyA6IHN0cmluZyAqIGludCAqIGludCAqIGludCA9IFwiJWxvY19QT1NcIlxuXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuXG4oKiBDb21wYXJpc29ucyAqKVxuXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxubGV0IG1pbiB4IHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcblxuKCogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggb3IgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcblxuKCogSW50ZWdlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcblxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxubGV0IGxub3QgeCA9IHggbHhvciAoLTEpXG5cbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcblxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5cbigqIEZsb2F0aW5nLXBvaW50IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxubGV0IGluZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5lZ19pbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHhGRl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuYW4gPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDFMXG5sZXQgbWF4X2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0VGX0ZGX0ZGX0ZGX0ZGX0ZGX0ZGTFxubGV0IG1pbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgwMF8xMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBlcHNpbG9uX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDNDX0IwXzAwXzAwXzAwXzAwXzAwXzAwTFxuXG50eXBlIGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuKCogU3RyaW5nIGFuZCBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGVzIFN0cmluZyBhbmQgQnl0ZXMgKilcblxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2xlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19jcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHN0cmluZ19ibGl0IDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgKCBeICkgczEgczIgPVxuICBsZXQgbDEgPSBzdHJpbmdfbGVuZ3RoIHMxIGFuZCBsMiA9IHN0cmluZ19sZW5ndGggczIgaW5cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgKGwxICsgbDIpIGluXG4gIHN0cmluZ19ibGl0IHMxIDAgcyAwIGwxO1xuICBzdHJpbmdfYmxpdCBzMiAwIHMgbDEgbDI7XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBDaGFyICopXG5cbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hhcl9vZl9pbnQgOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiY2hhcl9vZl9pbnRcIiBlbHNlIHVuc2FmZV9jaGFyX29mX2ludCBuXG5cbigqIFVuaXQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogUGFpciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5cbigqIFJlZmVyZW5jZXMgKilcblxudHlwZSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG5cbigqIFJlc3VsdCB0eXBlICopXG5cbnR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG5cbigqIFN0cmluZyBjb252ZXJzaW9uIGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbmxldCBzdHJpbmdfb2ZfYm9vbCBiID1cbiAgaWYgYiB0aGVuIFwidHJ1ZVwiIGVsc2UgXCJmYWxzZVwiXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBfIC0+IGludmFsaWRfYXJnIFwiYm9vbF9vZl9zdHJpbmdcIlxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiBTb21lIHRydWVcbiAgfCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxuICB8IF8gLT4gTm9uZVxuXG5sZXQgc3RyaW5nX29mX2ludCBuID1cbiAgZm9ybWF0X2ludCBcIiVkXCIgblxuXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuZXh0ZXJuYWwgc3RyaW5nX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5cbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBzdHJpbmdfbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPj0gbCB0aGVuIHMgXiBcIi5cIiBlbHNlXG4gICAgbWF0Y2ggc3RyaW5nX2dldCBzIGkgd2l0aFxuICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICB8IF8gLT4gc1xuICBpblxuICBsb29wIDBcblxubGV0IHN0cmluZ19vZl9mbG9hdCBmID0gdmFsaWRfZmxvYXRfbGV4ZW0gKGZvcm1hdF9mbG9hdCBcIiUuMTJnXCIgZilcblxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgTGlzdCAqKVxuXG5sZXQgcmVjICggQCApIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgaGQgOjogdGwgLT4gaGQgOjogKHRsIEAgbDIpXG5cbigqIEkvTyBvcGVyYXRpb25zICopXG5cbnR5cGUgaW5fY2hhbm5lbFxudHlwZSBvdXRfY2hhbm5lbFxuXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDogaW50IC0+IG91dF9jaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcIlxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX2luIDogaW50IC0+IGluX2NoYW5uZWwgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXCJcblxubGV0IHN0ZGluID0gb3Blbl9kZXNjcmlwdG9yX2luIDBcbmxldCBzdGRvdXQgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDFcbmxldCBzdGRlcnIgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDJcblxuKCogR2VuZXJhbCBvdXRwdXQgZnVuY3Rpb25zICopXG5cbnR5cGUgb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seSB8IE9wZW5fd3Jvbmx5IHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0IHwgT3Blbl90cnVuYyB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5IHwgT3Blbl90ZXh0IHwgT3Blbl9ub25ibG9ja1xuXG5leHRlcm5hbCBvcGVuX2Rlc2MgOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5cbmV4dGVybmFsIHNldF9vdXRfY2hhbm5lbF9uYW1lOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5fb3V0X2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX291dChvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9vdXRfY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9vdXQgbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fdGV4dF0gMG82NjYgbmFtZVxuXG5sZXQgb3Blbl9vdXRfYmluIG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX2JpbmFyeV0gMG82NjYgbmFtZVxuXG5leHRlcm5hbCBmbHVzaCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfZmx1c2hcIlxuXG5leHRlcm5hbCBvdXRfY2hhbm5lbHNfbGlzdCA6IHVuaXQgLT4gb3V0X2NoYW5uZWwgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3RcIlxuXG5sZXQgZmx1c2hfYWxsICgpID1cbiAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+ICgpXG4gICAgfCBhOjpsIC0+XG4gICAgICAgIGJlZ2luIHRyeVxuICAgICAgICAgICAgZmx1c2ggYVxuICAgICAgICB3aXRoIFN5c19lcnJvciBfIC0+XG4gICAgICAgICAgKCkgKCogaWdub3JlIGNoYW5uZWxzIGNsb3NlZCBkdXJpbmcgYSBwcmVjZWRpbmcgZmx1c2guICopXG4gICAgICAgIGVuZDtcbiAgICAgICAgaXRlciBsXG4gIGluIGl0ZXIgKG91dF9jaGFubmVsc19saXN0ICgpKVxuXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0IDogb3V0X2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dF9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0X3N0cmluZyA6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dFwiXG5cbmV4dGVybmFsIG91dHB1dF9jaGFyIDogb3V0X2NoYW5uZWwgLT4gY2hhciAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcblxubGV0IG91dHB1dF9ieXRlcyBvYyBzID1cbiAgdW5zYWZlX291dHB1dCBvYyBzIDAgKGJ5dGVzX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0X3N0cmluZyBvYyBzID1cbiAgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyAwIChzdHJpbmdfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXQgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXQgb2MgcyBvZnMgbGVuXG5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBzdHJpbmdfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dF9zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgb2ZzIGxlblxuXG5leHRlcm5hbCBvdXRwdXRfYnl0ZSA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcbmV4dGVybmFsIG91dHB1dF9iaW5hcnlfaW50IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2ludFwiXG5cbmV4dGVybmFsIG1hcnNoYWxfdG9fY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+ICdhIC0+IHVuaXQgbGlzdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5sZXQgb3V0cHV0X3ZhbHVlIGNoYW4gdiA9IG1hcnNoYWxfdG9fY2hhbm5lbCBjaGFuIHYgW11cblxuZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dFwiXG5leHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19vdXRcIlxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9vdXRfY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2Vfb3V0IG9jID0gZmx1c2ggb2M7IGNsb3NlX291dF9jaGFubmVsIG9jXG5sZXQgY2xvc2Vfb3V0X25vZXJyIG9jID1cbiAgKHRyeSBmbHVzaCBvYyB3aXRoIF8gLT4gKCkpO1xuICAodHJ5IGNsb3NlX291dF9jaGFubmVsIG9jIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9vdXQgOiBvdXRfY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogR2VuZXJhbCBpbnB1dCBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgc2V0X2luX2NoYW5uZWxfbmFtZTogaW5fY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5faW5fZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3JfaW4ob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfaW5fY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9pbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX3RleHRdIDAgbmFtZVxuXG5sZXQgb3Blbl9pbl9iaW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl9iaW5hcnldIDAgbmFtZVxuXG5leHRlcm5hbCBpbnB1dF9jaGFyIDogaW5fY2hhbm5lbCAtPiBjaGFyID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuXG5leHRlcm5hbCB1bnNhZmVfaW5wdXQgOiBpbl9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfaW5wdXRcIlxuXG5sZXQgaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJpbnB1dFwiXG4gIGVsc2UgdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVjIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgbGVuIDw9IDAgdGhlbiAoKSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuIGluXG4gICAgaWYgciA9IDBcbiAgICB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgKG9mcyArIHIpIChsZW4gLSByKVxuICBlbmRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcInJlYWxseV9pbnB1dFwiXG4gIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuID1cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgbGVuIGluXG4gIHJlYWxseV9pbnB1dCBpYyBzIDAgbGVuO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuZXh0ZXJuYWwgaW5wdXRfc2Nhbl9saW5lIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXCJcblxubGV0IGlucHV0X2xpbmUgY2hhbiA9XG4gIGxldCByZWMgYnVpbGRfcmVzdWx0IGJ1ZiBwb3MgPSBmdW5jdGlvblxuICAgIFtdIC0+IGJ1ZlxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBsZXQgbGVuID0gYnl0ZXNfbGVuZ3RoIGhkIGluXG4gICAgICBieXRlc19ibGl0IGhkIDAgYnVmIChwb3MgLSBsZW4pIGxlbjtcbiAgICAgIGJ1aWxkX3Jlc3VsdCBidWYgKHBvcyAtIGxlbikgdGwgaW5cbiAgbGV0IHJlYyBzY2FuIGFjY3UgbGVuID1cbiAgICBsZXQgbiA9IGlucHV0X3NjYW5fbGluZSBjaGFuIGluXG4gICAgaWYgbiA9IDAgdGhlbiBiZWdpbiAgICAgICAgICAgICAgICAgICAoKiBuID0gMDogd2UgYXJlIGF0IEVPRiAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICB8IF8gIC0+IGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIGFjY3VcbiAgICBlbmQgZWxzZSBpZiBuID4gMCB0aGVuIGJlZ2luICAgICAgICAgICgqIG4gPiAwOiBuZXdsaW5lIGZvdW5kIGluIGJ1ZmZlciAqKVxuICAgICAgbGV0IHJlcyA9IGJ5dGVzX2NyZWF0ZSAobiAtIDEpIGluXG4gICAgICBpZ25vcmUgKHVuc2FmZV9pbnB1dCBjaGFuIHJlcyAwIChuIC0gMSkpO1xuICAgICAgaWdub3JlIChpbnB1dF9jaGFyIGNoYW4pOyAgICAgICAgICAgKCogc2tpcCB0aGUgbmV3bGluZSAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJlc1xuICAgICAgfCAgXyAtPiBsZXQgbGVuID0gbGVuICsgbiAtIDEgaW5cbiAgICAgICAgICAgICAgYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gKHJlcyA6OiBhY2N1KVxuICAgIGVuZCBlbHNlIGJlZ2luICAgICAgICAgICAgICAgICAgICAgICAgKCogbiA8IDA6IG5ld2xpbmUgbm90IGZvdW5kICopXG4gICAgICBsZXQgYmVnID0gYnl0ZXNfY3JlYXRlICgtbikgaW5cbiAgICAgIGlnbm9yZSh1bnNhZmVfaW5wdXQgY2hhbiBiZWcgMCAoLW4pKTtcbiAgICAgIHNjYW4gKGJlZyA6OiBhY2N1KSAobGVuIC0gbilcbiAgICBlbmRcbiAgaW4gYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyAoc2NhbiBbXSAwKVxuXG5leHRlcm5hbCBpbnB1dF9ieXRlIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5leHRlcm5hbCBpbnB1dF9iaW5hcnlfaW50IDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfaW50XCJcbmV4dGVybmFsIGlucHV0X3ZhbHVlIDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXCJcbmV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19pblwiXG5leHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9pbl9ub2VyciBpYyA9ICh0cnkgY2xvc2VfaW4gaWMgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX2luIDogaW5fY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIG91dHB1dCAqKVxuXG5sZXQgcHJpbnRfY2hhciBjID0gb3V0cHV0X2NoYXIgc3Rkb3V0IGNcbmxldCBwcmludF9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IHNcbmxldCBwcmludF9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZG91dCBzXG5sZXQgcHJpbnRfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByaW50X2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJpbnRfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRvdXQgczsgb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcbmxldCBwcmludF9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBlcnJvciAqKVxuXG5sZXQgcHJlcnJfY2hhciBjID0gb3V0cHV0X2NoYXIgc3RkZXJyIGNcbmxldCBwcmVycl9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIHNcbmxldCBwcmVycl9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZGVyciBzXG5sZXQgcHJlcnJfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByZXJyX2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJlcnJfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRlcnIgczsgb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcbmxldCBwcmVycl9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcblxuKCogSW5wdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGlucHV0ICopXG5cbmxldCByZWFkX2xpbmUgKCkgPSBmbHVzaCBzdGRvdXQ7IGlucHV0X2xpbmUgc3RkaW5cbmxldCByZWFkX2ludCAoKSA9IGludF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9pbnRfb3B0ICgpID0gaW50X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdCAoKSA9IGZsb2F0X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0X29wdCAoKSA9IGZsb2F0X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5cbigqIE9wZXJhdGlvbnMgb24gbGFyZ2UgZmlsZXMgKilcblxubW9kdWxlIExhcmdlRmlsZSA9XG4gIHN0cnVjdFxuICAgIGV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dF82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19vdXRfNjRcIlxuICAgIGV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gICAgZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXzY0XCJcbiAgICBleHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19pbl82NFwiXG4gICAgZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gIGVuZFxuXG4oKiBGb3JtYXRzICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG4gICA9IEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZtdFxuICAgICAgICAgICAgICAgKiBzdHJpbmdcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxuXG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcblxubGV0IHN0cmluZ19vZl9mb3JtYXQgKEZvcm1hdCAoX2ZtdCwgc3RyKSkgPSBzdHJcblxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcblxubGV0ICggXl4gKSAoRm9ybWF0IChmbXQxLCBzdHIxKSkgKEZvcm1hdCAoZm10Miwgc3RyMikpID1cbiAgRm9ybWF0IChDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuY29uY2F0X2ZtdCBmbXQxIGZtdDIsXG4gICAgICAgICAgc3RyMSBeIFwiJSxcIiBeIHN0cjIpXG5cbigqIE1pc2NlbGxhbmVvdXMgKilcblxuZXh0ZXJuYWwgc3lzX2V4aXQgOiBpbnQgLT4gJ2EgPSBcImNhbWxfc3lzX2V4aXRcIlxuXG5sZXQgZXhpdF9mdW5jdGlvbiA9IHJlZiBmbHVzaF9hbGxcblxubGV0IGF0X2V4aXQgZiA9XG4gIGxldCBnID0gIWV4aXRfZnVuY3Rpb24gaW5cbiAgKCogTVBSIzcyNTMsIE1QUiM3Nzk2OiBtYWtlIHN1cmUgXCJmXCIgaXMgZXhlY3V0ZWQgb25seSBvbmNlICopXG4gIGxldCBmX2FscmVhZHlfcmFuID0gcmVmIGZhbHNlIGluXG4gIGV4aXRfZnVuY3Rpb24gOj1cbiAgICAoZnVuICgpIC0+XG4gICAgICBpZiBub3QgIWZfYWxyZWFkeV9yYW4gdGhlbiBiZWdpbiBmX2FscmVhZHlfcmFuIDo9IHRydWU7IGYoKSBlbmQ7XG4gICAgICBnKCkpXG5cbmxldCBkb19hdF9leGl0ICgpID0gKCFleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuXG4oKk1PRFVMRV9BTElBU0VTKilcbm1vZHVsZSBBcmcgICAgICAgICAgPSBBcmdcbm1vZHVsZSBBcnJheSAgICAgICAgPSBBcnJheVxubW9kdWxlIEFycmF5TGFiZWxzICA9IEFycmF5TGFiZWxzXG5tb2R1bGUgQmlnYXJyYXkgICAgID0gQmlnYXJyYXlcbm1vZHVsZSBCb29sICAgICAgICAgPSBCb29sXG5tb2R1bGUgQnVmZmVyICAgICAgID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgICAgICAgID0gQnl0ZXNcbm1vZHVsZSBCeXRlc0xhYmVscyAgPSBCeXRlc0xhYmVsc1xubW9kdWxlIENhbGxiYWNrICAgICA9IENhbGxiYWNrXG5tb2R1bGUgQ2hhciAgICAgICAgID0gQ2hhclxubW9kdWxlIENvbXBsZXggICAgICA9IENvbXBsZXhcbm1vZHVsZSBEaWdlc3QgICAgICAgPSBEaWdlc3Rcbm1vZHVsZSBFcGhlbWVyb24gICAgPSBFcGhlbWVyb25cbm1vZHVsZSBGaWxlbmFtZSAgICAgPSBGaWxlbmFtZVxubW9kdWxlIEZsb2F0ICAgICAgICA9IEZsb2F0XG5tb2R1bGUgRm9ybWF0ICAgICAgID0gRm9ybWF0XG5tb2R1bGUgRnVuICAgICAgICAgID0gRnVuXG5tb2R1bGUgR2MgICAgICAgICAgID0gR2Ncbm1vZHVsZSBHZW5sZXggICAgICAgPSBHZW5sZXhcbm1vZHVsZSBIYXNodGJsICAgICAgPSBIYXNodGJsXG5tb2R1bGUgSW50ICAgICAgICAgID0gSW50XG5tb2R1bGUgSW50MzIgICAgICAgID0gSW50MzJcbm1vZHVsZSBJbnQ2NCAgICAgICAgPSBJbnQ2NFxubW9kdWxlIExhenkgICAgICAgICA9IExhenlcbm1vZHVsZSBMZXhpbmcgICAgICAgPSBMZXhpbmdcbm1vZHVsZSBMaXN0ICAgICAgICAgPSBMaXN0XG5tb2R1bGUgTGlzdExhYmVscyAgID0gTGlzdExhYmVsc1xubW9kdWxlIE1hcCAgICAgICAgICA9IE1hcFxubW9kdWxlIE1hcnNoYWwgICAgICA9IE1hcnNoYWxcbm1vZHVsZSBNb3JlTGFiZWxzICAgPSBNb3JlTGFiZWxzXG5tb2R1bGUgTmF0aXZlaW50ICAgID0gTmF0aXZlaW50XG5tb2R1bGUgT2JqICAgICAgICAgID0gT2JqXG5tb2R1bGUgT28gICAgICAgICAgID0gT29cbm1vZHVsZSBPcHRpb24gICAgICAgPSBPcHRpb25cbm1vZHVsZSBQYXJzaW5nICAgICAgPSBQYXJzaW5nXG5tb2R1bGUgUGVydmFzaXZlcyAgID0gUGVydmFzaXZlc1xubW9kdWxlIFByaW50ZXhjICAgICA9IFByaW50ZXhjXG5tb2R1bGUgUHJpbnRmICAgICAgID0gUHJpbnRmXG5tb2R1bGUgUXVldWUgICAgICAgID0gUXVldWVcbm1vZHVsZSBSYW5kb20gICAgICAgPSBSYW5kb21cbm1vZHVsZSBSZXN1bHQgICAgICAgPSBSZXN1bHRcbm1vZHVsZSBTY2FuZiAgICAgICAgPSBTY2FuZlxubW9kdWxlIFNlcSAgICAgICAgICA9IFNlcVxubW9kdWxlIFNldCAgICAgICAgICA9IFNldFxubW9kdWxlIFNwYWNldGltZSAgICA9IFNwYWNldGltZVxubW9kdWxlIFN0YWNrICAgICAgICA9IFN0YWNrXG5tb2R1bGUgU3RkTGFiZWxzICAgID0gU3RkTGFiZWxzXG5tb2R1bGUgU3RyZWFtICAgICAgID0gU3RyZWFtXG5tb2R1bGUgU3RyaW5nICAgICAgID0gU3RyaW5nXG5tb2R1bGUgU3RyaW5nTGFiZWxzID0gU3RyaW5nTGFiZWxzXG5tb2R1bGUgU3lzICAgICAgICAgID0gU3lzXG5tb2R1bGUgVWNoYXIgICAgICAgID0gVWNoYXJcbm1vZHVsZSBVbml0ICAgICAgICAgPSBVbml0XG5tb2R1bGUgV2VhayAgICAgICAgID0gV2Vha1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICBOaWNvbGFzIE9qZWRhIEJhciwgTGV4aUZpICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBuZWcgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsIGFkZCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgc3ViIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCBtdWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsIGRpdiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgcmVtIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbWEgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbWFfZmxvYXRcIiBcImNhbWxfZm1hXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFicyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBpbmZpbml0eSA9IFN0ZGxpYi5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFN0ZGxpYi5uZWdfaW5maW5pdHlcbmxldCBuYW4gPSBTdGRsaWIubmFuXG5sZXQgaXNfZmluaXRlICh4OiBmbG9hdCkgPSB4IC0uIHggPSAwLlxubGV0IGlzX2luZmluaXRlICh4OiBmbG9hdCkgPSAxLiAvLiB4ID0gMC5cbmxldCBpc19uYW4gKHg6IGZsb2F0KSA9IHggPD4geFxuXG5sZXQgcGkgPSAweDEuOTIxZmI1NDQ0MmQxOHArMVxubGV0IG1heF9mbG9hdCA9IFN0ZGxpYi5tYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBTdGRsaWIubWluX2Zsb2F0XG5sZXQgZXBzaWxvbiA9IFN0ZGxpYi5lcHNpbG9uX2Zsb2F0XG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9mbG9hdFxudHlwZSBmcGNsYXNzID0gU3RkbGliLmZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHBvdyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRydW5jIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdHJ1bmNfZmxvYXRcIiBcImNhbWxfdHJ1bmNcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcm91bmQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9yb3VuZF9mbG9hdFwiIFwiY2FtbF9yb3VuZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG5bQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgaXNfaW50ZWdlciB4ID0geCA9IHRydW5jIHggJiYgaXNfZmluaXRlIHhcblxuZXh0ZXJuYWwgbmV4dF9hZnRlciA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gID0gXCJjYW1sX25leHRhZnRlcl9mbG9hdFwiIFwiY2FtbF9uZXh0YWZ0ZXJcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgc3VjYyB4ID0gbmV4dF9hZnRlciB4IGluZmluaXR5XG5sZXQgcHJlZCB4ID0gbmV4dF9hZnRlciB4IG5lZ19pbmZpbml0eVxuXG5leHRlcm5hbCBjb3B5X3NpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpZ25fYml0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGJvb2xcbiAgPSBcImNhbWxfc2lnbmJpdF9mbG9hdFwiIFwiY2FtbF9zaWduYml0XCIgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbnR5cGUgdCA9IGZsb2F0XG5leHRlcm5hbCBjb21wYXJlIDogZmxvYXQgLT4gZmxvYXQgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5sZXQgZXF1YWwgeCB5ID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldFtAaW5saW5lXSBtaW4gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHkgdGhlbiB5IGVsc2UgeFxuICBlbHNlIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIHlcblxubGV0W0BpbmxpbmVdIG1heCAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heCAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiBpc19uYW4geCB8fCBpc19uYW4geSB0aGVuIChuYW4sIG5hbilcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgsIHkpIGVsc2UgKHksIHgpXG5cbmxldFtAaW5saW5lXSBtaW5fbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXhfbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIHlcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG5cbmxldFtAaW5saW5lXSBtaW5fbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiBpc19uYW4geCB0aGVuICh5LHkpXG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiAoeCx4KVxuICBlbHNlIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlbiAoeCx5KSBlbHNlICh5LHgpXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiBpbnQgLT4gZmxvYXQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG5cbm1vZHVsZSBBcnJheSA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IGZsb2F0YXJyYXlcblxuICBleHRlcm5hbCBsZW5ndGggOiB0IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiB0IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiB0IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcblxuICBsZXQgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHYgPVxuICAgIGZvciBpID0gb2ZzIHRvIG9mcyArIGxlbiAtIDEgZG8gdW5zYWZlX3NldCBhIGkgdiBkb25lXG5cbiAgbGV0IHVuc2FmZV9ibGl0IHNyYyBzb2ZzIGRzdCBkb2ZzIGxlbiA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgZHN0IChkb2ZzICsgaSkgKHVuc2FmZV9nZXQgc3JjIChzb2ZzICsgaSkpXG4gICAgZG9uZVxuXG4gIGxldCBjaGVjayBhIG9mcyBsZW4gbXNnID1cbiAgICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzICsgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPiBsZW5ndGggYSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBsZXQgbWFrZSBuIHYgPVxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbiBpblxuICAgIHVuc2FmZV9maWxsIHJlc3VsdCAwIG4gdjtcbiAgICByZXN1bHRcblxuICBsZXQgaW5pdCBsIGYgPVxuICAgIGlmIGwgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pbml0XCJcbiAgICBlbHNlXG4gICAgICBsZXQgcmVzID0gY3JlYXRlIGwgaW5cbiAgICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICAgICBkb25lO1xuICAgICAgcmVzXG5cbiAgbGV0IGFwcGVuZCBhMSBhMiA9XG4gICAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gICAgbGV0IGwyID0gbGVuZ3RoIGEyIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgICB1bnNhZmVfYmxpdCBhMSAwIHJlc3VsdCAwIGwxO1xuICAgIHVuc2FmZV9ibGl0IGEyIDAgcmVzdWx0IGwxIGwyO1xuICAgIHJlc3VsdFxuXG4gICgqIG5leHQgMyBmdW5jdGlvbnM6IG1vZGlmaWVkIGNvcHkgb2YgY29kZSBmcm9tIHN0cmluZy5tbCAqKVxuICBsZXQgZW5zdXJlX2dlICh4OmludCkgeSA9XG4gICAgaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuY29uY2F0XCJcblxuICBsZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIGFjYykgYWNjKSB0bFxuXG4gIGxldCBjb25jYXQgbCA9XG4gICAgbGV0IGxlbiA9IHN1bV9sZW5ndGhzIDAgbCBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGwgaSA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IChpID0gbGVuKVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBsZXQgaGxlbiA9IGxlbmd0aCBoZCBpblxuICAgICAgICB1bnNhZmVfYmxpdCBoZCAwIHJlc3VsdCBpIGhsZW47XG4gICAgICAgIGxvb3AgdGwgKGkgKyBobGVuKVxuICAgIGluXG4gICAgbG9vcCBsIDA7XG4gICAgcmVzdWx0XG5cbiAgbGV0IHN1YiBhIG9mcyBsZW4gPVxuICAgIGNoZWNrIGEgb2ZzIGxlbiBcIkZsb2F0LkFycmF5LnN1YlwiO1xuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgYSBvZnMgcmVzdWx0IDAgbGVuO1xuICAgIHJlc3VsdFxuXG4gIGxldCBjb3B5IGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIGwgaW5cbiAgICB1bnNhZmVfYmxpdCBhIDAgcmVzdWx0IDAgbDtcbiAgICByZXN1bHRcblxuICBsZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuZmlsbFwiO1xuICAgIHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2XG5cbiAgbGV0IGJsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuID1cbiAgICBjaGVjayBzcmMgc29mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgY2hlY2sgZHN0IGRvZnMgbGVuIFwiRmxvYXQuYXJyYXkuYmxpdFwiO1xuICAgIHVuc2FmZV9ibGl0IHNyYyBzb2ZzIGRzdCBkb2ZzIGxlblxuXG4gIGxldCB0b19saXN0IGEgPVxuICAgIExpc3QuaW5pdCAobGVuZ3RoIGEpICh1bnNhZmVfZ2V0IGEpXG5cbiAgbGV0IG9mX2xpc3QgbCA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSAoTGlzdC5sZW5ndGggbCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgaSBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiByZXN1bHRcbiAgICAgIHwgaCA6OiB0IC0+IHVuc2FmZV9zZXQgcmVzdWx0IGkgaDsgZmlsbCAoaSArIDEpIHRcbiAgICBpblxuICAgIGZpbGwgMCBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyIGYgYSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlcjIgZiBhIGIgPVxuICAgIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuaXRlcjI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgICBlbHNlXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxuICBsZXQgbWFwIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbiAgbGV0IG1hcDIgZiBhIGIgPVxuICAgIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gICAgbGV0IGxiID0gbGVuZ3RoIGIgaW5cbiAgICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGNyZWF0ZSBsYSBpblxuICAgICAgZm9yIGkgPSAwIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlcmkgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuICBsZXQgbWFwaSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICAgIGxldCByID0gcmVmIHggaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICAgIGxldCByID0gcmVmIHggaW5cbiAgICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgICBkb25lO1xuICAgICFyXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBleGlzdHMgcCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKSBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9yX2FsbCBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gbG9vcCAoaSArIDEpXG4gICAgICBlbHNlIGZhbHNlIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBtZW0geCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEgaSkgeCA9IDAgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cbiAgKCogbW9zdGx5IGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgYnV0IHNsaWdodGx5IGRpZmZlcmVudCAqKVxuICBsZXQgbWVtX2llZWUgeCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiB4ID0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbiAgbGV0IHNvcnQgY21wIGEgPVxuICAgIGxldCBtYXhzb24gbCBpID1cbiAgICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgICBsZXQgeCA9IHJlZiBpMzEgaW5cbiAgICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgICAgaWYgY21wIChnZXQgYSAheCkgKGdldCBhIChpMzErMikpIDwgMCB0aGVuIHggOj0gaTMxKzI7XG4gICAgICAgICF4XG4gICAgICBlbmQgZWxzZVxuICAgICAgICBpZiBpMzErMSA8IGwgJiYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDBcbiAgICAgICAgdGhlbiBpMzErMVxuICAgICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gICAgaW5cbiAgICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgaWYgY21wIChnZXQgYSBqKSBlID4gMCB0aGVuIGJlZ2luXG4gICAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBhIGkgZTtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gICAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgYnViYmxlZG93biBsIGpcbiAgICBpblxuICAgIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICAgIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgICBsZXQgZmF0aGVyID0gKGkgLSAxKSAvIDMgaW5cbiAgICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgZmF0aGVyKTtcbiAgICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBhIGkgZTtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gICAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgaSkgaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICAgIGRvbmU7XG4gICAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwsIGV4Y2VwdCBmb3IgdGhlIGNhbGwgdG8gW2NyZWF0ZV0gKilcbiAgbGV0IGN1dG9mZiA9IDVcbiAgbGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgICAgbGV0IHNyYzFyID0gc3JjMW9mcyArIHNyYzFsZW4gYW5kIHNyYzJyID0gc3JjMm9mcyArIHNyYzJsZW4gaW5cbiAgICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICAgIHNldCBkc3QgZCBzMTtcbiAgICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICAgIGxvb3AgaTEgKGdldCBhIGkxKSBpMiBzMiAoZCArIDEpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgICBpZiBpMiA8IHNyYzJyIHRoZW5cbiAgICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmxpdCBhIGkxIGRzdCAoZCArIDEpIChzcmMxciAtIGkxKVxuICAgICAgICBlbmRcbiAgICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICAgIGluXG4gICAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGxldCBlID0gKGdldCBhIChzcmNvZnMgKyBpKSkgaW5cbiAgICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgICAgc2V0IGRzdCAoIWogKyAxKSAoZ2V0IGRzdCAhaik7XG4gICAgICAgICAgZGVjciBqO1xuICAgICAgICBkb25lO1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIGU7XG4gICAgICBkb25lO1xuICAgIGluXG4gICAgbGV0IHJlYyBzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgICAgbGV0IGwyID0gbGVuIC0gbDEgaW5cbiAgICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgICBtZXJnZSAoc3Jjb2ZzICsgbDIpIGwxIGRzdCAoZHN0b2ZzICsgbDEpIGwyIGRzdCBkc3RvZnM7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGwgLSBsMSBpblxuICAgICAgbGV0IHQgPSBjcmVhdGUgbDIgaW5cbiAgICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgICAgbWVyZ2UgbDIgbDEgdCAwIGwyIGEgMDtcbiAgICBlbmRcblxuICBsZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcSBhID1cbiAgICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAgIGlmIGkgPCBsZW5ndGggYVxuICAgICAgdGhlblxuICAgICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gICAgICBlbHNlIFNlcS5OaWxcbiAgICBpblxuICAgIGF1eCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCB0b19zZXFpIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgICBlbHNlIFNlcS5OaWxcbiAgICBpblxuICAgIGF1eCAwXG5cbiAgKCogbW9zdGx5IGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgb2ZfcmV2X2xpc3QgbCA9XG4gICAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgIFtdIC0+IGFcbiAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgaW5cbiAgICBmaWxsIChsZW4tMSkgbFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgb2Zfc2VxIGkgPVxuICAgIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICAgIG9mX3Jldl9saXN0IGxcblxuXG4gIGxldCBtYXBfdG9fYXJyYXkgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgaWYgbCA9IDAgdGhlbiBbfCB8XSBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IEFycmF5Lm1ha2UgbCAoZiAodW5zYWZlX2dldCBhIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICAgIEFycmF5LnVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuXG4gIGxldCBtYXBfZnJvbV9hcnJheSBmIGEgPVxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiAoQXJyYXkudW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuXG5lbmRcblxubW9kdWxlIEFycmF5TGFiZWxzID0gQXJyYXlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtOYXRpdmVpbnRdOiBwcm9jZXNzb3ItbmF0aXZlIGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZzogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9uZWdcIlxuZXh0ZXJuYWwgYWRkOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hZGRcIlxuZXh0ZXJuYWwgc3ViOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9zdWJcIlxuZXh0ZXJuYWwgbXVsOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tdWxcIlxuZXh0ZXJuYWwgZGl2OiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9kaXZcIlxuZXh0ZXJuYWwgcmVtOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29yXCJcbmV4dGVybmFsIGxvZ3hvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWw6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzclwiXG5leHRlcm5hbCBvZl9pbnQ6IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludDogbmF0aXZlaW50IC0+IGludCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogbmF0aXZlaW50IC0+IGZsb2F0XG4gID0gXCJjYW1sX25hdGl2ZWludF90b19mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyOiBuYXRpdmVpbnQgLT4gaW50MzIgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgemVybyA9IDBuXG5sZXQgb25lID0gMW5cbmxldCBtaW51c19vbmUgPSAtMW5cbmxldCBzdWNjIG4gPSBhZGQgbiAxblxubGV0IHByZWQgbiA9IHN1YiBuIDFuXG5sZXQgYWJzIG4gPSBpZiBuID49IDBuIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgc2l6ZSA9IFN5cy53b3JkX3NpemVcbmxldCBtaW5faW50ID0gc2hpZnRfbGVmdCAxbiAoc2l6ZSAtIDEpXG5sZXQgbWF4X2ludCA9IHN1YiBtaW5faW50IDFuXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFuKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZyA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmc6IHN0cmluZyAtPiBuYXRpdmVpbnQgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBuYXRpdmVpbnRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiBsaXN0cy4gKilcbnR5cGUgJ2EgdCA9ICdhIGxpc3QgPSBbXSB8ICg6Oikgb2YgJ2EgKiAnYSBsaXN0XG5cbigqIExpc3Qgb3BlcmF0aW9ucyAqKVxuXG5sZXQgcmVjIGxlbmd0aF9hdXggbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBsZW5cbiAgfCBfOjpsIC0+IGxlbmd0aF9hdXggKGxlbiArIDEpIGxcblxubGV0IGxlbmd0aCBsID0gbGVuZ3RoX2F1eCAwIGxcblxubGV0IGNvbnMgYSBsID0gYTo6bFxuXG5sZXQgaGQgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwiaGRcIlxuICB8IGE6Ol8gLT4gYVxuXG5sZXQgdGwgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwidGxcIlxuICB8IF86OmwgLT4gbFxuXG5sZXQgbnRoIGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBmYWlsd2l0aCBcIm50aFwiXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgbnRoX29wdCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIFNvbWUgYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgYXBwZW5kID0gKEApXG5cbmxldCByZWMgcmV2X2FwcGVuZCBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGEgOjogbCAtPiByZXZfYXBwZW5kIGwgKGEgOjogbDIpXG5cbmxldCByZXYgbCA9IHJldl9hcHBlbmQgbCBbXVxuXG5sZXQgcmVjIGluaXRfdGFpbHJlY19hdXggYWNjIGkgbiBmID1cbiAgaWYgaSA+PSBuIHRoZW4gYWNjXG4gIGVsc2UgaW5pdF90YWlscmVjX2F1eCAoZiBpIDo6IGFjYykgKGkrMSkgbiBmXG5cbmxldCByZWMgaW5pdF9hdXggaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBbXVxuICBlbHNlXG4gICAgbGV0IHIgPSBmIGkgaW5cbiAgICByIDo6IGluaXRfYXV4IChpKzEpIG4gZlxuXG5sZXQgcmV2X2luaXRfdGhyZXNob2xkID1cbiAgbWF0Y2ggU3lzLmJhY2tlbmRfdHlwZSB3aXRoXG4gIHwgU3lzLk5hdGl2ZSB8IFN5cy5CeXRlY29kZSAtPiAxMF8wMDBcbiAgKCogV2UgZG9uJ3Qga25vdyB0aGUgc2l6ZSBvZiB0aGUgc3RhY2ssIGJldHRlciBiZSBzYWZlIGFuZCBhc3N1bWUgaXQnc1xuICAgICBzbWFsbC4gKilcbiAgfCBTeXMuT3RoZXIgXyAtPiA1MFxuXG5sZXQgaW5pdCBsZW4gZiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QuaW5pdFwiIGVsc2VcbiAgaWYgbGVuID4gcmV2X2luaXRfdGhyZXNob2xkIHRoZW4gcmV2IChpbml0X3RhaWxyZWNfYXV4IFtdIDAgbGVuIGYpXG4gIGVsc2UgaW5pdF9hdXggMCBsZW4gZlxuXG5sZXQgcmVjIGZsYXR0ZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgbDo6ciAtPiBsIEAgZmxhdHRlbiByXG5cbmxldCBjb25jYXQgPSBmbGF0dGVuXG5cbmxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgYSBpbiByIDo6IG1hcCBmIGxcblxubGV0IHJlYyBtYXBpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBpIGEgaW4gciA6OiBtYXBpIChpICsgMSkgZiBsXG5cbmxldCBtYXBpIGYgbCA9IG1hcGkgMCBmIGxcblxubGV0IHJldl9tYXAgZiBsID1cbiAgbGV0IHJlYyBybWFwX2YgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCBhOjpsIC0+IHJtYXBfZiAoZiBhIDo6IGFjY3UpIGxcbiAgaW5cbiAgcm1hcF9mIFtdIGxcblxuXG5sZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgYTsgaXRlciBmIGxcblxubGV0IHJlYyBpdGVyaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGkgYTsgaXRlcmkgKGkgKyAxKSBmIGxcblxubGV0IGl0ZXJpIGYgbCA9IGl0ZXJpIDAgZiBsXG5cbmxldCByZWMgZm9sZF9sZWZ0IGYgYWNjdSBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZm9sZF9sZWZ0IGYgKGYgYWNjdSBhKSBsXG5cbmxldCByZWMgZm9sZF9yaWdodCBmIGwgYWNjdSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGYgYSAoZm9sZF9yaWdodCBmIGwgYWNjdSlcblxubGV0IHJlYyBtYXAyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGxldCByID0gZiBhMSBhMiBpbiByIDo6IG1hcDIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubWFwMlwiXG5cbmxldCByZXZfbWFwMiBmIGwxIGwyID1cbiAgbGV0IHJlYyBybWFwMl9mIGFjY3UgbDEgbDIgPVxuICAgIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICB8IChbXSwgW10pIC0+IGFjY3VcbiAgICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcm1hcDJfZiAoZiBhMSBhMiA6OiBhY2N1KSBsMSBsMlxuICAgIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZXZfbWFwMlwiXG4gIGluXG4gIHJtYXAyX2YgW10gbDEgbDJcblxuXG5sZXQgcmVjIGl0ZXIyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gKClcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTI7IGl0ZXIyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lml0ZXIyXCJcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmb2xkX2xlZnQyIGYgKGYgYWNjdSBhMSBhMikgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfbGVmdDJcIlxuXG5sZXQgcmVjIGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyIChmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UpXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX3JpZ2h0MlwiXG5cbmxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiB0cnVlXG4gIHwgYTo6bCAtPiBwIGEgJiYgZm9yX2FsbCBwIGxcblxubGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IHAgYSB8fCBleGlzdHMgcCBsXG5cbmxldCByZWMgZm9yX2FsbDIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiB0cnVlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyICYmIGZvcl9hbGwyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvcl9hbGwyXCJcblxubGV0IHJlYyBleGlzdHMyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gZmFsc2VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgfHwgZXhpc3RzMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5leGlzdHMyXCJcblxubGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW0geCBsXG5cbmxldCByZWMgbWVtcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gYSA9PSB4IHx8IG1lbXEgeCBsXG5cbmxldCByZWMgYXNzb2MgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gYiBlbHNlIGFzc29jIHggbFxuXG5sZXQgcmVjIGFzc29jX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gU29tZSBiIGVsc2UgYXNzb2Nfb3B0IHggbFxuXG5sZXQgcmVjIGFzc3EgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gYiBlbHNlIGFzc3EgeCBsXG5cbmxldCByZWMgYXNzcV9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIFNvbWUgYiBlbHNlIGFzc3Ffb3B0IHggbFxuXG5sZXQgcmVjIG1lbV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW1fYXNzb2MgeCBsXG5cbmxldCByZWMgbWVtX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBhID09IHggfHwgbWVtX2Fzc3EgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPlxuICAgICAgaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc29jIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPiBpZiBhID09IHggdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzcSB4IGxcblxubGV0IHJlYyBmaW5kIHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiB4IGVsc2UgZmluZCBwIGxcblxubGV0IHJlYyBmaW5kX29wdCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmRfb3B0IHAgbFxuXG5sZXQgZmluZF9hbGwgcCA9XG4gIGxldCByZWMgZmluZCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjdVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBmaW5kICh4IDo6IGFjY3UpIGwgZWxzZSBmaW5kIGFjY3UgbCBpblxuICBmaW5kIFtdXG5cbmxldCBmaWx0ZXIgPSBmaW5kX2FsbFxuXG5sZXQgZmlsdGVyX21hcCBmID1cbiAgbGV0IHJlYyBhdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjdVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBhdXggYWNjdSBsXG4gICAgICAgIHwgU29tZSB2IC0+IGF1eCAodiA6OiBhY2N1KSBsXG4gIGluXG4gIGF1eCBbXVxuXG5sZXQgcGFydGl0aW9uIHAgbCA9XG4gIGxldCByZWMgcGFydCB5ZXMgbm8gPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgeWVzLCByZXYgbm8pXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHBhcnQgKHggOjogeWVzKSBubyBsIGVsc2UgcGFydCB5ZXMgKHggOjogbm8pIGwgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCByZWMgc3BsaXQgPSBmdW5jdGlvblxuICAgIFtdIC0+IChbXSwgW10pXG4gIHwgKHgseSk6OmwgLT5cbiAgICAgIGxldCAocngsIHJ5KSA9IHNwbGl0IGwgaW4gKHg6OnJ4LCB5OjpyeSlcblxubGV0IHJlYyBjb21iaW5lIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiAoYTEsIGEyKSA6OiBjb21iaW5lIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5jb21iaW5lXCJcblxuKCoqIHNvcnRpbmcgKilcblxubGV0IHJlYyBtZXJnZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gaDEgOjogbWVyZ2UgY21wIHQxIGwyXG4gICAgICBlbHNlIGgyIDo6IG1lcmdlIGNtcCBsMSB0MlxuXG5cbmxldCByZWMgY2hvcCBrIGwgPVxuICBpZiBrID0gMCB0aGVuIGwgZWxzZSBiZWdpblxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgXzo6dCAtPiBjaG9wIChrLTEpIHRcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGVuZFxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICBlbmRcbiAgICB8IG4sIGwgLT5cbiAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgbGV0IGwyID0gY2hvcCBuMSBsIGluXG4gICAgICAgbGV0IHMxID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgIGxldCBzMiA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgcmV2X21lcmdlX3JldiBzMSBzMiBbXVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IF8gLT5cbiAgICAgICBpZiBjbXAgeDEgeDIgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogXyAtPlxuICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBiZWdpblxuICAgICAgICAgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgZW5kXG4gICAgfCBuLCBsIC0+XG4gICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgIGxldCBsMiA9IGNob3AgbjEgbCBpblxuICAgICAgIGxldCBzMSA9IHNvcnQgbjEgbCBpblxuICAgICAgIGxldCBzMiA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2UgczEgczIgW11cbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2Ugc29ydCBsZW4gbFxuXG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiBOb3RlOiBvbiBhIGxpc3Qgb2YgbGVuZ3RoIGJldHdlZW4gYWJvdXQgMTAwMDAwIChkZXBlbmRpbmcgb24gdGhlIG1pbm9yXG4gICBoZWFwIHNpemUgYW5kIHRoZSB0eXBlIG9mIHRoZSBsaXN0KSBhbmQgU3lzLm1heF9hcnJheV9zaXplLCBpdCBpc1xuICAgYWN0dWFsbHkgZmFzdGVyIHRvIHVzZSB0aGUgZm9sbG93aW5nLCBidXQgaXQgbWlnaHQgYWxzbyB1c2UgbW9yZSBtZW1vcnlcbiAgIGJlY2F1c2UgdGhlIGFyZ3VtZW50IGxpc3QgY2Fubm90IGJlIGRlYWxsb2NhdGVkIGluY3JlbWVudGFsbHkuXG5cbiAgIEFsc28sIHRoZXJlIHNlZW1zIHRvIGJlIGEgYnVnIGluIHRoaXMgY29kZSBvciBpbiB0aGVcbiAgIGltcGxlbWVudGF0aW9uIG9mIG9ial90cnVuY2F0ZS5cblxuZXh0ZXJuYWwgb2JqX3RydW5jYXRlIDogJ2EgYXJyYXkgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcblxubGV0IGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYSA9XG4gIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGFjY3UgbiBwID1cbiAgICBpZiBwIDw9IDAgdGhlbiBhY2N1IGVsc2UgYmVnaW5cbiAgICAgIGlmIHAgPSBuIHRoZW4gYmVnaW5cbiAgICAgICAgb2JqX3RydW5jYXRlIGEgcDtcbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSAobi0xMDAwKSAocC0xKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSBuIChwLTEpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBbXSAobC0xMDAwKSBsXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgQXJyYXkuc3RhYmxlX3NvcnQgY21wIGE7XG4gIGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYVxuXG4qKVxuXG5cbigqKiBzb3J0aW5nICsgcmVtb3ZpbmcgZHVwbGljYXRlcyAqKVxuXG5sZXQgc29ydF91bmlxIGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlIHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZV9yZXYgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdXG4gICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IF8gLT5cbiAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgZW5kIGVsc2UgaWYgYyA8IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgIGVuZFxuICAgIHwgbiwgbCAtPlxuICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICBsZXQgbDIgPSBjaG9wIG4xIGwgaW5cbiAgICAgICBsZXQgczEgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgbGV0IHMyID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICByZXZfbWVyZ2VfcmV2IHMxIHMyIFtdXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogXyAtPlxuICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdXG4gICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IF8gLT5cbiAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgZW5kIGVsc2UgaWYgYyA+IDAgdGhlbiBiZWdpblxuICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgIGVsc2UgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICBlbHNlIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgIGVuZFxuICAgIHwgbiwgbCAtPlxuICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICBsZXQgbDIgPSBjaG9wIG4xIGwgaW5cbiAgICAgICBsZXQgczEgPSBzb3J0IG4xIGwgaW5cbiAgICAgICBsZXQgczIgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgcmV2X21lcmdlIHMxIHMyIFtdXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIHNvcnQgbGVuIGxcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aHMgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgXyA6OiBsMSwgXyA6OiBsMiAtPiBjb21wYXJlX2xlbmd0aHMgbDEgbDJcbjs7XG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhfd2l0aCBsIG4gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGlmIG4gPSAwIHRoZW4gMCBlbHNlXG4gICAgICBpZiBuID4gMCB0aGVuIC0xIGVsc2UgMVxuICB8IF8gOjogbCAtPlxuICAgIGlmIG4gPD0gMCB0aGVuIDEgZWxzZVxuICAgICAgY29tcGFyZV9sZW5ndGhfd2l0aCBsIChuLTEpXG47O1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGwgPVxuICBsZXQgcmVjIGF1eCBsICgpID0gbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBTZXEuTmlsXG4gICAgfCB4IDo6IHRhaWwgLT4gU2VxLkNvbnMgKHgsIGF1eCB0YWlsKVxuICBpblxuICBhdXggbFxuXG5sZXQgb2Zfc2VxIHNlcSA9XG4gIGxldCByZWMgZGlyZWN0IGRlcHRoIHNlcSA6IF8gbGlzdCA9XG4gICAgaWYgZGVwdGg9MFxuICAgIHRoZW5cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIHNlcVxuICAgICAgfD4gcmV2ICgqIHRhaWxyZWMgKilcbiAgICBlbHNlIG1hdGNoIHNlcSgpIHdpdGhcbiAgICAgIHwgU2VxLk5pbCAtPiBbXVxuICAgICAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT4geCA6OiBkaXJlY3QgKGRlcHRoLTEpIG5leHRcbiAgaW5cbiAgZGlyZWN0IDUwMCBzZXFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTaW1vbiBDcnVhbmVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtTZXFdOiBmdW5jdGlvbmFsIGl0ZXJhdG9ycyAqKVxuXG50eXBlICsnYSBub2RlID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZVxuXG5sZXQgZW1wdHkgKCkgPSBOaWxcblxubGV0IHJldHVybiB4ICgpID0gQ29ucyAoeCwgZW1wdHkpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zIChmIHgsIG1hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyX21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgICB8IFNvbWUgeSAtPiBDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXIgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBpZiBmIHhcbiAgICAgIHRoZW4gQ29ucyAoeCwgZmlsdGVyIGYgbmV4dClcbiAgICAgIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBmbGF0X21hcF9hcHAgZiAoZiB4KSBuZXh0ICgpXG5cbigqIHRoaXMgaXMgW2FwcGVuZCBzZXEgKGZsYXRfbWFwIGYgdGFpbCldICopXG5hbmQgZmxhdF9tYXBfYXBwIGYgc2VxIHRhaWwgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBmbGF0X21hcCBmIHRhaWwgKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIENvbnMgKHgsIGZsYXRfbWFwX2FwcCBmIG5leHQgdGFpbClcblxubGV0IGZvbGRfbGVmdCBmIGFjYyBzZXEgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyBzZXEgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgYXV4IGYgYWNjIHNlcVxuXG5sZXQgaXRlciBmIHNlcSA9XG4gIGxldCByZWMgYXV4IHNlcSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgYXV4IG5leHRcbiAgaW5cbiAgYXV4IHNlcVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAnYSBvcHRpb24gPSBOb25lIHwgU29tZSBvZiAnYVxuXG5sZXQgbm9uZSA9IE5vbmVcbmxldCBzb21lIHYgPSBTb21lIHZcbmxldCB2YWx1ZSBvIH5kZWZhdWx0ID0gbWF0Y2ggbyB3aXRoIFNvbWUgdiAtPiB2IHwgTm9uZSAtPiBkZWZhdWx0XG5sZXQgZ2V0ID0gZnVuY3Rpb24gU29tZSB2IC0+IHYgfCBOb25lIC0+IGludmFsaWRfYXJnIFwib3B0aW9uIGlzIE5vbmVcIlxubGV0IGJpbmQgbyBmID0gbWF0Y2ggbyB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgdiAtPiBmIHZcbmxldCBqb2luID0gZnVuY3Rpb24gU29tZSAoU29tZSBfIGFzIG8pIC0+IG8gfCBfIC0+IE5vbmVcbmxldCBtYXAgZiBvID0gbWF0Y2ggbyB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgdiAtPiBTb21lIChmIHYpXG5sZXQgZm9sZCB+bm9uZSB+c29tZSA9IGZ1bmN0aW9uIFNvbWUgdiAtPiBzb21lIHYgfCBOb25lIC0+IG5vbmVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBTb21lIHYgLT4gZiB2IHwgTm9uZSAtPiAoKVxubGV0IGlzX25vbmUgPSBmdW5jdGlvbiBOb25lIC0+IHRydWUgfCBTb21lIF8gLT4gZmFsc2VcbmxldCBpc19zb21lID0gZnVuY3Rpb24gTm9uZSAtPiBmYWxzZSB8IFNvbWUgXyAtPiB0cnVlXG5cbmxldCBlcXVhbCBlcSBvMCBvMSA9IG1hdGNoIG8wLCBvMSB3aXRoXG58IFNvbWUgdjAsIFNvbWUgdjEgLT4gZXEgdjAgdjFcbnwgTm9uZSwgTm9uZSAtPiB0cnVlXG58IF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgY21wIG8wIG8xID0gbWF0Y2ggbzAsIG8xIHdpdGhcbnwgU29tZSB2MCwgU29tZSB2MSAtPiBjbXAgdjAgdjFcbnwgTm9uZSwgTm9uZSAtPiAwXG58IE5vbmUsIFNvbWUgXyAtPiAtMVxufCBTb21lIF8sIE5vbmUgLT4gMVxuXG5sZXQgdG9fcmVzdWx0IH5ub25lID0gZnVuY3Rpb24gTm9uZSAtPiBFcnJvciBub25lIHwgU29tZSB2IC0+IE9rIHZcbmxldCB0b19saXN0ID0gZnVuY3Rpb24gTm9uZSAtPiBbXSB8IFNvbWUgdiAtPiBbdl1cbmxldCB0b19zZXEgPSBmdW5jdGlvbiBOb25lIC0+IFNlcS5lbXB0eSB8IFNvbWUgdiAtPiBTZXEucmV0dXJuIHZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSkgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnZVxuXG5sZXQgb2sgdiA9IE9rIHZcbmxldCBlcnJvciBlID0gRXJyb3IgZVxubGV0IHZhbHVlIHIgfmRlZmF1bHQgPSBtYXRjaCByIHdpdGggT2sgdiAtPiB2IHwgRXJyb3IgXyAtPiBkZWZhdWx0XG5sZXQgZ2V0X29rID0gZnVuY3Rpb24gT2sgdiAtPiB2IHwgRXJyb3IgXyAtPiBpbnZhbGlkX2FyZyBcInJlc3VsdCBpcyBFcnJvciBfXCJcbmxldCBnZXRfZXJyb3IgPSBmdW5jdGlvbiBFcnJvciBlIC0+IGUgfCBPayBfIC0+IGludmFsaWRfYXJnIFwicmVzdWx0IGlzIE9rIF9cIlxubGV0IGJpbmQgciBmID0gbWF0Y2ggciB3aXRoIE9rIHYgLT4gZiB2IHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBqb2luID0gZnVuY3Rpb24gT2sgciAtPiByIHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBtYXAgZiA9IGZ1bmN0aW9uIE9rIHYgLT4gT2sgKGYgdikgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IG1hcF9lcnJvciBmID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBFcnJvciAoZiBlKSB8IE9rIF8gYXMgdiAtPiB2XG5sZXQgZm9sZCB+b2sgfmVycm9yID0gZnVuY3Rpb24gT2sgdiAtPiBvayB2IHwgRXJyb3IgZSAtPiBlcnJvciBlXG5sZXQgaXRlciBmID0gZnVuY3Rpb24gT2sgdiAtPiBmIHYgfCBFcnJvciBfIC0+ICgpXG5sZXQgaXRlcl9lcnJvciBmID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBmIGUgfCBPayBfIC0+ICgpXG5sZXQgaXNfb2sgPSBmdW5jdGlvbiBPayBfIC0+IHRydWUgfCBFcnJvciBfIC0+IGZhbHNlXG5sZXQgaXNfZXJyb3IgPSBmdW5jdGlvbiBFcnJvciBfIC0+IHRydWUgfCBPayBfIC0+IGZhbHNlXG5cbmxldCBlcXVhbCB+b2sgfmVycm9yIHIwIHIxID0gbWF0Y2ggcjAsIHIxIHdpdGhcbnwgT2sgdjAsIE9rIHYxIC0+IG9rIHYwIHYxXG58IEVycm9yIGUwLCBFcnJvciBlMSAtPiBlcnJvciBlMCBlMVxufCBfLCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIH5vayB+ZXJyb3IgcjAgcjEgPSBtYXRjaCByMCwgcjEgd2l0aFxufCBPayB2MCwgT2sgdjEgLT4gb2sgdjAgdjFcbnwgRXJyb3IgZTAsIEVycm9yIGUxIC0+IGVycm9yIGUwIGUxXG58IE9rIF8sIEVycm9yIF8gLT4gLTFcbnwgRXJyb3IgXywgT2sgXyAtPiAxXG5cbmxldCB0b19vcHRpb24gPSBmdW5jdGlvbiBPayB2IC0+IFNvbWUgdiB8IEVycm9yIF8gLT4gTm9uZVxubGV0IHRvX2xpc3QgPSBmdW5jdGlvbiBPayB2IC0+IFt2XSB8IEVycm9yIF8gLT4gW11cbmxldCB0b19zZXEgPSBmdW5jdGlvbiBPayB2IC0+IFNlcS5yZXR1cm4gdiB8IEVycm9yIF8gLT4gU2VxLmVtcHR5XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGJvb2wgPSBmYWxzZSB8IHRydWVcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxubGV0IGVxdWFsIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBib29sIC0+IGJvb2wgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCB0b19pbnQgPSBmdW5jdGlvbiBmYWxzZSAtPiAwIHwgdHJ1ZSAtPiAxXG5sZXQgdG9fZmxvYXQgPSBmdW5jdGlvbiBmYWxzZSAtPiAwLiB8IHRydWUgLT4gMS5cblxuKCpcbmxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxufCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxufCBcInRydWVcIiAtPiBTb21lIHRydWVcbnwgXyAtPiBOb25lXG4qKVxuXG5sZXQgdG9fc3RyaW5nID0gZnVuY3Rpb24gZmFsc2UgLT4gXCJmYWxzZVwiIHwgdHJ1ZSAtPiBcInRydWVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBjb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgY2hyIG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJDaGFyLmNoclwiIGVsc2UgdW5zYWZlX2NociBuXG5cbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZTogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBieXRlc191bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgZXNjYXBlZCA9IGZ1bmN0aW9uXG4gIHwgJ1xcJycgLT4gXCJcXFxcJ1wiXG4gIHwgJ1xcXFwnIC0+IFwiXFxcXFxcXFxcIlxuICB8ICdcXG4nIC0+IFwiXFxcXG5cIlxuICB8ICdcXHQnIC0+IFwiXFxcXHRcIlxuICB8ICdcXHInIC0+IFwiXFxcXHJcIlxuICB8ICdcXGInIC0+IFwiXFxcXGJcIlxuICB8ICcgJyAuLiAnficgYXMgYyAtPlxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgMSBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgYztcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuICB8IGMgLT5cbiAgICAgIGxldCBuID0gY29kZSBjIGluXG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSA0IGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCAnXFxcXCc7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMSAodW5zYWZlX2NociAoNDggKyBuIC8gMTAwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMiAodW5zYWZlX2NociAoNDggKyAobiAvIDEwKSBtb2QgMTApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAzICh1bnNhZmVfY2hyICg0OCArIG4gbW9kIDEwKSk7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcblxubGV0IGxvd2VyY2FzZSBjID1cbiAgaWYgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKVxuICB8fCAoYyA+PSAnXFwxOTInICYmIGMgPD0gJ1xcMjE0JylcbiAgfHwgKGMgPj0gJ1xcMjE2JyAmJiBjIDw9ICdcXDIyMicpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgZWxzZSBjXG5cbmxldCB1cHBlcmNhc2UgYyA9XG4gIGlmIChjID49ICdhJyAmJiBjIDw9ICd6JylcbiAgfHwgKGMgPj0gJ1xcMjI0JyAmJiBjIDw9ICdcXDI0NicpXG4gIHx8IChjID49ICdcXDI0OCcgJiYgYyA8PSAnXFwyNTQnKVxuICB0aGVuIHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIGVsc2UgY1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpIGMgPVxuICBpZiAoYyA+PSAnQScgJiYgYyA8PSAnWicpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgZWxzZSBjXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgYyA9XG4gIGlmIChjID49ICdhJyAmJiBjIDw9ICd6JylcbiAgdGhlbiB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICBlbHNlIGNcblxudHlwZSB0ID0gY2hhclxuXG5sZXQgY29tcGFyZSBjMSBjMiA9IGNvZGUgYzEgLSBjb2RlIGMyXG5sZXQgZXF1YWwgKGMxOiB0KSAoYzI6IHQpID0gY29tcGFyZSBjMSBjMiA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gc3RyaW5nLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gYnl0ZXMgPSBcIiVieXRlc19vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2JsaXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubGV0IG1ha2UgbiBjID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICB1bnNhZmVfZmlsbCBzIDAgbiBjO1xuICBzXG5cbmxldCBpbml0IG4gZiA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCBzIGkgKGYgaSlcbiAgZG9uZTtcbiAgc1xuXG5sZXQgZW1wdHkgPSBjcmVhdGUgMFxuXG5sZXQgY29weSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICB1bnNhZmVfYmxpdCBzIDAgciAwIGxlbjtcbiAgclxuXG5sZXQgdG9fc3RyaW5nIGIgPSB1bnNhZmVfdG9fc3RyaW5nIChjb3B5IGIpXG5sZXQgb2Zfc3RyaW5nIHMgPSBjb3B5ICh1bnNhZmVfb2Zfc3RyaW5nIHMpXG5cbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuc3ViIC8gQnl0ZXMuc3ViXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGxlbiBpblxuICAgIHVuc2FmZV9ibGl0IHMgb2ZzIHIgMCBsZW47XG4gICAgclxuICBlbmRcblxubGV0IHN1Yl9zdHJpbmcgYiBvZnMgbGVuID0gdW5zYWZlX3RvX3N0cmluZyAoc3ViIGIgb2ZzIGxlbilcblxuKCogYWRkaXRpb24gd2l0aCBhbiBvdmVyZmxvdyBjaGVjayAqKVxubGV0ICgrKykgYSBiID1cbiAgbGV0IGMgPSBhICsgYiBpblxuICBtYXRjaCBhIDwgMCwgYiA8IDAsIGMgPCAwIHdpdGhcbiAgfCB0cnVlICwgdHJ1ZSAsIGZhbHNlXG4gIHwgZmFsc2UsIGZhbHNlLCB0cnVlICAtPiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmV4dGVuZFwiICgqIG92ZXJmbG93ICopXG4gIHwgXyAtPiBjXG5cbmxldCBleHRlbmQgcyBsZWZ0IHJpZ2h0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzICsrIGxlZnQgKysgcmlnaHQgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIGxldCAoc3Jjb2ZmLCBkc3RvZmYpID0gaWYgbGVmdCA8IDAgdGhlbiAtbGVmdCwgMCBlbHNlIDAsIGxlZnQgaW5cbiAgbGV0IGNweWxlbiA9IG1pbiAobGVuZ3RoIHMgLSBzcmNvZmYpIChsZW4gLSBkc3RvZmYpIGluXG4gIGlmIGNweWxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCBzIHNyY29mZiByIGRzdG9mZiBjcHlsZW47XG4gIHJcblxubGV0IGZpbGwgcyBvZnMgbGVuIGMgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5maWxsIC8gQnl0ZXMuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgcyBvZnMgbGVuIGNcblxubGV0IGJsaXQgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IHMxIG9mczEgczIgb2ZzMiBsZW5cblxubGV0IGJsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBzdHJpbmdfbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmJsaXQgLyBCeXRlcy5ibGl0X3N0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX2JsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIkJ5dGVzLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZW1wdHlcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgczEgczIgPVxuICBsZXQgbDEgPSBsZW5ndGggczEgaW5cbiAgbGV0IGwyID0gbGVuZ3RoIHMyIGluXG4gIGxldCByID0gY3JlYXRlIChsMSArIGwyKSBpblxuICB1bnNhZmVfYmxpdCBzMSAwIHIgMCBsMTtcbiAgdW5zYWZlX2JsaXQgczIgMCByIGwxIGwyO1xuICByXG5cblxuZXh0ZXJuYWwgY2hhcl9jb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGNoYXJfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFpKSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBsZXQgaiA9IHJlZiAobGVuIC0gMSkgaW5cbiAgd2hpbGUgIWogPj0gIWkgJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaikgZG9cbiAgICBkZWNyIGpcbiAgZG9uZTtcbiAgaWYgIWogPj0gIWkgdGhlblxuICAgIHN1YiBzICFpICghaiAtICFpICsgMSlcbiAgZWxzZVxuICAgIGVtcHR5XG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICBuIDo9ICFuICtcbiAgICAgIChtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiAyXG4gICAgICAgfCAnICcgLi4gJ34nIC0+IDFcbiAgICAgICB8IF8gLT4gNClcbiAgZG9uZTtcbiAgaWYgIW4gPSBsZW5ndGggcyB0aGVuIGNvcHkgcyBlbHNlIGJlZ2luXG4gICAgbGV0IHMnID0gY3JlYXRlICFuIGluXG4gICAgbiA6PSAwO1xuICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgIGJlZ2luIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgKCdcXFwiJyB8ICdcXFxcJykgYXMgYyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ24nXG4gICAgICB8ICdcXHQnIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAndCdcbiAgICAgIHwgJ1xccicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdyJ1xuICAgICAgfCAnXFxiJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ2InXG4gICAgICB8ICgnICcgLi4gJ34nKSBhcyBjIC0+IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCBjIC0+XG4gICAgICAgICAgbGV0IGEgPSBjaGFyX2NvZGUgYyBpblxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIC8gMTAwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIChhIC8gMTApIG1vZCAxMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIG1vZCAxMCkpO1xuICAgICAgZW5kO1xuICAgICAgaW5jciBuXG4gICAgZG9uZTtcbiAgICBzJ1xuICBlbmRcblxubGV0IG1hcCBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXBpIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxubGV0IGFwcGx5MSBmIHMgPVxuICBpZiBsZW5ndGggcyA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNvcHkgcyBpblxuICAgIHVuc2FmZV9zZXQgciAwIChmKHVuc2FmZV9nZXQgcyAwKSk7XG4gICAgclxuICBlbmRcblxubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG50eXBlIHQgPSBieXRlc1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sID0gXCJjYW1sX2J5dGVzX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPSBtYXAgQ2hhci51cHBlcmNhc2Ugc1xubGV0IGxvd2VyY2FzZSBzID0gbWFwIENoYXIubG93ZXJjYXNlIHNcblxubGV0IGNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgdW5jYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2Ugc1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgbGV0IGJ1ZiA9IHJlZiAobWFrZSAyNTYgJ1xcMDAwJykgaW5cbiAgbGV0IHJlc2l6ZSAoKSA9XG4gICAgKCogcmVzaXplICopXG4gICAgbGV0IG5ld19sZW4gPSBtaW4gKDIgKiBsZW5ndGggIWJ1ZikgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGluXG4gICAgaWYgbGVuZ3RoICFidWYgPSBuZXdfbGVuIHRoZW4gZmFpbHdpdGggXCJCeXRlcy5vZl9zZXE6IGNhbm5vdCBncm93IGJ5dGVzXCI7XG4gICAgbGV0IG5ld19idWYgPSBtYWtlIG5ld19sZW4gJ1xcMDAwJyBpblxuICAgIGJsaXQgIWJ1ZiAwIG5ld19idWYgMCAhbjtcbiAgICBidWYgOj0gbmV3X2J1ZlxuICBpblxuICBTZXEuaXRlclxuICAgIChmdW4gYyAtPlxuICAgICAgIGlmICFuID0gbGVuZ3RoICFidWYgdGhlbiByZXNpemUoKTtcbiAgICAgICBzZXQgIWJ1ZiAhbiBjO1xuICAgICAgIGluY3IgbilcbiAgICBpO1xuICBzdWIgIWJ1ZiAwICFuXG5cbigqKiB7NiBCaW5hcnkgZW5jb2RpbmcvZGVjb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIGdldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBnZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZcIlxuZXh0ZXJuYWwgZ2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyID0gXCIlY2FtbF9ieXRlc19nZXQzMlwiXG5leHRlcm5hbCBnZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX2J5dGVzX2dldDY0XCJcbmV4dGVybmFsIHNldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgc2V0X2ludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNlwiXG5leHRlcm5hbCBzZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJcIlxuZXh0ZXJuYWwgc2V0X2ludDY0X25lIDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0XCJcbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cbmxldCBnZXRfaW50OCBiIGkgPVxuICAoKGdldF91aW50OCBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gOCkpIGFzciAoU3lzLmludF9zaXplIC0gOClcblxubGV0IGdldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF9pbnQxNl9uZSBiIGkgPVxuICAoKGdldF91aW50MTZfbmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9sZSBiIGkgPVxuICAoKGdldF91aW50MTZfbGUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9iZSBiIGkgPVxuICAoKGdldF91aW50MTZfYmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQzMl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50MzJfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IHNldF9pbnQxNl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2Ugc2V0X2ludDE2X25lIGIgaSB4XG5cbmxldCBzZXRfaW50MTZfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDMyX25lIGIgaSAoc3dhcDMyIHgpXG4gIGVsc2Ugc2V0X2ludDMyX25lIGIgaSB4XG5cbmxldCBzZXRfaW50MzJfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDY0X25lIGIgaSAoc3dhcDY0IHgpXG4gIGVsc2Ugc2V0X2ludDY0X25lIGIgaSB4XG5cbmxldCBzZXRfaW50NjRfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF91aW50OCA9IHNldF9pbnQ4XG5sZXQgc2V0X3VpbnQxNl9uZSA9IHNldF9pbnQxNl9uZVxubGV0IHNldF91aW50MTZfYmUgPSBzZXRfaW50MTZfYmVcbmxldCBzZXRfdWludDE2X2xlID0gc2V0X2ludDE2X2xlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBHYWxsaXVtLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFN0cmluZyBvcGVyYXRpb25zLCBiYXNlZCBvbiBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIGJ5dGVzLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5tb2R1bGUgQiA9IEJ5dGVzXG5cbmxldCBidHMgPSBCLnVuc2FmZV90b19zdHJpbmdcbmxldCBib3MgPSBCLnVuc2FmZV9vZl9zdHJpbmdcblxubGV0IG1ha2UgbiBjID1cbiAgQi5tYWtlIG4gYyB8PiBidHNcbmxldCBpbml0IG4gZiA9XG4gIEIuaW5pdCBuIGYgfD4gYnRzXG5sZXQgY29weSBzID1cbiAgQi5jb3B5IChib3MgcykgfD4gYnRzXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIEIuc3ViIChib3Mgcykgb2ZzIGxlbiB8PiBidHNcbmxldCBmaWxsID1cbiAgQi5maWxsXG5sZXQgYmxpdCA9XG4gIEIuYmxpdF9zdHJpbmdcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBcIlwiXG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpbiBidHMgQEBcbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChCLmNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlciBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyaSBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxubGV0IG1hcCBmIHMgPVxuICBCLm1hcCBmIChib3MgcykgfD4gYnRzXG5sZXQgbWFwaSBmIHMgPVxuICBCLm1hcGkgZiAoYm9zIHMpIHw+IGJ0c1xuXG4oKiBCZXdhcmU6IHdlIGNhbm5vdCB1c2UgQi50cmltIG9yIEIuZXNjYXBlIGJlY2F1c2UgdGhleSBhbHdheXMgbWFrZSBhXG4gICBjb3B5LCBidXQgU3RyaW5nLm1saSBzcGVsbHMgb3V0IHNvbWUgY2FzZXMgd2hlcmUgd2UgYXJlIG5vdCBhbGxvd2VkXG4gICB0byBtYWtlIGEgY29weS4gKilcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBpZiBzID0gXCJcIiB0aGVuIHNcbiAgZWxzZSBpZiBpc19zcGFjZSAodW5zYWZlX2dldCBzIDApIHx8IGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgKGxlbmd0aCBzIC0gMSkpXG4gICAgdGhlbiBidHMgKEIudHJpbSAoYm9zIHMpKVxuICBlbHNlIHNcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCByZWMgZXNjYXBlX2lmX25lZWRlZCBzIG4gaSA9XG4gICAgaWYgaSA+PSBuIHRoZW4gcyBlbHNlXG4gICAgICBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXDAwMCcuLidcXDAzMScgfCAnXFwxMjcnLi4gJ1xcMjU1JyAtPlxuICAgICAgICAgIGJ0cyAoQi5lc2NhcGVkIChib3MgcykpXG4gICAgICB8IF8gLT4gZXNjYXBlX2lmX25lZWRlZCBzIG4gKGkrMSlcbiAgaW5cbiAgZXNjYXBlX2lmX25lZWRlZCBzIChsZW5ndGggcykgMFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gICAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9XG4gIEIudXBwZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPVxuICBCLmxvd2VyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi51bmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N0cmluZ19lcXVhbFwiIFtAQG5vYWxsb2NdXG5cbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9XG4gIEIudXBwZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlIHMgPVxuICBCLmxvd2VyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemUgcyA9XG4gIEIuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZSBzID1cbiAgQi51bmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gYm9zIHMgfD4gQi50b19zZXFcblxubGV0IHRvX3NlcWkgcyA9IGJvcyBzIHw+IEIudG9fc2VxaVxuXG5sZXQgb2Zfc2VxIGcgPSBCLm9mX3NlcSBnIHw+IGJ0c1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSB1bml0ID0gKClcblxubGV0IGVxdWFsICgpICgpID0gdHJ1ZVxubGV0IGNvbXBhcmUgKCkgKCkgPSAwXG5sZXQgdG9fc3RyaW5nICgpID0gXCIoKVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgZXh0ZXJuX2ZsYWdzID1cbiAgICBOb19zaGFyaW5nXG4gIHwgQ2xvc3VyZXNcbiAgfCBDb21wYXRfMzJcbigqIG5vdGU6IHRoaXMgdHlwZSBkZWZpbml0aW9uIGlzIHVzZWQgaW4gJ3J1bnRpbWUvZGVidWdnZXIuYycgKilcblxuZXh0ZXJuYWwgdG9fY2hhbm5lbDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gdW5pdFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5leHRlcm5hbCB0b19ieXRlczogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gYnl0ZXNcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXNcIlxuZXh0ZXJuYWwgdG9fc3RyaW5nOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBzdHJpbmdcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHRvX2J1ZmZlcl91bnNhZmU6XG4gICAgICBieXRlcyAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGludFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcIlxuXG5sZXQgdG9fYnVmZmVyIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLnRvX2J1ZmZlcjogc3Vic3RyaW5nIG91dCBvZiBib3VuZHNcIlxuICBlbHNlIHRvX2J1ZmZlcl91bnNhZmUgYnVmZiBvZnMgbGVuIHYgZmxhZ3NcblxuKCogVGhlIGZ1bmN0aW9ucyBiZWxvdyB1c2UgYnl0ZSBzZXF1ZW5jZXMgYXMgaW5wdXQsIG5ldmVyIHVzaW5nIGFueVxuICAgbXV0YXRpb24uIEl0IG1ha2VzIHNlbnNlIHRvIHVzZSBub24tbXV0YXRlZCBbYnl0ZXNdIHJhdGhlciB0aGFuXG4gICBbc3RyaW5nXSwgYmVjYXVzZSB3ZSByZWFsbHkgd29yayB3aXRoIHNlcXVlbmNlcyBvZiBieXRlcywgbm90XG4gICBhIHRleHQgcmVwcmVzZW50YXRpb24uXG4qKVxuXG5leHRlcm5hbCBmcm9tX2NoYW5uZWw6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZnJvbV9ieXRlc191bnNhZmU6IGJ5dGVzIC0+IGludCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzXCJcbmV4dGVybmFsIGRhdGFfc2l6ZV91bnNhZmU6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcImNhbWxfbWFyc2hhbF9kYXRhX3NpemVcIlxuXG5sZXQgaGVhZGVyX3NpemUgPSAyMFxubGV0IGRhdGFfc2l6ZSBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5kYXRhX3NpemVcIlxuICBlbHNlIGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnNcbmxldCB0b3RhbF9zaXplIGJ1ZmYgb2ZzID0gaGVhZGVyX3NpemUgKyBkYXRhX3NpemUgYnVmZiBvZnNcblxubGV0IGZyb21fYnl0ZXMgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbGVuID0gZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mcyBpblxuICAgIGlmIG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gKGhlYWRlcl9zaXplICsgbGVuKVxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICAgIGVsc2UgZnJvbV9ieXRlc191bnNhZmUgYnVmZiBvZnNcbiAgZW5kXG5cbmxldCBmcm9tX3N0cmluZyBidWZmIG9mcyA9XG4gICgqIEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgaXMgc2FmZSBoZXJlLCBhcyB0aGUgcHJvZHVjZWQgYnl0ZVxuICAgICBzZXF1ZW5jZSBpcyBuZXZlciBtdXRhdGVkICopXG4gIGZyb21fYnl0ZXMgKEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgYnVmZikgb2ZzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE9wZXJhdGlvbnMgb24gaW50ZXJuYWwgcmVwcmVzZW50YXRpb25zIG9mIHZhbHVlcyAqKVxuXG50eXBlIHRcblxuZXh0ZXJuYWwgcmVwciA6ICdhIC0+IHQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBvYmogOiB0IC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgbWFnaWMgOiAnYSAtPiAnYiA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGlzX2ludCA6IHQgLT4gYm9vbCA9IFwiJW9ial9pc19pbnRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gaXNfYmxvY2sgYSA9IG5vdCAoaXNfaW50IGEpXG5leHRlcm5hbCB0YWcgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfdGFnXCJcbmV4dGVybmFsIHNldF90YWcgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial9zZXRfdGFnXCJcbmV4dGVybmFsIHNpemUgOiB0IC0+IGludCA9IFwiJW9ial9zaXplXCJcbmV4dGVybmFsIHJlYWNoYWJsZV93b3JkcyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial9yZWFjaGFibGVfd29yZHNcIlxuZXh0ZXJuYWwgZmllbGQgOiB0IC0+IGludCAtPiB0ID0gXCIlb2JqX2ZpZWxkXCJcbmV4dGVybmFsIHNldF9maWVsZCA6IHQgLT4gaW50IC0+IHQgLT4gdW5pdCA9IFwiJW9ial9zZXRfZmllbGRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdGFycmF5X2dldFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X3NldCA6XG4gICAgZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiY2FtbF9mbG9hdGFycmF5X3NldFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBkb3VibGVfZmllbGQgeCBpID0gZmxvYXRhcnJheV9nZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaVxubGV0IFtAaW5saW5lIGFsd2F5c10gc2V0X2RvdWJsZV9maWVsZCB4IGkgdiA9XG4gIGZsb2F0YXJyYXlfc2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGkgdlxuZXh0ZXJuYWwgbmV3X2Jsb2NrIDogaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX29ial9ibG9ja1wiXG5leHRlcm5hbCBkdXAgOiB0IC0+IHQgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcbmV4dGVybmFsIGFkZF9vZmZzZXQgOiB0IC0+IEludDMyLnQgLT4gdCA9IFwiY2FtbF9vYmpfYWRkX29mZnNldFwiXG5leHRlcm5hbCB3aXRoX3RhZyA6IGludCAtPiB0IC0+IHQgPSBcImNhbWxfb2JqX3dpdGhfdGFnXCJcblxubGV0IG1hcnNoYWwgKG9iaiA6IHQpID1cbiAgTWFyc2hhbC50b19ieXRlcyBvYmogW11cbmxldCB1bm1hcnNoYWwgc3RyIHBvcyA9XG4gIChNYXJzaGFsLmZyb21fYnl0ZXMgc3RyIHBvcywgcG9zICsgTWFyc2hhbC50b3RhbF9zaXplIHN0ciBwb3MpXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0NVxuXG5sZXQgbGF6eV90YWcgPSAyNDZcbmxldCBjbG9zdXJlX3RhZyA9IDI0N1xubGV0IG9iamVjdF90YWcgPSAyNDhcbmxldCBpbmZpeF90YWcgPSAyNDlcbmxldCBmb3J3YXJkX3RhZyA9IDI1MFxuXG5sZXQgbm9fc2Nhbl90YWcgPSAyNTFcblxubGV0IGFic3RyYWN0X3RhZyA9IDI1MVxubGV0IHN0cmluZ190YWcgPSAyNTJcbmxldCBkb3VibGVfdGFnID0gMjUzXG5sZXQgZG91YmxlX2FycmF5X3RhZyA9IDI1NFxubGV0IGN1c3RvbV90YWcgPSAyNTVcbmxldCBmaW5hbF90YWcgPSBjdXN0b21fdGFnXG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbm1vZHVsZSBFeHRlbnNpb25fY29uc3RydWN0b3IgPVxuc3RydWN0XG4gIHR5cGUgdCA9IGV4dGVuc2lvbl9jb25zdHJ1Y3RvclxuICBsZXQgb2ZfdmFsIHggPVxuICAgIGxldCB4ID0gcmVwciB4IGluXG4gICAgbGV0IHNsb3QgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHgpICYmICh0YWcgeCkgPD4gb2JqZWN0X3RhZyAmJiAoc2l6ZSB4KSA+PSAxIHRoZW4gZmllbGQgeCAwXG4gICAgICBlbHNlIHhcbiAgICBpblxuICAgIGxldCBuYW1lID1cbiAgICAgIGlmIChpc19ibG9jayBzbG90KSAmJiAodGFnIHNsb3QpID0gb2JqZWN0X3RhZyB0aGVuIGZpZWxkIHNsb3QgMFxuICAgICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuICAgIGluXG4gICAgICBpZiAodGFnIG5hbWUpID0gc3RyaW5nX3RhZyB0aGVuIChvYmogc2xvdCA6IHQpXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG5cbiAgbGV0IFtAaW5saW5lIGFsd2F5c10gbmFtZSAoc2xvdCA6IHQpID1cbiAgICAob2JqIChmaWVsZCAocmVwciBzbG90KSAwKSA6IHN0cmluZylcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBpZCAoc2xvdCA6IHQpID1cbiAgICAob2JqIChmaWVsZCAocmVwciBzbG90KSAxKSA6IGludClcbmVuZFxuXG5sZXQgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbFxubGV0IGV4dGVuc2lvbl9uYW1lID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm5hbWVcbmxldCBleHRlbnNpb25faWQgPSBFeHRlbnNpb25fY29uc3RydWN0b3IuaWRcblxubW9kdWxlIEVwaGVtZXJvbiA9IHN0cnVjdFxuICB0eXBlIG9ial90ID0gdFxuXG4gIHR5cGUgdCAoKiogZXBoZW1lcm9uICopXG5cbiAgICgqKiBUbyBjaGFuZ2UgaW4gc3luYyB3aXRoIHdlYWsuaCAqKVxuICBsZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG4gIGxldCBtYXhfZXBoZV9sZW5ndGggPSBTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZXBoZV9jcmVhdGVcIjs7XG4gIGxldCBjcmVhdGUgbCA9XG4gICAgaWYgbm90ICgwIDw9IGwgJiYgbCA8PSBtYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5jcmVhdGVcIjtcbiAgICBjcmVhdGUgbFxuXG4gIGxldCBsZW5ndGggeCA9IHNpemUocmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgbGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICAgIGlmIG5vdCAoMCA8PSBvICYmIG8gPCBsZW5ndGggZSkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgbXNnXG5cbiAgZXh0ZXJuYWwgZ2V0X2tleTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleVwiXG4gIGxldCBnZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5nZXRfa2V5XCI7XG4gICAgZ2V0X2tleSBlIG9cblxuICBleHRlcm5hbCBnZXRfa2V5X2NvcHk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlfY29weVwiXG4gIGxldCBnZXRfa2V5X2NvcHkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlfY29weVwiO1xuICAgIGdldF9rZXlfY29weSBlIG9cblxuICBleHRlcm5hbCBzZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG4gIGxldCBzZXRfa2V5IGUgbyB4ID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLnNldF9rZXlcIjtcbiAgICBzZXRfa2V5IGUgbyB4XG5cbiAgZXh0ZXJuYWwgdW5zZXRfa2V5OiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbiAgbGV0IHVuc2V0X2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24udW5zZXRfa2V5XCI7XG4gICAgdW5zZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGNoZWNrX2tleTogdCAtPiBpbnQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2tleVwiXG4gIGxldCBjaGVja19rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmNoZWNrX2tleVwiO1xuICAgIGNoZWNrX2tleSBlIG9cblxuICBleHRlcm5hbCBibGl0X2tleSA6IHQgLT4gaW50IC0+IHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgPSBcImNhbWxfZXBoZV9ibGl0X2tleVwiXG5cbiAgbGV0IGJsaXRfa2V5IGUxIG8xIGUyIG8yIGwgPVxuICAgIGlmIGwgPCAwIHx8IG8xIDwgMCB8fCBvMSA+IGxlbmd0aCBlMSAtIGxcbiAgICAgICB8fCBvMiA8IDAgfHwgbzIgPiBsZW5ndGggZTIgLSBsXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk9iai5FcGhlbWVyb24uYmxpdF9rZXlcIlxuICAgIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdF9rZXkgZTEgbzEgZTIgbzIgbFxuXG4gIGV4dGVybmFsIGdldF9kYXRhOiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhXCJcbiAgZXh0ZXJuYWwgZ2V0X2RhdGFfY29weTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XCJcbiAgZXh0ZXJuYWwgc2V0X2RhdGE6IHQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9kYXRhXCJcbiAgZXh0ZXJuYWwgdW5zZXRfZGF0YTogdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfZGF0YVwiXG4gIGV4dGVybmFsIGNoZWNrX2RhdGE6IHQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2RhdGFcIlxuICBleHRlcm5hbCBibGl0X2RhdGEgOiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX2JsaXRfZGF0YVwiXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgYXJyYXlzLiAqKVxudHlwZSAnYSB0ID0gJ2EgYXJyYXlcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIGNyZWF0ZV9mbG9hdDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG5sZXQgbWFrZV9mbG9hdCA9IGNyZWF0ZV9mbG9hdFxuXG5tb2R1bGUgRmxvYXRhcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gZmxvYXRhcnJheSA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IGZsb2F0YXJyYXkgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5lbmRcblxubGV0IGluaXQgbCBmID1cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2VcbiAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRcIlxuICAoKiBTZWUgIzY1NzUuIFdlIGNvdWxkIGFsc28gY2hlY2sgZm9yIG1heGltdW0gYXJyYXkgc2l6ZSwgYnV0IHRoaXMgZGVwZW5kc1xuICAgICBvbiB3aGV0aGVyIHdlIGNyZWF0ZSBhIGZsb2F0IGFycmF5IG9yIGEgcmVndWxhciBvbmUuLi4gKilcbiAgZWxzZVxuICAgbGV0IHJlcyA9IGNyZWF0ZSBsIChmIDApIGluXG4gICBmb3IgaSA9IDEgdG8gcHJlZCBsIGRvXG4gICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgIGRvbmU7XG4gICByZXNcblxubGV0IG1ha2VfbWF0cml4IHN4IHN5IGluaXQgPVxuICBsZXQgcmVzID0gY3JlYXRlIHN4IFt8fF0gaW5cbiAgZm9yIHggPSAwIHRvIHByZWQgc3ggZG9cbiAgICB1bnNhZmVfc2V0IHJlcyB4IChjcmVhdGUgc3kgaW5pdClcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBjcmVhdGVfbWF0cml4ID0gbWFrZV9tYXRyaXhcblxubGV0IGNvcHkgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW4gaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgdW5zYWZlX3N1YiBhIDAgbFxuXG5sZXQgYXBwZW5kIGExIGEyID1cbiAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gIGlmIGwxID0gMCB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsZW5ndGggYTIgPSAwIHRoZW4gdW5zYWZlX3N1YiBhMSAwIGwxXG4gIGVsc2UgYXBwZW5kX3ByaW0gYTEgYTJcblxubGV0IHN1YiBhIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LnN1YlwiXG4gIGVsc2UgdW5zYWZlX3N1YiBhIG9mcyBsZW5cblxubGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZpbGxcIlxuICBlbHNlIGZvciBpID0gb2ZzIHRvIG9mcyArIGxlbiAtIDEgZG8gdW5zYWZlX3NldCBhIGkgdiBkb25lXG5cbmxldCBibGl0IGExIG9mczEgYTIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggYTEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIGEyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuXG5cbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgaXRlcjIgZiBhIGIgPVxuICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbmxldCBtYXAgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcDIgZiBhIGIgPVxuICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2UgYmVnaW5cbiAgICBpZiBsYSA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIChmICh1bnNhZmVfZ2V0IGEgMCkgKHVuc2FmZV9nZXQgYiAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcbiAgZW5kXG5cbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IG1hcGkgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYgMCAodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHRvX2xpc3QgYSA9XG4gIGxldCByZWMgdG9saXN0IGkgcmVzID1cbiAgICBpZiBpIDwgMCB0aGVuIHJlcyBlbHNlIHRvbGlzdCAoaSAtIDEpICh1bnNhZmVfZ2V0IGEgaSA6OiByZXMpIGluXG4gIHRvbGlzdCAobGVuZ3RoIGEgLSAxKSBbXVxuXG4oKiBDYW5ub3QgdXNlIExpc3QubGVuZ3RoIGhlcmUgYmVjYXVzZSB0aGUgTGlzdCBtb2R1bGUgZGVwZW5kcyBvbiBBcnJheS4gKilcbmxldCByZWMgbGlzdF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjdVxuICB8IF86OnQgLT4gbGlzdF9sZW5ndGggKHN1Y2MgYWNjdSkgdFxuXG5sZXQgb2ZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgYSA9IGNyZWF0ZSAobGlzdF9sZW5ndGggMCBsKSBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGkrMSkgdGwgaW5cbiAgICAgIGZpbGwgMSB0bFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW1xIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHggPT0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG5sZXQgc29ydCBjbXAgYSA9XG4gIGxldCBtYXhzb24gbCBpID1cbiAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICF4XG4gICAgZW5kIGVsc2VcbiAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgdGhlbiBpMzErMVxuICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICBpblxuICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgIGJ1YmJsZWRvd24gbCBqXG4gIGluXG4gIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgZG9uZTtcbiAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuXG5sZXQgY3V0b2ZmID0gNVxubGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICBlbmRcbiAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgaW5cbiAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgZGVjciBqO1xuICAgICAgZG9uZTtcbiAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICBkb25lO1xuICBpblxuICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgbGV0IHQgPSBtYWtlIGwyIChnZXQgYSAwKSBpblxuICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICBlbmRcblxuXG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgb2ZfcmV2X2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGxlbiA9IGxpc3RfbGVuZ3RoIDAgbCBpblxuICAgICAgbGV0IGEgPSBjcmVhdGUgbGVuIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgICAgaW5cbiAgICAgIGZpbGwgKGxlbi0yKSB0bFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgb2ZfcmV2X2xpc3QgbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBpbnRcblxubGV0IHplcm8gPSAwXG5sZXQgb25lID0gMVxubGV0IG1pbnVzX29uZSA9IC0xXG5leHRlcm5hbCBuZWcgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsIGFkZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsIHN1YiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsIG11bCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsIGRpdiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsIHJlbSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcbmV4dGVybmFsIGxvZ2FuZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsIGxvZ29yIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5sZXQgbG9nbm90IHggPSBsb2d4b3IgeCAoLTEpXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5cbigqXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmcgcyA9IHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcbiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmxldCB0b19zdHJpbmcgeCA9IGZvcm1hdF9pbnQgXCIlZFwiIHhcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtJbnQzMl06IDMyLWJpdCBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX25lZ1wiXG5leHRlcm5hbCBhZGQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FkZFwiXG5leHRlcm5hbCBzdWIgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3N1YlwiXG5leHRlcm5hbCBtdWwgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX211bFwiXG5leHRlcm5hbCBkaXYgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2RpdlwiXG5leHRlcm5hbCByZW0gOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX21vZFwiXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FuZFwiXG5leHRlcm5hbCBsb2dvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfb3JcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNyXCJcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBpbnQzMiA9IFwiJWludDMyX29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQgOiBpbnQzMiAtPiBpbnQgPSBcIiVpbnQzMl90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfdG9fZmxvYXRcIiBcImNhbWxfaW50MzJfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHplcm8gPSAwbFxubGV0IG9uZSA9IDFsXG5sZXQgbWludXNfb25lID0gLTFsXG5sZXQgc3VjYyBuID0gYWRkIG4gMWxcbmxldCBwcmVkIG4gPSBzdWIgbiAxbFxubGV0IGFicyBuID0gaWYgbiA+PSAwbCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwbFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGbFxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xbClcblxubGV0IHVuc2lnbmVkX3RvX2ludCA9XG4gIG1hdGNoIFN5cy53b3JkX3NpemUgd2l0aFxuICB8IDMyIC0+XG4gICAgICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICAgICAgZnVuIG4gLT5cbiAgICAgICAgaWYgY29tcGFyZSB6ZXJvIG4gPD0gMCAmJiBjb21wYXJlIG4gbWF4X2ludCA8PSAwIHRoZW5cbiAgICAgICAgICBTb21lICh0b19pbnQgbilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIE5vbmVcbiAgfCA2NCAtPlxuICAgICAgKCogU28gdGhhdCBpdCBjb21waWxlcyBpbiAzMi1iaXQgKilcbiAgICAgIGxldCBtb3ZlID0gaW50X29mX3N0cmluZyBcIjB4MV8wMDAwXzAwMDBcIiBpblxuICAgICAgZnVuIG4gLT4gbGV0IGkgPSB0b19pbnQgbiBpbiBTb21lIChpZiBpIDwgMCB0aGVuIGkgKyBtb3ZlIGVsc2UgaSlcbiAgfCBfIC0+XG4gICAgICBhc3NlcnQgZmFsc2VcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZyA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMiA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gaW50MzJcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBwYXJzaW5nIGVuZ2luZSAqKVxuXG5vcGVuIExleGluZ1xuXG4oKiBJbnRlcm5hbCBpbnRlcmZhY2UgdG8gdGhlIHBhcnNpbmcgZW5naW5lICopXG5cbnR5cGUgcGFyc2VyX2VudiA9XG4gIHsgbXV0YWJsZSBzX3N0YWNrIDogaW50IGFycmF5OyAgICAgICAgKCogU3RhdGVzICopXG4gICAgbXV0YWJsZSB2X3N0YWNrIDogT2JqLnQgYXJyYXk7ICAgICAgKCogU2VtYW50aWMgYXR0cmlidXRlcyAqKVxuICAgIG11dGFibGUgc3ltYl9zdGFydF9zdGFjayA6IHBvc2l0aW9uIGFycmF5OyAoKiBTdGFydCBwb3NpdGlvbnMgKilcbiAgICBtdXRhYmxlIHN5bWJfZW5kX3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICAgKCogRW5kIHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3RhY2tzaXplIDogaW50OyAgICAgICAgICAgICgqIFNpemUgb2YgdGhlIHN0YWNrcyAqKVxuICAgIG11dGFibGUgc3RhY2tiYXNlIDogaW50OyAgICAgICAgICAgICgqIEJhc2Ugc3AgZm9yIGN1cnJlbnQgcGFyc2UgKilcbiAgICBtdXRhYmxlIGN1cnJfY2hhciA6IGludDsgICAgICAgICAgICAoKiBMYXN0IHRva2VuIHJlYWQgKilcbiAgICBtdXRhYmxlIGx2YWwgOiBPYmoudDsgICAgICAgICAgICAgICAoKiBJdHMgc2VtYW50aWMgYXR0cmlidXRlICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0IDogcG9zaXRpb247ICAgICAgKCogU3RhcnQgcG9zLiBvZiB0aGUgY3VycmVudCBzeW1ib2wqKVxuICAgIG11dGFibGUgc3ltYl9lbmQgOiBwb3NpdGlvbjsgICAgICAgICgqIEVuZCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCAqKVxuICAgIG11dGFibGUgYXNwIDogaW50OyAgICAgICAgICAgICAgICAgICgqIFRoZSBzdGFjayBwb2ludGVyIGZvciBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBydWxlX2xlbiA6IGludDsgICAgICAgICAgICAgKCogTnVtYmVyIG9mIHJocyBpdGVtcyBpbiB0aGUgcnVsZSAqKVxuICAgIG11dGFibGUgcnVsZV9udW1iZXIgOiBpbnQ7ICAgICAgICAgICgqIFJ1bGUgbnVtYmVyIHRvIHJlZHVjZSBieSAqKVxuICAgIG11dGFibGUgc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgICgqIFNhdmVkIHNwIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIHN0YXRlIDogaW50OyAgICAgICAgICAgICAgICAoKiBTYXZlZCBzdGF0ZSBmb3IgcGFyc2VfZW5naW5lICopXG4gICAgbXV0YWJsZSBlcnJmbGFnIDogaW50IH0gICAgICAgICAgICAgKCogU2F2ZWQgZXJyb3IgZmxhZyBmb3IgcGFyc2VfZW5naW5lICopXG5cbnR5cGUgcGFyc2VfdGFibGVzID1cbiAgeyBhY3Rpb25zIDogKHBhcnNlcl9lbnYgLT4gT2JqLnQpIGFycmF5O1xuICAgIHRyYW5zbF9jb25zdCA6IGludCBhcnJheTtcbiAgICB0cmFuc2xfYmxvY2sgOiBpbnQgYXJyYXk7XG4gICAgbGhzIDogc3RyaW5nO1xuICAgIGxlbiA6IHN0cmluZztcbiAgICBkZWZyZWQgOiBzdHJpbmc7XG4gICAgZGdvdG8gOiBzdHJpbmc7XG4gICAgc2luZGV4IDogc3RyaW5nO1xuICAgIHJpbmRleCA6IHN0cmluZztcbiAgICBnaW5kZXggOiBzdHJpbmc7XG4gICAgdGFibGVzaXplIDogaW50O1xuICAgIHRhYmxlIDogc3RyaW5nO1xuICAgIGNoZWNrIDogc3RyaW5nO1xuICAgIGVycm9yX2Z1bmN0aW9uIDogc3RyaW5nIC0+IHVuaXQ7XG4gICAgbmFtZXNfY29uc3QgOiBzdHJpbmc7XG4gICAgbmFtZXNfYmxvY2sgOiBzdHJpbmcgfVxuXG5leGNlcHRpb24gWVlleGl0IG9mIE9iai50XG5leGNlcHRpb24gUGFyc2VfZXJyb3JcblxudHlwZSBwYXJzZXJfaW5wdXQgPVxuICAgIFN0YXJ0XG4gIHwgVG9rZW5fcmVhZFxuICB8IFN0YWNrc19ncm93bl8xXG4gIHwgU3RhY2tzX2dyb3duXzJcbiAgfCBTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWRcbiAgfCBFcnJvcl9kZXRlY3RlZFxuXG50eXBlIHBhcnNlcl9vdXRwdXQgPVxuICAgIFJlYWRfdG9rZW5cbiAgfCBSYWlzZV9wYXJzZV9lcnJvclxuICB8IEdyb3dfc3RhY2tzXzFcbiAgfCBHcm93X3N0YWNrc18yXG4gIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb25cbiAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uXG5cbigqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5sZXQgXyA9IFtSZWFkX3Rva2VuOyBSYWlzZV9wYXJzZV9lcnJvcjsgR3Jvd19zdGFja3NfMTsgR3Jvd19zdGFja3NfMjtcbiAgICAgICAgIENvbXB1dGVfc2VtYW50aWNfYWN0aW9uOyBDYWxsX2Vycm9yX2Z1bmN0aW9uXVxuXG5leHRlcm5hbCBwYXJzZV9lbmdpbmUgOlxuICAgIHBhcnNlX3RhYmxlcyAtPiBwYXJzZXJfZW52IC0+IHBhcnNlcl9pbnB1dCAtPiBPYmoudCAtPiBwYXJzZXJfb3V0cHV0XG4gICAgPSBcImNhbWxfcGFyc2VfZW5naW5lXCJcblxuZXh0ZXJuYWwgc2V0X3RyYWNlOiBib29sIC0+IGJvb2xcbiAgICA9IFwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlXCJcblxubGV0IGVudiA9XG4gIHsgc19zdGFjayA9IEFycmF5Lm1ha2UgMTAwIDA7XG4gICAgdl9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIChPYmoucmVwciAoKSk7XG4gICAgc3ltYl9zdGFydF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzeW1iX2VuZF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzdGFja3NpemUgPSAxMDA7XG4gICAgc3RhY2tiYXNlID0gMDtcbiAgICBjdXJyX2NoYXIgPSAwO1xuICAgIGx2YWwgPSBPYmoucmVwciAoKTtcbiAgICBzeW1iX3N0YXJ0ID0gZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kID0gZHVtbXlfcG9zO1xuICAgIGFzcCA9IDA7XG4gICAgcnVsZV9sZW4gPSAwO1xuICAgIHJ1bGVfbnVtYmVyID0gMDtcbiAgICBzcCA9IDA7XG4gICAgc3RhdGUgPSAwO1xuICAgIGVycmZsYWcgPSAwIH1cblxubGV0IGdyb3dfc3RhY2tzKCkgPVxuICBsZXQgb2xkc2l6ZSA9IGVudi5zdGFja3NpemUgaW5cbiAgbGV0IG5ld3NpemUgPSBvbGRzaXplICogMiBpblxuICBsZXQgbmV3X3MgPSBBcnJheS5tYWtlIG5ld3NpemUgMFxuICBhbmQgbmV3X3YgPSBBcnJheS5tYWtlIG5ld3NpemUgKE9iai5yZXByICgpKVxuICBhbmQgbmV3X3N0YXJ0ID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3Bvc1xuICBhbmQgbmV3X2VuZCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3MgaW5cbiAgICBBcnJheS5ibGl0IGVudi5zX3N0YWNrIDAgbmV3X3MgMCBvbGRzaXplO1xuICAgIGVudi5zX3N0YWNrIDwtIG5ld19zO1xuICAgIEFycmF5LmJsaXQgZW52LnZfc3RhY2sgMCBuZXdfdiAwIG9sZHNpemU7XG4gICAgZW52LnZfc3RhY2sgPC0gbmV3X3Y7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9zdGFydF9zdGFjayAwIG5ld19zdGFydCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfc3RhcnRfc3RhY2sgPC0gbmV3X3N0YXJ0O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfZW5kX3N0YWNrIDAgbmV3X2VuZCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfZW5kX3N0YWNrIDwtIG5ld19lbmQ7XG4gICAgZW52LnN0YWNrc2l6ZSA8LSBuZXdzaXplXG5cbmxldCBjbGVhcl9wYXJzZXIoKSA9XG4gIEFycmF5LmZpbGwgZW52LnZfc3RhY2sgMCBlbnYuc3RhY2tzaXplIChPYmoucmVwciAoKSk7XG4gIGVudi5sdmFsIDwtIE9iai5yZXByICgpXG5cbmxldCBjdXJyZW50X2xvb2thaGVhZF9mdW4gPSByZWYgKGZ1biAoXyA6IE9iai50KSAtPiBmYWxzZSlcblxubGV0IHl5cGFyc2UgdGFibGVzIHN0YXJ0IGxleGVyIGxleGJ1ZiA9XG4gIGxldCByZWMgbG9vcCBjbWQgYXJnID1cbiAgICBtYXRjaCBwYXJzZV9lbmdpbmUgdGFibGVzIGVudiBjbWQgYXJnIHdpdGhcbiAgICAgIFJlYWRfdG9rZW4gLT5cbiAgICAgICAgbGV0IHQgPSBPYmoucmVwcihsZXhlciBsZXhidWYpIGluXG4gICAgICAgIGVudi5zeW1iX3N0YXJ0IDwtIGxleGJ1Zi5sZXhfc3RhcnRfcDtcbiAgICAgICAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICAgICAgICBsb29wIFRva2VuX3JlYWQgdFxuICAgIHwgUmFpc2VfcGFyc2VfZXJyb3IgLT5cbiAgICAgICAgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uIC0+XG4gICAgICAgIGxldCAoYWN0aW9uLCB2YWx1ZSkgPVxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgKFNlbWFudGljX2FjdGlvbl9jb21wdXRlZCwgdGFibGVzLmFjdGlvbnMuKGVudi5ydWxlX251bWJlcikgZW52KVxuICAgICAgICAgIHdpdGggUGFyc2VfZXJyb3IgLT5cbiAgICAgICAgICAgIChFcnJvcl9kZXRlY3RlZCwgT2JqLnJlcHIgKCkpIGluXG4gICAgICAgIGxvb3AgYWN0aW9uIHZhbHVlXG4gICAgfCBHcm93X3N0YWNrc18xIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzEgKE9iai5yZXByICgpKVxuICAgIHwgR3Jvd19zdGFja3NfMiAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8yIChPYmoucmVwciAoKSlcbiAgICB8IENhbGxfZXJyb3JfZnVuY3Rpb24gLT5cbiAgICAgICAgdGFibGVzLmVycm9yX2Z1bmN0aW9uIFwic3ludGF4IGVycm9yXCI7XG4gICAgICAgIGxvb3AgRXJyb3JfZGV0ZWN0ZWQgKE9iai5yZXByICgpKSBpblxuICBsZXQgaW5pdF9hc3AgPSBlbnYuYXNwXG4gIGFuZCBpbml0X3NwID0gZW52LnNwXG4gIGFuZCBpbml0X3N0YWNrYmFzZSA9IGVudi5zdGFja2Jhc2VcbiAgYW5kIGluaXRfc3RhdGUgPSBlbnYuc3RhdGVcbiAgYW5kIGluaXRfY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhclxuICBhbmQgaW5pdF9sdmFsID0gZW52Lmx2YWxcbiAgYW5kIGluaXRfZXJyZmxhZyA9IGVudi5lcnJmbGFnIGluXG4gIGVudi5zdGFja2Jhc2UgPC0gZW52LnNwICsgMTtcbiAgZW52LmN1cnJfY2hhciA8LSBzdGFydDtcbiAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICB0cnlcbiAgICBsb29wIFN0YXJ0IChPYmoucmVwciAoKSlcbiAgd2l0aCBleG4gLT5cbiAgICBsZXQgY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhciBpblxuICAgIGVudi5hc3AgPC0gaW5pdF9hc3A7XG4gICAgZW52LnNwIDwtIGluaXRfc3A7XG4gICAgZW52LnN0YWNrYmFzZSA8LSBpbml0X3N0YWNrYmFzZTtcbiAgICBlbnYuc3RhdGUgPC0gaW5pdF9zdGF0ZTtcbiAgICBlbnYuY3Vycl9jaGFyIDwtIGluaXRfY3Vycl9jaGFyO1xuICAgIGVudi5sdmFsIDwtIGluaXRfbHZhbDtcbiAgICBlbnYuZXJyZmxhZyA8LSBpbml0X2VycmZsYWc7XG4gICAgbWF0Y2ggZXhuIHdpdGhcbiAgICAgIFlZZXhpdCB2IC0+XG4gICAgICAgIE9iai5tYWdpYyB2XG4gICAgfCBfIC0+XG4gICAgICAgIGN1cnJlbnRfbG9va2FoZWFkX2Z1biA6PVxuICAgICAgICAgIChmdW4gdG9rIC0+XG4gICAgICAgICAgICBpZiBPYmouaXNfYmxvY2sgdG9rXG4gICAgICAgICAgICB0aGVuIHRhYmxlcy50cmFuc2xfYmxvY2suKE9iai50YWcgdG9rKSA9IGN1cnJfY2hhclxuICAgICAgICAgICAgZWxzZSB0YWJsZXMudHJhbnNsX2NvbnN0LihPYmoubWFnaWMgdG9rKSA9IGN1cnJfY2hhcik7XG4gICAgICAgIHJhaXNlIGV4blxuXG5sZXQgcGVla192YWwgZW52IG4gPVxuICBPYmoubWFnaWMgZW52LnZfc3RhY2suKGVudi5hc3AgLSBuKVxuXG5sZXQgc3ltYm9sX3N0YXJ0X3BvcyAoKSA9XG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDw9IDAgdGhlbiBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHN0ID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGxldCBlbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgaWYgc3QgPD4gZW4gdGhlbiBzdCBlbHNlIGxvb3AgKGkgLSAxKVxuICAgIGVuZFxuICBpblxuICBsb29wIGVudi5ydWxlX2xlblxuXG5sZXQgc3ltYm9sX2VuZF9wb3MgKCkgPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG5sZXQgcmhzX3N0YXJ0X3BvcyBuID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5sZXQgcmhzX2VuZF9wb3MgbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcblxubGV0IHN5bWJvbF9zdGFydCAoKSA9IChzeW1ib2xfc3RhcnRfcG9zICgpKS5wb3NfY251bVxubGV0IHN5bWJvbF9lbmQgKCkgPSAoc3ltYm9sX2VuZF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgcmhzX3N0YXJ0IG4gPSAocmhzX3N0YXJ0X3BvcyBuKS5wb3NfY251bVxubGV0IHJoc19lbmQgbiA9IChyaHNfZW5kX3BvcyBuKS5wb3NfY251bVxuXG5sZXQgaXNfY3VycmVudF9sb29rYWhlYWQgdG9rID1cbiAgKCFjdXJyZW50X2xvb2thaGVhZF9mdW4pKE9iai5yZXByIHRvaylcblxubGV0IHBhcnNlX2Vycm9yIChfIDogc3RyaW5nKSA9ICgpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGVsdFxuICAgIHR5cGUgdFxuICAgIHZhbCBlbXB0eTogdFxuICAgIHZhbCBpc19lbXB0eTogdCAtPiBib29sXG4gICAgdmFsIG1lbTogZWx0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgc2luZ2xldG9uOiBlbHQgLT4gdFxuICAgIHZhbCByZW1vdmU6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gICAgdmFsIGludGVyOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBkaXNqb2ludDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZGlmZjogdCAtPiB0IC0+IHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgc3Vic2V0OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoZWx0IC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICAgIHZhbCBtYXA6IChlbHQgLT4gZWx0KSAtPiB0IC0+IHRcbiAgICB2YWwgZm9sZDogKGVsdCAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICAgIHZhbCBmb3JfYWxsOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHRcbiAgICB2YWwgcGFydGl0aW9uOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdCAqIHRcbiAgICB2YWwgY2FyZGluYWw6IHQgLT4gaW50XG4gICAgdmFsIGVsZW1lbnRzOiB0IC0+IGVsdCBsaXN0XG4gICAgdmFsIG1pbl9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1pbl9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgbWF4X2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWF4X2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBjaG9vc2U6IHQgLT4gZWx0XG4gICAgdmFsIGNob29zZV9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBzcGxpdDogZWx0IC0+IHQgLT4gdCAqIGJvb2wgKiB0XG4gICAgdmFsIGZpbmQ6IGVsdCAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX29wdDogZWx0IC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgb2ZfbGlzdDogZWx0IGxpc3QgLT4gdFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGVsdCAtPiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogZWx0IFNlcS50IC0+IHQgLT4gdFxuICAgIHZhbCBvZl9zZXEgOiBlbHQgU2VxLnQgLT4gdFxuICBlbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGVsdCA9IE9yZC50XG4gICAgdHlwZSB0ID0gRW1wdHkgfCBOb2RlIG9mIHtsOnQ7IHY6ZWx0OyByOnQ7IGg6aW50fVxuXG4gICAgKCogU2V0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYmFsYW5jZWQgYmluYXJ5IHRyZWVzICh0aGUgaGVpZ2h0cyBvZiB0aGVcbiAgICAgICBjaGlsZHJlbiBkaWZmZXIgYnkgYXQgbW9zdCAyICopXG5cbiAgICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtofSAtPiBoXG5cbiAgICAoKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBsZWZ0IHNvbiBsLCB2YWx1ZSB2IGFuZCByaWdodCBzb24gci5cbiAgICAgICBXZSBtdXN0IGhhdmUgYWxsIGVsZW1lbnRzIG9mIGwgPCB2IDwgYWxsIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgbCBhbmQgciBtdXN0IGJlIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgaGVpZ2h0IGZvciBiZXR0ZXIgc3BlZWQuICopXG5cbiAgICBsZXQgY3JlYXRlIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIFNhbWUgYXMgY3JlYXRlLCBidXQgcGVyZm9ybXMgb25lIHN0ZXAgb2YgcmViYWxhbmNpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAgIEFzc3VtZXMgbCBhbmQgciBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMy5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGNyZWF0ZSBmb3IgYmV0dGVyIHNwZWVkIGluIHRoZSBtb3N0IGZyZXF1ZW50IGNhc2VcbiAgICAgICB3aGVyZSBubyByZWJhbGFuY2luZyBpcyByZXF1aXJlZC4gKilcblxuICAgIGxldCBiYWwgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGlmIGhsID4gaHIgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9bGw7IHY9bHY7IHI9bHJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIGxsIGx2IChjcmVhdGUgbHIgdiByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgcj1scnJ9LT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxybCkgbHJ2IChjcmVhdGUgbHJyIHYgcilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2UgaWYgaHIgPiBobCArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1ybDsgdj1ydjsgcj1ycn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmwgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmwpIHJ2IHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyByPXJscn0gLT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybGwpIHJsdiAoY3JlYXRlIHJsciBydiBycilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBJbnNlcnRpb24gb2Ygb25lIGVsZW1lbnQgKilcblxuICAgIGxldCByZWMgYWRkIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdCBlbHNlXG4gICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gYWRkIHggbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHQgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHQgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgc2luZ2xldG9uIHggPSBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCB2IGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGVsZW1lbnRzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGVsZW1lbnQuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9lbGVtZW50IHggbCkgdiByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiAoYWRkX21heF9lbGVtZW50IHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2VsZW1lbnQgdiByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9lbGVtZW50IHYgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyByPWxyOyBoPWxofSwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyOyBoPXJofSkgLT5cbiAgICAgICAgICBpZiBsaCA+IHJoICsgMiB0aGVuIGJhbCBsbCBsdiAoam9pbiBsciB2IHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgcmwpIHJ2IHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IHJcblxuICAgICgqIFNtYWxsZXN0IGFuZCBncmVhdGVzdCBlbGVtZW50IG9mIGEgc2V0ICopXG5cbiAgICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdCBsXG5cbiAgICBsZXQgcmVjIG1pbl9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHRfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0IHJcblxuICAgIGxldCByZWMgbWF4X2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdF9vcHQgclxuXG4gICAgKCogUmVtb3ZlIHRoZSBzbWFsbGVzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBzZXQgKilcblxuICAgIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGJhbCAocmVtb3ZlX21pbl9lbHQgbCkgdiByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgQXNzdW1lIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG5cbiAgICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBiYWwgdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gam9pbiB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogU3BsaXR0aW5nLiAgc3BsaXQgeCBzIHJldHVybnMgYSB0cmlwbGUgKGwsIHByZXNlbnQsIHIpIHdoZXJlXG4gICAgICAgIC0gbCBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPCB4XG4gICAgICAgIC0gciBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPiB4XG4gICAgICAgIC0gcHJlc2VudCBpcyBmYWxzZSBpZiBzIGNvbnRhaW5zIG5vIGVsZW1lbnQgZXF1YWwgdG8geCxcbiAgICAgICAgICBvciB0cnVlIGlmIHMgY29udGFpbnMgYW4gZWxlbWVudCBlcXVhbCB0byB4LiAqKVxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIGZhbHNlLCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgdHJ1ZSwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiByKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobHIsIHByZXMsIHJyKSA9IHNwbGl0IHggciBpbiAoam9pbiBsIHYgbHIsIHByZXMsIHJyKVxuXG4gICAgKCogSW1wbGVtZW50YXRpb24gb2YgdGhlIHNldCBvcGVyYXRpb25zICopXG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBjID0gMCB8fCBtZW0geCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgcmVtb3ZlIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSBhcyB0KSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICAgIGxldCBsbCA9IHJlbW92ZSB4IGwgaW5cbiAgICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW5cbiAgICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgcmVjIHVuaW9uIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0MikgLT4gdDJcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMTsgaD1oMX0sIE5vZGV7bD1sMjsgdj12Mjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgaWYgaDIgPSAxIHRoZW4gYWRkIHYyIHMxIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMiwgXywgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYxICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGgxID0gMSB0aGVuIGFkZCB2MSBzMiBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDEsIF8sIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MiAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgaW50ZXIgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8IChfLCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGludGVyIGwxIGwyKSAoaW50ZXIgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChpbnRlciBsMSBsMikgdjEgKGludGVyIHIxIHIyKVxuXG4gICAgKCogU2FtZSBhcyBzcGxpdCwgYnV0IGNvbXB1dGUgdGhlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWVzXG4gICAgICAgb25seSBpZiB0aGUgcGl2b3QgZWxlbWVudCBpcyBub3QgaW4gdGhlIHNldC4gIFRoZSByaWdodCBzdWJ0cmVlXG4gICAgICAgaXMgY29tcHV0ZWQgb24gZGVtYW5kLiAqKVxuXG4gICAgdHlwZSBzcGxpdF9iaXMgPVxuICAgICAgfCBGb3VuZFxuICAgICAgfCBOb3RGb3VuZCBvZiB0ICogKHVuaXQgLT4gdClcblxuICAgIGxldCByZWMgc3BsaXRfYmlzIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vdEZvdW5kIChFbXB0eSwgKGZ1biAoKSAtPiBFbXB0eSkpXG4gICAgICB8IE5vZGV7bDsgdjsgcjsgX30gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gRm91bmRcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IGwgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobGwsIHJsKSAtPiBOb3RGb3VuZCAobGwsIChmdW4gKCkgLT4gam9pbiAocmwgKCkpIHYgcikpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWF0Y2ggc3BsaXRfYmlzIHggciB3aXRoXG4gICAgICAgICAgICB8IEZvdW5kIC0+IEZvdW5kXG4gICAgICAgICAgICB8IE5vdEZvdW5kIChsciwgcnIpIC0+IE5vdEZvdW5kIChqb2luIGwgdiBsciwgcnIpXG5cbiAgICBsZXQgcmVjIGRpc2pvaW50IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSB8IChfLCBFbXB0eSkgLT4gdHJ1ZVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgaWYgczEgPT0gczIgdGhlbiBmYWxzZVxuICAgICAgICAgIGVsc2UgbWF0Y2ggc3BsaXRfYmlzIHYxIHQyIHdpdGhcbiAgICAgICAgICAgICAgTm90Rm91bmQobDIsIHIyKSAtPiBkaXNqb2ludCBsMSBsMiAmJiBkaXNqb2ludCByMSAocjIgKCkpXG4gICAgICAgICAgICB8IEZvdW5kIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGRpZmYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoZGlmZiBsMSBsMikgdjEgKGRpZmYgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGRpZmYgbDEgbDIpIChkaWZmIHIxIHIyKVxuXG4gICAgdHlwZSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2YgZWx0ICogdCAqIGVudW1lcmF0aW9uXG5cbiAgICBsZXQgcmVjIGNvbnNfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCByLCBlKSlcblxuICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgIChFbmQsIEVuZCkgLT4gMFxuICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgfCAoTW9yZSh2MSwgcjEsIGUxKSwgTW9yZSh2MiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgZWxzZSBjb21wYXJlX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuXG4gICAgbGV0IGNvbXBhcmUgczEgczIgPVxuICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSBzMSBFbmQpIChjb25zX2VudW0gczIgRW5kKVxuXG4gICAgbGV0IGVxdWFsIHMxIHMyID1cbiAgICAgIGNvbXBhcmUgczEgczIgPSAwXG5cbiAgICBsZXQgcmVjIHN1YnNldCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIEVtcHR5LCBfIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBfLCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IE5vZGUge2w9bDE7IHY9djE7IHI9cjF9LCAoTm9kZSB7bD1sMjsgdj12Mjsgcj1yMn0gYXMgdDIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCBsMSBsMiAmJiBzdWJzZXQgcjEgcjJcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1sMTsgdj12MTsgcj1FbXB0eTsgaD0wfSkgbDIgJiYgc3Vic2V0IHIxIHQyXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPUVtcHR5OyB2PXYxOyByPXIxOyBoPTB9KSByMiAmJiBzdWJzZXQgbDEgdDJcblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBpdGVyIGYgbDsgZiB2OyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBmb2xkIGYgcyBhY2N1ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZm9sZCBmIHIgKGYgdiAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgIGxldCByZWMgZmlsdGVyIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSkgYXMgdCAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdiB0aGVuXG4gICAgICAgICAgICBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIHQgZWxzZSBqb2luIGwnIHYgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb24gcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IChFbXB0eSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiByZilcblxuICAgIGxldCByZWMgY2FyZGluYWwgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGV7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGVsZW1lbnRzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGVsZW1lbnRzX2F1eCAodiA6OiBlbGVtZW50c19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgZWxlbWVudHMgcyA9XG4gICAgICBlbGVtZW50c19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9lbHRcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2VsdF9vcHRcblxuICAgIGxldCByZWMgZmluZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdlxuICAgICAgICAgIGVsc2UgZmluZCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX29wdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFNvbWUgdlxuICAgICAgICAgIGVsc2UgZmluZF9vcHQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCB0cnlfam9pbiBsIHYgciA9XG4gICAgICAoKiBbam9pbiBsIHYgcl0gY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gKGVsZW1lbnRzIG9mIGwgPCB2IDxcbiAgICAgICAgIGVsZW1lbnRzIG9mIHIpOyB1c2UgW3RyeV9qb2luIGwgdiByXSB3aGVuIHRoaXMgcHJvcGVydHkgbWF5XG4gICAgICAgICBub3QgaG9sZCwgYnV0IHlvdSBob3BlIGl0IGRvZXMgaG9sZCBpbiB0aGUgY29tbW9uIGNhc2UgKilcbiAgICAgIGlmIChsID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgKG1heF9lbHQgbCkgdiA8IDApXG4gICAgICAmJiAociA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIHYgKG1pbl9lbHQgcikgPCAwKVxuICAgICAgdGhlbiBqb2luIGwgdiByXG4gICAgICBlbHNlIHVuaW9uIGwgKGFkZCB2IHIpXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAoKiBlbmZvcmNlIGxlZnQtdG8tcmlnaHQgZXZhbHVhdGlvbiBvcmRlciAqKVxuICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgbGV0IHYnID0gZiB2IGluXG4gICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgIGVsc2UgdHJ5X2pvaW4gbCcgdicgcidcblxuICAgIGxldCBvZl9zb3J0ZWRfbGlzdCBsID1cbiAgICAgIGxldCByZWMgc3ViIG4gbCA9XG4gICAgICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgICAgICB8IDAsIGwgLT4gRW1wdHksIGxcbiAgICAgICAgfCAxLCB4MCA6OiBsIC0+IE5vZGUge2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX0sIGxcbiAgICAgICAgfCAyLCB4MCA6OiB4MSA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxOyByPUVtcHR5OyBoPTJ9LCBsXG4gICAgICAgIHwgMywgeDAgOjogeDEgOjogeDIgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTtcbiAgICAgICAgICAgICAgICAgcj1Ob2Rle2w9RW1wdHk7IHY9eDI7IHI9RW1wdHk7IGg9MX07IGg9Mn0sIGxcbiAgICAgICAgfCBuLCBsIC0+XG4gICAgICAgICAgbGV0IG5sID0gbiAvIDIgaW5cbiAgICAgICAgICBsZXQgbGVmdCwgbCA9IHN1YiBubCBsIGluXG4gICAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IG1pZCA6OiBsIC0+XG4gICAgICAgICAgICBsZXQgcmlnaHQsIGwgPSBzdWIgKG4gLSBubCAtIDEpIGwgaW5cbiAgICAgICAgICAgIGNyZWF0ZSBsZWZ0IG1pZCByaWdodCwgbFxuICAgICAgaW5cbiAgICAgIGZzdCAoc3ViIChMaXN0Lmxlbmd0aCBsKSBsKVxuXG4gICAgbGV0IG9mX2xpc3QgbCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gZW1wdHlcbiAgICAgIHwgW3gwXSAtPiBzaW5nbGV0b24geDBcbiAgICAgIHwgW3gwOyB4MV0gLT4gYWRkIHgxIChzaW5nbGV0b24geDApXG4gICAgICB8IFt4MDsgeDE7IHgyXSAtPiBhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzXSAtPiBhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzOyB4NF0gLT4gYWRkIHg0IChhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSkpXG4gICAgICB8IF8gLT4gb2Zfc29ydGVkX2xpc3QgKExpc3Quc29ydF91bmlxIE9yZC5jb21wYXJlIGwpXG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIHMgeCAtPiBhZGQgeCBzKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlICh4LCB0LCByZXN0KSAtPiBTZXEuQ29ucyAoeCwgc2VxX29mX2VudW1fIChjb25zX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19zZXEgYyA9IHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBzID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBzIGMgPSBtYXRjaCBzIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgcjsgdjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBzIEVuZClcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgKydhIHRcbiAgICB2YWwgZW1wdHk6ICdhIHRcbiAgICB2YWwgaXNfZW1wdHk6ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBtZW06ICBrZXkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGFkZDoga2V5IC0+ICdhIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCB1cGRhdGU6IGtleSAtPiAoJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHNpbmdsZXRvbjoga2V5IC0+ICdhIC0+ICdhIHRcbiAgICB2YWwgcmVtb3ZlOiBrZXkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIG1lcmdlOlxuICAgICAgICAgIChrZXkgLT4gJ2Egb3B0aW9uIC0+ICdiIG9wdGlvbiAtPiAnYyBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdCAtPiAnYyB0XG4gICAgdmFsIHVuaW9uOiAoa2V5IC0+ICdhIC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgY29tcGFyZTogKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQ6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgZm9yX2FsbDogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBmaWx0ZXI6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgKiAnYSB0XG4gICAgdmFsIGNhcmRpbmFsOiAnYSB0IC0+IGludFxuICAgIHZhbCBiaW5kaW5nczogJ2EgdCAtPiAoa2V5ICogJ2EpIGxpc3RcbiAgICB2YWwgbWluX2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtaW5fYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWF4X2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtYXhfYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgY2hvb3NlX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBzcGxpdDoga2V5IC0+ICdhIHQgLT4gJ2EgdCAqICdhIG9wdGlvbiAqICdhIHRcbiAgICB2YWwgZmluZDoga2V5IC0+ICdhIHQgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6IGtleSAtPiAnYSB0IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWFwOiAoJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBtYXBpOiAoa2V5IC0+ICdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9mcm9tIDoga2V5IC0+ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9IHN0cnVjdFxuXG4gICAgdHlwZSBrZXkgPSBPcmQudFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSBvZiB7bDonYSB0OyB2OmtleTsgZDonYTsgcjonYSB0OyBoOmludH1cblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgIGxldCBjcmVhdGUgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBoZWlnaHQgbCBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBzaW5nbGV0b24geCBkID0gTm9kZXtsPUVtcHR5OyB2PXg7IGQ7IHI9RW1wdHk7IGg9MX1cblxuICAgIGxldCBiYWwgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IGQ9bHJkOyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgZD1ybGQ7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGFkZCB4IGRhdGEgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBkYXRhIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggZGF0YSByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBkXG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkXG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0gLT4gbWluX2JpbmRpbmcgbFxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge2x9LT4gbWluX2JpbmRpbmdfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nIHJcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZ19vcHQgclxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2JpbmRpbmcgbCkgdiBkIHJcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgYmFsIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgKE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0pIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpbiBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW4gaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgdXBkYXRlIHggZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZiBOb25lIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRW1wdHlcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICAgICAgZW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IG1lcmdlIGwgclxuICAgICAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbmQgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSB1cGRhdGUgeCBmIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gdXBkYXRlIHggZiByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGl0ZXIgZiBsOyBmIHYgZDsgaXRlciBmIHJcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIG1hcGkgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXBpIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwaSBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIGZvbGQgZiBtIGFjY3UgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBmb2xkIGYgciAoZiB2IGQgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIGsgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQga2V5cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBrZXkuXG5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9iaW5kaW5nIGsgeCBsKSB2IGQgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgbCB2IGQgKGFkZF9tYXhfYmluZGluZyBrIHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IGQgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fYmluZGluZyB2IGQgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfYmluZGluZyB2IGQgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyOyBoPWxofSxcbiAgICAgICAgIE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgbGQgKGpvaW4gbHIgdiBkIHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgZCBybCkgcnYgcmQgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgZCByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgam9pbiB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCBjb25jYXRfb3Jfam9pbiB0MSB2IGQgdDIgPVxuICAgICAgbWF0Y2ggZCB3aXRoXG4gICAgICB8IFNvbWUgZCAtPiBqb2luIHQxIHYgZCB0MlxuICAgICAgfCBOb25lIC0+IGNvbmNhdCB0MSB0MlxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIE5vbmUsIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgU29tZSBkLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IGQgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGQgbHIsIHByZXMsIHJyKVxuXG4gICAgbGV0IHJlYyBtZXJnZSBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LCBfKSB3aGVuIGgxID49IGhlaWdodCBzMiAtPlxuICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MSAoZiB2MSAoU29tZSBkMSkgZDIpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCAoXywgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMn0pIC0+XG4gICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYyIChmIHYyIGQxIChTb21lIGQyKSkgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBhc3NlcnQgZmFsc2VcblxuICAgIGxldCByZWMgdW5pb24gZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICB8IChFbXB0eSwgcykgfCAocywgRW1wdHkpIC0+IHNcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LFxuICAgICAgICAgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZkXG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IGQgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiBkIHJmKVxuXG4gICAgdHlwZSAnYSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2Yga2V5ICogJ2EgKiAnYSB0ICogJ2EgZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIG0gZSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCBkLCByLCBlKSlcblxuICAgIGxldCBjb21wYXJlIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBjb21wYXJlX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgZXF1YWxfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiB0cnVlXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IGZhbHNlXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gZmFsc2VcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgT3JkLmNvbXBhcmUgdjEgdjIgPSAwICYmIGNtcCBkMSBkMiAmJlxuICAgICAgICAgICAgZXF1YWxfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBlcXVhbF9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGJpbmRpbmdzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiaW5kaW5nc19hdXggKCh2LCBkKSA6OiBiaW5kaW5nc19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgYmluZGluZ3MgcyA9XG4gICAgICBiaW5kaW5nc19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9iaW5kaW5nXG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9iaW5kaW5nX29wdFxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBtIChrLHYpIC0+IGFkZCBrIHYgbSkgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoayx2LHQscmVzdCkgLT4gU2VxLkNvbnMgKChrLHYpLCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBtID1cbiAgICAgIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIG0gRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCBwb3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgU29tZSBoZFxuICB8IFtdICAgICAtPiBOb25lXG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBTb21lIGhkXG4gIHwgW10gICAgLT4gTm9uZVxuXG5sZXQgaXNfZW1wdHkgcyA9IChzLmMgPSBbXSlcblxubGV0IGxlbmd0aCBzID0gcy5sZW5cblxubGV0IGl0ZXIgZiBzID0gTGlzdC5pdGVyIGYgcy5jXG5cbmxldCBmb2xkIGYgYWNjIHMgPSBMaXN0LmZvbGRfbGVmdCBmIGFjYyBzLmNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gTGlzdC50b19zZXEgcy5jXG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcyA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcyBnO1xuICBzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgcGVla19vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBTb21lIGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCB0YWtlX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBTb21lIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBTb21lIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEludGVybmFscyBvZiBmb3JjaW5nIGxhenkgdmFsdWVzLiAqKVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuZXhjZXB0aW9uIFVuZGVmaW5lZFxuXG5sZXQgcmFpc2VfdW5kZWZpbmVkID0gT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBVbmRlZmluZWQpXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6IE9iai50IC0+IE9iai50IC0+IHVuaXQgPSBcImNhbWxfb2JqX21ha2VfZm9yd2FyZFwiXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIHRyeVxuICAgIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICAgIHJlc3VsdFxuICB3aXRoIGUgLT5cbiAgICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgKE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgZSkpO1xuICAgIHJhaXNlIGVcblxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfdmFsX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICByZXN1bHRcblxuXG4oKiBbZm9yY2VdIGlzIG5vdCB1c2VkLCBzaW5jZSBbTGF6eS5mb3JjZV0gaXMgZGVjbGFyZWQgYXMgYSBwcmltaXRpdmVcbiAgIHdob3NlIGNvZGUgaW5saW5lcyB0aGUgdGFnIHRlc3RzIG9mIGl0cyBhcmd1bWVudC4gIFRoaXMgZnVuY3Rpb24gaXNcbiAgIGhlcmUgZm9yIHRoZSBzYWtlIG9mIGNvbXBsZXRlbmVzcywgYW5kIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS4gKilcblxubGV0IGZvcmNlIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX2xhenlfYmxvY2sgbHp2XG5cblxubGV0IGZvcmNlX3ZhbCAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV92YWxfbGF6eV9ibG9jayBsenZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtMYXp5XTogZGVmZXJyZWQgY29tcHV0YXRpb25zICopXG5cblxuKCpcbiAgIFdBUk5JTkc6IHNvbWUgcHVycGxlIG1hZ2ljIGlzIGdvaW5nIG9uIGhlcmUuICBEbyBub3QgdGFrZSB0aGlzIGZpbGVcbiAgIGFzIGFuIGV4YW1wbGUgb2YgaG93IHRvIHByb2dyYW0gaW4gT0NhbWwuXG4qKVxuXG5cbigqIFdlIG1ha2UgdXNlIG9mIHR3byBzcGVjaWFsIHRhZ3MgcHJvdmlkZWQgYnkgdGhlIHJ1bnRpbWU6XG4gICBbbGF6eV90YWddIGFuZCBbZm9yd2FyZF90YWddLlxuXG4gICBBIHZhbHVlIG9mIHR5cGUgWydhIExhenkudF0gY2FuIGJlIG9uZSBvZiB0aHJlZSB0aGluZ3M6XG4gICAxLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbbGF6eV90YWddLiAgSXRzIGZpZWxkIGlzIGEgY2xvc3VyZSBvZlxuICAgICAgdHlwZSBbdW5pdCAtPiAnYV0gdGhhdCBjb21wdXRlcyB0aGUgdmFsdWUuXG4gICAyLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbZm9yd2FyZF90YWddLiAgSXRzIGZpZWxkIGlzIHRoZSB2YWx1ZVxuICAgICAgb2YgdHlwZSBbJ2FdIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgMy4gQW55dGhpbmcgZWxzZSBleGNlcHQgYSBmbG9hdC4gIFRoaXMgaGFzIHR5cGUgWydhXSBhbmQgaXMgdGhlIHZhbHVlXG4gICAgICB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIEV4Y2VwdGlvbnMgYXJlIHN0b3JlZCBpbiBmb3JtYXQgKDEpLlxuICAgVGhlIEdDIHdpbGwgbWFnaWNhbGx5IGNoYW5nZSB0aGluZ3MgZnJvbSAoMikgdG8gKDMpIGFjY29yZGluZyB0byBpdHNcbiAgIGZhbmN5LlxuXG4gICBJZiBPQ2FtbCB3YXMgY29uZmlndXJlZCB3aXRoIHRoZSAtZmxhdC1mbG9hdC1hcnJheSBvcHRpb24gKHdoaWNoIGlzXG4gICBjdXJyZW50bHkgdGhlIGRlZmF1bHQpLCB0aGUgZm9sbG93aW5nIGlzIGFsc28gdHJ1ZTpcbiAgIFdlIGNhbm5vdCB1c2UgcmVwcmVzZW50YXRpb24gKDMpIGZvciBhIFtmbG9hdCBMYXp5LnRdIGJlY2F1c2VcbiAgIFtjYW1sX21ha2VfYXJyYXldIGFzc3VtZXMgdGhhdCBvbmx5IGEgW2Zsb2F0XSB2YWx1ZSBjYW4gaGF2ZSB0YWdcbiAgIFtEb3VibGVfdGFnXS5cblxuICAgV2UgaGF2ZSB0byB1c2UgdGhlIGJ1aWx0LWluIHR5cGUgY29uc3RydWN0b3IgW2xhenlfdF0gdG9cbiAgIGxldCB0aGUgY29tcGlsZXIgaW1wbGVtZW50IHRoZSBzcGVjaWFsIHR5cGluZyBhbmQgY29tcGlsYXRpb25cbiAgIHJ1bGVzIGZvciB0aGUgW2xhenldIGtleXdvcmQuXG4qKVxuXG50eXBlICdhIHQgPSAnYSBDYW1saW50ZXJuYWxMYXp5LnRcblxuZXhjZXB0aW9uIFVuZGVmaW5lZCA9IENhbWxpbnRlcm5hbExhenkuVW5kZWZpbmVkXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6ICdhIC0+ICdhIGxhenlfdCA9IFwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZFwiXG5cbmV4dGVybmFsIGZvcmNlIDogJ2EgdCAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuXG4oKiBsZXQgZm9yY2UgPSBmb3JjZSAqKVxuXG5sZXQgZm9yY2VfdmFsID0gQ2FtbGludGVybmFsTGF6eS5mb3JjZV92YWxcblxubGV0IGZyb21fZnVuIChmIDogdW5pdCAtPiAnYXJnKSA9XG4gIGxldCB4ID0gT2JqLm5ld19ibG9jayBPYmoubGF6eV90YWcgMSBpblxuICBPYmouc2V0X2ZpZWxkIHggMCAoT2JqLnJlcHIgZik7XG4gIChPYmoub2JqIHggOiAnYXJnIHQpXG5cblxubGV0IGZyb21fdmFsICh2IDogJ2FyZykgPVxuICBsZXQgdCA9IE9iai50YWcgKE9iai5yZXByIHYpIGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgfHwgdCA9IE9iai5sYXp5X3RhZyB8fCB0ID0gT2JqLmRvdWJsZV90YWcgdGhlbiBiZWdpblxuICAgIG1ha2VfZm9yd2FyZCB2XG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgKE9iai5tYWdpYyB2IDogJ2FyZyB0KVxuICBlbmRcblxuXG5sZXQgaXNfdmFsIChsIDogJ2FyZyB0KSA9IE9iai50YWcgKE9iai5yZXByIGwpIDw+IE9iai5sYXp5X3RhZ1xuXG5sZXQgbGF6eV9mcm9tX2Z1biA9IGZyb21fZnVuXG5cbmxldCBsYXp5X2Zyb21fdmFsID0gZnJvbV92YWxcblxubGV0IGxhenlfaXNfdmFsID0gaXNfdmFsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIERhbmllbCBkZSBSYXVnbGF1ZHJlLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIGNlbGwgb3B0aW9uXG5hbmQgJ2EgY2VsbCA9IHsgbXV0YWJsZSBjb3VudCA6IGludDsgbXV0YWJsZSBkYXRhIDogJ2EgZGF0YSB9XG5hbmQgJ2EgZGF0YSA9XG4gICAgU2VtcHR5XG4gIHwgU2NvbnMgb2YgJ2EgKiAnYSBkYXRhXG4gIHwgU2FwcCBvZiAnYSBkYXRhICogJ2EgZGF0YVxuICB8IFNsYXp5IG9mICdhIGRhdGEgTGF6eS50XG4gIHwgU2dlbiBvZiAnYSBnZW5cbiAgfCBTYnVmZmlvIDogYnVmZmlvIC0+IGNoYXIgZGF0YVxuYW5kICdhIGdlbiA9IHsgbXV0YWJsZSBjdXJyIDogJ2Egb3B0aW9uIG9wdGlvbjsgZnVuYyA6IGludCAtPiAnYSBvcHRpb24gfVxuYW5kIGJ1ZmZpbyA9XG4gIHsgaWMgOiBpbl9jaGFubmVsOyBidWZmIDogYnl0ZXM7IG11dGFibGUgbGVuIDogaW50OyBtdXRhYmxlIGluZCA6IGludCB9XG5cbmV4Y2VwdGlvbiBGYWlsdXJlXG5leGNlcHRpb24gRXJyb3Igb2Ygc3RyaW5nXG5cbmxldCBjb3VudCA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSB7IGNvdW50IH0gLT4gY291bnRcbmxldCBkYXRhID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFNlbXB0eVxuICB8IFNvbWUgeyBkYXRhIH0gLT4gZGF0YVxuXG5sZXQgZmlsbF9idWZmIGIgPVxuICBiLmxlbiA8LSBpbnB1dCBiLmljIGIuYnVmZiAwIChCeXRlcy5sZW5ndGggYi5idWZmKTsgYi5pbmQgPC0gMFxuXG5cbmxldCByZWMgZ2V0X2RhdGEgOiB0eXBlIHYuIGludCAtPiB2IGRhdGEgLT4gdiBkYXRhID0gZnVuIGNvdW50IGQgLT4gbWF0Y2ggZCB3aXRoXG4gKCogUmV0dXJucyBlaXRoZXIgU2VtcHR5IG9yIFNjb25zKGEsIF8pIGV2ZW4gd2hlbiBkIGlzIGEgZ2VuZXJhdG9yXG4gICAgb3IgYSBidWZmZXIuIEluIHRob3NlIGNhc2VzLCB0aGUgaXRlbSBhIGlzIHNlZW4gYXMgZXh0cmFjdGVkIGZyb21cbiB0aGUgZ2VuZXJhdG9yL2J1ZmZlci5cbiBUaGUgY291bnQgcGFyYW1ldGVyIGlzIHVzZWQgZm9yIGNhbGxpbmcgYFNnZW4tZnVuY3Rpb25zJy4gICopXG4gICBTZW1wdHkgfCBTY29ucyAoXywgXykgLT4gZFxuIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBjb3VudCBkMSB3aXRoXG4gICAgICAgU2NvbnMgKGEsIGQxMSkgLT4gU2NvbnMgKGEsIFNhcHAgKGQxMSwgZDIpKVxuICAgICB8IFNlbXB0eSAtPiBnZXRfZGF0YSBjb3VudCBkMlxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2dlbiB7Y3VyciA9IFNvbWUgTm9uZX0gLT4gU2VtcHR5XG4gfCBTZ2VuICh7Y3VyciA9IFNvbWUoU29tZSBhKX0gYXMgZykgLT5cbiAgICAgZy5jdXJyIDwtIE5vbmU7IFNjb25zKGEsIGQpXG4gfCBTZ2VuIGcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZy5mdW5jIGNvdW50IHdpdGhcbiAgICAgICBOb25lIC0+IGcuY3VyciA8LSBTb21lKE5vbmUpOyBTZW1wdHlcbiAgICAgfCBTb21lIGEgLT4gU2NvbnMoYSwgZClcbiAgICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICBlbmRcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gU2VtcHR5IGVsc2VcbiAgICAgICBsZXQgciA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kIGluXG4gICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgICAgYi5pbmQgPC0gc3VjYyBiLmluZDsgU2NvbnMociwgZClcbiB8IFNsYXp5IGYgLT4gZ2V0X2RhdGEgY291bnQgKExhenkuZm9yY2UgZilcblxuXG5sZXQgcmVjIHBlZWtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHYgb3B0aW9uID0gZnVuIHMgLT5cbiAoKiBjb25zdWx0IHRoZSBmaXJzdCBpdGVtIG9mIHMgKilcbiBtYXRjaCBzLmRhdGEgd2l0aFxuICAgU2VtcHR5IC0+IE5vbmVcbiB8IFNjb25zIChhLCBfKSAtPiBTb21lIGFcbiB8IFNhcHAgKF8sIF8pIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIHMuY291bnQgcy5kYXRhIHdpdGhcbiAgICAgICBTY29ucyhhLCBfKSBhcyBkIC0+IHMuZGF0YSA8LSBkOyBTb21lIGFcbiAgICAgfCBTZW1wdHkgLT4gTm9uZVxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2xhenkgZiAtPiBzLmRhdGEgPC0gKExhenkuZm9yY2UgZik7IHBlZWtfZGF0YSBzXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBhfSAtPiBhXG4gfCBTZ2VuIGcgLT4gbGV0IHggPSBnLmZ1bmMgcy5jb3VudCBpbiBnLmN1cnIgPC0gU29tZSB4OyB4XG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIGJlZ2luIHMuZGF0YSA8LSBTZW1wdHk7IE5vbmUgZW5kXG4gICAgIGVsc2UgU29tZSAoQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQpXG5cblxubGV0IHBlZWsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgcyAtPiBwZWVrX2RhdGEgc1xuXG5cbmxldCByZWMganVua19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdW5pdCA9IGZ1biBzIC0+XG4gIG1hdGNoIHMuZGF0YSB3aXRoXG4gICAgU2NvbnMgKF8sIGQpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IHMuZGF0YSA8LSBkXG4gIHwgU2dlbiAoe2N1cnIgPSBTb21lIF99IGFzIGcpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGcuY3VyciA8LSBOb25lXG4gIHwgU2J1ZmZpbyBiIC0+XG4gICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIHMuZGF0YSA8LSBTZW1wdHlcbiAgICAgIGVsc2UgKHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGIuaW5kIDwtIHN1Y2MgYi5pbmQpXG4gIHwgXyAtPlxuICAgICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgICBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyAtPiBqdW5rX2RhdGEgc1xuXG5cbmxldCBqdW5rID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBkYXRhIC0+IGp1bmtfZGF0YSBkYXRhXG5cbmxldCByZWMgbmdldF9kYXRhIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuIFtdLCBzLmRhdGEsIDBcbiAgZWxzZVxuICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgIFNvbWUgYSAtPlxuICAgICAgICBqdW5rX2RhdGEgcztcbiAgICAgICAgbGV0IChhbCwgZCwgaykgPSBuZ2V0X2RhdGEgKHByZWQgbikgcyBpbiBhIDo6IGFsLCBTY29ucyAoYSwgZCksIHN1Y2Mga1xuICAgIHwgTm9uZSAtPiBbXSwgcy5kYXRhLCAwXG5cblxubGV0IG5wZWVrX2RhdGEgbiBzID1cbiAgbGV0IChhbCwgZCwgbGVuKSA9IG5nZXRfZGF0YSBuIHMgaW5cbiAgcy5jb3VudCA8LSAocy5jb3VudCAtIGxlbik7XG4gIHMuZGF0YSA8LSBkO1xuICBhbFxuXG5cbmxldCBucGVlayBuID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBkIC0+IG5wZWVrX2RhdGEgbiBkXG5cbmxldCBuZXh0IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgYSAtPiBqdW5rIHM7IGFcbiAgfCBOb25lIC0+IHJhaXNlIEZhaWx1cmVcblxuXG5sZXQgZW1wdHkgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBfIC0+IHJhaXNlIEZhaWx1cmVcbiAgfCBOb25lIC0+ICgpXG5cblxubGV0IGl0ZXIgZiBzdHJtID1cbiAgbGV0IHJlYyBkb19yZWMgKCkgPVxuICAgIG1hdGNoIHBlZWsgc3RybSB3aXRoXG4gICAgICBTb21lIGEgLT4ganVuayBzdHJtOyBpZ25vcmUoZiBhKTsgZG9fcmVjICgpXG4gICAgfCBOb25lIC0+ICgpXG4gIGluXG4gIGRvX3JlYyAoKVxuXG5cbigqIFN0cmVhbSBidWlsZGluZyBmdW5jdGlvbnMgKilcblxubGV0IGZyb20gZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNnZW4ge2N1cnIgPSBOb25lOyBmdW5jID0gZn19XG5cbmxldCBvZl9saXN0IGwgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBMaXN0LmZvbGRfcmlnaHQgKGZ1biB4IGwgLT4gU2NvbnMgKHgsIGwpKSBsIFNlbXB0eX1cblxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgICgqIFdlIGNhbm5vdCB1c2UgdGhlIGluZGV4IHBhc3NlZCBieSB0aGUgW2Zyb21dIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICAgYmVjYXVzZSBpdCByZXR1cm5zIHRoZSBjdXJyZW50IHN0cmVhbSBjb3VudCwgd2l0aCBhYnNvbHV0ZWx5IG5vXG4gICAgICAgZ3VhcmFudGVlIHRoYXQgaXQgd2lsbCBzdGFydCBmcm9tIDAuIEZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuICAgICAgIG9mIFtTdHJlYW0uaWNvbnMgJ2MnIChTdHJlYW0uZnJvbV9zdHJpbmcgXCJhYlwiKV0sIHRoZSBmaXJzdFxuICAgICAgIGFjY2VzcyB0byB0aGUgc3RyaW5nIHdpbGwgYmUgbWFkZSB3aXRoIGNvdW50IFsxXSBhbHJlYWR5LlxuICAgICopXG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSBzLltjXSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2J5dGVzIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IEJ5dGVzLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSAoQnl0ZXMuZ2V0IHMgYykpXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9jaGFubmVsIGljID1cbiAgU29tZSB7Y291bnQgPSAwO1xuICAgICAgICBkYXRhID0gU2J1ZmZpbyB7aWMgPSBpYzsgYnVmZiA9IEJ5dGVzLmNyZWF0ZSA0MDk2OyBsZW4gPSAwOyBpbmQgPSAwfX1cblxuXG4oKiBTdHJlYW0gZXhwcmVzc2lvbnMgYnVpbGRlcnMgKilcblxubGV0IGlhcHAgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2FwcCAoZGF0YSBpLCBkYXRhIHMpfVxubGV0IGljb25zIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBkYXRhIHMpfVxubGV0IGlzaW5nIGkgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgU2VtcHR5KX1cblxubGV0IGxhcHAgZiBzID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2FwcCAoZGF0YSAoZiAoKSksIGRhdGEgcykpKX1cblxubGV0IGxjb25zIGYgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBkYXRhIHMpKSl9XG5sZXQgbHNpbmcgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBTZW1wdHkpKSl9XG5cbmxldCBzZW1wdHkgPSBOb25lXG5sZXQgc2xhenkgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KGRhdGEgKGYgKCkpKSl9XG5cbigqIEZvciBkZWJ1Z2dpbmcgdXNlICopXG5cbmxldCByZWMgZHVtcCA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiB0IC0+IHVuaXQgPSBmdW4gZiBzIC0+XG4gIHByaW50X3N0cmluZyBcIntjb3VudCA9IFwiO1xuICBwcmludF9pbnQgKGNvdW50IHMpO1xuICBwcmludF9zdHJpbmcgXCI7IGRhdGEgPSBcIjtcbiAgZHVtcF9kYXRhIGYgKGRhdGEgcyk7XG4gIHByaW50X3N0cmluZyBcIn1cIjtcbiAgcHJpbnRfbmV3bGluZSAoKVxuYW5kIGR1bXBfZGF0YSA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiBkYXRhIC0+IHVuaXQgPSBmdW4gZiAtPlxuICBmdW5jdGlvblxuICAgIFNlbXB0eSAtPiBwcmludF9zdHJpbmcgXCJTZW1wdHlcIlxuICB8IFNjb25zIChhLCBkKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2NvbnMgKFwiO1xuICAgICAgZiBhO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQ7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTYXBwIChcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQxO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQyO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2xhenkgXyAtPiBwcmludF9zdHJpbmcgXCJTbGF6eVwiXG4gIHwgU2dlbiBfIC0+IHByaW50X3N0cmluZyBcIlNnZW5cIlxuICB8IFNidWZmaW8gXyAtPiBwcmludF9zdHJpbmcgXCJTYnVmZmlvXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgIFBpZXJyZSBXZWlzIGFuZCBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTkgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXh0ZW5zaWJsZSBidWZmZXJzICopXG5cbnR5cGUgdCA9XG4ge211dGFibGUgYnVmZmVyIDogYnl0ZXM7XG4gIG11dGFibGUgcG9zaXRpb24gOiBpbnQ7XG4gIG11dGFibGUgbGVuZ3RoIDogaW50O1xuICBpbml0aWFsX2J1ZmZlciA6IGJ5dGVzfVxuKCogSW52YXJpYW50czogYWxsIHBhcnRzIG9mIHRoZSBjb2RlIHByZXNlcnZlIHRoZSBpbnZhcmlhbnRzIHRoYXQ6XG4gICAtIFswIDw9IGIucG9zaXRpb24gPD0gYi5sZW5ndGhdXG4gICAtIFtiLmxlbmd0aCA9IEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlcl1cblxuICAgTm90ZSBpbiBwYXJ0aWN1bGFyIHRoYXQgW2IucG9zaXRpb24gPSBiLmxlbmd0aF0gaXMgbGVnYWwsXG4gICBpdCBtZWFucyB0aGF0IHRoZSBidWZmZXIgaXMgZnVsbCBhbmQgd2lsbCBoYXZlIHRvIGJlIGV4dGVuZGVkXG4gICBiZWZvcmUgYW55IGZ1cnRoZXIgYWRkaXRpb24uICopXG5cbmxldCBjcmVhdGUgbiA9XG4gbGV0IG4gPSBpZiBuIDwgMSB0aGVuIDEgZWxzZSBuIGluXG4gbGV0IG4gPSBpZiBuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGVsc2UgbiBpblxuIGxldCBzID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiB7YnVmZmVyID0gczsgcG9zaXRpb24gPSAwOyBsZW5ndGggPSBuOyBpbml0aWFsX2J1ZmZlciA9IHN9XG5cbmxldCBjb250ZW50cyBiID0gQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cbmxldCB0b19ieXRlcyBiID0gQnl0ZXMuc3ViIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgc3ViIGIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBiLnBvc2l0aW9uIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuc3ViXCJcbiAgZWxzZSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIG9mcyBsZW5cblxuXG5sZXQgYmxpdCBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBzcmNvZmYgPCAwIHx8IHNyY29mZiA+IHNyYy5wb3NpdGlvbiAtIGxlblxuICAgICAgICAgICAgIHx8IGRzdG9mZiA8IDAgfHwgZHN0b2ZmID4gKEJ5dGVzLmxlbmd0aCBkc3QpIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYmxpdFwiXG4gIGVsc2VcbiAgICBCeXRlcy51bnNhZmVfYmxpdCBzcmMuYnVmZmVyIHNyY29mZiBkc3QgZHN0b2ZmIGxlblxuXG5cbmxldCBudGggYiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+PSBiLnBvc2l0aW9uIHRoZW5cbiAgIGludmFsaWRfYXJnIFwiQnVmZmVyLm50aFwiXG4gIGVsc2UgQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBvZnNcblxuXG5sZXQgbGVuZ3RoIGIgPSBiLnBvc2l0aW9uXG5cbmxldCBjbGVhciBiID0gYi5wb3NpdGlvbiA8LSAwXG5cbmxldCByZXNldCBiID1cbiAgYi5wb3NpdGlvbiA8LSAwO1xuICBiLmJ1ZmZlciA8LSBiLmluaXRpYWxfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSBCeXRlcy5sZW5ndGggYi5idWZmZXJcblxuKCogW3Jlc2l6ZSBiIG1vcmVdIGVuc3VyZXMgdGhhdCBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIGhvbGRzXG4gICBieSBkeW5hbWljYWxseSBleHRlbmRpbmcgW2IuYnVmZmVyXSBpZiBuZWNlc3NhcnkgLS0gYW5kIHRodXNcbiAgIGluY3JlYXNpbmcgW2IubGVuZ3RoXS5cblxuICAgSW4gcGFydGljdWxhciwgYWZ0ZXIgW3Jlc2l6ZSBiIG1vcmVdIGlzIGNhbGxlZCwgYSBkaXJlY3QgYWNjZXNzIG9mXG4gICBzaXplIFttb3JlXSBhdCBbYi5wb3NpdGlvbl0gd2lsbCBhbHdheXMgYmUgaW4tYm91bmRzLCBzbyB0aGF0XG4gICAodW5zYWZlX3tnZXQsc2V0fSkgbWF5IGJlIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuKilcbmxldCByZXNpemUgYiBtb3JlID1cbiAgbGV0IG9sZF9wb3MgPSBiLnBvc2l0aW9uIGluXG4gIGxldCBvbGRfbGVuID0gYi5sZW5ndGggaW5cbiAgbGV0IG5ld19sZW4gPSByZWYgb2xkX2xlbiBpblxuICB3aGlsZSBvbGRfcG9zICsgbW9yZSA+ICFuZXdfbGVuIGRvIG5ld19sZW4gOj0gMiAqICFuZXdfbGVuIGRvbmU7XG4gIGlmICFuZXdfbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBpZiBvbGRfcG9zICsgbW9yZSA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICB0aGVuIG5ld19sZW4gOj0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgZWxzZSBmYWlsd2l0aCBcIkJ1ZmZlci5hZGQ6IGNhbm5vdCBncm93IGJ1ZmZlclwiXG4gIGVuZDtcbiAgbGV0IG5ld19idWZmZXIgPSBCeXRlcy5jcmVhdGUgIW5ld19sZW4gaW5cbiAgKCogUFIjNjE0ODogbGV0J3Mga2VlcCB1c2luZyBbYmxpdF0gcmF0aGVyIHRoYW4gW3Vuc2FmZV9ibGl0XSBpblxuICAgICB0aGlzIHRyaWNreSBmdW5jdGlvbiB0aGF0IGlzIHNsb3cgYW55d2F5LiAqKVxuICBCeXRlcy5ibGl0IGIuYnVmZmVyIDAgbmV3X2J1ZmZlciAwIGIucG9zaXRpb247XG4gIGIuYnVmZmVyIDwtIG5ld19idWZmZXI7XG4gIGIubGVuZ3RoIDwtICFuZXdfbGVuO1xuICBhc3NlcnQgKGIucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoKTtcbiAgYXNzZXJ0IChvbGRfcG9zICsgbW9yZSA8PSBiLmxlbmd0aCk7XG4gICgpXG4gICgqIE5vdGU6IHRoZXJlIGFyZSB2YXJpb3VzIHNpdHVhdGlvbnMgKHByZWVtcHRpdmUgdGhyZWFkcywgc2lnbmFscyBhbmRcbiAgICAgZ2MgZmluYWxpemVycykgd2hlcmUgT0NhbWwgY29kZSBtYXkgYmUgcnVuIGFzeW5jaHJvbm91c2x5OyBpblxuICAgICBwYXJ0aWN1bGFyLCB0aGVyZSBtYXkgYmUgYSByYWNlIHdpdGggYW5vdGhlciB1c2VyIG9mIFtiXSwgY2hhbmdpbmdcbiAgICAgaXRzIG11dGFibGUgZmllbGRzIGluIHRoZSBtaWRkbGUgb2YgdGhlIFtyZXNpemVdIGNhbGwuIFRoZSBCdWZmZXJcbiAgICAgbW9kdWxlIGRvZXMgbm90IHByb3ZpZGUgYW55IGNvcnJlY3RuZXNzIGd1YXJhbnRlZSBpZiB0aGF0IGhhcHBlbnMsXG4gICAgIGJ1dCB3ZSBtdXN0IHN0aWxsIGVuc3VyZSB0aGF0IHRoZSBkYXRhc3RydWN0dXJlIGludmFyaWFudHMgaG9sZCBmb3JcbiAgICAgbWVtb3J5LXNhZmV0eSAtLSBhcyB3ZSBwbGFuIHRvIHVzZSBbdW5zYWZlX3tnZXQsc2V0fV0uXG5cbiAgICAgVGhlcmUgYXJlIHR3byBwb3RlbnRpYWwgYWxsb2NhdGlvbiBwb2ludHMgaW4gdGhpcyBmdW5jdGlvbixcbiAgICAgW3JlZl0gYW5kIFtCeXRlcy5jcmVhdGVdLCBidXQgYWxsIHJlYWRzIGFuZCB3cml0ZXMgdG8gdGhlIGZpZWxkc1xuICAgICBvZiBbYl0gaGFwcGVuIGJlZm9yZSBib3RoIG9mIHRoZW0gb3IgYWZ0ZXIgYm90aCBvZiB0aGVtLlxuXG4gICAgIFdlIHRoZXJlZm9yZSBhc3N1bWUgdGhhdCBbYi5wb3NpdGlvbl0gbWF5IGNoYW5nZSBhdCB0aGVzZSBhbGxvY2F0aW9ucyxcbiAgICAgYW5kIGNoZWNrIHRoYXQgdGhlIFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gcG9zdGNvbmRpdGlvblxuICAgICBob2xkcyBmb3IgYm90aCB2YWx1ZXMgb2YgW2IucG9zaXRpb25dLCBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGZ1bmN0aW9uXG4gICAgIGlzIGNhbGxlZC4gTW9yZSBwcmVjaXNlbHksIHRoZSBmb2xsb3dpbmcgaW52YXJpYW50cyBtdXN0IGhvbGQgaWYgdGhlXG4gICAgIGZ1bmN0aW9uIHJldHVybnMgY29ycmVjdGx5LCBpbiBhZGRpdGlvbiB0byB0aGUgdXN1YWwgYnVmZmVyIGludmFyaWFudHM6XG4gICAgIC0gW29sZChiLnBvc2l0aW9uKSArIG1vcmUgPD0gbmV3KGIubGVuZ3RoKV1cbiAgICAgLSBbbmV3KGIucG9zaXRpb24pICsgbW9yZSA8PSBuZXcoYi5sZW5ndGgpXVxuICAgICAtIFtvbGQoYi5sZW5ndGgpIDw9IG5ldyhiLmxlbmd0aCldXG5cbiAgICAgTm90ZTogW2IucG9zaXRpb24gKyBtb3JlIDw9IG9sZChiLmxlbmd0aCldIGRvZXMgKm5vdCpcbiAgICAgaG9sZCBpbiBnZW5lcmFsLCBhcyBpdCBpcyBwcmVjaXNlbHkgdGhlIGNhc2Ugd2hlcmUgeW91IG5lZWRcbiAgICAgdG8gY2FsbCBbcmVzaXplXSB0byBpbmNyZWFzZSBbYi5sZW5ndGhdLlxuXG4gICAgIE5vdGU6IFthc3NlcnRdIGFib3ZlIGRvZXMgbm90IG1lYW4gdGhhdCB3ZSBrbm93IHRoZSBjb25kaXRpb25zXG4gICAgIGFsd2F5cyBob2xkLCBidXQgdGhhdCB0aGUgZnVuY3Rpb24gbWF5IHJldHVybiBjb3JyZWN0bHlcbiAgICAgb25seSBpZiB0aGV5IGhvbGQuXG5cbiAgICAgTm90ZTogdGhlIG90aGVyIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBkb2VzIG5vdCBuZWVkXG4gICAgIHRvIGJlIGNoZWNrZWQgd2l0aCB0aGlzIGxldmVsIG9mIHNjcnV0aW55LCBnaXZlbiB0aGF0IHRoZXlcbiAgICAgcmVhZC93cml0ZSB0aGUgYnVmZmVyIGltbWVkaWF0ZWx5IGFmdGVyIGNoZWNraW5nIHRoYXRcbiAgICAgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBob2xkIG9yIGNhbGxpbmcgW3Jlc2l6ZV0uXG4gICopXG5cbmxldCBhZGRfY2hhciBiIGMgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIHBvcyBjO1xuICBiLnBvc2l0aW9uIDwtIHBvcyArIDFcblxuIGxldCBhZGRfdXRmXzhfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+XG4gICAgIGFkZF9jaGFyIGIgKENoYXIudW5zYWZlX2NociB1KVxuIHwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhDMCBsb3IgKHUgbHNyIDYpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAzID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAzO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4RTAgbG9yICh1IGxzciAxMikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMilcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgM1xuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEYwIGxvciAodSBsc3IgMTgpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciAxMikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gbGV0IGFkZF91dGZfMTZiZV91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAodSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyICh1IGxhbmQgMHhGRikpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgIGxldCBoaSA9IDB4RDgwMCBsb3IgKHUnIGxzciAxMCkgaW5cbiAgICAgbGV0IGxvID0gMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikgaW5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAoaGkgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAoaGkgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxhbmQgMHhGRikpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiBsZXQgYWRkX3V0Zl8xNmxlX3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyICh1IGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyICh1IGxzciA4KSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgbGV0IGhpID0gMHhEODAwIGxvciAodScgbHNyIDEwKSBpblxuICAgICBsZXQgbG8gPSAweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSBpblxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAoaGkgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMikgKENoYXIudW5zYWZlX2NociAobG8gbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxzciA4KSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGFkZF9zdWJzdHJpbmcgYiBzIG9mZnNldCBsZW4gPVxuICBpZiBvZmZzZXQgPCAwIHx8IGxlbiA8IDAgfHwgb2Zmc2V0ID4gU3RyaW5nLmxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX3N1YnN0cmluZy9hZGRfc3ViYnl0ZXNcIjtcbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIG9mZnNldCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9zdWJieXRlcyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGFkZF9zdWJzdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKSBvZmZzZXQgbGVuXG5cbmxldCBhZGRfc3RyaW5nIGIgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIDAgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfYnl0ZXMgYiBzID0gYWRkX3N0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpXG5cbmxldCBhZGRfYnVmZmVyIGIgYnMgPVxuICBhZGRfc3ViYnl0ZXMgYiBicy5idWZmZXIgMCBicy5wb3NpdGlvblxuXG4oKiB0aGlzIChwcml2YXRlKSBmdW5jdGlvbiBjb3VsZCBtb3ZlIGludG8gdGhlIHN0YW5kYXJkIGxpYnJhcnkgKilcbmxldCByZWFsbHlfaW5wdXRfdXBfdG8gaWMgYnVmIG9mcyBsZW4gPVxuICBsZXQgcmVjIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZCA9XG4gICAgaWYgdG9fcmVhZCA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGlucHV0IGljIGJ1ZiBvZnMgdG9fcmVhZCBpblxuICAgICAgaWYgciA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGFscmVhZHlfcmVhZCA9IGFscmVhZHlfcmVhZCArIHIgaW5cbiAgICAgICAgbGV0IG9mcyA9IG9mcyArIHIgaW5cbiAgICAgICAgbGV0IHRvX3JlYWQgPSB0b19yZWFkIC0gciBpblxuICAgICAgICBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkIH5vZnMgfnRvX3JlYWRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBpbiBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkOjAgfm9mcyB+dG9fcmVhZDpsZW5cblxuXG5sZXQgdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuID1cbiAgaWYgYi5wb3NpdGlvbiArIGxlbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBsZXQgbiA9IHJlYWxseV9pbnB1dF91cF90byBpYyBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbiBpblxuICAoKiBUaGUgYXNzZXJ0aW9uIGJlbG93IG1heSBmYWlsIGluIHdlaXJkIHNjZW5hcmlvIHdoZXJlXG4gICAgIHRocmVhZGVkL2ZpbmFsaXplciBjb2RlLCBydW4gYXN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZVxuICAgICBbcmVhbGx5X2lucHV0X3VwX3RvXSBjYWxsLCByYWNlcyBvbiB0aGUgYnVmZmVyOyB3ZSBkb24ndCBlbnN1cmVcbiAgICAgY29ycmVjdG5lc3MgaW4gdGhpcyBjYXNlLCBidXQgbmVlZCB0byBwcmVzZXJ2ZSB0aGUgaW52YXJpYW50cyBmb3JcbiAgICAgbWVtb3J5LXNhZmV0eSAoc2VlIGRpc2N1c3Npb24gb2YgW3Jlc2l6ZV0pLiAqKVxuICBhc3NlcnQgKGIucG9zaXRpb24gKyBuIDw9IGIubGVuZ3RoKTtcbiAgYi5wb3NpdGlvbiA8LSBiLnBvc2l0aW9uICsgbjtcbiAgblxuXG5sZXQgYWRkX2NoYW5uZWwgYiBpYyBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IGxlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuICAgKCogUFIjNTAwNCAqKVxuICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9jaGFubmVsXCI7XG4gIGxldCBuID0gdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuIGluXG4gICgqIEl0IGlzIGludGVudGlvbmFsIHRoYXQgYSBjb25zdW1lciBjYXRjaGluZyBFbmRfb2ZfZmlsZVxuICAgICB3aWxsIHNlZSB0aGUgZGF0YSB3cml0dGVuIChzZWUgIzY3MTksICM3MTM2KS4gKilcbiAgaWYgbiA8IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAoKVxuXG5sZXQgb3V0cHV0X2J1ZmZlciBvYyBiID1cbiAgb3V0cHV0IG9jIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgY2xvc2luZyA9IGZ1bmN0aW9uXG4gIHwgJygnIC0+ICcpJ1xuICB8ICd7JyAtPiAnfSdcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4oKiBvcGVuaW5nIGFuZCBjbG9zaW5nOiBvcGVuIGFuZCBjbG9zZSBjaGFyYWN0ZXJzLCB0eXBpY2FsbHkgKCBhbmQgKVxuICAgazogYmFsYW5jZSBvZiBvcGVuaW5nIGFuZCBjbG9zaW5nIGNoYXJzXG4gICBzOiB0aGUgc3RyaW5nIHdoZXJlIHdlIGFyZSBzZWFyY2hpbmdcbiAgIHN0YXJ0OiB0aGUgaW5kZXggd2hlcmUgd2Ugc3RhcnQgdGhlIHNlYXJjaC4gKilcbmxldCBhZHZhbmNlX3RvX2Nsb3Npbmcgb3BlbmluZyBjbG9zaW5nIGsgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBrIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gICAgaWYgcy5baV0gPSBvcGVuaW5nIHRoZW4gYWR2YW5jZSAoayArIDEpIChpICsgMSkgbGltIGVsc2VcbiAgICBpZiBzLltpXSA9IGNsb3NpbmcgdGhlblxuICAgICAgaWYgayA9IDAgdGhlbiBpIGVsc2UgYWR2YW5jZSAoayAtIDEpIChpICsgMSkgbGltXG4gICAgZWxzZSBhZHZhbmNlIGsgKGkgKyAxKSBsaW0gaW5cbiAgYWR2YW5jZSBrIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbmxldCBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIGxpbSBlbHNlXG4gICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknIHwgJ18nIC0+IGFkdmFuY2UgKGkgKyAxKSBsaW1cbiAgICB8IF8gLT4gaSBpblxuICBhZHZhbmNlIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbigqIFdlIGFyZSBqdXN0IGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gaWRlbnQgaW4gcywgc3RhcnRpbmcgYXQgc3RhcnQuICopXG5sZXQgZmluZF9pZGVudCBzIHN0YXJ0IGxpbSA9XG4gIGlmIHN0YXJ0ID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIG1hdGNoIHMuW3N0YXJ0XSB3aXRoXG4gICgqIFBhcmVudGhlc2l6ZWQgaWRlbnQgPyAqKVxuICB8ICcoJyB8ICd7JyBhcyBjIC0+XG4gICAgIGxldCBuZXdfc3RhcnQgPSBzdGFydCArIDEgaW5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX2Nsb3NpbmcgYyAoY2xvc2luZyBjKSAwIHMgbmV3X3N0YXJ0IGluXG4gICAgIFN0cmluZy5zdWIgcyBuZXdfc3RhcnQgKHN0b3AgLSBzdGFydCAtIDEpLCBzdG9wICsgMVxuICAoKiBSZWd1bGFyIGlkZW50ICopXG4gIHwgXyAtPlxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgKHN0YXJ0ICsgMSkgaW5cbiAgICAgU3RyaW5nLnN1YiBzIHN0YXJ0IChzdG9wIC0gc3RhcnQpLCBzdG9wXG5cbigqIFN1YnN0aXR1dGUgJGlkZW50LCAkKGlkZW50KSwgb3IgJHtpZGVudH0gaW4gcyxcbiAgICBhY2NvcmRpbmcgdG8gdGhlIGZ1bmN0aW9uIG1hcHBpbmcgZi4gKilcbmxldCBhZGRfc3Vic3RpdHV0ZSBiIGYgcyA9XG4gIGxldCBsaW0gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBzdWJzdCBwcmV2aW91cyBpID1cbiAgICBpZiBpIDwgbGltIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJyQnIGFzIGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJyQnIC0+XG4gICAgICAgICBsZXQgaiA9IGkgKyAxIGluXG4gICAgICAgICBsZXQgaWRlbnQsIG5leHRfaSA9IGZpbmRfaWRlbnQgcyBqIGxpbSBpblxuICAgICAgICAgYWRkX3N0cmluZyBiIChmIGlkZW50KTtcbiAgICAgICAgIHN1YnN0ICcgJyBuZXh0X2lcbiAgICAgIHwgY3VycmVudCB3aGVuIHByZXZpb3VzID09ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiAnXFxcXCc7XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnXFxcXCcgYXMgY3VycmVudCAtPlxuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgICB8IGN1cnJlbnQgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgIGVuZCBlbHNlXG4gICAgaWYgcHJldmlvdXMgPSAnXFxcXCcgdGhlbiBhZGRfY2hhciBiIHByZXZpb3VzIGluXG4gIHN1YnN0ICcgJyAwXG5cbmxldCB0cnVuY2F0ZSBiIGxlbiA9XG4gICAgaWYgbGVuIDwgMCB8fCBsZW4gPiBsZW5ndGggYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci50cnVuY2F0ZVwiXG4gICAgZWxzZVxuICAgICAgYi5wb3NpdGlvbiA8LSBsZW5cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgKCogTm90ZSB0aGF0IGIucG9zaXRpb24gaXMgbm90IGEgY29uc3RhbnQgYW5kIGNhbm5vdCBiZSBsaWZ0ZWQgb3V0IG9mIGF1eCAqKVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgYWRkX3NlcSBiIHNlcSA9IFNlcS5pdGVyIChhZGRfY2hhciBiKSBzZXFcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IGIgPSBjcmVhdGUgMzIgaW5cbiAgYWRkX3NlcSBiIGk7XG4gIGJcblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDE2IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQzMiA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ2NCA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NHVcIlxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxuXG5sZXQgYWRkX2ludDggYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyAxIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgdW5zYWZlX3NldF9pbnQ4IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDIgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICB1bnNhZmVfc2V0X2ludDE2IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQzMl9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDQgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICB1bnNhZmVfc2V0X2ludDMyIGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQ2NF9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDggaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA4O1xuICB1bnNhZmVfc2V0X2ludDY0IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9sZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MTZfYmUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAxNiB4KVxuXG5sZXQgYWRkX2ludDMyX2xlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQzMl9iZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDMyIHgpXG5cbmxldCBhZGRfaW50NjRfbGUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDY0X2JlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwNjQgeClcblxubGV0IGFkZF91aW50OCA9IGFkZF9pbnQ4XG5sZXQgYWRkX3VpbnQxNl9uZSA9IGFkZF9pbnQxNl9uZVxubGV0IGFkZF91aW50MTZfbGUgPSBhZGRfaW50MTZfbGVcbmxldCBhZGRfdWludDE2X2JlID0gYWRkX2ludDE2X2JlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIFhhdmllciBMZXJveSBhbmQgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG5sZXQga2ZwcmludGYgayBvIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBvIGFjYzsgayBvKSBFbmRfb2ZfYWNjIGZtdFxubGV0IGticHJpbnRmIGsgYiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IGJ1ZnB1dF9hY2MgYiBhY2M7IGsgYikgRW5kX29mX2FjYyBmbXRcbmxldCBpa2ZwcmludGYgayBvYyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIG9jIGZtdFxuXG5sZXQgZnByaW50ZiBvYyBmbXQgPSBrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgYnByaW50ZiBiIGZtdCA9IGticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IGlmcHJpbnRmIG9jIGZtdCA9IGlrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3Rkb3V0IGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBzdGRlcnIgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGsnIGFjYyA9XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgICBzdHJwdXRfYWNjIGJ1ZiBhY2M7XG4gICAgayAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXRcblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUga2V5ID0gc3RyaW5nXG50eXBlIGRvYyA9IHN0cmluZ1xudHlwZSB1c2FnZV9tc2cgPSBzdHJpbmdcbnR5cGUgYW5vbl9mdW4gPSAoc3RyaW5nIC0+IHVuaXQpXG5cbnR5cGUgc3BlYyA9XG4gIHwgVW5pdCBvZiAodW5pdCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB1bml0IGFyZ3VtZW50ICopXG4gIHwgQm9vbCBvZiAoYm9vbCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGJvb2wgYXJndW1lbnQgKilcbiAgfCBTZXQgb2YgYm9vbCByZWYgICAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0cnVlICopXG4gIHwgQ2xlYXIgb2YgYm9vbCByZWYgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gZmFsc2UgKilcbiAgfCBTdHJpbmcgb2YgKHN0cmluZyAtPiB1bml0KSAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgU2V0X3N0cmluZyBvZiBzdHJpbmcgcmVmICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IEludCBvZiAoaW50IC0+IHVuaXQpICAgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYW4gaW50IGFyZ3VtZW50ICopXG4gIHwgU2V0X2ludCBvZiBpbnQgcmVmICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGludCBhcmd1bWVudCAqKVxuICB8IEZsb2F0IG9mIChmbG9hdCAtPiB1bml0KSAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFNldF9mbG9hdCBvZiBmbG9hdCByZWYgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFR1cGxlIG9mIHNwZWMgbGlzdCAgICAgICAgICgqIFRha2Ugc2V2ZXJhbCBhcmd1bWVudHMgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWMgbGlzdCAqKVxuICB8IFN5bWJvbCBvZiBzdHJpbmcgbGlzdCAqIChzdHJpbmcgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUYWtlIG9uZSBvZiB0aGUgc3ltYm9scyBhcyBhcmd1bWVudCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBzeW1ib2wuICopXG4gIHwgUmVzdCBvZiAoc3RyaW5nIC0+IHVuaXQpICAgKCogU3RvcCBpbnRlcnByZXRpbmcga2V5d29yZHMgYW5kIGNhbGwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aCBlYWNoIHJlbWFpbmluZyBhcmd1bWVudCAqKVxuICB8IEV4cGFuZCBvZiAoc3RyaW5nIC0+IHN0cmluZyBhcnJheSkgKCogSWYgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW1wiLWZvb1wiOyBcImFyZ1wiXSBAIHJlc3RdIHdoZXJlIFwiZm9vXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHJlZ2lzdGVyZWQgYXMgW0V4cGFuZCBmXSwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyBbZiBcImFyZ1wiIEAgcmVzdF0gYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQuIE9ubHkgYWxsb3dlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXS4gKilcblxuZXhjZXB0aW9uIEJhZCBvZiBzdHJpbmdcbmV4Y2VwdGlvbiBIZWxwIG9mIHN0cmluZ1xuXG50eXBlIGVycm9yID1cbiAgfCBVbmtub3duIG9mIHN0cmluZ1xuICB8IFdyb25nIG9mIHN0cmluZyAqIHN0cmluZyAqIHN0cmluZyAgKCogb3B0aW9uLCBhY3R1YWwsIGV4cGVjdGVkICopXG4gIHwgTWlzc2luZyBvZiBzdHJpbmdcbiAgfCBNZXNzYWdlIG9mIHN0cmluZ1xuXG5leGNlcHRpb24gU3RvcCBvZiBlcnJvciAoKiB1c2VkIGludGVybmFsbHkgKilcblxub3BlbiBQcmludGZcblxubGV0IHJlYyBhc3NvYzMgeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKHkxLCB5MiwgXykgOjogXyB3aGVuIHkxID0geCAtPiB5MlxuICB8IF8gOjogdCAtPiBhc3NvYzMgeCB0XG5cblxubGV0IHNwbGl0IHMgPVxuICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc9JyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIFN0cmluZy5zdWIgcyAwIGksIFN0cmluZy5zdWIgcyAoaSsxKSAobGVuLShpKzEpKVxuXG5cbmxldCBtYWtlX3N5bWxpc3QgcHJlZml4IHNlcCBzdWZmaXggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiPG5vbmU+XCJcbiAgfCBoOjp0IC0+IChMaXN0LmZvbGRfbGVmdCAoZnVuIHggeSAtPiB4IF4gc2VwIF4geSkgKHByZWZpeCBeIGgpIHQpIF4gc3VmZml4XG5cblxubGV0IHByaW50X3NwZWMgYnVmIChrZXksIHNwZWMsIGRvYykgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRvYyA+IDAgdGhlblxuICAgIG1hdGNoIHNwZWMgd2l0aFxuICAgIHwgU3ltYm9sIChsLCBfKSAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXMlc1xcblwiIGtleSAobWFrZV9zeW1saXN0IFwie1wiIFwifFwiIFwifVwiIGwpIGRvY1xuICAgIHwgXyAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXNcXG5cIiBrZXkgZG9jXG5cblxubGV0IGhlbHBfYWN0aW9uICgpID0gcmFpc2UgKFN0b3AgKFVua25vd24gXCItaGVscFwiKSlcblxubGV0IGFkZF9oZWxwIHNwZWNsaXN0ID1cbiAgbGV0IGFkZDEgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItaGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGFuZCBhZGQyID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi0taGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGluXG4gIHNwZWNsaXN0IEAgKGFkZDEgQCBhZGQyKVxuXG5cbmxldCB1c2FnZV9iIGJ1ZiBzcGVjbGlzdCBlcnJtc2cgPVxuICBicHJpbnRmIGJ1ZiBcIiVzXFxuXCIgZXJybXNnO1xuICBMaXN0Lml0ZXIgKHByaW50X3NwZWMgYnVmKSAoYWRkX2hlbHAgc3BlY2xpc3QpXG5cblxubGV0IHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIHVzYWdlX2IgYiBzcGVjbGlzdCBlcnJtc2c7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IHVzYWdlIHNwZWNsaXN0IGVycm1zZyA9XG4gIGVwcmludGYgXCIlc1wiICh1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnKVxuXG5cbmxldCBjdXJyZW50ID0gcmVmIDBcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGJvb2xfb2Zfc3RyaW5nIHgpXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBhbGxvd19leHBhbmQgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJybXNnID1cbiAgbGV0IGluaXRwb3MgPSAhY3VycmVudCBpblxuICBsZXQgY29udmVydF9lcnJvciBlcnJvciA9XG4gICAgKCogY29udmVydCBhbiBpbnRlcm5hbCBlcnJvciB0byBhIEJhZC9IZWxwIGV4Y2VwdGlvblxuICAgICAgICpvciogYWRkIHRoZSBwcm9ncmFtIG5hbWUgYXMgYSBwcmVmaXggYW5kIHRoZSB1c2FnZSBtZXNzYWdlIGFzIGEgc3VmZml4XG4gICAgICAgdG8gYW4gdXNlci1yYWlzZWQgQmFkIGV4Y2VwdGlvbi5cbiAgICAqKVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgICBsZXQgcHJvZ25hbWUgPVxuICAgICAgaWYgaW5pdHBvcyA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKGluaXRwb3MpIGVsc2UgXCIoPylcIiBpblxuICAgIGJlZ2luIG1hdGNoIGVycm9yIHdpdGhcbiAgICAgIHwgVW5rbm93biBcIi1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBcIi0taGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB1bmtub3duIG9wdGlvbiAnJXMnLlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgTWlzc2luZyBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IG9wdGlvbiAnJXMnIG5lZWRzIGFuIGFyZ3VtZW50LlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgV3JvbmcgKG9wdCwgYXJnLCBleHBlY3RlZCkgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogd3JvbmcgYXJndW1lbnQgJyVzJzsgb3B0aW9uICclcycgZXhwZWN0cyAlcy5cXG5cIlxuICAgICAgICAgICAgICAgICAgcHJvZ25hbWUgYXJnIG9wdCBleHBlY3RlZFxuICAgICAgfCBNZXNzYWdlIHMgLT4gKCogdXNlciBlcnJvciBtZXNzYWdlICopXG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6ICVzLlxcblwiIHByb2duYW1lIHNcbiAgICBlbmQ7XG4gICAgdXNhZ2VfYiBiICFzcGVjbGlzdCBlcnJtc2c7XG4gICAgaWYgZXJyb3IgPSBVbmtub3duIFwiLWhlbHBcIiB8fCBlcnJvciA9IFVua25vd24gXCItLWhlbHBcIlxuICAgIHRoZW4gSGVscCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gICAgZWxzZSBCYWQgKEJ1ZmZlci5jb250ZW50cyBiKVxuICBpblxuICBpbmNyIGN1cnJlbnQ7XG4gIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgZG9cbiAgICBiZWdpbiB0cnlcbiAgICAgIGxldCBzID0gIWFyZ3YuKCFjdXJyZW50KSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBzID49IDEgJiYgcy5bMF0gPSAnLScgdGhlbiBiZWdpblxuICAgICAgICBsZXQgYWN0aW9uLCBmb2xsb3cgPVxuICAgICAgICAgIHRyeSBhc3NvYzMgcyAhc3BlY2xpc3QsIE5vbmVcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IGtleXdvcmQsIGFyZyA9IHNwbGl0IHMgaW5cbiAgICAgICAgICAgIGFzc29jMyBrZXl3b3JkICFzcGVjbGlzdCwgU29tZSBhcmdcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RvcCAoVW5rbm93biBzKSlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5vX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm5vIGFyZ3VtZW50XCIpKSkgaW5cbiAgICAgICAgbGV0IGdldF9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIGlmICFjdXJyZW50ICsgMSA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgZWxzZSByYWlzZSAoU3RvcCAoTWlzc2luZyBzKSlcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IGFyZ1xuICAgICAgICBpblxuICAgICAgICBsZXQgY29uc3VtZV9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGluY3IgY3VycmVudFxuICAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgIGluXG4gICAgICAgIGxldCByZWMgdHJlYXRfYWN0aW9uID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbml0IGYgLT4gbm9fYXJnICgpOyBmICgpO1xuICAgICAgICB8IEJvb2wgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGJvb2xfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgYm9vbGVhblwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgcyAtPiBmIHNcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldCByIC0+IG5vX2FyZyAoKTsgciA6PSB0cnVlO1xuICAgICAgICB8IENsZWFyIHIgLT4gbm9fYXJnICgpOyByIDo9IGZhbHNlO1xuICAgICAgICB8IFN0cmluZyBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTeW1ib2wgKHN5bWIsIGYpIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgaWYgTGlzdC5tZW0gYXJnIHN5bWIgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJvbmUgb2Y6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIChtYWtlX3N5bWxpc3QgXCJcIiBcIiBcIiBcIlwiIHN5bWIpKSkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBTZXRfc3RyaW5nIHIgLT5cbiAgICAgICAgICAgIHIgOj0gZ2V0X2FyZyAoKTtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEludCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2ludCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgRmxvYXQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2Zsb2F0IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFR1cGxlIHNwZWNzIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICBMaXN0Lml0ZXIgdHJlYXRfYWN0aW9uIHNwZWNzO1xuICAgICAgICB8IFJlc3QgZiAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSAtIDEgZG9cbiAgICAgICAgICAgICAgZiAhYXJndi4oIWN1cnJlbnQgKyAxKTtcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICB8IEV4cGFuZCBmIC0+XG4gICAgICAgICAgICBpZiBub3QgYWxsb3dfZXhwYW5kIHRoZW5cbiAgICAgICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJBcmcuRXhwYW5kIGlzIGlzIG9ubHkgYWxsb3dlZCB3aXRoIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcmcucGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNcIik7XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgbGV0IG5ld2FyZyA9IGYgYXJnIGluXG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBBcnJheS5zdWIgIWFyZ3YgMCAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgYW5kIGFmdGVyID1cbiAgICAgICAgICAgICAgQXJyYXkuc3ViICFhcmd2ICghY3VycmVudCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAoKEFycmF5Lmxlbmd0aCAhYXJndikgLSAhY3VycmVudCAtIDEpIGluXG4gICAgICAgICAgICBhcmd2Oj0gQXJyYXkuY29uY2F0IFtiZWZvcmU7bmV3YXJnO2FmdGVyXTtcbiAgICAgICAgaW5cbiAgICAgICAgdHJlYXRfYWN0aW9uIGFjdGlvbiBlbmRcbiAgICAgIGVsc2UgYW5vbmZ1biBzXG4gICAgd2l0aCB8IEJhZCBtIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIChNZXNzYWdlIG0pKTtcbiAgICAgICAgIHwgU3RvcCBlIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIGUpO1xuICAgIGVuZDtcbiAgICBpbmNyIGN1cnJlbnRcbiAgZG9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IHRydWUgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnXG5cbmxldCBwYXJzZV9hcmd2X2R5bmFtaWMgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggZmFsc2UgY3VycmVudCAocmVmIGFyZ3YpIHNwZWNsaXN0IGFub25mdW5cbiAgICBlcnJtc2dcblxuXG5sZXQgcGFyc2VfYXJndiA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FyZ3ZfZHluYW1pYyB+Y3VycmVudDpjdXJyZW50IGFyZ3YgKHJlZiBzcGVjbGlzdCkgYW5vbmZ1biBlcnJtc2dcblxuXG5sZXQgcGFyc2UgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3YgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgcGFyc2VfZHluYW1pYyBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndl9keW5hbWljIFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cbmxldCBwYXJzZV9leHBhbmQgbCBmIG1zZyA9XG4gIHRyeVxuICAgIGxldCBhcmd2ID0gcmVmIFN5cy5hcmd2IGluXG4gICAgbGV0IHNwZWMgPSByZWYgbCBpblxuICAgIGxldCBjdXJyZW50ID0gcmVmICghY3VycmVudCkgaW5cbiAgICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlYyBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgc2Vjb25kX3dvcmQgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIG4gPVxuICAgIGlmIG4gPj0gbGVuIHRoZW4gbGVuXG4gICAgZWxzZSBpZiBzLltuXSA9ICcgJyB0aGVuIGxvb3AgKG4rMSlcbiAgICBlbHNlIG5cbiAgaW5cbiAgbWF0Y2ggU3RyaW5nLmluZGV4IHMgJ1xcdCcgd2l0aFxuICB8IG4gLT4gbG9vcCAobisxKVxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgIGJlZ2luIG1hdGNoIFN0cmluZy5pbmRleCBzICcgJyB3aXRoXG4gICAgICB8IG4gLT4gbG9vcCAobisxKVxuICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IGxlblxuICAgICAgZW5kXG5cblxubGV0IG1heF9hcmdfbGVuIGN1ciAoa3dkLCBzcGVjLCBkb2MpID1cbiAgbWF0Y2ggc3BlYyB3aXRoXG4gIHwgU3ltYm9sIF8gLT4gbWF4IGN1ciAoU3RyaW5nLmxlbmd0aCBrd2QpXG4gIHwgXyAtPiBtYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZCArIHNlY29uZF93b3JkIGRvYylcblxuXG5sZXQgcmVwbGFjZV9sZWFkaW5nX3RhYiBzID1cbiAgbGV0IHNlZW4gPSByZWYgZmFsc2UgaW5cbiAgU3RyaW5nLm1hcCAoZnVuY3Rpb24gJ1xcdCcgd2hlbiBub3QgIXNlZW4gLT4gc2VlbiA6PSB0cnVlOyAnICcgfCBjIC0+IGMpIHNcblxubGV0IGFkZF9wYWRkaW5nIGxlbiBrc2QgPVxuICBtYXRjaCBrc2Qgd2l0aFxuICB8IChfLCBfLCBcIlwiKSAtPlxuICAgICAgKCogRG8gbm90IHBhZCB1bmRvY3VtZW50ZWQgb3B0aW9ucywgc28gdGhhdCB0aGV5IHN0aWxsIGRvbid0IHNob3cgdXAgd2hlblxuICAgICAgICogcnVuIHRocm91Z2ggW3VzYWdlXSBvciBbcGFyc2VdLiAqKVxuICAgICAga3NkXG4gIHwgKGt3ZCwgKFN5bWJvbCBfIGFzIHNwZWMpLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgKChtYXggMCAobGVuIC0gY3V0Y29sKSkgKyAzKSAnICcgaW5cbiAgICAgIChrd2QsIHNwZWMsIFwiXFxuXCIgXiBzcGFjZXMgXiByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgfCAoa3dkLCBzcGVjLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQga3dkX2xlbiA9IFN0cmluZy5sZW5ndGgga3dkIGluXG4gICAgICBsZXQgZGlmZiA9IGxlbiAtIGt3ZF9sZW4gLSBjdXRjb2wgaW5cbiAgICAgIGlmIGRpZmYgPD0gMCB0aGVuXG4gICAgICAgIChrd2QsIHNwZWMsIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgZGlmZiAnICcgaW5cbiAgICAgICAgbGV0IHByZWZpeCA9IFN0cmluZy5zdWIgKHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKSAwIGN1dGNvbCBpblxuICAgICAgICBsZXQgc3VmZml4ID0gU3RyaW5nLnN1YiBtc2cgY3V0Y29sIChTdHJpbmcubGVuZ3RoIG1zZyAtIGN1dGNvbCkgaW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcHJlZml4IF4gc3BhY2VzIF4gc3VmZml4KVxuXG5cbmxldCBhbGlnbiA/KGxpbWl0PW1heF9pbnQpIHNwZWNsaXN0ID1cbiAgbGV0IGNvbXBsZXRlZCA9IGFkZF9oZWxwIHNwZWNsaXN0IGluXG4gIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCBtYXhfYXJnX2xlbiAwIGNvbXBsZXRlZCBpblxuICBsZXQgbGVuID0gbWluIGxlbiBsaW1pdCBpblxuICBMaXN0Lm1hcCAoYWRkX3BhZGRpbmcgbGVuKSBjb21wbGV0ZWRcblxubGV0IHRyaW1fY3IgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgaWYgbGVuID4gMCAmJiBTdHJpbmcuZ2V0IHMgKGxlbiAtIDEpID0gJ1xccicgdGhlblxuICAgIFN0cmluZy5zdWIgcyAwIChsZW4gLSAxKVxuICBlbHNlXG4gICAgc1xuXG5sZXQgcmVhZF9hdXggdHJpbSBzZXAgZmlsZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGUgaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIGxldCB3b3JkcyA9IHJlZiBbXSBpblxuICBsZXQgc3Rhc2ggKCkgPVxuICAgIGxldCB3b3JkID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICAgIGxldCB3b3JkID0gaWYgdHJpbSB0aGVuIHRyaW1fY3Igd29yZCBlbHNlIHdvcmQgaW5cbiAgICB3b3JkcyA6PSB3b3JkIDo6ICF3b3JkcztcbiAgICBCdWZmZXIuY2xlYXIgYnVmXG4gIGluXG4gIGJlZ2luXG4gICAgdHJ5IHdoaWxlIHRydWUgZG9cbiAgICAgICAgbGV0IGMgPSBpbnB1dF9jaGFyIGljIGluXG4gICAgICAgIGlmIGMgPSBzZXAgdGhlbiBzdGFzaCAoKSBlbHNlIEJ1ZmZlci5hZGRfY2hhciBidWYgY1xuICAgICAgZG9uZVxuICAgIHdpdGggRW5kX29mX2ZpbGUgLT4gKClcbiAgZW5kO1xuICBpZiBCdWZmZXIubGVuZ3RoIGJ1ZiA+IDAgdGhlbiBzdGFzaCAoKTtcbiAgY2xvc2VfaW4gaWM7XG4gIEFycmF5Lm9mX2xpc3QgKExpc3QucmV2ICF3b3JkcylcblxubGV0IHJlYWRfYXJnID0gcmVhZF9hdXggdHJ1ZSAnXFxuJ1xuXG5sZXQgcmVhZF9hcmcwID0gcmVhZF9hdXggZmFsc2UgJ1xceDAwJ1xuXG5sZXQgd3JpdGVfYXV4IHNlcCBmaWxlIGFyZ3MgPVxuICBsZXQgb2MgPSBvcGVuX291dF9iaW4gZmlsZSBpblxuICBBcnJheS5pdGVyIChmdW4gcyAtPiBmcHJpbnRmIG9jIFwiJXMlY1wiIHMgc2VwKSBhcmdzO1xuICBjbG9zZV9vdXQgb2NcblxubGV0IHdyaXRlX2FyZyA9IHdyaXRlX2F1eCAnXFxuJ1xuXG5sZXQgd3JpdGVfYXJnMCA9IHdyaXRlX2F1eCAnXFx4MDAnXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGlkIDogJ2EgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5sZXQgY29uc3QgYyBfID0gY1xubGV0IGZsaXAgZiB4IHkgPSBmIHkgeFxubGV0IG5lZ2F0ZSBwIHYgPSBub3QgKHAgdilcblxuZXhjZXB0aW9uIEZpbmFsbHlfcmFpc2VkIG9mIGV4blxuXG5sZXQgcHJvdGVjdCB+KGZpbmFsbHkgOiB1bml0IC0+IHVuaXQpIHdvcmsgPVxuICBsZXQgZmluYWxseV9ub19leG4gKCkgPVxuICAgIHRyeSBmaW5hbGx5ICgpIHdpdGggZSAtPlxuICAgICAgbGV0IGJ0ID0gUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIChGaW5hbGx5X3JhaXNlZCBlKSBidFxuICBpblxuICBtYXRjaCB3b3JrICgpIHdpdGhcbiAgfCByZXN1bHQgLT4gZmluYWxseV9ub19leG4gKCkgOyByZXN1bHRcbiAgfCBleGNlcHRpb24gd29ya19leG4gLT5cbiAgICAgIGxldCB3b3JrX2J0ID0gUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIGZpbmFsbHlfbm9fZXhuICgpIDtcbiAgICAgIFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIHdvcmtfZXhuIHdvcmtfYnRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBzdGF0ID0ge1xuICBtaW5vcl93b3JkcyA6IGZsb2F0O1xuICBwcm9tb3RlZF93b3JkcyA6IGZsb2F0O1xuICBtYWpvcl93b3JkcyA6IGZsb2F0O1xuICBtaW5vcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgbWFqb3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIGhlYXBfd29yZHMgOiBpbnQ7XG4gIGhlYXBfY2h1bmtzIDogaW50O1xuICBsaXZlX3dvcmRzIDogaW50O1xuICBsaXZlX2Jsb2NrcyA6IGludDtcbiAgZnJlZV93b3JkcyA6IGludDtcbiAgZnJlZV9ibG9ja3MgOiBpbnQ7XG4gIGxhcmdlc3RfZnJlZSA6IGludDtcbiAgZnJhZ21lbnRzIDogaW50O1xuICBjb21wYWN0aW9ucyA6IGludDtcbiAgdG9wX2hlYXBfd29yZHMgOiBpbnQ7XG4gIHN0YWNrX3NpemUgOiBpbnQ7XG59XG5cbnR5cGUgY29udHJvbCA9IHtcbiAgbXV0YWJsZSBtaW5vcl9oZWFwX3NpemUgOiBpbnQ7XG4gIG11dGFibGUgbWFqb3JfaGVhcF9pbmNyZW1lbnQgOiBpbnQ7XG4gIG11dGFibGUgc3BhY2Vfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgdmVyYm9zZSA6IGludDtcbiAgbXV0YWJsZSBtYXhfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgc3RhY2tfbGltaXQgOiBpbnQ7XG4gIG11dGFibGUgYWxsb2NhdGlvbl9wb2xpY3kgOiBpbnQ7XG4gIHdpbmRvd19zaXplIDogaW50O1xuICBjdXN0b21fbWFqb3JfcmF0aW8gOiBpbnQ7XG4gIGN1c3RvbV9taW5vcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX21heF9zaXplIDogaW50O1xufVxuXG5leHRlcm5hbCBzdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3N0YXRcIlxuZXh0ZXJuYWwgcXVpY2tfc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19xdWlja19zdGF0XCJcbmV4dGVybmFsIGNvdW50ZXJzIDogdW5pdCAtPiAoZmxvYXQgKiBmbG9hdCAqIGZsb2F0KSA9IFwiY2FtbF9nY19jb3VudGVyc1wiXG5leHRlcm5hbCBtaW5vcl93b3JkcyA6IHVuaXQgLT4gKGZsb2F0IFtAdW5ib3hlZF0pXG4gID0gXCJjYW1sX2djX21pbm9yX3dvcmRzXCIgXCJjYW1sX2djX21pbm9yX3dvcmRzX3VuYm94ZWRcIlxuZXh0ZXJuYWwgZ2V0IDogdW5pdCAtPiBjb250cm9sID0gXCJjYW1sX2djX2dldFwiXG5leHRlcm5hbCBzZXQgOiBjb250cm9sIC0+IHVuaXQgPSBcImNhbWxfZ2Nfc2V0XCJcbmV4dGVybmFsIG1pbm9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21pbm9yXCJcbmV4dGVybmFsIG1ham9yX3NsaWNlIDogaW50IC0+IGludCA9IFwiY2FtbF9nY19tYWpvcl9zbGljZVwiXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBmdWxsX21ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2Z1bGxfbWFqb3JcIlxuZXh0ZXJuYWwgY29tcGFjdCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19jb21wYWN0aW9uXCJcbmV4dGVybmFsIGdldF9taW5vcl9mcmVlIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21pbm9yX2ZyZWVcIlxuZXh0ZXJuYWwgZ2V0X2J1Y2tldCA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2J1Y2tldFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBnZXRfY3JlZGl0IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2NyZWRpdFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBodWdlX2ZhbGxiYWNrX2NvdW50IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudFwiXG5cbm9wZW4gUHJpbnRmXG5cbmxldCBwcmludF9zdGF0IGMgPVxuICBsZXQgc3QgPSBzdGF0ICgpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0Lm1pbm9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJtYWpvcl9jb2xsZWN0aW9uczogJWRcXG5cIiBzdC5tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiY29tcGFjdGlvbnM6ICAgICAgICVkXFxuXCIgc3QuY29tcGFjdGlvbnM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDEgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJS4wZlwiIHN0Lm1pbm9yX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5taW5vcl93b3JkcztcbiAgZnByaW50ZiBjIFwicHJvbW90ZWRfd29yZHM6ICUqLjBmXFxuXCIgbDEgc3QucHJvbW90ZWRfd29yZHM7XG4gIGZwcmludGYgYyBcIm1ham9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1ham9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwyID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiVkXCIgc3QudG9wX2hlYXBfd29yZHMpIGluXG4gIGZwcmludGYgYyBcInRvcF9oZWFwX3dvcmRzOiAlKmRcXG5cIiBsMiBzdC50b3BfaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwiaGVhcF93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmhlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImxpdmVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5saXZlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJmcmVlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuZnJlZV93b3JkcztcbiAgZnByaW50ZiBjIFwibGFyZ2VzdF9mcmVlOiAgICUqZFxcblwiIGwyIHN0Lmxhcmdlc3RfZnJlZTtcbiAgZnByaW50ZiBjIFwiZnJhZ21lbnRzOiAgICAgICUqZFxcblwiIGwyIHN0LmZyYWdtZW50cztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGZwcmludGYgYyBcImxpdmVfYmxvY2tzOiAlZFxcblwiIHN0LmxpdmVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJmcmVlX2Jsb2NrczogJWRcXG5cIiBzdC5mcmVlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiaGVhcF9jaHVua3M6ICVkXFxuXCIgc3QuaGVhcF9jaHVua3NcblxuXG5sZXQgYWxsb2NhdGVkX2J5dGVzICgpID1cbiAgbGV0IChtaSwgcHJvLCBtYSkgPSBjb3VudGVycyAoKSBpblxuICAobWkgKy4gbWEgLS4gcHJvKSAqLiBmbG9hdF9vZl9pbnQgKFN5cy53b3JkX3NpemUgLyA4KVxuXG5cbmV4dGVybmFsIGZpbmFsaXNlIDogKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVnaXN0ZXJcIlxuZXh0ZXJuYWwgZmluYWxpc2VfbGFzdCA6ICh1bml0IC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPVxuICBcImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZmluYWxpc2VfcmVsZWFzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWxlYXNlXCJcblxuXG50eXBlIGFsYXJtID0gYm9vbCByZWZcbnR5cGUgYWxhcm1fcmVjID0ge2FjdGl2ZSA6IGFsYXJtOyBmIDogdW5pdCAtPiB1bml0fVxuXG5sZXQgcmVjIGNhbGxfYWxhcm0gYXJlYyA9XG4gIGlmICEoYXJlYy5hY3RpdmUpIHRoZW4gYmVnaW5cbiAgICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gICAgYXJlYy5mICgpO1xuICBlbmRcblxuXG5sZXQgY3JlYXRlX2FsYXJtIGYgPVxuICBsZXQgYXJlYyA9IHsgYWN0aXZlID0gcmVmIHRydWU7IGYgPSBmIH0gaW5cbiAgZmluYWxpc2UgY2FsbF9hbGFybSBhcmVjO1xuICBhcmVjLmFjdGl2ZVxuXG5cbmxldCBkZWxldGVfYWxhcm0gYSA9IGEgOj0gZmFsc2VcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTWVzc2FnZSBkaWdlc3QgKE1ENSkgKilcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlID0gU3RyaW5nLmNvbXBhcmVcbmxldCBlcXVhbCA9IFN0cmluZy5lcXVhbFxuXG5leHRlcm5hbCB1bnNhZmVfc3RyaW5nOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9zdHJpbmdcIlxuZXh0ZXJuYWwgY2hhbm5lbDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfY2hhblwiXG5cbmxldCBzdHJpbmcgc3RyID1cbiAgdW5zYWZlX3N0cmluZyBzdHIgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbmxldCBieXRlcyBiID0gc3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpXG5cbmxldCBzdWJzdHJpbmcgc3RyIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gU3RyaW5nLmxlbmd0aCBzdHIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9zdHJpbmcgc3RyIG9mcyBsZW5cblxubGV0IHN1YmJ5dGVzIGIgb2ZzIGxlbiA9IHN1YnN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKSBvZnMgbGVuXG5cbmxldCBmaWxlIGZpbGVuYW1lID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZW5hbWUgaW5cbiAgbWF0Y2ggY2hhbm5lbCBpYyAoLTEpIHdpdGhcbiAgICB8IGQgLT4gY2xvc2VfaW4gaWM7IGRcbiAgICB8IGV4Y2VwdGlvbiBlIC0+IGNsb3NlX2luIGljOyByYWlzZSBlXG5cbmxldCBvdXRwdXQgY2hhbiBkaWdlc3QgPVxuICBvdXRwdXRfc3RyaW5nIGNoYW4gZGlnZXN0XG5cbmxldCBpbnB1dCBjaGFuID0gcmVhbGx5X2lucHV0X3N0cmluZyBjaGFuIDE2XG5cbmxldCBjaGFyX2hleCBuID1cbiAgQ2hhci51bnNhZmVfY2hyIChuICsgaWYgbiA8IDEwIHRoZW4gQ2hhci5jb2RlICcwJyBlbHNlIChDaGFyLmNvZGUgJ2EnIC0gMTApKVxuXG5sZXQgdG9faGV4IGQgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGQgPD4gMTYgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC50b19oZXhcIjtcbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAzMiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBsZXQgeCA9IENoYXIuY29kZSBkLltpXSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIpIChjaGFyX2hleCAoeCBsc3IgNCkpO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIrMSkgKGNoYXJfaGV4ICh4IGxhbmQgMHgwZikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuXG5sZXQgZnJvbV9oZXggcyA9XG4gIGlmIFN0cmluZy5sZW5ndGggcyA8PiAzMiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LmZyb21faGV4XCI7XG4gIGxldCBkaWdpdCBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcwJy4uJzknIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICcwJ1xuICAgIHwgJ0EnLi4nRicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ0EnICsgMTBcbiAgICB8ICdhJy4uJ2YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdhJyArIDEwXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRGlnZXN0LmZyb21faGV4XCIpXG4gIGluXG4gIGxldCBieXRlIGkgPSBkaWdpdCBzLltpXSBsc2wgNCArIGRpZ2l0IHMuW2krMV0gaW5cbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAxNiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBCeXRlcy5zZXQgcmVzdWx0IGkgKENoYXIuY2hyIChieXRlICgyICogaSkpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICBUaGlzIGlzIGEgbGFnZ2VkLUZpYm9uYWNjaSBGKDU1LCAyNCwgKykgd2l0aCBhIG1vZGlmaWVkIGFkZGl0aW9uXG4gICBmdW5jdGlvbiB0byBlbmhhbmNlIHRoZSBtaXhpbmcgb2YgYml0cy5cbiAgIElmIHdlIHVzZSBub3JtYWwgYWRkaXRpb24sIHRoZSBsb3ctb3JkZXIgYml0IGZhaWxzIHRlc3RzIDEgYW5kIDdcbiAgIG9mIHRoZSBEaWVoYXJkIHRlc3Qgc3VpdGUsIGFuZCBiaXRzIDEgYW5kIDIgYWxzbyBmYWlsIHRlc3QgNy5cbiAgIElmIHdlIHVzZSBtdWx0aXBsaWNhdGlvbiBhcyBzdWdnZXN0ZWQgYnkgTWFyc2FnbGlhLCBpdCBkb2Vzbid0IGZhcmVcbiAgIG11Y2ggYmV0dGVyLlxuICAgQnkgbWl4aW5nIHRoZSBiaXRzIG9mIG9uZSBvZiB0aGUgbnVtYmVycyBiZWZvcmUgYWRkaXRpb24gKFhPUiB0aGVcbiAgIDUgaGlnaC1vcmRlciBiaXRzIGludG8gdGhlIGxvdy1vcmRlciBiaXRzKSwgd2UgZ2V0IGEgZ2VuZXJhdG9yIHRoYXRcbiAgIHBhc3NlcyBhbGwgdGhlIERpZWhhcmQgdGVzdHMuXG4qKVxuXG5leHRlcm5hbCByYW5kb21fc2VlZDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG5cbiAgdHlwZSB0ID0geyBzdCA6IGludCBhcnJheTsgbXV0YWJsZSBpZHggOiBpbnQgfVxuXG4gIGxldCBuZXdfc3RhdGUgKCkgPSB7IHN0ID0gQXJyYXkubWFrZSA1NSAwOyBpZHggPSAwIH1cbiAgbGV0IGFzc2lnbiBzdDEgc3QyID1cbiAgICBBcnJheS5ibGl0IHN0Mi5zdCAwIHN0MS5zdCAwIDU1O1xuICAgIHN0MS5pZHggPC0gc3QyLmlkeFxuXG5cbiAgbGV0IGZ1bGxfaW5pdCBzIHNlZWQgPVxuICAgIGxldCBjb21iaW5lIGFjY3UgeCA9IERpZ2VzdC5zdHJpbmcgKGFjY3UgXiBJbnQudG9fc3RyaW5nIHgpIGluXG4gICAgbGV0IGV4dHJhY3QgZCA9XG4gICAgICBDaGFyLmNvZGUgZC5bMF0gKyAoQ2hhci5jb2RlIGQuWzFdIGxzbCA4KSArIChDaGFyLmNvZGUgZC5bMl0gbHNsIDE2KVxuICAgICAgKyAoQ2hhci5jb2RlIGQuWzNdIGxzbCAyNClcbiAgICBpblxuICAgIGxldCBzZWVkID0gaWYgQXJyYXkubGVuZ3RoIHNlZWQgPSAwIHRoZW4gW3wgMCB8XSBlbHNlIHNlZWQgaW5cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBzZWVkIGluXG4gICAgZm9yIGkgPSAwIHRvIDU0IGRvXG4gICAgICBzLnN0LihpKSA8LSBpO1xuICAgIGRvbmU7XG4gICAgbGV0IGFjY3UgPSByZWYgXCJ4XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgKyBtYXggNTUgbCBkb1xuICAgICAgbGV0IGogPSBpIG1vZCA1NSBpblxuICAgICAgbGV0IGsgPSBpIG1vZCBsIGluXG4gICAgICBhY2N1IDo9IGNvbWJpbmUgIWFjY3Ugc2VlZC4oayk7XG4gICAgICBzLnN0LihqKSA8LSAocy5zdC4oaikgbHhvciBleHRyYWN0ICFhY2N1KSBsYW5kIDB4M0ZGRkZGRkY7ICAoKiBQUiM1NTc1ICopXG4gICAgZG9uZTtcbiAgICBzLmlkeCA8LSAwXG5cblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgZnVsbF9pbml0IHJlc3VsdCBzZWVkO1xuICAgIHJlc3VsdFxuXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID0gbWFrZSAocmFuZG9tX3NlZWQgKCkpXG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGFzc2lnbiByZXN1bHQgcztcbiAgICByZXN1bHRcblxuXG4gICgqIFJldHVybnMgMzAgcmFuZG9tIGJpdHMgYXMgYW4gaW50ZWdlciAwIDw9IHggPCAxMDczNzQxODI0ICopXG4gIGxldCBiaXRzIHMgPVxuICAgIHMuaWR4IDwtIChzLmlkeCArIDEpIG1vZCA1NTtcbiAgICBsZXQgY3VydmFsID0gcy5zdC4ocy5pZHgpIGluXG4gICAgbGV0IG5ld3ZhbCA9IHMuc3QuKChzLmlkeCArIDI0KSBtb2QgNTUpXG4gICAgICAgICAgICAgICAgICsgKGN1cnZhbCBseG9yICgoY3VydmFsIGxzciAyNSkgbGFuZCAweDFGKSkgaW5cbiAgICBsZXQgbmV3dmFsMzAgPSBuZXd2YWwgbGFuZCAweDNGRkZGRkZGIGluICAoKiBQUiM1NTc1ICopXG4gICAgcy5zdC4ocy5pZHgpIDwtIG5ld3ZhbDMwO1xuICAgIG5ld3ZhbDMwXG5cblxuICBsZXQgcmVjIGludGF1eCBzIG4gPVxuICAgIGxldCByID0gYml0cyBzIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiAweDNGRkZGRkZGIC0gbiArIDEgdGhlbiBpbnRhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiAweDNGRkZGRkZGIHx8IGJvdW5kIDw9IDBcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludFwiXG4gICAgZWxzZSBpbnRhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQzMmF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDMyLm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDMyLnNoaWZ0X2xlZnQgKEludDMyLm9mX2ludCAoYml0cyBzIGxhbmQgMSkpIDMwIGluXG4gICAgbGV0IHIgPSBJbnQzMi5sb2dvciBiMSBiMiBpblxuICAgIGxldCB2ID0gSW50MzIucmVtIHIgbiBpblxuICAgIGlmIEludDMyLnN1YiByIHYgPiBJbnQzMi5hZGQgKEludDMyLnN1YiBJbnQzMi5tYXhfaW50IG4pIDFsXG4gICAgdGhlbiBpbnQzMmF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50MzIgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDMyXCJcbiAgICBlbHNlIGludDMyYXV4IHMgYm91bmRcblxuXG4gIGxldCByZWMgaW50NjRhdXggcyBuID1cbiAgICBsZXQgYjEgPSBJbnQ2NC5vZl9pbnQgKGJpdHMgcykgaW5cbiAgICBsZXQgYjIgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcykpIDMwIGluXG4gICAgbGV0IGIzID0gSW50NjQuc2hpZnRfbGVmdCAoSW50NjQub2ZfaW50IChiaXRzIHMgbGFuZCA3KSkgNjAgaW5cbiAgICBsZXQgciA9IEludDY0LmxvZ29yIGIxIChJbnQ2NC5sb2dvciBiMiBiMykgaW5cbiAgICBsZXQgdiA9IEludDY0LnJlbSByIG4gaW5cbiAgICBpZiBJbnQ2NC5zdWIgciB2ID4gSW50NjQuYWRkIChJbnQ2NC5zdWIgSW50NjQubWF4X2ludCBuKSAxTFxuICAgIHRoZW4gaW50NjRhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDY0IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBMXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQ2NFwiXG4gICAgZWxzZSBpbnQ2NGF1eCBzIGJvdW5kXG5cblxuICBsZXQgbmF0aXZlaW50ID1cbiAgICBpZiBOYXRpdmVpbnQuc2l6ZSA9IDMyXG4gICAgdGhlbiBmdW4gcyBib3VuZCAtPiBOYXRpdmVpbnQub2ZfaW50MzIgKGludDMyIHMgKE5hdGl2ZWludC50b19pbnQzMiBib3VuZCkpXG4gICAgZWxzZSBmdW4gcyBib3VuZCAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGludDY0IHMgKEludDY0Lm9mX25hdGl2ZWludCBib3VuZCkpXG5cblxuICAoKiBSZXR1cm5zIGEgZmxvYXQgMCA8PSB4IDw9IDEgd2l0aCBhdCBtb3N0IDYwIGJpdHMgb2YgcHJlY2lzaW9uLiAqKVxuICBsZXQgcmF3ZmxvYXQgcyA9XG4gICAgbGV0IHNjYWxlID0gMTA3Mzc0MTgyNC4wICAoKiAyXjMwICopXG4gICAgYW5kIHIxID0gU3RkbGliLmZsb2F0IChiaXRzIHMpXG4gICAgYW5kIHIyID0gU3RkbGliLmZsb2F0IChiaXRzIHMpXG4gICAgaW4gKHIxIC8uIHNjYWxlICsuIHIyKSAvLiBzY2FsZVxuXG5cbiAgbGV0IGZsb2F0IHMgYm91bmQgPSByYXdmbG9hdCBzICouIGJvdW5kXG5cbiAgbGV0IGJvb2wgcyA9IChiaXRzIHMgbGFuZCAxID0gMClcblxuZW5kXG5cbigqIFRoaXMgaXMgdGhlIHN0YXRlIHlvdSBnZXQgd2l0aCBbaW5pdCAyNzE4MjgxOF0gYW5kIHRoZW4gYXBwbHlpbmdcbiAgIHRoZSBcImxhbmQgMHgzRkZGRkZGRlwiIGZpbHRlciB0byB0aGVtLiAgU2VlICM1NTc1LCAjNTc5MywgIzU5NzcuICopXG5sZXQgZGVmYXVsdCA9IHtcbiAgU3RhdGUuc3QgPSBbfFxuICAgICAgMHgzYWUyNTIyYjsgMHgxZDhkNDYzNDsgMHgxNWI0ZmFkMDsgMHgxOGIxNGFjZTsgMHgxMmY4YTNjNDsgMHgzYjA4NmM0NztcbiAgICAgIDB4MTZkNDY3ZDY7IDB4MTAxZDkxYzc7IDB4MzIxZGYxNzc7IDB4MDE3NmMxOTM7IDB4MWZmNzJiZjE7IDB4MWU4ODkxMDk7XG4gICAgICAweDBiNDY0YjE4OyAweDJiODZiOTdjOyAweDA4OTFkYTQ4OyAweDAzMTM3NDYzOyAweDA4NWFjNWExOyAweDE1ZDYxZjJmO1xuICAgICAgMHgzYmNlZDM1OTsgMHgyOWMxYzEzMjsgMHgzYTg2NzY2ZTsgMHgzNjZkOGM4NjsgMHgxZjViNjIyMjsgMHgzY2UxYjU5ZjtcbiAgICAgIDB4MmViZjc4ZTE7IDB4MjdjZDFiODY7IDB4MjU4ZjNkYzM7IDB4Mzg5YTgxOTQ7IDB4MDJlNGM0NGM7IDB4MThjNDNmN2Q7XG4gICAgICAweDBmNmU1MzRmOyAweDFlN2RmMzU5OyAweDA1NWQwYjdlOyAweDEwZTg0ZTdlOyAweDEyNjE5OGU0OyAweDBlNzcyMmNiO1xuICAgICAgMHgxY2JlZGUyODsgMHgzMzkxYjk2NDsgMHgzZDQwZTkyYTsgMHgwYzU5OTMzZDsgMHgwYjhjZDBiNzsgMHgyNGVmZmYxYztcbiAgICAgIDB4MjgwM2ZkYWE7IDB4MDhlYmM3MmU7IDB4MGY1MjJlMzI7IDB4MDUzOThlZGM7IDB4MjE0NGEwNGM7IDB4MGFlZjNjYmQ7XG4gICAgICAweDAxYWQ0NzE5OyAweDM1YjkzY2Q2OyAweDJhNTU5ZDRmOyAweDFlNmZkNzY4OyAweDI2ZTI3ZjM2OyAweDE4NmYxOGMzO1xuICAgICAgMHgyZmJmOTY3YTtcbiAgICB8XTtcbiAgU3RhdGUuaWR4ID0gMDtcbn1cblxubGV0IGJpdHMgKCkgPSBTdGF0ZS5iaXRzIGRlZmF1bHRcbmxldCBpbnQgYm91bmQgPSBTdGF0ZS5pbnQgZGVmYXVsdCBib3VuZFxubGV0IGludDMyIGJvdW5kID0gU3RhdGUuaW50MzIgZGVmYXVsdCBib3VuZFxubGV0IG5hdGl2ZWludCBib3VuZCA9IFN0YXRlLm5hdGl2ZWludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50NjQgYm91bmQgPSBTdGF0ZS5pbnQ2NCBkZWZhdWx0IGJvdW5kXG5sZXQgZmxvYXQgc2NhbGUgPSBTdGF0ZS5mbG9hdCBkZWZhdWx0IHNjYWxlXG5sZXQgYm9vbCAoKSA9IFN0YXRlLmJvb2wgZGVmYXVsdFxuXG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBzZWVkXG5sZXQgaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgW3wgc2VlZCB8XVxubGV0IHNlbGZfaW5pdCAoKSA9IGZ1bGxfaW5pdCAocmFuZG9tX3NlZWQoKSlcblxuKCogTWFuaXB1bGF0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiAqKVxuXG5sZXQgZ2V0X3N0YXRlICgpID0gU3RhdGUuY29weSBkZWZhdWx0XG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gZGVmYXVsdCBzXG5cbigqKioqKioqKioqKioqKioqKioqKlxuXG4oKiBUZXN0IGZ1bmN0aW9ucy4gIE5vdCBpbmNsdWRlZCBpbiB0aGUgbGlicmFyeS5cbiAgIFRoZSBbY2hpc3F1YXJlXSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIHdpdGggbiA+IDEwci5cbiAgIEl0IHJldHVybnMgYSB0cmlwbGUgKGxvdywgYWN0dWFsLCBoaWdoKS5cbiAgIElmIGxvdyA8PSBhY3R1YWwgPD0gaGlnaCwgdGhlIFtnXSBmdW5jdGlvbiBwYXNzZWQgdGhlIHRlc3QsXG4gICBvdGhlcndpc2UgaXQgZmFpbGVkLlxuXG4gIFNvbWUgcmVzdWx0czpcblxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCA1MDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyOTk3OTI2NDM7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMTQxNDIxMzY7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDI0OyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDI0OyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAxNDE0MjEzNjsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDI5OTc5MjY0MzsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG4tIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk5Ny41LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODkuNzQwMDAwMDAwMDA1MjM4NywgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg0ODU4LjU3ODY0Mzc2MjY5LCA1MDQ1LjUsIDUxNDEuNDIxMzU2MjM3MzEpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPVxuKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk0NC44MDU5OTk5OTk5ODIzMDUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAxOS4xOTc0NDAwMDAwMDM1NSwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1OS4zMTc3NjAwMDAwMDUzNiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAzOS45ODQ2Mzk5OTk5OTUxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1NC4zODIwNzk5OTk5OTU3NywgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA5MC4wOTYwMDAwMDAwMDUsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA3Ni43ODcyMDAwMDAwMDYxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4xNzYwMDAwMDAwMDY3NTIxLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMjE2MDAwMDAwMDAwMzQ5MiwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDgwLjYyMjAwMDAwMDAwMzAyNjgsIDEyMC4pXG5cbiopXG5cbigqIFJldHVybiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHZbaTAsaTFbICopXG5sZXQgcmVjIHN1bXNxIHYgaTAgaTEgPVxuICBpZiBpMCA+PSBpMSB0aGVuIDAuMFxuICBlbHNlIGlmIGkxID0gaTAgKyAxIHRoZW4gU3RkbGliLmZsb2F0IHYuKGkwKSAqLiBTdGRsaWIuZmxvYXQgdi4oaTApXG4gIGVsc2Ugc3Vtc3EgdiBpMCAoKGkwK2kxKS8yKSArLiBzdW1zcSB2ICgoaTAraTEpLzIpIGkxXG5cblxubGV0IGNoaXNxdWFyZSBnIG4gciA9XG4gIGlmIG4gPD0gMTAgKiByIHRoZW4gaW52YWxpZF9hcmcgXCJjaGlzcXVhcmVcIjtcbiAgbGV0IGYgPSBBcnJheS5tYWtlIHIgMCBpblxuICBmb3IgaSA9IDEgdG8gbiBkb1xuICAgIGxldCB0ID0gZyByIGluXG4gICAgZi4odCkgPC0gZi4odCkgKyAxXG4gIGRvbmU7XG4gIGxldCB0ID0gc3Vtc3EgZiAwIHJcbiAgYW5kIHIgPSBTdGRsaWIuZmxvYXQgclxuICBhbmQgbiA9IFN0ZGxpYi5mbG9hdCBuIGluXG4gIGxldCBzciA9IDIuMCAqLiBzcXJ0IHIgaW5cbiAgKHIgLS4gc3IsICAgKHIgKi4gdCAvLiBuKSAtLiBuLCAgIHIgKy4gc3IpXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBsaW5lYXIgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb20gbnVtYmVycy5cbiopXG5sZXQgc3QgPSByZWYgMFxubGV0IGluaXRfZGlmZiByID0gc3QgOj0gaW50IHJcbmxldCBkaWZmIHIgPVxuICBsZXQgeDEgPSAhc3RcbiAgYW5kIHgyID0gaW50IHJcbiAgaW5cbiAgc3QgOj0geDI7XG4gIGlmIHgxID49IHgyIHRoZW5cbiAgICB4MSAtIHgyXG4gIGVsc2VcbiAgICByICsgeDEgLSB4MlxuXG5cbmxldCBzdDEgPSByZWYgMFxuYW5kIHN0MiA9IHJlZiAwXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBxdWFkcmF0aWMgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb21cbiAgIG51bWJlcnMuXG4qKVxubGV0IGluaXRfZGlmZjIgciA9IHN0MSA6PSBpbnQgcjsgc3QyIDo9IGludCByXG5sZXQgZGlmZjIgciA9XG4gIGxldCB4MSA9ICFzdDFcbiAgYW5kIHgyID0gIXN0MlxuICBhbmQgeDMgPSBpbnQgclxuICBpblxuICBzdDEgOj0geDI7XG4gIHN0MiA6PSB4MztcbiAgKHgzIC0geDIgLSB4MiArIHgxICsgMipyKSBtb2QgclxuXG5cbioqKioqKioqKioqKioqKioqKioqKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBIYXNoIHRhYmxlcyAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG9sZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaF91bml2X3BhcmFtXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbigqIFdlIGRvIGR5bmFtaWMgaGFzaGluZywgYW5kIHJlc2l6ZSB0aGUgdGFibGUgYW5kIHJlaGFzaCB0aGUgZWxlbWVudHNcbiAgIHdoZW4gYnVja2V0cyBiZWNvbWUgdG9vIGxvbmcuICopXG5cbnR5cGUgKCdhLCAnYikgdCA9XG4gIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICBtdXRhYmxlIGRhdGE6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgbXV0YWJsZSBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gIH1cblxuYW5kICgnYSwgJ2IpIGJ1Y2tldGxpc3QgPVxuICAgIEVtcHR5XG4gIHwgQ29ucyBvZiB7IG11dGFibGUga2V5OiAnYTtcbiAgICAgICAgICAgICAgbXV0YWJsZSBkYXRhOiAnYjtcbiAgICAgICAgICAgICAgbXV0YWJsZSBuZXh0OiAoJ2EsICdiKSBidWNrZXRsaXN0IH1cblxuKCogVGhlIHNpZ24gb2YgaW5pdGlhbF9zaXplIGVuY29kZXMgdGhlIGZhY3QgdGhhdCBhIHRyYXZlcnNhbCBpc1xuICAgb25nb2luZyBvciBub3QuXG5cbiAgIFRoaXMgZGlzYWJsZXMgdGhlIGVmZmljaWVudCBpbiBwbGFjZSBpbXBsZW1lbnRhdGlvbiBvZiByZXNpemluZy5cbiopXG5cbmxldCBvbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIHx8IGguaW5pdGlhbF9zaXplIDwgMFxuXG5sZXQgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgaC5pbml0aWFsX3NpemUgPC0gLSBoLmluaXRpYWxfc2l6ZVxuXG4oKiBUbyBwaWNrIHJhbmRvbSBzZWVkcyBpZiByZXF1ZXN0ZWQgKilcblxubGV0IHJhbmRvbWl6ZWRfZGVmYXVsdCA9XG4gIGxldCBwYXJhbXMgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJDQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPiBcIlwiIGluXG4gIFN0cmluZy5jb250YWlucyBwYXJhbXMgJ1InXG5cbmxldCByYW5kb21pemVkID0gcmVmIHJhbmRvbWl6ZWRfZGVmYXVsdFxuXG5sZXQgcmFuZG9taXplICgpID0gcmFuZG9taXplZCA6PSB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9ICFyYW5kb21pemVkXG5cbmxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbigqIENyZWF0aW5nIGEgZnJlc2gsIGVtcHR5IHRhYmxlICopXG5cbmxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICBpZiB4ID49IG4gdGhlbiB4XG4gIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG5sZXQgY3JlYXRlID8ocmFuZG9tID0gIXJhbmRvbWl6ZWQpIGluaXRpYWxfc2l6ZSA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG5sZXQgY2xlYXIgaCA9XG4gIGguc2l6ZSA8LSAwO1xuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgZG9uZVxuXG5sZXQgcmVzZXQgaCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICAgIHx8IGxlbiA9IGFicyBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgY2xlYXIgaFxuICBlbHNlIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgKGFicyBoLmluaXRpYWxfc2l6ZSkgRW1wdHlcbiAgZW5kXG5cbmxldCBjb3B5X2J1Y2tldGxpc3QgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IEVtcHR5XG4gIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgbGV0IHJlYyBsb29wIHByZWMgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IENvbnMgcHJlYyAtPiAgcHJlYy5uZXh0IDwtIHJcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGxvb3AgciBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICBsb29wIHIgbmV4dDtcbiAgICAgIHJcblxubGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5tYXAgY29weV9idWNrZXRsaXN0IGguZGF0YSB9XG5cbmxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG5sZXQgcmVzaXplIGluZGV4ZnVuIGggPVxuICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IG5kYXRhX3RhaWwgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IGlucGxhY2UgPSBub3QgKG9uZ29pbmdfdHJhdmVyc2FsIGgpIGluXG4gICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAgICAoKiBzbyB0aGF0IGluZGV4ZnVuIHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGFzIGNlbGwgLT5cbiAgICAgICAgICBsZXQgY2VsbCA9XG4gICAgICAgICAgICBpZiBpbnBsYWNlIHRoZW4gY2VsbFxuICAgICAgICAgICAgZWxzZSBDb25zIHtrZXk7IGRhdGE7IG5leHQgPSBFbXB0eX1cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBuaWR4ID0gaW5kZXhmdW4gaCBrZXkgaW5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBuZGF0YV90YWlsLihuaWR4KSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBuZGF0YS4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gY2VsbDtcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgbmRhdGFfdGFpbC4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG5leHRcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBpbnBsYWNlIHRoZW5cbiAgICAgIGZvciBpID0gMCB0byBuc2l6ZSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggbmRhdGFfdGFpbC4oaSkgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBFbXB0eVxuICAgICAgZG9uZTtcbiAgZW5kXG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSAzXG4gIHRoZW4gKHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcbiAgZWxzZSAob2xkX2hhc2hfcGFyYW0gMTAgMTAwIGtleSkgbW9kIChBcnJheS5sZW5ndGggaC5kYXRhKVxuXG5sZXQgYWRkIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbmxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICAoKVxuICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgIGVuZFxuICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbmxldCByZW1vdmUgaCBrZXkgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG5sZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG5sZXQgZmluZCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxubGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgTm9uZVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG5sZXQgZmluZF9vcHQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG5sZXQgZmluZF9hbGwgaCBrZXkgPVxuICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgW11cbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gZGF0YSA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbmxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gIGVuZFxuXG5sZXQgbWVtIGgga2V5ID1cbiAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgY29tcGFyZSBrIGtleSA9IDAgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCBpdGVyIGYgaCA9XG4gIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+XG4gICAgICAgICgpXG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZiBrZXkgZGF0YTsgZG9fYnVja2V0IG5leHQgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gRW1wdHlcbiAgICAgIGVuZFxuICB8IChDb25zICh7a2V5OyBkYXRhOyBuZXh0fSBhcyBjKSkgYXMgc2xvdCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZiBrZXkgZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgbmV4dFxuICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gc2xvdFxuICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBzbG90XG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGMuZGF0YSA8LSBkYXRhO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgc2xvdCBuZXh0XG4gICAgICBlbmRcblxubGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICBsZXQgZCA9IGguZGF0YSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBFbXB0eSBoLmRhdGEuKGkpXG4gICAgZG9uZVxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IGZvbGQgZiBoIGluaXQgPVxuICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgIG1hdGNoIGIgd2l0aFxuICAgICAgRW1wdHkgLT5cbiAgICAgICAgYWNjdVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGRvX2J1Y2tldCBuZXh0IChmIGtleSBkYXRhIGFjY3UpIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgICFhY2N1XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG50eXBlIHN0YXRpc3RpY3MgPSB7XG4gIG51bV9iaW5kaW5nczogaW50O1xuICBudW1fYnVja2V0czogaW50O1xuICBtYXhfYnVja2V0X2xlbmd0aDogaW50O1xuICBidWNrZXRfaGlzdG9ncmFtOiBpbnQgYXJyYXlcbn1cblxubGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFjY3VcbiAgfCBDb25ze25leHR9IC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSBuZXh0XG5cbmxldCBzdGF0cyBoID1cbiAgbGV0IG1ibCA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgQXJyYXkuaXRlclxuICAgIChmdW4gYiAtPlxuICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgaC5kYXRhO1xuICB7IG51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSB0YmwgPVxuICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgaW5cbiAgYXV4IDAgRW1wdHlcblxubGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbmxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbmxldCBhZGRfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG5sZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gIHJlcGxhY2Vfc2VxIHRibCBpO1xuICB0YmxcblxuKCogRnVuY3RvcmlhbCBpbnRlcmZhY2UgKilcblxubW9kdWxlIHR5cGUgSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnYSB0XG4gICAgdmFsIGNyZWF0ZSA6ID9yYW5kb206Ym9vbCAtPiBpbnQgLT4gJ2EgdFxuICAgIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICAgIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbCA6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyIDogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQgOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlU2VlZGVkKEg6IFNlZWRlZEhhc2hlZFR5cGUpOiAoU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIHR5cGUga2V5ID0gSC50XG4gICAgdHlwZSAnYSBoYXNodGJsID0gKGtleSwgJ2EpIHRcbiAgICB0eXBlICdhIHQgPSAnYSBoYXNodGJsXG4gICAgbGV0IGNyZWF0ZSA9IGNyZWF0ZVxuICAgIGxldCBjbGVhciA9IGNsZWFyXG4gICAgbGV0IHJlc2V0ID0gcmVzZXRcbiAgICBsZXQgY29weSA9IGNvcHlcblxuICAgIGxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAgICAgKEguaGFzaCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBhZGQgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG4gICAgbGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgKClcbiAgICAgIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGJlZ2luXG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBbXVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhPWQ7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gZCA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxuICAgIGxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gICAgICBlbmRcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgICAgIEguZXF1YWwgayBrZXkgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICAgIGxldCBpdGVyID0gaXRlclxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgPSBmaWx0ZXJfbWFwX2lucGxhY2VcbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IHN0YXRzID0gc3RhdHNcbiAgICBsZXQgdG9fc2VxID0gdG9fc2VxXG4gICAgbGV0IHRvX3NlcV9rZXlzID0gdG9fc2VxX2tleXNcbiAgICBsZXQgdG9fc2VxX3ZhbHVlcyA9IHRvX3NlcV92YWx1ZXNcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKEg6IEhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIFdlYWsgYXJyYXkgb3BlcmF0aW9ucyAqKVxuXG50eXBlICdhIHRcblxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+ICdhIHQgPSBcImNhbWxfd2Vha19jcmVhdGVcIlxuXG5sZXQgY3JlYXRlIGwgPVxuICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IE9iai5FcGhlbWVyb24ubWF4X2VwaGVfbGVuZ3RoKSB0aGVuXG4gICAgaW52YWxpZF9hcmcoXCJXZWFrLmNyZWF0ZVwiKTtcbiAgY3JlYXRlIGxcblxuKCoqIG51bWJlciBvZiBhZGRpdGlvbmFsIHZhbHVlcyBpbiBhIHdlYWsgcG9pbnRlciAqKVxubGV0IGFkZGl0aW9uYWxfdmFsdWVzID0gMlxuXG5sZXQgbGVuZ3RoIHggPSBPYmouc2l6ZShPYmoucmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbmxldCByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gbXNnID1cbiAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgaW52YWxpZF9hcmcobXNnKVxuXG5leHRlcm5hbCBzZXQnIDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9rZXlcIlxuZXh0ZXJuYWwgdW5zZXQgOiAnYSB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbmxldCBzZXQgZSBvIHggPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLnNldFwiO1xuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHVuc2V0IGUgb1xuICB8IFNvbWUgeCAtPiBzZXQnIGUgbyB4XG5cbmV4dGVybmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldFwiXG5sZXQgZ2V0IGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuZ2V0XCI7XG4gIGdldCBlIG9cblxuZXh0ZXJuYWwgZ2V0X2NvcHkgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRfY29weVwiXG5sZXQgZ2V0X2NvcHkgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRfY29weVwiO1xuICBnZXRfY29weSBlIG9cblxuZXh0ZXJuYWwgY2hlY2sgOiAnYSB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX3dlYWtfY2hlY2tcIlxubGV0IGNoZWNrIGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuY2hlY2tcIjtcbiAgY2hlY2sgZSBvXG5cbmV4dGVybmFsIGJsaXQgOiAnYSB0IC0+IGludCAtPiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF93ZWFrX2JsaXRcIlxuXG4oKiBibGl0OiBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuICopXG5sZXQgYmxpdCBlMSBvMSBlMiBvMiBsID1cbiAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICB8fCBvMiA8IDAgfHwgbzIgPiBsZW5ndGggZTIgLSBsXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJXZWFrLmJsaXRcIlxuICBlbHNlIGlmIGwgPD4gMCB0aGVuIGJsaXQgZTEgbzEgZTIgbzIgbFxuXG5sZXQgZmlsbCBhciBvZnMgbGVuIHggPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGFyIC0gbGVuXG4gIHRoZW4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJXZWFrLmZpbGxcIilcbiAgZWxzZSBiZWdpblxuICAgIGZvciBpID0gb2ZzIHRvIChvZnMgKyBsZW4gLSAxKSBkb1xuICAgICAgc2V0IGFyIGkgeFxuICAgIGRvbmVcbiAgZW5kXG5cblxuKCoqIFdlYWsgaGFzaCB0YWJsZXMgKilcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIGRhdGFcbiAgdHlwZSB0XG4gIHZhbCBjcmVhdGUgOiBpbnQgLT4gdFxuICB2YWwgY2xlYXIgOiB0IC0+IHVuaXRcbiAgdmFsIG1lcmdlIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGFkZCA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgZmluZCA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBmaW5kX29wdCA6IHQgLT4gZGF0YSAtPiBkYXRhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiB0IC0+IGRhdGEgLT4gZGF0YSBsaXN0XG4gIHZhbCBtZW0gOiB0IC0+IGRhdGEgLT4gYm9vbFxuICB2YWwgaXRlciA6IChkYXRhIC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICB2YWwgZm9sZCA6IChkYXRhIC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gIHZhbCBjb3VudCA6IHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6IHQgLT4gaW50ICogaW50ICogaW50ICogaW50ICogaW50ICogaW50XG5lbmRcblxubW9kdWxlIE1ha2UgKEggOiBIYXNodGJsLkhhc2hlZFR5cGUpIDogKFMgd2l0aCB0eXBlIGRhdGEgPSBILnQpID0gc3RydWN0XG5cbiAgdHlwZSAnYSB3ZWFrX3QgPSAnYSB0XG4gIGxldCB3ZWFrX2NyZWF0ZSA9IGNyZWF0ZVxuICBsZXQgZW1wdHlidWNrZXQgPSB3ZWFrX2NyZWF0ZSAwXG5cbiAgdHlwZSBkYXRhID0gSC50XG5cbiAgdHlwZSB0ID0ge1xuICAgIG11dGFibGUgdGFibGUgOiBkYXRhIHdlYWtfdCBhcnJheTtcbiAgICBtdXRhYmxlIGhhc2hlcyA6IGludCBhcnJheSBhcnJheTtcbiAgICBtdXRhYmxlIGxpbWl0IDogaW50OyAgICAgICAgICAgICAgICgqIGJ1Y2tldCBzaXplIGxpbWl0ICopXG4gICAgbXV0YWJsZSBvdmVyc2l6ZSA6IGludDsgICAgICAgICAgICAoKiBudW1iZXIgb2Ygb3ZlcnNpemUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgcm92ZXIgOiBpbnQ7ICAgICAgICAgICAgICAgKCogZm9yIGludGVybmFsIGJvb2trZWVwaW5nICopXG4gIH1cblxuICBsZXQgZ2V0X2luZGV4IHQgaCA9IChoIGxhbmQgbWF4X2ludCkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuICBsZXQgbGltaXQgPSA3XG4gIGxldCBvdmVyX2xpbWl0ID0gMlxuXG4gIGxldCBjcmVhdGUgc3ogPVxuICAgIGxldCBzeiA9IGlmIHN6IDwgNyB0aGVuIDcgZWxzZSBzeiBpblxuICAgIGxldCBzeiA9IGlmIHN6ID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBTeXMubWF4X2FycmF5X2xlbmd0aCBlbHNlIHN6IGluXG4gICAge1xuICAgICAgdGFibGUgPSBBcnJheS5tYWtlIHN6IGVtcHR5YnVja2V0O1xuICAgICAgaGFzaGVzID0gQXJyYXkubWFrZSBzeiBbfCB8XTtcbiAgICAgIGxpbWl0ID0gbGltaXQ7XG4gICAgICBvdmVyc2l6ZSA9IDA7XG4gICAgICByb3ZlciA9IDA7XG4gICAgfVxuXG4gIGxldCBjbGVhciB0ID1cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgICB0LnRhYmxlLihpKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgIHQuaGFzaGVzLihpKSA8LSBbfCB8XTtcbiAgICBkb25lO1xuICAgIHQubGltaXQgPC0gbGltaXQ7XG4gICAgdC5vdmVyc2l6ZSA8LSAwXG5cblxuICBsZXQgZm9sZCBmIHQgaW5pdCA9XG4gICAgbGV0IHJlYyBmb2xkX2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGZvbGRfYnVja2V0IChpKzEpIGIgKGYgdiBhY2N1KVxuICAgICAgfCBOb25lIC0+IGZvbGRfYnVja2V0IChpKzEpIGIgYWNjdVxuICAgIGluXG4gICAgQXJyYXkuZm9sZF9yaWdodCAoZm9sZF9idWNrZXQgMCkgdC50YWJsZSBpbml0XG5cblxuICBsZXQgaXRlciBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGYgdjsgaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgICAgfCBOb25lIC0+IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXIgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCBpdGVyX3dlYWsgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgaiBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBjaGVjayBiIGkgd2l0aFxuICAgICAgfCB0cnVlIC0+IGYgYiB0Lmhhc2hlcy4oaikgaTsgaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgICB8IGZhbHNlIC0+IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgIGluXG4gICAgQXJyYXkuaXRlcmkgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCByZWMgY291bnRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgY291bnRfYnVja2V0IChpKzEpIGIgKGFjY3UgKyAoaWYgY2hlY2sgYiBpIHRoZW4gMSBlbHNlIDApKVxuXG5cbiAgbGV0IGNvdW50IHQgPVxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGNvdW50X2J1Y2tldCAwKSB0LnRhYmxlIDBcblxuXG4gIGxldCBuZXh0X3N6IG4gPSBtaW4gKDMgKiBuIC8gMiArIDMpIFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG4gIGxldCBwcmV2X3N6IG4gPSAoKG4gLSAzKSAqIDIgKyAyKSAvIDNcblxuICBsZXQgdGVzdF9zaHJpbmtfYnVja2V0IHQgPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLih0LnJvdmVyKSBpblxuICAgIGxldCBoYnVja2V0ID0gdC5oYXNoZXMuKHQucm92ZXIpIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcHJldl9sZW4gPSBwcmV2X3N6IGxlbiBpblxuICAgIGxldCBsaXZlID0gY291bnRfYnVja2V0IDAgYnVja2V0IDAgaW5cbiAgICBpZiBsaXZlIDw9IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWMgbG9vcCBpIGogPVxuICAgICAgICBpZiBqID49IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGxvb3AgKGkgKyAxKSBqXG4gICAgICAgICAgZWxzZSBpZiBjaGVjayBidWNrZXQgaiB0aGVuIGJlZ2luXG4gICAgICAgICAgICBibGl0IGJ1Y2tldCBqIGJ1Y2tldCBpIDE7XG4gICAgICAgICAgICBoYnVja2V0LihpKSA8LSBoYnVja2V0LihqKTtcbiAgICAgICAgICAgIGxvb3AgKGkgKyAxKSAoaiAtIDEpO1xuICAgICAgICAgIGVuZCBlbHNlIGxvb3AgaSAoaiAtIDEpO1xuICAgICAgICBlbmQ7XG4gICAgICBpblxuICAgICAgbG9vcCAwIChsZW5ndGggYnVja2V0IC0gMSk7XG4gICAgICBpZiBwcmV2X2xlbiA9IDAgdGhlbiBiZWdpblxuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIFt8IHxdO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIHByZXZfbGVuIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgcHJldl9sZW47XG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIEFycmF5LnN1YiBoYnVja2V0IDAgcHJldl9sZW5cbiAgICAgIGVuZDtcbiAgICAgIGlmIGxlbiA+IHQubGltaXQgJiYgcHJldl9sZW4gPD0gdC5saW1pdCB0aGVuIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSAtIDE7XG4gICAgZW5kO1xuICAgIHQucm92ZXIgPC0gKHQucm92ZXIgKyAxKSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG5cbiAgbGV0IHJlYyByZXNpemUgdCA9XG4gICAgbGV0IG9sZGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG5ld2xlbiA9IG5leHRfc3ogb2xkbGVuIGluXG4gICAgaWYgbmV3bGVuID4gb2xkbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCBuZXd0ID0gY3JlYXRlIG5ld2xlbiBpblxuICAgICAgbGV0IGFkZF93ZWFrIG9iIG9oIG9pID1cbiAgICAgICAgbGV0IHNldHRlciBuYiBuaSBfID0gYmxpdCBvYiBvaSBuYiBuaSAxIGluXG4gICAgICAgIGxldCBoID0gb2guKG9pKSBpblxuICAgICAgICBhZGRfYXV4IG5ld3Qgc2V0dGVyIE5vbmUgaCAoZ2V0X2luZGV4IG5ld3QgaCk7XG4gICAgICBpblxuICAgICAgaXRlcl93ZWFrIGFkZF93ZWFrIHQ7XG4gICAgICB0LnRhYmxlIDwtIG5ld3QudGFibGU7XG4gICAgICB0Lmhhc2hlcyA8LSBuZXd0Lmhhc2hlcztcbiAgICAgIHQubGltaXQgPC0gbmV3dC5saW1pdDtcbiAgICAgIHQub3ZlcnNpemUgPC0gbmV3dC5vdmVyc2l6ZTtcbiAgICAgIHQucm92ZXIgPC0gdC5yb3ZlciBtb2QgQXJyYXkubGVuZ3RoIG5ld3QudGFibGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHQubGltaXQgPC0gbWF4X2ludDsgICAgICAgICAgICAgKCogbWF4aW11bSBzaXplIGFscmVhZHkgcmVhY2hlZCAqKVxuICAgICAgdC5vdmVyc2l6ZSA8LSAwO1xuICAgIGVuZFxuXG4gIGFuZCBhZGRfYXV4IHQgc2V0dGVyIGQgaCBpbmRleCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmV3c3ogPVxuICAgICAgICAgIG1pbiAoMyAqIHN6IC8gMiArIDMpIChTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzKVxuICAgICAgICBpblxuICAgICAgICBpZiBuZXdzeiA8PSBzeiB0aGVuIGZhaWx3aXRoIFwiV2Vhay5NYWtlOiBoYXNoIGJ1Y2tldCBjYW5ub3QgZ3JvdyBtb3JlXCI7XG4gICAgICAgIGxldCBuZXdidWNrZXQgPSB3ZWFrX2NyZWF0ZSBuZXdzeiBpblxuICAgICAgICBsZXQgbmV3aGFzaGVzID0gQXJyYXkubWFrZSBuZXdzeiAwIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgc3o7XG4gICAgICAgIEFycmF5LmJsaXQgaGFzaGVzIDAgbmV3aGFzaGVzIDAgc3o7XG4gICAgICAgIHNldHRlciBuZXdidWNrZXQgc3ogZDtcbiAgICAgICAgbmV3aGFzaGVzLihzeikgPC0gaDtcbiAgICAgICAgdC50YWJsZS4oaW5kZXgpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKGluZGV4KSA8LSBuZXdoYXNoZXM7XG4gICAgICAgIGlmIHN6IDw9IHQubGltaXQgJiYgbmV3c3ogPiB0LmxpbWl0IHRoZW4gYmVnaW5cbiAgICAgICAgICB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgKyAxO1xuICAgICAgICAgIGZvciBfaSA9IDAgdG8gb3Zlcl9saW1pdCBkbyB0ZXN0X3Nocmlua19idWNrZXQgdCBkb25lO1xuICAgICAgICBlbmQ7XG4gICAgICAgIGlmIHQub3ZlcnNpemUgPiBBcnJheS5sZW5ndGggdC50YWJsZSAvIG92ZXJfbGltaXQgdGhlbiByZXNpemUgdDtcbiAgICAgIGVuZCBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gYmVnaW5cbiAgICAgICAgbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXR0ZXIgYnVja2V0IGkgZDtcbiAgICAgICAgaGFzaGVzLihpKSA8LSBoO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgYWRkIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCAoZ2V0X2luZGV4IHQgaClcblxuXG4gIGxldCBmaW5kX29yIHQgZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZCBoIGluZGV4XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBtZXJnZSB0IGQgPVxuICAgIGZpbmRfb3IgdCBkIChmdW4gaCBpbmRleCAtPiBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggaW5kZXg7IGQpXG5cblxuICBsZXQgZmluZCB0IGQgPSBmaW5kX29yIHQgZCAoZnVuIF9oIF9pbmRleCAtPiByYWlzZSBOb3RfZm91bmQpXG5cbiAgbGV0IGZpbmRfb3B0IHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIE5vbmVcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgZmluZF9zaGFkb3cgdCBkIGlmZm91bmQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmRcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGQgLT4gaWZmb3VuZCBidWNrZXQgaVxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IHJlbW92ZSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biB3IGkgLT4gc2V0IHcgaSBOb25lKSAoKVxuXG5cbiAgbGV0IG1lbSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biBfdyBfaSAtPiB0cnVlKSBmYWxzZVxuXG5cbiAgbGV0IGZpbmRfYWxsIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgYWNjdSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYWNjdVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiBsb29wIChpICsgMSkgKHYgOjogYWNjdSlcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgaW5cbiAgICBsb29wIDAgW11cblxuXG4gIGxldCBzdGF0cyB0ID1cbiAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbGVucyA9IEFycmF5Lm1hcCBsZW5ndGggdC50YWJsZSBpblxuICAgIEFycmF5LnNvcnQgY29tcGFyZSBsZW5zO1xuICAgIGxldCB0b3RsZW4gPSBBcnJheS5mb2xkX2xlZnQgKCArICkgMCBsZW5zIGluXG4gICAgKGxlbiwgY291bnQgdCwgdG90bGVuLCBsZW5zLigwKSwgbGVucy4obGVuLzIpLCBsZW5zLihsZW4tMSkpXG5cblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEEgcHJldHR5LXByaW50aW5nIGZhY2lsaXR5IGFuZCBkZWZpbml0aW9uIG9mIGZvcm1hdHRlcnMgZm9yICdwYXJhbGxlbCdcbiAgIChpLmUuIHVucmVsYXRlZCBvciBpbmRlcGVuZGVudCkgcHJldHR5LXByaW50aW5nIG9uIG11bHRpcGxlIG91dCBjaGFubmVscy4gKilcblxuKCpcbiAgIFRoZSBwcmV0dHktcHJpbnRpbmcgZW5naW5lIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiopXG5cbmxldCBpZCB4ID0geFxuXG4oKiBBIGRldm90ZWQgdHlwZSBmb3Igc2l6ZXMgdG8gYXZvaWQgY29uZnVzaW9uXG4gICBiZXR3ZWVuIHNpemVzIGFuZCBtZXJlIGludGVnZXJzLiAqKVxubW9kdWxlIFNpemUgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICB2YWwgemVybyA6IHRcbiAgdmFsIHVua25vd24gOiB0XG4gIHZhbCBpc19rbm93biA6IHQgLT4gYm9vbFxuZW5kICA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgdG9faW50ID0gaWRcbiAgbGV0IG9mX2ludCA9IGlkXG4gIGxldCB6ZXJvID0gMFxuICBsZXQgdW5rbm93biA9IC0xXG4gIGxldCBpc19rbm93biBuID0gbiA+PSAwXG5lbmRcblxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgYm94ZXMgZGVmaW5pdGlvbjpcbiAgIGEgcHJldHR5LXByaW50aW5nIGJveCBpcyBlaXRoZXJcbiAgIC0gaGJveDogaG9yaXpvbnRhbCBib3ggKG5vIGxpbmUgc3BsaXR0aW5nKVxuICAgLSB2Ym94OiB2ZXJ0aWNhbCBib3ggKGV2ZXJ5IGJyZWFrIGhpbnQgc3BsaXRzIHRoZSBsaW5lKVxuICAgLSBodmJveDogaG9yaXpvbnRhbC92ZXJ0aWNhbCBib3hcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIGJveCBpZiBpdCBmaXRzIG9uXG4gICAgICB0aGUgY3VycmVudCBsaW5lLCBvdGhlcndpc2UgdGhlIGJveCBiZWhhdmVzIGFzIGEgdmVydGljYWwgYm94KVxuICAgLSBob3Zib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3hcbiAgICAgKHRoZSBib3ggaXMgY29tcGFjdGluZyBtYXRlcmlhbCwgcHJpbnRpbmcgYXMgbXVjaCBtYXRlcmlhbCBhcyBwb3NzaWJsZVxuICAgICAgb24gZXZlcnkgbGluZXMpXG4gICAtIGJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveCB3aXRoIGVuaGFuY2VkIGJveCBzdHJ1Y3R1cmVcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGJveCBidXQgYnJlYWsgaGludHMgc3BsaXRcbiAgICAgIHRoZSBsaW5lIGlmIHNwbGl0dGluZyB3b3VsZCBtb3ZlIHRvIHRoZSBsZWZ0KVxuKilcbnR5cGUgYm94X3R5cGUgPSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHNcblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIHRva2VucyBkZWZpbml0aW9uOlxuICAgYXJlIGVpdGhlciB0ZXh0IHRvIHByaW50IG9yIHByZXR0eSBwcmludGluZ1xuICAgZWxlbWVudHMgdGhhdCBkcml2ZSBpbmRlbnRhdGlvbiBhbmQgbGluZSBzcGxpdHRpbmcuICopXG50eXBlIHBwX3Rva2VuID1cbiAgfCBQcF90ZXh0IG9mIHN0cmluZyAgICAgICAgICAoKiBub3JtYWwgdGV4dCAqKVxuICB8IFBwX2JyZWFrIG9mIHsgICAgICAgICAgICAgICgqIGNvbXBsZXRlIGJyZWFrICopXG4gICAgICBmaXRzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICAgKCogbGluZSBpcyBub3Qgc3BsaXQgKilcbiAgICAgIGJyZWFrczogc3RyaW5nICogaW50ICogc3RyaW5nOyAoKiBsaW5lIGlzIHNwbGl0ICopXG4gICAgfVxuICB8IFBwX3RicmVhayBvZiBpbnQgKiBpbnQgICAgICgqIGdvIHRvIG5leHQgdGFidWxhdGlvbiAqKVxuICB8IFBwX3N0YWIgICAgICAgICAgICAgICAgICAgICgqIHNldCBhIHRhYnVsYXRpb24gKilcbiAgfCBQcF9iZWdpbiBvZiBpbnQgKiBib3hfdHlwZSAoKiBiZWdpbm5pbmcgb2YgYSBib3ggKilcbiAgfCBQcF9lbmQgICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSBib3ggKilcbiAgfCBQcF90YmVnaW4gb2YgdGJveCAgICAgICAgICAoKiBiZWdpbm5pbmcgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX3RlbmQgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfbmV3bGluZSAgICAgICAgICAgICAgICAgKCogdG8gZm9yY2UgYSBuZXdsaW5lIGluc2lkZSBhIGJveCAqKVxuICB8IFBwX2lmX25ld2xpbmUgICAgICAgICAgICAgICgqIHRvIGRvIHNvbWV0aGluZyBvbmx5IGlmIHRoaXMgdmVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgaGFzIGJlZW4gYnJva2VuICopXG4gIHwgUHBfb3Blbl90YWcgb2Ygc3RhZyAgICAgICAgICgqIG9wZW5pbmcgYSB0YWcgbmFtZSAqKVxuICB8IFBwX2Nsb3NlX3RhZyAgICAgICAgICAgICAgICgqIGNsb3NpbmcgdGhlIG1vc3QgcmVjZW50bHkgb3BlbiB0YWcgKilcblxuYW5kIHN0YWcgPSAuLlxuXG5hbmQgdGJveCA9IFBwX3Rib3ggb2YgaW50IGxpc3QgcmVmICAoKiBUYWJ1bGF0aW9uIGJveCAqKVxuXG50eXBlIHRhZyA9IHN0cmluZ1xudHlwZSBzdGFnICs9IFN0cmluZ190YWcgb2YgdGFnXG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlOlxuICAgcHJldHR5LXByaW50aW5nIG1hdGVyaWFsIGlzIG5vdCB3cml0dGVuIGluIHRoZSBvdXRwdXQgYXMgc29vbiBhcyBlbWl0dGVkO1xuICAgaW5zdGVhZCwgdGhlIG1hdGVyaWFsIGlzIHNpbXBseSByZWNvcmRlZCBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsXG4gICB1bnRpbCB0aGUgZW5jbG9zaW5nIGJveCBoYXMgYSBrbm93biBjb21wdXRlZCBzaXplIGFuZCBwcm9wZXIgc3BsaXR0aW5nXG4gICBkZWNpc2lvbnMgY2FuIGJlIG1hZGUuXG5cbiAgIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBjb250YWlucyBmb3JtYXR0aW5nIGVsZW1lbnRzIHRvIGJlIHByaW50ZWQuXG4gICBFYWNoIGZvcm1hdHRpbmcgZWxlbWVudCBpcyBhIHR1cGxlIChzaXplLCB0b2tlbiwgbGVuZ3RoKSwgd2hlcmVcbiAgIC0gbGVuZ3RoIGlzIHRoZSBkZWNsYXJlZCBsZW5ndGggb2YgdGhlIHRva2VuLFxuICAgLSBzaXplIGlzIGVmZmVjdGl2ZSBzaXplIG9mIHRoZSB0b2tlbiB3aGVuIGl0IGlzIHByaW50ZWRcbiAgICAgKHNpemUgaXMgc2V0IHdoZW4gdGhlIHNpemUgb2YgdGhlIGJveCBpcyBrbm93biwgc28gdGhhdCBzaXplIG9mIGJyZWFrXG4gICAgICBoaW50cyBhcmUgZGVmaW5pdGl2ZSkuICopXG50eXBlIHBwX3F1ZXVlX2VsZW0gPSB7XG4gIG11dGFibGUgc2l6ZSA6IFNpemUudDtcbiAgdG9rZW4gOiBwcF90b2tlbjtcbiAgbGVuZ3RoIDogaW50O1xufVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9xdWV1ZSA9IHBwX3F1ZXVlX2VsZW0gUXVldWUudFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjazogc2Nhbm5pbmcgZWxlbWVudCBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9zY2FuX2VsZW0gPSB7XG4gIGxlZnRfdG90YWwgOiBpbnQ7ICgqIFZhbHVlIG9mIHBwX2xlZnRfdG90YWwgd2hlbiB0aGUgZWxlbWVudCB3YXMgZW5xdWV1ZWQuICopXG4gIHF1ZXVlX2VsZW0gOiBwcF9xdWV1ZV9lbGVtXG59XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOlxuICAgdGhlIGZvcm1hdHRpbmcgc3RhY2sgY29udGFpbnMgdGhlIGRlc2NyaXB0aW9uIG9mIGFsbCB0aGUgY3VycmVudGx5IGFjdGl2ZVxuICAgYm94ZXM7IHRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrIGlzIHVzZWQgdG8gc3BsaXQgdGhlIGxpbmVzXG4gICB3aGlsZSBwcmludGluZyB0b2tlbnMuICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOiBmb3JtYXR0aW5nIHN0YWNrIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIEVhY2ggc3RhY2sgZWxlbWVudCBkZXNjcmliZXMgYSBwcmV0dHktcHJpbnRpbmcgYm94LiAqKVxudHlwZSBwcF9mb3JtYXRfZWxlbSA9IHsgYm94X3R5cGUgOiBib3hfdHlwZTsgd2lkdGggOiBpbnQgfVxuXG4oKiBUaGUgZm9ybWF0dGVyIGRlZmluaXRpb24uXG4gICBFYWNoIGZvcm1hdHRlciB2YWx1ZSBpcyBhIHByZXR0eS1wcmludGVyIGluc3RhbmNlIHdpdGggYWxsIGl0c1xuICAgbWFjaGluZXJ5LiAqKVxudHlwZSBmb3JtYXR0ZXIgPSB7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcbiAgcHBfc2Nhbl9zdGFjayA6IHBwX3NjYW5fZWxlbSBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjay4gKilcbiAgcHBfZm9ybWF0X3N0YWNrIDogcHBfZm9ybWF0X2VsZW0gU3RhY2sudDtcbiAgcHBfdGJveF9zdGFjayA6IHRib3ggU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNlbWFudGljcyB0YWcgc3RhY2suICopXG4gIHBwX3RhZ19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgcHBfbWFya19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgKCogVmFsdWUgb2YgcmlnaHQgbWFyZ2luLiAqKVxuICBtdXRhYmxlIHBwX21hcmdpbiA6IGludDtcbiAgKCogTWluaW1hbCBzcGFjZSBsZWZ0IGJlZm9yZSBtYXJnaW4sIHdoZW4gb3BlbmluZyBhIGJveC4gKilcbiAgbXV0YWJsZSBwcF9taW5fc3BhY2VfbGVmdCA6IGludDtcbiAgKCogTWF4aW11bSB2YWx1ZSBvZiBpbmRlbnRhdGlvbjpcbiAgICAgbm8gYm94IGNhbiBiZSBvcGVuZWQgZnVydGhlci4gKilcbiAgbXV0YWJsZSBwcF9tYXhfaW5kZW50IDogaW50O1xuICAoKiBTcGFjZSByZW1haW5pbmcgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbiAgbXV0YWJsZSBwcF9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBDdXJyZW50IHZhbHVlIG9mIGluZGVudGF0aW9uLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJlbnRfaW5kZW50IDogaW50O1xuICAoKiBUcnVlIHdoZW4gdGhlIGxpbmUgaGFzIGJlZW4gYnJva2VuIGJ5IHRoZSBwcmV0dHktcHJpbnRlci4gKilcbiAgbXV0YWJsZSBwcF9pc19uZXdfbGluZSA6IGJvb2w7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBhbHJlYWR5IHByaW50ZWQuICopXG4gIG11dGFibGUgcHBfbGVmdF90b3RhbCA6IGludDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGV2ZXIgcHV0IGluIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHBwX3JpZ2h0X3RvdGFsIDogaW50O1xuICAoKiBDdXJyZW50IG51bWJlciBvZiBvcGVuIGJveGVzLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJfZGVwdGggOiBpbnQ7XG4gICgqIE1heGltdW0gbnVtYmVyIG9mIGJveGVzIHdoaWNoIGNhbiBiZSBzaW11bHRhbmVvdXNseSBvcGVuLiAqKVxuICBtdXRhYmxlIHBwX21heF9ib3hlcyA6IGludDtcbiAgKCogRWxsaXBzaXMgc3RyaW5nLiAqKVxuICBtdXRhYmxlIHBwX2VsbGlwc2lzIDogc3RyaW5nO1xuICAoKiBPdXRwdXQgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gICgqIEZsdXNoaW5nIGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGJyZWFrIGhpbnRzIHNwYWNlcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xuICAoKiBBcmUgdGFncyBwcmludGVkID8gKilcbiAgbXV0YWJsZSBwcF9wcmludF90YWdzIDogYm9vbDtcbiAgKCogQXJlIHRhZ3MgbWFya2VkID8gKilcbiAgbXV0YWJsZSBwcF9tYXJrX3RhZ3MgOiBib29sO1xuICAoKiBGaW5kIG9wZW5pbmcgYW5kIGNsb3NpbmcgbWFya2VycyBvZiB0YWdzLiAqKVxuICBtdXRhYmxlIHBwX21hcmtfb3Blbl90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9tYXJrX2Nsb3NlX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX3ByaW50X29wZW5fdGFnIDogc3RhZyAtPiB1bml0O1xuICBtdXRhYmxlIHBwX3ByaW50X2Nsb3NlX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxuICBwcF9xdWV1ZSA6IHBwX3F1ZXVlO1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgc3BlY2lmaWMgdGFnIGhhbmRsaW5nIGZ1bmN0aW9ucy4gKilcbnR5cGUgZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgcHJpbnRfb3Blbl9zdGFnIDogc3RhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV9zdGFnIDogc3RhZyAtPiB1bml0O1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb25zIHRvIG91dHB1dCBtYXRlcmlhbC4gKilcbnR5cGUgZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPSB7XG4gIG91dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICBvdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICBvdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gIG91dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbn1cblxuXG4oKlxuXG4gIEF1eGlsaWFyaWVzIGFuZCBiYXNpYyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEVudGVyIGEgdG9rZW4gaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2VucXVldWUgc3RhdGUgdG9rZW4gPVxuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBzdGF0ZS5wcF9yaWdodF90b3RhbCArIHRva2VuLmxlbmd0aDtcbiAgUXVldWUuYWRkIHRva2VuIHN0YXRlLnBwX3F1ZXVlXG5cblxubGV0IHBwX2NsZWFyX3F1ZXVlIHN0YXRlID1cbiAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSAxOyBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSAxO1xuICBRdWV1ZS5jbGVhciBzdGF0ZS5wcF9xdWV1ZVxuXG5cbigqIFBwX2luZmluaXR5OiBsYXJnZSB2YWx1ZSBmb3IgZGVmYXVsdCB0b2tlbnMgc2l6ZS5cblxuICAgUHBfaW5maW5pdHkgaXMgZG9jdW1lbnRlZCBhcyBiZWluZyBncmVhdGVyIHRoYW4gMWUxMDsgdG8gYXZvaWRcbiAgIGNvbmZ1c2lvbiBhYm91dCB0aGUgd29yZCAnZ3JlYXRlcicsIHdlIGNob29zZSBwcF9pbmZpbml0eSBncmVhdGVyXG4gICB0aGFuIDFlMTAgKyAxOyBmb3IgY29ycmVjdCBoYW5kbGluZyBvZiB0ZXN0cyBpbiB0aGUgYWxnb3JpdGhtLFxuICAgcHBfaW5maW5pdHkgbXVzdCBiZSBldmVuIG9uZSBtb3JlIHRoYW4gMWUxMCArIDE7IGxldCdzIHN0YW5kIG9uIHRoZVxuICAgc2FmZSBzaWRlIGJ5IGNob29zaW5nIDEuZTEwKzEwLlxuXG4gICBQcF9pbmZpbml0eSBjb3VsZCBwcm9iYWJseSBiZSAxMDczNzQxODIzIHRoYXQgaXMgMl4zMCAtIDEsIHRoYXQgaXNcbiAgIHRoZSBtaW5pbWFsIHVwcGVyIGJvdW5kIGZvciBpbnRlZ2Vyczsgbm93IHRoYXQgbWF4X2ludCBpcyBkZWZpbmVkLFxuICAgdGhpcyBsaW1pdCBjb3VsZCBhbHNvIGJlIGRlZmluZWQgYXMgbWF4X2ludCAtIDEuXG5cbiAgIEhvd2V2ZXIsIGJlZm9yZSBzZXR0aW5nIHBwX2luZmluaXR5IHRvIHNvbWV0aGluZyBhcm91bmQgbWF4X2ludCwgd2VcbiAgIG11c3QgY2FyZWZ1bGx5IGRvdWJsZS1jaGVjayBhbGwgdGhlIGludGVnZXIgYXJpdGhtZXRpYyBvcGVyYXRpb25zXG4gICB0aGF0IGludm9sdmUgcHBfaW5maW5pdHksIHNpbmNlIGFueSBvdmVyZmxvdyB3b3VsZCB3cmVjayBoYXZvYyB0aGVcbiAgIHByZXR0eS1wcmludGluZyBhbGdvcml0aG0ncyBpbnZhcmlhbnRzLiBHaXZlbiB0aGF0IHRoaXMgYXJpdGhtZXRpY1xuICAgY29ycmVjdG5lc3MgY2hlY2sgaXMgZGlmZmljdWx0IGFuZCBlcnJvciBwcm9uZSBhbmQgZ2l2ZW4gdGhhdCAxZTEwXG4gICArIDEgaXMgaW4gcHJhY3RpY2UgbGFyZ2UgZW5vdWdoLCB0aGVyZSBpcyBubyBuZWVkIHRvIGF0dGVtcHQgdG8gc2V0XG4gICBwcF9pbmZpbml0eSB0byB0aGUgdGhlb3JldGljYWxseSBtYXhpbXVtIGxpbWl0LiBJdCBpcyBub3Qgd29ydGggdGhlXG4gICBidXJkZW4gISAqKVxubGV0IHBwX2luZmluaXR5ID0gMTAwMDAwMDAxMFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIGZvciB0aGUgZm9ybWF0dGVyLiAqKVxubGV0IHBwX291dHB1dF9zdHJpbmcgc3RhdGUgcyA9IHN0YXRlLnBwX291dF9zdHJpbmcgcyAwIChTdHJpbmcubGVuZ3RoIHMpXG5hbmQgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZSAoKVxuYW5kIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9zcGFjZXMgblxuYW5kIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9pbmRlbnQgblxuXG4oKiBGb3JtYXQgYSB0ZXh0dWFsIHRva2VuICopXG5sZXQgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSB0ZXh0ID1cbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gc2l6ZTtcbiAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSB0ZXh0O1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSBmYWxzZVxuXG4oKiBGb3JtYXQgYSBzdHJpbmcgYnkgaXRzIGxlbmd0aCwgaWYgbm90IGVtcHR5ICopXG5sZXQgZm9ybWF0X3N0cmluZyBzdGF0ZSBzID1cbiAgaWYgcyA8PiBcIlwiIHRoZW4gZm9ybWF0X3BwX3RleHQgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG4oKiBUbyBmb3JtYXQgYSBicmVhaywgaW5kZW50aW5nIGEgbmV3IGxpbmUuICopXG5sZXQgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKGJlZm9yZSwgb2Zmc2V0LCBhZnRlcikgd2lkdGggPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIHRydWU7XG4gIGxldCBpbmRlbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZnNldCBpblxuICAoKiBEb24ndCBpbmRlbnQgbW9yZSB0aGFuIHBwX21heF9pbmRlbnQuICopXG4gIGxldCByZWFsX2luZGVudCA9IG1pbiBzdGF0ZS5wcF9tYXhfaW5kZW50IGluZGVudCBpblxuICBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA8LSByZWFsX2luZGVudDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBhZnRlclxuXG5cbigqIFRvIGZvcmNlIGEgbGluZSBicmVhayBpbnNpZGUgYSBib3g6IG5vIG9mZnNldCBpcyBhZGRlZC4gKilcbmxldCBicmVha19saW5lIHN0YXRlIHdpZHRoID0gYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIDAsIFwiXCIpIHdpZHRoXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrIHRoYXQgZml0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoYmVmb3JlLCB3aWR0aCwgYWZ0ZXIpID1cbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBiZWZvcmU7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHdpZHRoO1xuICBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIHdpZHRoO1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gaW5kZW50IG5vIG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LCBpZiBvbmUgdHJpZXMgdG8gb3BlbiBhIGJveFxuICAgYmV5b25kIHBwX21heF9pbmRlbnQsIHRoZW4gdGhlIGJveCBpcyByZWplY3RlZCBvbiB0aGUgbGVmdFxuICAgYnkgc2ltdWxhdGluZyBhIGJyZWFrLiAqKVxubGV0IHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgPVxuICBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZVxuICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgIGlmIHdpZHRoID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuXG4gICAgICBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2ZpdHMgfCBQcF9oYm94IC0+ICgpXG4gICAgICB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG5cblxuKCogVG8gc2tpcCBhIHRva2VuLCBpZiB0aGUgcHJldmlvdXMgbGluZSBoYXMgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfc2tpcF90b2tlbiBzdGF0ZSA9XG4gIG1hdGNoIFF1ZXVlLnRha2Vfb3B0IHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHByaW50X2lmX25ld2xpbmUgbXVzdCBoYXZlIGJlZW4gdGhlIGxhc3QgcHJpbnRpbmcgY29tbWFuZCAqKVxuICB8IFNvbWUgeyBzaXplOyBsZW5ndGg7IF8gfSAtPlxuICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gc3RhdGUucHBfbGVmdF90b3RhbCAtIGxlbmd0aDtcbiAgICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgKyBTaXplLnRvX2ludCBzaXplXG5cblxuKCpcblxuICBUaGUgbWFpbiBwcmV0dHkgcHJpbnRpbmcgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBGb3JtYXR0aW5nIGEgdG9rZW4gd2l0aCBhIGdpdmVuIHNpemUuICopXG5sZXQgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgPSBmdW5jdGlvblxuXG4gIHwgUHBfdGV4dCBzIC0+XG4gICAgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSBzXG5cbiAgfCBQcF9iZWdpbiAob2ZmLCB0eSkgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGlmIGluc2VydGlvbl9wb2ludCA+IHN0YXRlLnBwX21heF9pbmRlbnQgdGhlblxuICAgICAgKCogY2FuIG5vdCBvcGVuIGEgYm94IHJpZ2h0IHRoZXJlLiAqKVxuICAgICAgYmVnaW4gcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSBlbmQ7XG4gICAgbGV0IHdpZHRoID0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIG9mZiBpblxuICAgIGxldCBib3hfdHlwZSA9XG4gICAgICBtYXRjaCB0eSB3aXRoXG4gICAgICB8IFBwX3Zib3ggLT4gUHBfdmJveFxuICAgICAgfCBQcF9oYm94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzIC0+XG4gICAgICAgIGlmIHNpemUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gdHkgZWxzZSBQcF9maXRzIGluXG4gICAgU3RhY2sucHVzaCB7IGJveF90eXBlOyB3aWR0aCB9IHN0YXRlLnBwX2Zvcm1hdF9zdGFja1xuXG4gIHwgUHBfZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF90YmVnaW4gKFBwX3Rib3ggXyBhcyB0Ym94KSAtPlxuICAgIFN0YWNrLnB1c2ggdGJveCBzdGF0ZS5wcF90Ym94X3N0YWNrXG5cbiAgfCBQcF90ZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHw+IGlnbm9yZVxuXG4gIHwgUHBfc3RhYiAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgfCBTb21lIChQcF90Ym94IHRhYnMpIC0+XG4gICAgICBsZXQgcmVjIGFkZF90YWIgbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT4gW25dXG4gICAgICAgIHwgeCA6OiBsIGFzIGxzIC0+IGlmIG4gPCB4IHRoZW4gbiA6OiBscyBlbHNlIHggOjogYWRkX3RhYiBuIGwgaW5cbiAgICAgIHRhYnMgOj0gYWRkX3RhYiAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCkgIXRhYnNcbiAgICBlbmRcblxuICB8IFBwX3RicmVhayAobiwgb2ZmKSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCB0YWIgPVxuICAgICAgICBtYXRjaCAhdGFicyB3aXRoXG4gICAgICAgIHwgW10gLT4gaW5zZXJ0aW9uX3BvaW50XG4gICAgICAgIHwgZmlyc3QgOjogXyAtPlxuICAgICAgICAgIGxldCByZWMgZmluZCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGhlYWQgOjogdGFpbCAtPlxuICAgICAgICAgICAgICBpZiBoZWFkID49IGluc2VydGlvbl9wb2ludCB0aGVuIGhlYWQgZWxzZSBmaW5kIHRhaWxcbiAgICAgICAgICAgIHwgW10gLT4gZmlyc3QgaW5cbiAgICAgICAgICBmaW5kICF0YWJzIGluXG4gICAgICBsZXQgb2Zmc2V0ID0gdGFiIC0gaW5zZXJ0aW9uX3BvaW50IGluXG4gICAgICBpZiBvZmZzZXQgPj0gMFxuICAgICAgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgKFwiXCIsIG9mZnNldCArIG4sIFwiXCIpXG4gICAgICBlbHNlIGJyZWFrX25ld19saW5lIHN0YXRlIChcIlwiLCB0YWIgKyBvZmYsIFwiXCIpIHN0YXRlLnBwX21hcmdpblxuICAgIGVuZFxuXG4gIHwgUHBfbmV3bGluZSAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgKCogTm8gb3BlbiBib3guICopXG4gICAgfCBTb21lIHsgd2lkdGg7IF99IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcbiAgICBlbmRcblxuICB8IFBwX2lmX25ld2xpbmUgLT5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCAhPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgdGhlbiBwcF9za2lwX3Rva2VuIHN0YXRlXG5cbiAgfCBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IC0+XG4gICAgbGV0IGJlZm9yZSwgb2ZmLCBfID0gYnJlYWtzIGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggYm94X3R5cGUgd2l0aFxuICAgICAgfCBQcF9ob3Zib3ggLT5cbiAgICAgICAgaWYgc2l6ZSArIFN0cmluZy5sZW5ndGggYmVmb3JlID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2JveCAtPlxuICAgICAgICAoKiBIYXZlIHRoZSBsaW5lIGp1c3QgYmVlbiBicm9rZW4gaGVyZSA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2lzX25ld19saW5lIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHMgZWxzZVxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGggZWxzZVxuICAgICAgICAoKiBicmVhayB0aGUgbGluZSBoZXJlIGxlYWRzIHRvIG5ldyBpbmRlbnRhdGlvbiA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ID4gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF9odmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgIHwgUHBfZml0cyAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF92Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9oYm94IC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgfCBQcF9vcGVuX3RhZyB0YWdfbmFtZSAtPlxuICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlcjtcbiAgICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF9tYXJrX3N0YWNrXG5cbiAgIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgIGJlZ2luIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfbWFya19zdGFjayB3aXRoXG4gICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIHRhZ19uYW1lIGluXG4gICAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXJcbiAgICAgZW5kXG5cblxuKCogUHJpbnQgaWYgdG9rZW4gc2l6ZSBpcyBrbm93biBlbHNlIHByaW50aW5nIGlzIGRlbGF5ZWQuXG4gICBQcmludGluZyBpcyBkZWxheWVkIHdoZW4gdGhlIHRleHQgd2FpdGluZyBpbiB0aGUgcXVldWUgcmVxdWlyZXNcbiAgIG1vcmUgcm9vbSB0byBmb3JtYXQgdGhhbiBleGlzdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCByZWMgYWR2YW5jZV9sZWZ0IHN0YXRlID1cbiAgbWF0Y2ggUXVldWUucGVla19vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogTm8gdG9rZW5zIHRvIHByaW50ICopXG4gIHwgU29tZSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSAtPlxuICAgIGxldCBwZW5kaW5nX2NvdW50ID0gc3RhdGUucHBfcmlnaHRfdG90YWwgLSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIGluXG4gICAgaWYgU2l6ZS5pc19rbm93biBzaXplIHx8IHBlbmRpbmdfY291bnQgPj0gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIGJlZ2luXG4gICAgICBRdWV1ZS50YWtlIHN0YXRlLnBwX3F1ZXVlIHw+IGlnbm9yZTsgKCogTm90IGVtcHR5OiB3ZSBwZWVrIGludG8gaXQgKilcbiAgICAgIGxldCBzaXplID0gaWYgU2l6ZS5pc19rbm93biBzaXplIHRoZW4gU2l6ZS50b19pbnQgc2l6ZSBlbHNlIHBwX2luZmluaXR5IGluXG4gICAgICBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSB0b2tlbjtcbiAgICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gbGVuZ3RoICsgc3RhdGUucHBfbGVmdF90b3RhbDtcbiAgICAgIChhZHZhbmNlX2xlZnQgW0B0YWlsY2FsbF0pIHN0YXRlXG4gICAgZW5kXG5cblxuKCogVG8gZW5xdWV1ZSBhIHRva2VuIDogdHJ5IHRvIGFkdmFuY2UuICopXG5sZXQgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHRvayA9IHBwX2VucXVldWUgc3RhdGUgdG9rOyBhZHZhbmNlX2xlZnQgc3RhdGVcblxuXG4oKiBUbyBlbnF1ZXVlIHN0cmluZ3MuICopXG5sZXQgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzID1cbiAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZTsgdG9rZW4gPSBQcF90ZXh0IHM7IGxlbmd0aCA9IFNpemUudG9faW50IHNpemUgfVxuXG5cbmxldCBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzID1cbiAgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgKFNpemUub2ZfaW50IChTdHJpbmcubGVuZ3RoIHMpKSBzXG5cblxuKCogUm91dGluZXMgZm9yIHNjYW4gc3RhY2tcbiAgIGRldGVybWluZSBzaXplIG9mIGJveGVzLiAqKVxuXG4oKiBUaGUgc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbmxldCBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhY2sgPVxuICBTdGFjay5jbGVhciBzdGFjaztcbiAgbGV0IHF1ZXVlX2VsZW0gPSB7IHNpemUgPSBTaXplLnVua25vd247IHRva2VuID0gUHBfdGV4dCBcIlwiOyBsZW5ndGggPSAwIH0gaW5cbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAtMTsgcXVldWVfZWxlbSB9IHN0YWNrXG5cbigqIFNldHRpbmcgdGhlIHNpemUgb2YgYm94ZXMgb24gc2NhbiBzdGFjazpcbiAgIGlmIHR5ID0gdHJ1ZSB0aGVuIHNpemUgb2YgYnJlYWsgaXMgc2V0IGVsc2Ugc2l6ZSBvZiBib3ggaXMgc2V0O1xuICAgaW4gZWFjaCBjYXNlIHBwX3NjYW5fc3RhY2sgaXMgcG9wcGVkLlxuXG4gICBOb3RlOlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiBzY2FuIHN0YWNrIGlzIGV4aGF1c3RpdmUsIHNpbmNlIHNjYW5fc3RhY2sgaXMgbmV2ZXJcbiAgIGVtcHR5LlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiB0b2tlbiBpbiBzY2FuIHN0YWNrIGlzIGFsc28gZXhoYXVzdGl2ZSxcbiAgIHNpbmNlIHNjYW5fcHVzaCBpcyB1c2VkIG9uIGJyZWFrcyBhbmQgb3BlbmluZyBvZiBib3hlcy4gKilcbmxldCBzZXRfc2l6ZSBzdGF0ZSB0eSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxuICB8IFNvbWUgeyBsZWZ0X3RvdGFsOyBxdWV1ZV9lbGVtIH0gLT5cbiAgICBsZXQgc2l6ZSA9IFNpemUudG9faW50IHF1ZXVlX2VsZW0uc2l6ZSBpblxuICAgICgqIHRlc3QgaWYgc2NhbiBzdGFjayBjb250YWlucyBhbnkgZGF0YSB0aGF0IGlzIG5vdCBvYnNvbGV0ZS4gKilcbiAgICBpZiBsZWZ0X3RvdGFsIDwgc3RhdGUucHBfbGVmdF90b3RhbCB0aGVuXG4gICAgICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFja1xuICAgIGVsc2VcbiAgICAgIG1hdGNoIHF1ZXVlX2VsZW0udG9rZW4gd2l0aFxuICAgICAgfCBQcF9icmVhayBfIHwgUHBfdGJyZWFrIChfLCBfKSAtPlxuICAgICAgICBpZiB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX2JlZ2luIChfLCBfKSAtPlxuICAgICAgICBpZiBub3QgdHkgdGhlbiBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uc2l6ZSA8LSBTaXplLm9mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgfD4gaWdub3JlXG4gICAgICAgIGVuZFxuICAgICAgfCBQcF90ZXh0IF8gfCBQcF9zdGFiIHwgUHBfdGJlZ2luIF8gfCBQcF90ZW5kIHwgUHBfZW5kXG4gICAgICB8IFBwX25ld2xpbmUgfCBQcF9pZl9uZXdsaW5lIHwgUHBfb3Blbl90YWcgXyB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICAgICAoKSAoKiBzY2FuX3B1c2ggaXMgb25seSB1c2VkIGZvciBicmVha3MgYW5kIGJveGVzLiAqKVxuXG5cbigqIFB1c2ggYSB0b2tlbiBvbiBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay5cbiAgIElmIGIgaXMgdHJ1ZSBzZXRfc2l6ZSBpcyBjYWxsZWQuICopXG5sZXQgc2Nhbl9wdXNoIHN0YXRlIGIgdG9rZW4gPVxuICBwcF9lbnF1ZXVlIHN0YXRlIHRva2VuO1xuICBpZiBiIHRoZW4gc2V0X3NpemUgc3RhdGUgdHJ1ZTtcbiAgbGV0IGVsZW0gPSB7IGxlZnRfdG90YWwgPSBzdGF0ZS5wcF9yaWdodF90b3RhbDsgcXVldWVfZWxlbSA9IHRva2VuIH0gaW5cbiAgU3RhY2sucHVzaCBlbGVtIHN0YXRlLnBwX3NjYW5fc3RhY2tcblxuXG4oKiBUbyBvcGVuIGEgbmV3IGJveCA6XG4gICB0aGUgdXNlciBtYXkgc2V0IHRoZSBkZXB0aCBib3VuZCBwcF9tYXhfYm94ZXNcbiAgIGFueSB0ZXh0IG5lc3RlZCBkZWVwZXIgaXMgcHJpbnRlZCBhcyB0aGUgZWxsaXBzaXMgc3RyaW5nLiAqKVxubGV0IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgYnJfdHkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX2JlZ2luIChpbmRlbnQsIGJyX3R5KTsgbGVuZ3RoID0gMCB9IGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIGZhbHNlIGVsZW0gZWxzZVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmcgc3RhdGUgc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUaGUgYm94IHdoaWNoIGlzIGFsd2F5cyBvcGVuLiAqKVxubGV0IHBwX29wZW5fc3lzX2JveCBzdGF0ZSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hvdmJveFxuXG4oKiBDbG9zZSBhIGJveCwgc2V0dGluZyBzaXplcyBvZiBpdHMgc3ViIGJveGVzLiAqKVxubGV0IHBwX2Nsb3NlX2JveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBiZWdpblxuICAgICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfZW5kOyBsZW5ndGggPSAwIH07XG4gICAgICBzZXRfc2l6ZSBzdGF0ZSB0cnVlOyBzZXRfc2l6ZSBzdGF0ZSBmYWxzZVxuICAgIGVuZDtcbiAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxO1xuICBlbmRcblxuXG4oKiBPcGVuIGEgdGFnLCBwdXNoaW5nIGl0IG9uIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfb3Blbl9zdGFnIHN0YXRlIHRhZ19uYW1lID1cbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gIGJlZ2luXG4gICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gICAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgdGFnX25hbWVcbiAgZW5kO1xuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIGxldCB0b2tlbiA9IFBwX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuOyBsZW5ndGggPSAwIH1cblxuXG4oKiBDbG9zZSBhIHRhZywgcG9wcGluZyBpdCBmcm9tIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfY2xvc2Vfc3RhZyBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfY2xvc2VfdGFnOyBsZW5ndGggPSAwIH07XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICAgIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfdGFnX3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgdGFnX25hbWVcblxubGV0IHBwX29wZW5fdGFnIHN0YXRlIHMgPSBwcF9vcGVuX3N0YWcgc3RhdGUgKFN0cmluZ190YWcgcylcbmxldCBwcF9jbG9zZV90YWcgc3RhdGUgKCkgPSBwcF9jbG9zZV9zdGFnIHN0YXRlICgpXG5cbmxldCBwcF9zZXRfcHJpbnRfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfcHJpbnRfdGFncyA8LSBiXG5sZXQgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfbWFya190YWdzIDwtIGJcbmxldCBwcF9nZXRfcHJpbnRfdGFncyBzdGF0ZSAoKSA9IHN0YXRlLnBwX3ByaW50X3RhZ3NcbmxldCBwcF9nZXRfbWFya190YWdzIHN0YXRlICgpID0gc3RhdGUucHBfbWFya190YWdzXG5sZXQgcHBfc2V0X3RhZ3Mgc3RhdGUgYiA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0YXRlIGI7IHBwX3NldF9tYXJrX3RhZ3Mgc3RhdGUgYlxuXG5cbigqIEhhbmRsaW5nIHRhZyBoYW5kbGluZyBmdW5jdGlvbnM6IGdldC9zZXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG1hcmtfb3Blbl9zdGFnID0gc3RhdGUucHBfbWFya19vcGVuX3RhZztcbiAgbWFya19jbG9zZV9zdGFnID0gc3RhdGUucHBfbWFya19jbG9zZV90YWc7XG4gIHByaW50X29wZW5fc3RhZyA9IHN0YXRlLnBwX3ByaW50X29wZW5fdGFnO1xuICBwcmludF9jbG9zZV9zdGFnID0gc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnO1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3N0YWcgPSBtb3Q7XG4gICAgIG1hcmtfY2xvc2Vfc3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl9zdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV9zdGFnID0gcGN0O1xuICB9ID1cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBtb3Q7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIG1jdDtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gcG90O1xuICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgPC0gcGN0XG5cblxuKCogSW5pdGlhbGl6ZSBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9yaW5pdCBzdGF0ZSA9XG4gIHBwX2NsZWFyX3F1ZXVlIHN0YXRlO1xuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfZm9ybWF0X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90Ym94X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX21hcmtfc3RhY2s7XG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIDA7XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gMDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW47XG4gIHBwX29wZW5fc3lzX2JveCBzdGF0ZVxuXG5sZXQgY2xlYXJfdGFnX3N0YWNrIHN0YXRlID1cbiAgU3RhY2suaXRlciAoZnVuIF8gLT4gcHBfY2xvc2VfdGFnIHN0YXRlICgpKSBzdGF0ZS5wcF90YWdfc3RhY2tcblxuXG4oKiBGbHVzaGluZyBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBiID1cbiAgY2xlYXJfdGFnX3N0YWNrIHN0YXRlO1xuICB3aGlsZSBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSBkb1xuICAgIHBwX2Nsb3NlX2JveCBzdGF0ZSAoKVxuICBkb25lO1xuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBwcF9pbmZpbml0eTtcbiAgYWR2YW5jZV9sZWZ0IHN0YXRlO1xuICBpZiBiIHRoZW4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHBwX3Jpbml0IHN0YXRlXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBmb3JtYXQgdmFsdWVzIGFuZCB1c2UgYm94ZXMuXG5cbiopXG5cbigqIFRvIGZvcm1hdCBhIHN0cmluZy4gKilcbmxldCBwcF9wcmludF9hc19zaXplIHN0YXRlIHNpemUgcyA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHNcblxuXG5sZXQgcHBfcHJpbnRfYXMgc3RhdGUgaXNpemUgcyA9XG4gIHBwX3ByaW50X2FzX3NpemUgc3RhdGUgKFNpemUub2ZfaW50IGlzaXplKSBzXG5cblxubGV0IHBwX3ByaW50X3N0cmluZyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG5cbigqIFRvIGZvcm1hdCBhbiBpbnRlZ2VyLiAqKVxubGV0IHBwX3ByaW50X2ludCBzdGF0ZSBpID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChJbnQudG9fc3RyaW5nIGkpXG5cbigqIFRvIGZvcm1hdCBhIGZsb2F0LiAqKVxubGV0IHBwX3ByaW50X2Zsb2F0IHN0YXRlIGYgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9mbG9hdCBmKVxuXG4oKiBUbyBmb3JtYXQgYSBib29sZWFuLiAqKVxubGV0IHBwX3ByaW50X2Jvb2wgc3RhdGUgYiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Jvb2wgYilcblxuKCogVG8gZm9ybWF0IGEgY2hhci4gKilcbmxldCBwcF9wcmludF9jaGFyIHN0YXRlIGMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAxIChTdHJpbmcubWFrZSAxIGMpXG5cblxuKCogT3BlbmluZyBib3hlcy4gKilcbmxldCBwcF9vcGVuX2hib3ggc3RhdGUgKCkgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9oYm94XG5hbmQgcHBfb3Blbl92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfdmJveFxuXG5hbmQgcHBfb3Blbl9odmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2h2Ym94XG5hbmQgcHBfb3Blbl9ob3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ob3Zib3hcbmFuZCBwcF9vcGVuX2JveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2JveFxuXG5cbigqIFByaW50aW5nIHF1ZXVlZCB0ZXh0LlxuXG4gICBbcHBfcHJpbnRfZmx1c2hdIHByaW50cyBhbGwgcGVuZGluZyBpdGVtcyBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYW5kXG4gICB0aGVuIGZsdXNoZXMgdGhlIGxvdyBsZXZlbCBvdXRwdXQgZGV2aWNlIG9mIHRoZSBmb3JtYXR0ZXIgdG8gYWN0dWFsbHlcbiAgIGRpc3BsYXkgcHJpbnRpbmcgbWF0ZXJpYWwuXG5cbiAgIFtwcF9wcmludF9uZXdsaW5lXSBiZWhhdmVzIGFzIFtwcF9wcmludF9mbHVzaF0gYWZ0ZXIgcHJpbnRpbmcgYW4gYWRkaXRpb25hbFxuICAgbmV3IGxpbmUuICopXG5sZXQgcHBfcHJpbnRfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIHRydWU7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuYW5kIHBwX3ByaW50X2ZsdXNoIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgZmFsc2U7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuXG5cbigqIFRvIGdldCBhIG5ld2xpbmUgd2hlbiBvbmUgZG9lcyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3VycmVudCBib3guICopXG5sZXQgcHBfZm9yY2VfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfbmV3bGluZTsgbGVuZ3RoID0gMCB9XG5cblxuKCogVG8gZm9ybWF0IHNvbWV0aGluZywgb25seSBpbiBjYXNlIHRoZSBsaW5lIGhhcyBqdXN0IGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3ByaW50X2lmX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGVcbiAgICAgIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9pZl9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBHZW5lcmFsaXplZCBicmVhayBoaW50IHRoYXQgYWxsb3dzIHByaW50aW5nIHN0cmluZ3MgYmVmb3JlL2FmdGVyXG4gICBzYW1lLWxpbmUgb2Zmc2V0ICh3aWR0aCkgb3IgbmV3LWxpbmUgb2Zmc2V0ICopXG5sZXQgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlIH5maXRzIH5icmVha3MgPVxuICBsZXQgYmVmb3JlLCB3aWR0aCwgYWZ0ZXIgPSBmaXRzIGluXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IHRva2VuID0gUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSBpblxuICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoIGJlZm9yZSArIHdpZHRoICsgU3RyaW5nLmxlbmd0aCBhZnRlciBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cbigqIFByaW50aW5nIGJyZWFrIGhpbnRzOlxuICAgQSBicmVhayBoaW50IGluZGljYXRlcyB3aGVyZSBhIGJveCBtYXkgYmUgYnJva2VuLlxuICAgSWYgbGluZSBpcyBicm9rZW4gdGhlbiBvZmZzZXQgaXMgYWRkZWQgdG8gdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICBib3ggZWxzZSAodGhlIHZhbHVlIG9mKSB3aWR0aCBibGFua3MgYXJlIHByaW50ZWQuICopXG5sZXQgcHBfcHJpbnRfYnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlXG4gICAgfmZpdHM6KFwiXCIsIHdpZHRoLCBcIlwiKSB+YnJlYWtzOihcIlwiLCBvZmZzZXQsIFwiXCIpXG5cblxuKCogUHJpbnQgYSBzcGFjZSA6XG4gICBhIHNwYWNlIGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBhIHNpbmdsZSBzcGFjZSBpZiB0aGUgYnJlYWsgZG9lcyBub3RcbiAgIHNwbGl0IHRoZSBsaW5lO1xuICAgYSBjdXQgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIG5vdGhpbmcgaWYgdGhlIGJyZWFrIGRvZXMgbm90IHNwbGl0IHRoZVxuICAgbGluZS4gKilcbmxldCBwcF9wcmludF9zcGFjZSBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDEgMFxuYW5kIHBwX3ByaW50X2N1dCBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDAgMFxuXG5cbigqIFRhYnVsYXRpb24gYm94ZXMuICopXG5sZXQgcHBfb3Blbl90Ym94IHN0YXRlICgpID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLnplcm8gaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF90YmVnaW4gKFBwX3Rib3ggKHJlZiBbXSkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqIENsb3NlIGEgdGFidWxhdGlvbiBib3guICopXG5sZXQgcHBfY2xvc2VfdGJveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF90ZW5kOyBsZW5ndGggPSAwIH0gaW5cbiAgICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW07XG4gICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDFcbiAgZW5kXG5cblxuKCogUHJpbnQgYSB0YWJ1bGF0aW9uIGJyZWFrLiAqKVxubGV0IHBwX3ByaW50X3RicmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RicmVhayAod2lkdGgsIG9mZnNldCk7IGxlbmd0aCA9IHdpZHRoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cblxubGV0IHBwX3ByaW50X3RhYiBzdGF0ZSAoKSA9IHBwX3ByaW50X3RicmVhayBzdGF0ZSAwIDBcblxubGV0IHBwX3NldF90YWIgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9zdGFiOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBjb250cm9sIHRoZSBwcmV0dHktcHJpbnRlcnNcblxuKilcblxuKCogU2V0X21heF9ib3hlcy4gKilcbmxldCBwcF9zZXRfbWF4X2JveGVzIHN0YXRlIG4gPSBpZiBuID4gMSB0aGVuIHN0YXRlLnBwX21heF9ib3hlcyA8LSBuXG5cbigqIFRvIGtub3cgdGhlIGN1cnJlbnQgbWF4aW11bSBudW1iZXIgb2YgYm94ZXMgYWxsb3dlZC4gKilcbmxldCBwcF9nZXRfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbmxldCBwcF9vdmVyX21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxuKCogRWxsaXBzaXMuICopXG5sZXQgcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgcyA9IHN0YXRlLnBwX2VsbGlwc2lzIDwtIHNcbmFuZCBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSAoKSA9IHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVG8gc2V0IHRoZSBtYXJnaW4gb2YgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfbGltaXQgbiA9XG4gIGlmIG4gPCBwcF9pbmZpbml0eSB0aGVuIG4gZWxzZSBwcmVkIHBwX2luZmluaXR5XG5cblxuKCogSW50ZXJuYWwgcHJldHR5LXByaW50ZXIgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdCA8LSBuO1xuICAgIHN0YXRlLnBwX21heF9pbmRlbnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfcmluaXQgc3RhdGVcblxuXG4oKiBJbml0aWFsbHksIHdlIGhhdmUgOlxuICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0LCBhbmRcbiAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW4uICopXG5sZXQgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbiA9XG4gIGlmIG4gPiAxIHRoZW5cbiAgICBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgKHN0YXRlLnBwX21hcmdpbiAtIG4pXG5cblxubGV0IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2luZGVudFxuXG5sZXQgcHBfc2V0X21hcmdpbiBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9tYXJnaW4gPC0gbjtcbiAgICBsZXQgbmV3X21heF9pbmRlbnQgPVxuICAgICAgKCogVHJ5IHRvIG1haW50YWluIG1heF9pbmRlbnQgdG8gaXRzIGFjdHVhbCB2YWx1ZS4gKilcbiAgICAgIGlmIHN0YXRlLnBwX21heF9pbmRlbnQgPD0gc3RhdGUucHBfbWFyZ2luXG4gICAgICB0aGVuIHN0YXRlLnBwX21heF9pbmRlbnQgZWxzZVxuICAgICAgKCogSWYgcG9zc2libGUgbWFpbnRhaW4gcHBfbWluX3NwYWNlX2xlZnQgdG8gaXRzIGFjdHVhbCB2YWx1ZSxcbiAgICAgICAgIGlmIHRoaXMgbGVhZHMgdG8gYSB0b28gc21hbGwgbWF4X2luZGVudCwgdGFrZSBoYWxmIG9mIHRoZVxuICAgICAgICAgbmV3IG1hcmdpbiwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDEuICopXG4gICAgICAgbWF4IChtYXggKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0KVxuICAgICAgICAgICAgICAgIChzdGF0ZS5wcF9tYXJnaW4gLyAyKSkgMSBpblxuICAgICgqIFJlYnVpbGQgaW52YXJpYW50cy4gKilcbiAgICBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuZXdfbWF4X2luZGVudFxuXG5cbigqKiBHZW9tZXRyeSBmdW5jdGlvbnMgYW5kIHR5cGVzICopXG50eXBlIGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OmludDsgbWFyZ2luOiBpbnR9XG5cbmxldCBjaGVja19nZW9tZXRyeSBnZW9tZXRyeSA9XG4gIGdlb21ldHJ5Lm1heF9pbmRlbnQgPiAxXG4gICYmICBnZW9tZXRyeS5tYXJnaW4gPiBnZW9tZXRyeS5tYXhfaW5kZW50XG5cbmxldCBwcF9nZXRfbWFyZ2luIHN0YXRlICgpID0gc3RhdGUucHBfbWFyZ2luXG5cbmxldCBwcF9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGlmIG1heF9pbmRlbnQgPCAyIHRoZW5cbiAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkZvcm1hdC5wcF9zZXRfZ2VvbWV0cnk6IG1heF9pbmRlbnQgPCAyXCIpXG4gIGVsc2UgaWYgbWFyZ2luIDw9IG1heF9pbmRlbnQgdGhlblxuICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJGb3JtYXQucHBfc2V0X2dlb21ldHJ5OiBtYXJnaW4gPD0gbWF4X2luZGVudFwiKVxuICBlbHNlXG4gICAgcHBfc2V0X21hcmdpbiBzdGF0ZSBtYXJnaW47IHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG1heF9pbmRlbnRcblxubGV0IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0YXRlIH5tYXhfaW5kZW50IH5tYXJnaW4gPVxuICBpZiBjaGVja19nZW9tZXRyeSB7bWF4X2luZGVudDttYXJnaW59IHRoZW5cbiAgICBwcF9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpblxuICBlbHNlXG4gICAgKClcblxubGV0IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSA9XG4gIHsgbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKTsgbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpIH1cblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgICBvdXRfc3RyaW5nID0gZjtcbiAgICAgIG91dF9mbHVzaCA9IGc7XG4gICAgICBvdXRfbmV3bGluZSA9IGg7XG4gICAgICBvdXRfc3BhY2VzID0gaTtcbiAgICAgIG91dF9pbmRlbnQgPSBqO1xuICAgIH0gPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGk7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0galxuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBvdXRfc3RyaW5nID0gc3RhdGUucHBfb3V0X3N0cmluZztcbiAgb3V0X2ZsdXNoID0gc3RhdGUucHBfb3V0X2ZsdXNoO1xuICBvdXRfbmV3bGluZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lO1xuICBvdXRfc3BhY2VzID0gc3RhdGUucHBfb3V0X3NwYWNlcztcbiAgb3V0X2luZGVudCA9IHN0YXRlLnBwX291dF9pbmRlbnQ7XG59XG5cblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBzdHJpbmcgb3V0cHV0IGFuZCBmbHVzaCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjsgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGdcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9XG4gIChzdGF0ZS5wcF9vdXRfc3RyaW5nLCBzdGF0ZS5wcF9vdXRfZmx1c2gpXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X25ld2xpbmUgc3RhdGUgKCkgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIFwiXFxuXCIgMCAgMVxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgc3BhY2VzLiAqKVxubGV0IGJsYW5rX2xpbmUgPSBTdHJpbmcubWFrZSA4MCAnICdcbmxldCByZWMgZGlzcGxheV9ibGFua3Mgc3RhdGUgbiA9XG4gIGlmIG4gPiAwIHRoZW5cbiAgaWYgbiA8PSA4MCB0aGVuIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIG4gZWxzZVxuICBiZWdpblxuICAgIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIDgwO1xuICAgIGRpc3BsYXlfYmxhbmtzIHN0YXRlIChuIC0gODApXG4gIGVuZFxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9pbmRlbnQgPSBkaXNwbGF5X2JsYW5rc1xuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMgYXMgcHJpbnRpbmcgdG8gYSBnaXZlblxuICAgW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGF0ZSBvYyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gb3V0cHV0X3N1YnN0cmluZyBvYztcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIChmdW4gKCkgLT4gZmx1c2ggb2MpO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3Mgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgc3RhdGVcblxuKCpcblxuICBEZWZpbmluZyBzcGVjaWZpYyBmb3JtYXR0ZXJzXG5cbiopXG5cbmxldCBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjxcIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxubGV0IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjwvXCIgXiBzIF4gXCI+XCJcbiAgfCBfIC0+IFwiXCJcblxubGV0IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWcgPSBpZ25vcmVcbmxldCBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyA9IGlnbm9yZVxuXG4oKiBCdWlsZGluZyBhIGZvcm1hdHRlciBnaXZlbiBpdHMgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy5cbiAgIE90aGVyIGZpZWxkcyBnZXQgcmVhc29uYWJsZSBkZWZhdWx0IHZhbHVlcy4gKilcbmxldCBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGogPVxuICAoKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZm9ybWF0dGVyIGNvbnRhaW5zIGEgZHVtbXkgYm94LiAqKVxuICBsZXQgcHBfcXVldWUgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0IHN5c190b2sgPVxuICAgIHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF9iZWdpbiAoMCwgUHBfaG92Ym94KTsgbGVuZ3RoID0gMCB9IGluXG4gIFF1ZXVlLmFkZCBzeXNfdG9rIHBwX3F1ZXVlO1xuICBsZXQgc2Nhbl9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKSBpblxuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc2Nhbl9zdGFjaztcbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAxOyBxdWV1ZV9lbGVtID0gc3lzX3RvayB9IHNjYW5fc3RhY2s7XG4gIGxldCBwcF9tYXJnaW4gPSA3OFxuICBhbmQgcHBfbWluX3NwYWNlX2xlZnQgPSAxMCBpblxuICB7XG4gICAgcHBfc2Nhbl9zdGFjayA9IHNjYW5fc3RhY2s7XG4gICAgcHBfZm9ybWF0X3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX3Rib3hfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGFnX3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX21hcmtfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFyZ2luID0gcHBfbWFyZ2luO1xuICAgIHBwX21pbl9zcGFjZV9sZWZ0ID0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW47XG4gICAgcHBfY3VycmVudF9pbmRlbnQgPSAwO1xuICAgIHBwX2lzX25ld19saW5lID0gdHJ1ZTtcbiAgICBwcF9sZWZ0X3RvdGFsID0gMTtcbiAgICBwcF9yaWdodF90b3RhbCA9IDE7XG4gICAgcHBfY3Vycl9kZXB0aCA9IDE7XG4gICAgcHBfbWF4X2JveGVzID0gbWF4X2ludDtcbiAgICBwcF9lbGxpcHNpcyA9IFwiLlwiO1xuICAgIHBwX291dF9zdHJpbmcgPSBmO1xuICAgIHBwX291dF9mbHVzaCA9IGc7XG4gICAgcHBfb3V0X25ld2xpbmUgPSBoO1xuICAgIHBwX291dF9zcGFjZXMgPSBpO1xuICAgIHBwX291dF9pbmRlbnQgPSBqO1xuICAgIHBwX3ByaW50X3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX29wZW5fdGFnID0gZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnO1xuICAgIHBwX21hcmtfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZztcbiAgICBwcF9wcmludF9vcGVuX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWc7XG4gICAgcHBfcHJpbnRfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWc7XG4gICAgcHBfcXVldWUgPSBwcF9xdWV1ZTtcbiAgfVxuXG5cbigqIEJ1aWxkIGEgZm9ybWF0dGVyIG91dCBvZiBpdHMgb3V0IGZ1bmN0aW9ucy4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyBvdXRfZnVucyA9XG4gIHBwX21ha2VfZm9ybWF0dGVyXG4gICAgb3V0X2Z1bnMub3V0X3N0cmluZ1xuICAgIG91dF9mdW5zLm91dF9mbHVzaFxuICAgIG91dF9mdW5zLm91dF9uZXdsaW5lXG4gICAgb3V0X2Z1bnMub3V0X3NwYWNlc1xuICAgIG91dF9mdW5zLm91dF9pbmRlbnRcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdpdGggZGVmYXVsdCBmdW5jdGlvbnMgdG8gb3V0cHV0IHNwYWNlcyxcbiAgaW5kZW50YXRpb24sIGFuZCBuZXcgbGluZXMuICopXG5sZXQgbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoID1cbiAgbGV0IHBwZiA9IHBwX21ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCBpZ25vcmUgaWdub3JlIGlnbm9yZSBpblxuICBwcGYucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHBwZjtcbiAgcHBmLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3MgcHBmO1xuICBwcGYucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBwcGY7XG4gIHBwZlxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBvYyA9XG4gIG1ha2VfZm9ybWF0dGVyIChvdXRwdXRfc3Vic3RyaW5nIG9jKSAoZnVuICgpIC0+IGZsdXNoIG9jKVxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtCdWZmZXIudF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX2J1ZmZlciBiID1cbiAgbWFrZV9mb3JtYXR0ZXIgKEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIpIGlnbm9yZVxuXG5cbigqIEFsbG9jYXRpbmcgYnVmZmVyIGZvciBwcmV0dHktcHJpbnRpbmcgcHVycG9zZXMuXG4gICBEZWZhdWx0IGJ1ZmZlciBzaXplIGlzIHBwX2J1ZmZlcl9zaXplIG9yIDUxMi5cbiopXG5sZXQgcHBfYnVmZmVyX3NpemUgPSA1MTJcbmxldCBwcF9tYWtlX2J1ZmZlciAoKSA9IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemVcblxuKCogVGhlIHN0YW5kYXJkIChzaGFyZWQpIGJ1ZmZlci4gKilcbmxldCBzdGRidWYgPSBwcF9tYWtlX2J1ZmZlciAoKVxuXG4oKiBQcmVkZWZpbmVkIGZvcm1hdHRlcnMgc3RhbmRhcmQgZm9ybWF0dGVyIHRvIHByaW50XG4gICB0byBbU3RkbGliLnN0ZG91dF0sIFtTdGRsaWIuc3RkZXJyXSwgYW5kIHshc3RkYnVmfS4gKilcbmxldCBzdGRfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRvdXRcbmFuZCBlcnJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRlcnJcbmFuZCBzdHJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX2J1ZmZlciBzdGRidWZcblxuXG4oKiBbZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmXSBmbHVzaGVzIGZvcm1hdHRlciBbcHBmXSxcbiAgIHRoZW4gcmV0dXJucyB0aGUgY29udGVudHMgb2YgYnVmZmVyIFtidWZdIHRoYXQgaXMgcmVzZXQuXG4gICBGb3JtYXR0ZXIgW3BwZl0gaXMgc3VwcG9zZWQgdG8gcHJpbnQgdG8gYnVmZmVyIFtidWZdLCBvdGhlcndpc2UgdGhpc1xuICAgZnVuY3Rpb24gaXMgbm90IHJlYWxseSB1c2VmdWwuICopXG5sZXQgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmID1cbiAgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlO1xuICBsZXQgcyA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgQnVmZmVyLnJlc2V0IGJ1ZjtcbiAgc1xuXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID0gZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtTdGRsaWIuc3Rkb3V0XSkuXG5cbiopXG5cbmxldCBvcGVuX2hib3ggPSBwcF9vcGVuX2hib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdmJveCA9IHBwX29wZW5fdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9odmJveCA9IHBwX29wZW5faHZib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faG92Ym94ID0gcHBfb3Blbl9ob3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fYm94ID0gcHBfb3Blbl9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX2JveCA9IHBwX2Nsb3NlX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl90YWcgPSBwcF9vcGVuX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGFnID0gcHBfY2xvc2VfdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3N0YWcgPSBwcF9vcGVuX3N0YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3N0YWcgPSBwcF9jbG9zZV9zdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9hcyA9IHBwX3ByaW50X2FzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zdHJpbmcgPSBwcF9wcmludF9zdHJpbmcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ludCA9IHBwX3ByaW50X2ludCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmxvYXQgPSBwcF9wcmludF9mbG9hdCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY2hhciA9IHBwX3ByaW50X2NoYXIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Jvb2wgPSBwcF9wcmludF9ib29sIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9icmVhayA9IHBwX3ByaW50X2JyZWFrIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jdXQgPSBwcF9wcmludF9jdXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3NwYWNlID0gcHBfcHJpbnRfc3BhY2Ugc3RkX2Zvcm1hdHRlclxuYW5kIGZvcmNlX25ld2xpbmUgPSBwcF9mb3JjZV9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbHVzaCA9IHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9uZXdsaW5lID0gcHBfcHJpbnRfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaWZfbmV3bGluZSA9IHBwX3ByaW50X2lmX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuXG5hbmQgb3Blbl90Ym94ID0gcHBfb3Blbl90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90Ym94ID0gcHBfY2xvc2VfdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGJyZWFrID0gcHBfcHJpbnRfdGJyZWFrIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF90YWIgPSBwcF9zZXRfdGFiIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YWIgPSBwcF9wcmludF90YWIgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21hcmdpbiA9IHBwX3NldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfaW5kZW50ID0gcHBfc2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2dlb21ldHJ5ID0gcHBfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBzYWZlX3NldF9nZW9tZXRyeSA9IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21heF9ib3hlcyA9IHBwX3NldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfYm94ZXMgPSBwcF9nZXRfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBvdmVyX21heF9ib3hlcyA9IHBwX292ZXJfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9lbGxpcHNpc190ZXh0ID0gcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9lbGxpcHNpc190ZXh0ID0gcHBfZ2V0X2VsbGlwc2lzX3RleHQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfcHJpbnRfdGFncyA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfcHJpbnRfdGFncyA9XG4gIHBwX2dldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfbWFya190YWdzID1cbiAgcHBfc2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmtfdGFncyA9XG4gIHBwX2dldF9tYXJrX3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF90YWdzID1cbiAgcHBfc2V0X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuXG5cbigqIENvbnZlbmllbmNlIGZ1bmN0aW9ucyAqKVxuXG4oKiBUbyBmb3JtYXQgYSBsaXN0ICopXG5sZXQgcmVjIHBwX3ByaW50X2xpc3QgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIHBwX3YgcHBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAoKVxuICB8IFt2XSAtPiBwcF92IHBwZiB2XG4gIHwgdiA6OiB2cyAtPlxuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF9wcmludF9saXN0IH5wcF9zZXAgcHBfdiBwcGYgdnNcblxuKCogVG8gZm9ybWF0IGZyZWUtZmxvd2luZyB0ZXh0ICopXG5sZXQgcHBfcHJpbnRfdGV4dCBwcGYgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGxlZnQgPSByZWYgMCBpblxuICBsZXQgcmlnaHQgPSByZWYgMCBpblxuICBsZXQgZmx1c2ggKCkgPVxuICAgIHBwX3ByaW50X3N0cmluZyBwcGYgKFN0cmluZy5zdWIgcyAhbGVmdCAoIXJpZ2h0IC0gIWxlZnQpKTtcbiAgICBpbmNyIHJpZ2h0OyBsZWZ0IDo9ICFyaWdodDtcbiAgaW5cbiAgd2hpbGUgKCFyaWdodCA8PiBsZW4pIGRvXG4gICAgbWF0Y2ggcy5bIXJpZ2h0XSB3aXRoXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGZsdXNoICgpO1xuICAgICAgICBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgZmx1c2ggKCk7IHBwX3ByaW50X3NwYWNlIHBwZiAoKVxuICAgICAgKCogdGhlcmUgaXMgbm8gc3BlY2lmaWMgc3VwcG9ydCBmb3IgJ1xcdCdcbiAgICAgICAgIGFzIGl0IGlzIHVuY2xlYXIgd2hhdCBhIHJpZ2h0IHNlbWFudGljcyB3b3VsZCBiZSAqKVxuICAgICAgfCBfIC0+IGluY3IgcmlnaHRcbiAgZG9uZTtcbiAgaWYgIWxlZnQgPD4gbGVuIHRoZW4gZmx1c2ggKClcblxubGV0IHBwX3ByaW50X29wdGlvbiA/KG5vbmUgPSBmdW4gXyAoKSAtPiAoKSkgcHBfdiBwcGYgPSBmdW5jdGlvblxufCBOb25lIC0+IG5vbmUgcHBmICgpXG58IFNvbWUgdiAtPiBwcF92IHBwZiB2XG5cbmxldCBwcF9wcmludF9yZXN1bHQgfm9rIH5lcnJvciBwcGYgPSBmdW5jdGlvblxufCBPayB2IC0+IG9rIHBwZiB2XG58IEVycm9yIGUgLT4gZXJyb3IgcHBmIGVcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfdGFnIHBwZiAoKVxuICB8IEJyZWFrIChfLCB3aWR0aCwgb2Zmc2V0KSAgLT4gcHBfcHJpbnRfYnJlYWsgcHBmIHdpZHRoIG9mZnNldFxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfZmx1c2ggcHBmICgpXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfcHJpbnRfbmV3bGluZSBwcGYgKClcbiAgfCBNYWdpY19zaXplIChfLCBfKSAgICAgICAgIC0+ICgpXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCdcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICclJ1xuICB8IFNjYW5faW5kaWMgYyAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnOyBwcF9wcmludF9jaGFyIHBwZiBjXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5vdXRwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IGYgcHBmO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5idWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2RlbGF5IChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoZiAoKSk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgKGYgKCkpO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCpcblxuICBEZWZpbmluZyBbZnByaW50Zl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbZnByaW50Zl0uXG5cbiopXG5cbmxldCBrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBwcGYgYWNjOyBrIHBwZilcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5hbmQgaWtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgcHBmIGZtdFxuXG5sZXQgaWZwcmludGYgX3BwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBpZ25vcmUgKCkgZm10XG5cbmxldCBmcHJpbnRmIHBwZiA9IGtmcHJpbnRmIGlnbm9yZSBwcGZcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRfZm9ybWF0dGVyIGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBlcnJfZm9ybWF0dGVyIGZtdFxuXG5sZXQga2RwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gayAoZnVuIHBwZiAtPiBvdXRwdXRfYWNjIHBwZiBhY2MpKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmxldCBkcHJpbnRmIGZtdCA9IGtkcHJpbnRmIChmdW4gaSAtPiBpKSBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBzdHJwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIGlkIGZtdFxuXG5sZXQga2FzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBvdXRwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBhc3ByaW50ZiBmbXQgPSBrYXNwcmludGYgaWQgZm10XG5cbigqIEZsdXNoaW5nIHN0YW5kYXJkIGZvcm1hdHRlcnMgYXQgZW5kIG9mIGV4ZWN1dGlvbi4gKilcblxubGV0IGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMgKCkgPVxuICBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyICgpO1xuICBwcF9wcmludF9mbHVzaCBlcnJfZm9ybWF0dGVyICgpXG5cbmxldCAoKSA9IGF0X2V4aXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVyc1xuXG4oKlxuXG4gIERlcHJlY2F0ZWQgc3R1ZmYuXG5cbiopXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlXG4gICAgfm91dDpmIH5mbHVzaDpnIH5uZXdsaW5lOmggfnNwYWNlczppID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaCxcbiAgIHN0YXRlLnBwX291dF9uZXdsaW5lLCBzdGF0ZS5wcF9vdXRfc3BhY2VzKVxuXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IGdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogZXJyb3IgcHJvbmUgZnVuY3Rpb24sIGRvIG5vdCB1c2UgaXQuXG4gICBUaGlzIGZ1bmN0aW9uIGlzIG5laXRoZXIgY29tcG9zaXRpb25hbCBub3IgaW5jcmVtZW50YWwsIHNpbmNlIGl0IGZsdXNoZXNcbiAgIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhdCBlYWNoIGNhbGwuXG4gICBUbyBnZXQgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSwgZGVmaW5lIGEgZm9ybWF0dGVyIG9mIHlvdXIgb3duIHdyaXRpbmcgdG9cbiAgIHRoZSBidWZmZXIgYXJndW1lbnQsIGFzIGluXG4gICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiXG4gICB0aGVuIHVzZSB7IWZwcmludGYgcHBmfSBhcyB1c3VhbC4gKilcbmxldCBicHJpbnRmIGIgKEZvcm1hdCAoZm10LCBfKSA6ICgnYSwgZm9ybWF0dGVyLCB1bml0KSBmb3JtYXQpID1cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPSBvdXRwdXRfYWNjIHBwZiBhY2M7IHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxuKCogRGVwcmVjYXRlZCA6IGFsaWFzIGZvciBrc3ByaW50Zi4gKilcbmxldCBrcHJpbnRmID0ga3NwcmludGZcblxuXG5cbigqIERlcHJlY2F0ZWQgdGFnIGZ1bmN0aW9ucyAqKVxuXG50eXBlIGZvcm1hdHRlcl90YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fdGFnIDogdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3RhZyA6IHRhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV90YWcgOiB0YWcgLT4gdW5pdDtcbn1cblxuXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV90YWcgPSBtY3Q7XG4gICAgIHByaW50X29wZW5fdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV90YWcgPSBwY3Q7XG4gICB9ID1cbiAgbGV0IHN0cmluZ2lmeSBmIGUgPSBmdW5jdGlvbiBTdHJpbmdfdGFnIHMgLT4gZiBzIHwgXyAtPiBlIGluXG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gc3RyaW5naWZ5IG1vdCBcIlwiO1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgbWN0IFwiXCI7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHN0cmluZ2lmeSBwb3QgKCk7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgcGN0ICgpXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgZm10ICgpID1cbiAgbGV0IGZ1bnMgPSBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIGZtdCAoKSBpblxuICBsZXQgbWFya19vcGVuX3RhZyBzID0gZnVucy5tYXJrX29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgbWFya19jbG9zZV90YWcgcyA9IGZ1bnMubWFya19jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBwcmludF9vcGVuX3RhZyBzID0gZnVucy5wcmludF9vcGVuX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X2Nsb3NlX3RhZyBzID0gZnVucy5wcmludF9jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIHttYXJrX29wZW5fdGFnOyBtYXJrX2Nsb3NlX3RhZzsgcHJpbnRfb3Blbl90YWc7IHByaW50X2Nsb3NlX3RhZ31cblxubGV0IHNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIGFsaWFzIHRvIGF2b2lkIHdhcm5pbmcgZm9yIGFtYmlndWl0eSBiZXR3ZWVuXG4gICBTdGRsaWIuZm9ybWF0NlxuICAgYW5kIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG5cbiAgICh0aGUgZm9ybWVyIGlzIGluIGZhY3QgYW4gYWxpYXMgZm9yIHRoZSBsYXR0ZXIsXG4gICAgYnV0IHRoZSBhbWJpZ3VpdHkgd2FybmluZyBkb2Vzbid0IGNhcmUpXG4qKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBTdGRsaWIuZm9ybWF0NlxuXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FubmVycy4gKilcblxuKCogU2Nhbm5pbmcgYnVmZmVycy4gKilcbm1vZHVsZSB0eXBlIFNDQU5OSU5HID0gc2lnXG5cbiAgdHlwZSBpbl9jaGFubmVsXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdmFsIHN0ZGluIDogaW5fY2hhbm5lbFxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS5cbiAgICAgW3N0ZGliXSBpcyBlcXVpdmFsZW50IHRvIFtTY2FubmluZy5mcm9tX2NoYW5uZWwgU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgc3RkaWIgOiBpbl9jaGFubmVsXG4gICgqIEFuIGFsaWFzIGZvciBbU2NhbmYuc3RkaW5dLCB0aGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbVxuICAgICBbU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgbmV4dF9jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5uZXh0X2NoYXIgaWJdIGFkdmFuY2UgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3Rlci5cbiAgICAgSWYgbm8gbW9yZSBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYSBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXSBtYXJrIHRoZSBjdXJyZW50X2NoYXIgYXMgYWxyZWFkeVxuICAgICBzY2FubmVkLiAqKVxuXG4gIHZhbCBwZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLnBlZWtfY2hhciBpYl0gcmV0dXJucyB0aGUgY3VycmVudCBjaGFyIGF2YWlsYWJsZSBpblxuICAgICB0aGUgYnVmZmVyIG9yIHJlYWRzIG9uZSBpZiBuZWNlc3NhcnkgKHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzXG4gICAgIGFscmVhZHkgc2Nhbm5lZCkuXG4gICAgIElmIG5vIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhbiBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgY2hlY2tlZF9wZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogU2FtZSBhcyBbU2Nhbm5pbmcucGVla19jaGFyXSBhYm92ZSBidXQgYWx3YXlzIHJldHVybnMgYSB2YWxpZCBjaGFyIG9yXG4gICAgIGZhaWxzOiBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG51bGwgY2hhciB3aGVuIHRoZSByZWFkaW5nIG1ldGhvZCBvZiB0aGVcbiAgICAgaW5wdXQgYnVmZmVyIGhhcyByZWFjaGVkIGFuIGVuZCBvZiBmaWxlLCB0aGUgZnVuY3Rpb24gcmFpc2VzIGV4Y2VwdGlvblxuICAgICBbRW5kX29mX2ZpbGVdLiAqKVxuXG4gIHZhbCBzdG9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gY2hhciAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnN0b3JlX2NoYXIgbGltIGliIGNdIGFkZHMgW2NdIHRvIHRoZSB0b2tlbiBidWZmZXJcbiAgICAgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlciBbaWJdLiBJdCBhbHNvIGFkdmFuY2VzIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIgYW5kIHJldHVybnMgW2xpbSAtIDFdLCBpbmRpY2F0aW5nIHRoZSBuZXcgbGltaXQgZm9yIHRoZVxuICAgICBsZW5ndGggb2YgdGhlIGN1cnJlbnQgdG9rZW4uICopXG5cbiAgdmFsIHNraXBfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc2tpcF9jaGFyIGxpbSBpYl0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuICopXG5cbiAgdmFsIGlnbm9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5pZ25vcmVfY2hhciBpYiBsaW1dIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGFuZFxuICAgICBkZWNyZW1lbnRzIHRoZSBsaW1pdC4gKilcblxuICB2YWwgdG9rZW4gOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcudG9rZW4gaWJdIHJldHVybnMgdGhlIHN0cmluZyBzdG9yZWQgaW50byB0aGUgdG9rZW5cbiAgICAgYnVmZmVyIG9mIHRoZSBzY2FubmluZyBidWZmZXI6IGl0IHJldHVybnMgdGhlIHRva2VuIG1hdGNoZWQgYnkgdGhlXG4gICAgIGZvcm1hdC4gKilcblxuICB2YWwgcmVzZXRfdG9rZW4gOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLnJlc2V0X3Rva2VuIGliXSByZXNldHMgdGhlIHRva2VuIGJ1ZmZlciBvZlxuICAgICB0aGUgZ2l2ZW4gc2Nhbm5pbmcgYnVmZmVyLiAqKVxuXG4gIHZhbCBjaGFyX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmNoYXJfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbGluZV9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5saW5lX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbmV3IGxpbmVcbiAgICAgY2hhcmFjdGVycyByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIHRva2VuX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnRva2VuX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgdG9rZW5zIHJlYWRcbiAgICAgc28gZmFyIGZyb20gW2liXS4gKilcblxuICB2YWwgZW9mIDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lb2YgaWJdIHJldHVybnMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgZW5kX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIgKGlmIG5vIGNoYXIgaGFzIGV2ZXIgYmVlbiByZWFkLCBhbiBhdHRlbXB0IHRvXG4gICAgIHJlYWQgb25lIGlzIHBlcmZvcm1lZCkuICopXG5cbiAgdmFsIGJlZ2lubmluZ19vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuYmVnaW5uaW5nX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgYmVnaW5uaW5nIG9mIGlucHV0XG4gICAgIGNvbmRpdGlvbiBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBuYW1lX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLm5hbWVfb2ZfaW5wdXQgaWJdIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNoYXJhY3RlclxuICAgICBzb3VyY2UgZm9yIGlucHV0IGJ1ZmZlciBbaWJdLiAqKVxuXG4gIHZhbCBvcGVuX2luIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIG9wZW5faW5fYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZSA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGVfYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fc3RyaW5nIDogc3RyaW5nIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZnVuY3Rpb24gOiAodW5pdCAtPiBjaGFyKSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2NoYW5uZWwgOiBTdGRsaWIuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG5cbiAgdmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0XG5cbiAgdmFsIG1lbW9fZnJvbV9jaGFubmVsIDogU3RkbGliLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuICAoKiBPYnNvbGV0ZS4gKilcblxuZW5kXG5cblxubW9kdWxlIFNjYW5uaW5nIDogU0NBTk5JTkcgPSBzdHJ1Y3RcblxuICAoKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2NhbmYuICopXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB0eXBlIGluX2NoYW5uZWxfbmFtZSA9XG4gICAgfCBGcm9tX2NoYW5uZWwgb2YgU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZmlsZSBvZiBmaWxlX25hbWUgKiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9mdW5jdGlvblxuICAgIHwgRnJvbV9zdHJpbmdcblxuXG4gIHR5cGUgaW5fY2hhbm5lbCA9IHtcbiAgICBtdXRhYmxlIGljX2VvZiA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXIgOiBjaGFyO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2NoYXJfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19saW5lX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfdG9rZW5fY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19nZXRfbmV4dF9jaGFyIDogdW5pdCAtPiBjaGFyO1xuICAgIGljX3Rva2VuX2J1ZmZlciA6IEJ1ZmZlci50O1xuICAgIGljX2lucHV0X25hbWUgOiBpbl9jaGFubmVsX25hbWU7XG4gIH1cblxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICBsZXQgbnVsbF9jaGFyID0gJ1xcMDAwJ1xuXG4gICgqIFJlYWRzIGEgbmV3IGNoYXJhY3RlciBmcm9tIGlucHV0IGJ1ZmZlci5cbiAgICAgTmV4dF9jaGFyIG5ldmVyIGZhaWxzLCBldmVuIGluIGNhc2Ugb2YgZW5kIG9mIGlucHV0OlxuICAgICBpdCB0aGVuIHNpbXBseSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24uICopXG4gIGxldCBuZXh0X2NoYXIgaWIgPVxuICAgIHRyeVxuICAgICAgbGV0IGMgPSBpYi5pY19nZXRfbmV4dF9jaGFyICgpIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSB0cnVlO1xuICAgICAgaWIuaWNfY2hhcl9jb3VudCA8LSBzdWNjIGliLmljX2NoYXJfY291bnQ7XG4gICAgICBpZiBjID0gJ1xcbicgdGhlbiBpYi5pY19saW5lX2NvdW50IDwtIHN1Y2MgaWIuaWNfbGluZV9jb3VudDtcbiAgICAgIGMgd2l0aFxuICAgIHwgRW5kX29mX2ZpbGUgLT5cbiAgICAgIGxldCBjID0gbnVsbF9jaGFyIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZTtcbiAgICAgIGliLmljX2VvZiA8LSB0cnVlO1xuICAgICAgY1xuXG5cbiAgbGV0IHBlZWtfY2hhciBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jdXJyZW50X2NoYXJcbiAgICBlbHNlIG5leHRfY2hhciBpYlxuXG5cbiAgKCogUmV0dXJucyBhIHZhbGlkIGN1cnJlbnQgY2hhciBmb3IgdGhlIGlucHV0IGJ1ZmZlci4gSW4gcGFydGljdWxhclxuICAgICBubyBpcnJlbGV2YW50IG51bGwgY2hhcmFjdGVyIChhcyBzZXQgYnkgW25leHRfY2hhcl0gaW4gY2FzZSBvZiBlbmRcbiAgICAgb2YgaW5wdXQpIGlzIHJldHVybmVkLCBzaW5jZSBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuXG4gICAgIFtuZXh0X2NoYXJdIHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiB3aGlsZSB0cnlpbmcgdG8gcmVhZCBhXG4gICAgIG5ldyBjaGFyYWN0ZXIuICopXG4gIGxldCBjaGVja2VkX3BlZWtfY2hhciBpYiA9XG4gICAgbGV0IGMgPSBwZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpYi5pY19lb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgICBjXG5cblxuICBsZXQgZW5kX29mX2lucHV0IGliID1cbiAgICBpZ25vcmUgKHBlZWtfY2hhciBpYik7XG4gICAgaWIuaWNfZW9mXG5cblxuICBsZXQgZW9mIGliID0gaWIuaWNfZW9mXG5cbiAgbGV0IGJlZ2lubmluZ19vZl9pbnB1dCBpYiA9IGliLmljX2NoYXJfY291bnQgPSAwXG5cbiAgbGV0IG5hbWVfb2ZfaW5wdXQgaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIF9pYyAtPiBcInVubmFtZWQgU3RkbGliIGlucHV0IGNoYW5uZWxcIlxuICAgIHwgRnJvbV9maWxlIChmbmFtZSwgX2ljKSAtPiBmbmFtZVxuICAgIHwgRnJvbV9mdW5jdGlvbiAtPiBcInVubmFtZWQgZnVuY3Rpb25cIlxuICAgIHwgRnJvbV9zdHJpbmcgLT4gXCJ1bm5hbWVkIGNoYXJhY3RlciBzdHJpbmdcIlxuXG5cbiAgbGV0IGNoYXJfY291bnQgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY2hhcl9jb3VudCAtIDFcbiAgICBlbHNlIGliLmljX2NoYXJfY291bnRcblxuXG4gIGxldCBsaW5lX2NvdW50IGliID0gaWIuaWNfbGluZV9jb3VudFxuXG4gIGxldCByZXNldF90b2tlbiBpYiA9IEJ1ZmZlci5yZXNldCBpYi5pY190b2tlbl9idWZmZXJcblxuICBsZXQgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgPSBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2VcblxuICBsZXQgdG9rZW4gaWIgPVxuICAgIGxldCB0b2tlbl9idWZmZXIgPSBpYi5pY190b2tlbl9idWZmZXIgaW5cbiAgICBsZXQgdG9rID0gQnVmZmVyLmNvbnRlbnRzIHRva2VuX2J1ZmZlciBpblxuICAgIEJ1ZmZlci5jbGVhciB0b2tlbl9idWZmZXI7XG4gICAgaWIuaWNfdG9rZW5fY291bnQgPC0gc3VjYyBpYi5pY190b2tlbl9jb3VudDtcbiAgICB0b2tcblxuXG4gIGxldCB0b2tlbl9jb3VudCBpYiA9IGliLmljX3Rva2VuX2NvdW50XG5cbiAgbGV0IHNraXBfY2hhciB3aWR0aCBpYiA9XG4gICAgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7XG4gICAgd2lkdGhcblxuXG4gIGxldCBpZ25vcmVfY2hhciB3aWR0aCBpYiA9IHNraXBfY2hhciAod2lkdGggLSAxKSBpYlxuXG4gIGxldCBzdG9yZV9jaGFyIHdpZHRoIGliIGMgPVxuICAgIEJ1ZmZlci5hZGRfY2hhciBpYi5pY190b2tlbl9idWZmZXIgYztcbiAgICBpZ25vcmVfY2hhciB3aWR0aCBpYlxuXG5cbiAgbGV0IGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUgPSAxMDI0XG5cbiAgbGV0IGNyZWF0ZSBpbmFtZSBuZXh0ID0ge1xuICAgIGljX2VvZiA9IGZhbHNlO1xuICAgIGljX2N1cnJlbnRfY2hhciA9IG51bGxfY2hhcjtcbiAgICBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPSBmYWxzZTtcbiAgICBpY19jaGFyX2NvdW50ID0gMDtcbiAgICBpY19saW5lX2NvdW50ID0gMDtcbiAgICBpY190b2tlbl9jb3VudCA9IDA7XG4gICAgaWNfZ2V0X25leHRfY2hhciA9IG5leHQ7XG4gICAgaWNfdG9rZW5fYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplO1xuICAgIGljX2lucHV0X25hbWUgPSBpbmFtZTtcbiAgfVxuXG5cbiAgbGV0IGZyb21fc3RyaW5nIHMgPVxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPj0gbGVuIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZVxuICAgICAgbGV0IGMgPSBzLlshaV0gaW5cbiAgICAgIGluY3IgaTtcbiAgICAgIGMgaW5cbiAgICBjcmVhdGUgRnJvbV9zdHJpbmcgbmV4dFxuXG5cbiAgbGV0IGZyb21fZnVuY3Rpb24gPSBjcmVhdGUgRnJvbV9mdW5jdGlvblxuXG4gICgqIFNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbC4gKilcblxuICAoKiBQb3NpdGlvbiBvZiB0aGUgcHJvYmxlbTpcblxuICAgICBXZSBjYW5ub3QgcHJldmVudCB0aGUgc2Nhbm5pbmcgbWVjaGFuaXNtIHRvIHVzZSBvbmUgbG9va2FoZWFkIGNoYXJhY3RlcixcbiAgICAgaWYgbmVlZGVkIGJ5IHRoZSBzZW1hbnRpY3Mgb2YgdGhlIGZvcm1hdCBzdHJpbmcgc3BlY2lmaWNhdGlvbnMgKGUuZy4gYVxuICAgICB0cmFpbGluZyAnc2tpcCBzcGFjZScgc3BlY2lmaWNhdGlvbiBpbiB0aGUgZm9ybWF0IHN0cmluZyk7IGluIHRoaXMgY2FzZSxcbiAgICAgdGhlIG1hbmRhdG9yeSBsb29rYWhlYWQgY2hhcmFjdGVyIGlzIGluZGVlZCByZWFkIGZyb20gdGhlIGlucHV0IGFuZCBub3RcbiAgICAgdXNlZCB0byByZXR1cm4gdGhlIHRva2VuIHJlYWQuIEl0IGlzIHRodXMgbWFuZGF0b3J5IHRvIGJlIGFibGUgdG8gc3RvcmVcbiAgICAgYW4gdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgc29tZXdoZXJlIHRvIGdldCBpdCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAgIG9mIHRoZSBuZXh0IHNjYW4uXG5cbiAgICAgVG8gY2lyY3VtdmVudCB0aGlzIHByb2JsZW0sIGFsbCB0aGUgc2Nhbm5pbmcgZnVuY3Rpb25zIGdldCBhIGxvdyBsZXZlbFxuICAgICBpbnB1dCBidWZmZXIgYXJndW1lbnQgd2hlcmUgdGhleSBzdG9yZSB0aGUgbG9va2FoZWFkIGNoYXJhY3RlciB3aGVuXG4gICAgIG5lZWRlZDsgYWRkaXRpb25hbGx5LCB0aGUgaW5wdXQgYnVmZmVyIGlzIHRoZSBvbmx5IHNvdXJjZSBvZiBjaGFyYWN0ZXIgb2ZcbiAgICAgYSBzY2FubmVyLiBUaGUgW3NjYW5idWZdIGlucHV0IGJ1ZmZlcnMgYXJlIGRlZmluZWQgaW4gbW9kdWxlIHshU2Nhbm5pbmd9LlxuXG4gICAgIE5vdyB3ZSB1bmRlcnN0YW5kIHRoYXQgaXQgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0aGF0IHJlbGF0ZWQgYW5kXG4gICAgIHN1Y2Nlc3NpdmUgY2FsbHMgdG8gc2Nhbm5lcnMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgc2FtZSBpbnB1dCBidWZmZXIuXG4gICAgIEluIGVmZmVjdCwgaWYgYSBzY2FubmVyIFtzY2FuMV0gaXMgcmVhZGluZyBmcm9tIFtpYjFdIGFuZCBzdG9yZXMgYW5cbiAgICAgdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgW2MxXSBpbnRvIGl0cyBpbnB1dCBidWZmZXIgW2liMV0sIHRoZW5cbiAgICAgYW5vdGhlciBzY2FubmVyIFtzY2FuMl0gbm90IHJlYWRpbmcgZnJvbSB0aGUgc2FtZSBidWZmZXIgW2liMV0gd2lsbCBtaXNzXG4gICAgIHRoZSBjaGFyYWN0ZXIgW2MxXSwgc2VlbWluZ2x5IHZhbmlzaGVkIGluIHRoZSBhaXIgZnJvbSB0aGUgcG9pbnQgb2Ygdmlld1xuICAgICBvZiBbc2NhbjJdLlxuXG4gICAgIFRoaXMgbWVjaGFuaXNtIHdvcmtzIHBlcmZlY3RseSB0byByZWFkIGZyb20gc3RyaW5ncywgZnJvbSBmaWxlcywgYW5kIGZyb21cbiAgICAgZnVuY3Rpb25zLCBzaW5jZSBpbiB0aG9zZSBjYXNlcywgYWxsb2NhdGluZyB0d28gYnVmZmVycyByZWFkaW5nIGZyb20gdGhlXG4gICAgIHNhbWUgc291cmNlIGlzIHVubmF0dXJhbC5cblxuICAgICBTdGlsbCwgdGhlcmUgaXMgYSBkaWZmaWN1bHR5IGluIHRoZSBjYXNlIG9mIHNjYW5uaW5nIGZyb20gYW4gaW5wdXRcbiAgICAgY2hhbm5lbC4gSW4gZWZmZWN0LCB3aGVuIHNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbCBbaWNdLCB0aGlzIGNoYW5uZWxcbiAgICAgbWF5IG5vdCBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gd2l0aGluIHRoaXMgbGlicmFyeS4gSGVuY2UsIGl0IG1heSBiZVxuICAgICBzaGFyZWQgKHR3byBmdW5jdGlvbnMgb2YgdGhlIHVzZXIncyBwcm9ncmFtIG1heSBzdWNjZXNzaXZlbHkgcmVhZCBmcm9tXG4gICAgIFtpY10pLiBUaGlzIGlzIGhpZ2hseSBlcnJvciBwcm9uZSBzaW5jZSwgb25lIG9mIHRoZSBmdW5jdGlvbiBtYXkgc2VlayB0aGVcbiAgICAgaW5wdXQgY2hhbm5lbCwgd2hpbGUgdGhlIG90aGVyIGZ1bmN0aW9uIGhhcyBzdGlsbCBhbiB1bnVzZWQgbG9va2FoZWFkXG4gICAgIGNoYXJhY3RlciBpbiBpdHMgaW5wdXQgYnVmZmVyLiBJbiBjb25jbHVzaW9uLCB5b3Ugc2hvdWxkIG5ldmVyIG1peCBkaXJlY3RcbiAgICAgbG93IGxldmVsIHJlYWRpbmcgYW5kIGhpZ2ggbGV2ZWwgc2Nhbm5pbmcgZnJvbSB0aGUgc2FtZSBpbnB1dCBjaGFubmVsLlxuXG4gICopXG5cbiAgKCogUGVyZm9ybSBidWZmZXJpemVkIGlucHV0IHRvIGltcHJvdmUgZWZmaWNpZW5jeS4gKilcbiAgbGV0IGZpbGVfYnVmZmVyX3NpemUgPSByZWYgMTAyNFxuXG4gICgqIFRoZSBzY2FubmVyIGNsb3NlcyB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQuICopXG4gIGxldCBzY2FuX2Nsb3NlX2F0X2VuZCBpYyA9IFN0ZGxpYi5jbG9zZV9pbiBpYzsgcmFpc2UgRW5kX29mX2ZpbGVcblxuICAoKiBUaGUgc2Nhbm5lciBkb2VzIG5vdCBjbG9zZSB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IGp1c3QgcmFpc2VzIFtFbmRfb2ZfZmlsZV0uICopXG4gIGxldCBzY2FuX3JhaXNlX2F0X2VuZCBfaWMgPSByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gIGxldCBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgaW5hbWUgaWMgPVxuICAgIGxldCBsZW4gPSAhZmlsZV9idWZmZXJfc2l6ZSBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsaW0gPSByZWYgMCBpblxuICAgIGxldCBlb2YgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA8ICFsaW0gdGhlbiBiZWdpbiBsZXQgYyA9IEJ5dGVzLmdldCBidWYgIWkgaW4gaW5jciBpOyBjIGVuZCBlbHNlXG4gICAgICBpZiAhZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZSBiZWdpblxuICAgICAgICBsaW0gOj0gaW5wdXQgaWMgYnVmIDAgbGVuO1xuICAgICAgICBpZiAhbGltID0gMCB0aGVuIGJlZ2luIGVvZiA6PSB0cnVlOyBzY2FuX2Nsb3NlX2ljIGljIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgaSA6PSAxO1xuICAgICAgICAgIEJ5dGVzLmdldCBidWYgMFxuICAgICAgICBlbmRcbiAgICAgIGVuZCBpblxuICAgIGNyZWF0ZSBpbmFtZSBuZXh0XG5cblxuICBsZXQgZnJvbV9pY19jbG9zZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fY2xvc2VfYXRfZW5kXG4gIGxldCBmcm9tX2ljX3JhaXNlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS5cbiAgICAgT25lIGNvdWxkIHRyeSB0byBkZWZpbmUgW3N0ZGliXSBhcyBhIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGEgY2hhcmFjdGVyXG4gICAgIGF0IGEgdGltZSAobm8gYnVmZmVyaXphdGlvbiBhdCBhbGwpLCBidXQgdW5mb3J0dW5hdGVseSB0aGUgdG9wLWxldmVsXG4gICAgIGludGVyYWN0aW9uIHdvdWxkIGJlIHdyb25nLiBUaGlzIGlzIGR1ZSB0byBzb21lIGtpbmQgb2ZcbiAgICAgJ3JhY2UgY29uZGl0aW9uJyB3aGVuIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXSxcbiAgICAgc2luY2UgdGhlIGludGVyYWN0aXZlIGNvbXBpbGVyIGFuZCBbU2NhbmYuc2NhbmZdIHdpbGwgc2ltdWx0YW5lb3VzbHlcbiAgICAgcmVhZCB0aGUgbWF0ZXJpYWwgdGhleSBuZWVkIGZyb20gW1N0ZGxpYi5zdGRpbl07IHRoZW4sIGNvbmZ1c2lvblxuICAgICB3aWxsIHJlc3VsdCBmcm9tIHdoYXQgc2hvdWxkIGJlIHJlYWQgYnkgdGhlIHRvcC1sZXZlbCBhbmQgd2hhdCBzaG91bGQgYmVcbiAgICAgcmVhZCBieSBbU2NhbmYuc2NhbmZdLlxuICAgICBUaGlzIGlzIGV2ZW4gbW9yZSBjb21wbGljYXRlZCBieSB0aGUgb25lIGNoYXJhY3RlciBsb29rYWhlYWQgdGhhdFxuICAgICBbU2NhbmYuc2NhbmZdIGlzIHNvbWV0aW1lcyBvYmxpZ2VkIHRvIG1haW50YWluOiB0aGUgbG9va2FoZWFkIGNoYXJhY3RlclxuICAgICB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgdGhlIG5leHQgW1NjYW5mLnNjYW5mXSBlbnRyeSwgc2VlbWluZ2x5IGNvbWluZyBmcm9tXG4gICAgIG5vd2hlcmUuXG4gICAgIEFsc28gbm8gW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlbiByZWFkaW5nIGZyb20gc3RkaW46IGlmIG5vdCBlbm91Z2hcbiAgICAgY2hhcmFjdGVycyBoYXZlIGJlZW4gcmVhZCwgd2Ugc2ltcGx5IGFzayB0byByZWFkIG1vcmUuICopXG4gIGxldCBzdGRpbiA9XG4gICAgZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuICAgICAgKEZyb21fZmlsZSAoXCItXCIsIFN0ZGxpYi5zdGRpbikpIFN0ZGxpYi5zdGRpblxuXG5cbiAgbGV0IHN0ZGliID0gc3RkaW5cblxuICBsZXQgb3Blbl9pbl9maWxlIG9wZW5faW4gZm5hbWUgPVxuICAgIG1hdGNoIGZuYW1lIHdpdGhcbiAgICB8IFwiLVwiIC0+IHN0ZGluXG4gICAgfCBmbmFtZSAtPlxuICAgICAgbGV0IGljID0gb3Blbl9pbiBmbmFtZSBpblxuICAgICAgZnJvbV9pY19jbG9zZV9hdF9lbmQgKEZyb21fZmlsZSAoZm5hbWUsIGljKSkgaWNcblxuXG4gIGxldCBvcGVuX2luID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luXG4gIGxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fZmlsZSBTdGRsaWIub3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9maWxlID0gb3Blbl9pblxuICBsZXQgZnJvbV9maWxlX2JpbiA9IG9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fY2hhbm5lbCBpYyA9XG4gICAgZnJvbV9pY19yYWlzZV9hdF9lbmQgKEZyb21fY2hhbm5lbCBpYykgaWNcblxuXG4gIGxldCBjbG9zZV9pbiBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgaWMgLT5cbiAgICAgIFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9maWxlIChfZm5hbWUsIGljKSAtPiBTdGRsaWIuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZnVuY3Rpb24gfCBGcm9tX3N0cmluZyAtPiAoKVxuXG5cbiAgKCpcbiAgICAgT2Jzb2xldGU6IGEgbWVtbyBbZnJvbV9jaGFubmVsXSB2ZXJzaW9uIHRvIGJ1aWxkIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdXG4gICAgIHNjYW5uaW5nIGJ1ZmZlciBvdXQgb2YgYSBbU3RkbGliLmluX2NoYW5uZWxdLlxuICAgICBUaGlzIGZ1bmN0aW9uIHdhcyB1c2VkIHRvIHRyeSB0byBwcmVzZXJ2ZSB0aGUgc2Nhbm5pbmdcbiAgICAgc2VtYW50aWNzIGZvciB0aGUgKG5vdyBvYnNvbGV0ZSkgZnVuY3Rpb24gW2ZzY2FuZl0uXG4gICAgIEdpdmVuIHRoYXQgYWxsIHNjYW5uZXIgbXVzdCByZWFkIGZyb20gYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF0gc2Nhbm5pbmdcbiAgICAgYnVmZmVyLCBbZnNjYW5mXSBtdXN0IHJlYWQgZnJvbSBvbmUhXG4gICAgIE1vcmUgcHJlY2lzZWx5LCBnaXZlbiBbaWNdLCBhbGwgc3VjY2Vzc2l2ZSBjYWxscyBbZnNjYW5mIGljXSBtdXN0IHJlYWRcbiAgICAgZnJvbSB0aGUgc2FtZSBzY2FubmluZyBidWZmZXIuXG4gICAgIFRoaXMgb2JsaWdlZCB0aGlzIGxpYnJhcnkgdG8gYWxsb2NhdGVkIHNjYW5uaW5nIGJ1ZmZlcnMgdGhhdCB3ZXJlXG4gICAgIG5vdCBwcm9wZXJseSBnYXJiYWdlIGNvbGxlY3RhYmxlLCBoZW5jZSBsZWFkaW5nIHRvIG1lbW9yeSBsZWFrcy5cbiAgICAgSWYgeW91IG5lZWQgdG8gcmVhZCBmcm9tIGEgW1N0ZGxpYi5pbl9jaGFubmVsXSBpbnB1dCBjaGFubmVsXG4gICAgIFtpY10sIHNpbXBseSBkZWZpbmUgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF0gZm9ybWF0dGVkIGlucHV0IGNoYW5uZWwgYXMgaW5cbiAgICAgW2xldCBpYiA9IFNjYW5uaW5nLmZyb21fY2hhbm5lbCBpY10sIHRoZW4gdXNlIFtTY2FuZi5ic2NhbmYgaWJdIGFzIHVzdWFsLlxuICAqKVxuICBsZXQgbWVtb19mcm9tX2ljID1cbiAgICBsZXQgbWVtbyA9IHJlZiBbXSBpblxuICAgIChmdW4gc2Nhbl9jbG9zZV9pYyBpYyAtPlxuICAgICB0cnkgTGlzdC5hc3NxIGljICFtZW1vIHdpdGhcbiAgICAgfCBOb3RfZm91bmQgLT5cbiAgICAgICBsZXQgaWIgPVxuICAgICAgICAgZnJvbV9pYyBzY2FuX2Nsb3NlX2ljIChGcm9tX2NoYW5uZWwgaWMpIGljIGluXG4gICAgICAgbWVtbyA6PSAoaWMsIGliKSA6OiAhbWVtbztcbiAgICAgICBpYilcblxuXG4gICgqIE9ic29sZXRlOiBzZWUgeyFtZW1vX2Zyb21faWN9IGFib3ZlLiAqKVxuICBsZXQgbWVtb19mcm9tX2NoYW5uZWwgPSBtZW1vX2Zyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuZW5kXG5cblxuKCogRm9ybWF0dGVkIGlucHV0IGZ1bmN0aW9ucy4gKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIHNjYW5uZXIgPVxuICAgICAoJ2EsIFNjYW5uaW5nLmluX2NoYW5uZWwsICdiLCAnYywgJ2EgLT4gJ2QsICdkKSBmb3JtYXQ2IC0+ICdjXG5cblxuKCogUmVwb3J0aW5nIGVycm9ycy4gKilcbmV4Y2VwdGlvbiBTY2FuX2ZhaWx1cmUgb2Ygc3RyaW5nXG5cbmxldCBiYWRfaW5wdXQgcyA9IHJhaXNlIChTY2FuX2ZhaWx1cmUgcylcblxubGV0IGJhZF9pbnB1dF9lc2NhcGUgYyA9XG4gIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbGxlZ2FsIGVzY2FwZSBjaGFyYWN0ZXIgJUNcIiBjKVxuXG5cbmxldCBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgdGhlIHNwZWNpZmllZCBsZW5ndGggd2FzIHRvbyBzaG9ydCBmb3IgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9lbmRfb2ZfaW5wdXQgbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICBwcmVtYXR1cmUgZW5kIG9mIGZpbGUgb2NjdXJyZWQgYmVmb3JlIGVuZCBvZiB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm8gZG90IG9yIGV4cG9uZW50IHBhcnQgZm91bmQgaW4gZmxvYXQgdG9rZW5cIlxuXG5cbmxldCBiYWRfaGV4X2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm90IGEgdmFsaWQgZmxvYXQgaW4gaGV4YWRlY2ltYWwgbm90YXRpb25cIlxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kgPVxuICBQcmludGYuc3ByaW50ZiBcImxvb2tpbmcgZm9yICVDLCBmb3VuZCAlQ1wiIGMgY2lcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoIGMgY2kgPVxuICBiYWRfaW5wdXQgKGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSlcblxuXG5sZXQgcmVjIHNraXBfd2hpdGVzIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW4gYmVnaW5cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPlxuICAgICAgU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IHNraXBfd2hpdGVzIGliXG4gICAgfCBfIC0+ICgpXG4gIGVuZFxuXG5cbigqIENoZWNraW5nIHRoYXQgW2NdIGlzIGluZGVlZCBpbiB0aGUgaW5wdXQsIHRoZW4gc2tpcHMgaXQuXG4gICBJbiB0aGlzIGNhc2UsIHRoZSBjaGFyYWN0ZXIgW2NdIGhhcyBiZWVuIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZVxuICAgZm9ybWF0IGFzIGJlaW5nIG1hbmRhdG9yeSBpbiB0aGUgaW5wdXQ7IGhlbmNlIHdlIHNob3VsZCBmYWlsIHdpdGhcbiAgIFtFbmRfb2ZfZmlsZV0gaW4gY2FzZSBvZiBlbmRfb2ZfaW5wdXQuXG4gICAoUmVtZW1iZXIgdGhhdCBbU2Nhbl9mYWlsdXJlXSBpcyByYWlzZWQgb25seSB3aGVuICh3ZSBjYW4gcHJvdmUgYnlcbiAgIGV2aWRlbmNlKSB0aGF0IHRoZSBpbnB1dCBkb2VzIG5vdCBtYXRjaCB0aGUgZm9ybWF0IHN0cmluZyBnaXZlbi4gV2UgbXVzdFxuICAgdGh1cyBkaWZmZXJlbnRpYXRlIFtFbmRfb2ZfZmlsZV0gYXMgYW4gZXJyb3IgZHVlIHRvIGxhY2sgb2YgaW5wdXQsIGFuZFxuICAgW1NjYW5fZmFpbHVyZV0gd2hpY2ggaXMgZHVlIHRvIHByb3ZhYmx5IHdyb25nIGlucHV0LiBJIGFtIG5vdCBzdXJlIHRoaXMgaXNcbiAgIHdvcnRoIHRoZSBidXJkZW46IGl0IGlzIGNvbXBsZXggYW5kIHNvbWVob3cgc3VibGltaW5hbDsgc2hvdWxkIGJlIGNsZWFyZXJcbiAgIHRvIGZhaWwgd2l0aCBTY2FuX2ZhaWx1cmUgXCJOb3QgZW5vdWdoIGlucHV0IHRvIGNvbXBsZXRlIHNjYW5uaW5nXCIhKVxuXG4gICBUaGF0J3Mgd2h5LCB3YWl0aW5nIGZvciBhIGJldHRlciBzb2x1dGlvbiwgd2UgdXNlIGNoZWNrZWRfcGVla19jaGFyIGhlcmUuXG4gICBXZSBhcmUgYWxzbyBjYXJlZnVsIHRvIHRyZWF0IFwiXFxyXFxuXCIgaW4gdGhlIGlucHV0IGFzIGFuIGVuZCBvZiBsaW5lIG1hcmtlcjpcbiAgIGl0IGFsd2F5cyBtYXRjaGVzIGEgJ1xcbicgc3BlY2lmaWNhdGlvbiBpbiB0aGUgaW5wdXQgZm9ybWF0IHN0cmluZy4gKilcbmxldCByZWMgY2hlY2tfY2hhciBpYiBjID1cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJyAnIC0+IHNraXBfd2hpdGVzIGliXG4gIHwgJ1xcbicgLT4gY2hlY2tfbmV3bGluZSBpYlxuICB8IGMgLT4gY2hlY2tfdGhpc19jaGFyIGliIGNcblxuYW5kIGNoZWNrX3RoaXNfY2hhciBpYiBjID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgY2kgPSBjIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgZWxzZVxuICBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaVxuXG5hbmQgY2hlY2tfbmV3bGluZSBpYiA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGNpIHdpdGhcbiAgfCAnXFxuJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYlxuICB8ICdcXHInIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBjaGVja190aGlzX2NoYXIgaWIgJ1xcbidcbiAgfCBfIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxuJyBjaVxuXG5cbigqIEV4dHJhY3RpbmcgdG9rZW5zIGZyb20gdGhlIG91dHB1dCB0b2tlbiBidWZmZXIuICopXG5cbmxldCB0b2tlbl9jaGFyIGliID0gKFNjYW5uaW5nLnRva2VuIGliKS5bMF1cblxubGV0IHRva2VuX3N0cmluZyA9IFNjYW5uaW5nLnRva2VuXG5cbmxldCB0b2tlbl9ib29sIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcudG9rZW4gaWIgd2l0aFxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBzIC0+IGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbnZhbGlkIGJvb2xlYW4gJyVzJ1wiIHMpXG5cblxuKCogVGhlIHR5cGUgb2YgaW50ZWdlciBjb252ZXJzaW9ucy4gKilcbnR5cGUgaW50ZWdlcl9jb252ZXJzaW9uID1cbiAgfCBCX2NvbnZlcnNpb24gKCogVW5zaWduZWQgYmluYXJ5IGNvbnZlcnNpb24gKilcbiAgfCBEX2NvbnZlcnNpb24gKCogU2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IElfY29udmVyc2lvbiAoKiBTaWduZWQgaW50ZWdlciBjb252ZXJzaW9uICopXG4gIHwgT19jb252ZXJzaW9uICgqIFVuc2lnbmVkIG9jdGFsIGNvbnZlcnNpb24gKilcbiAgfCBVX2NvbnZlcnNpb24gKCogVW5zaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgWF9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGhleGFkZWNpbWFsIGNvbnZlcnNpb24gKilcblxuXG5sZXQgaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgPSBmdW5jdGlvblxuICB8ICdiJyAtPiBCX2NvbnZlcnNpb25cbiAgfCAnZCcgLT4gRF9jb252ZXJzaW9uXG4gIHwgJ2knIC0+IElfY29udmVyc2lvblxuICB8ICdvJyAtPiBPX2NvbnZlcnNpb25cbiAgfCAndScgLT4gVV9jb252ZXJzaW9uXG4gIHwgJ3gnIHwgJ1gnIC0+IFhfY29udmVyc2lvblxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cblxuKCogRXh0cmFjdCBhbiBpbnRlZ2VyIGxpdGVyYWwgdG9rZW4uXG4gICBTaW5jZSB0aGUgZnVuY3Rpb25zIFN0ZGxpYi4qaW50Kl9vZl9zdHJpbmcgZG8gbm90IGFjY2VwdCBhIGxlYWRpbmcgKyxcbiAgIHdlIHNraXAgaXQgaWYgbmVjZXNzYXJ5LiAqKVxubGV0IHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIgPVxuICBsZXQgdG9rID1cbiAgICBtYXRjaCBjb252IHdpdGhcbiAgICB8IERfY29udmVyc2lvbiB8IElfY29udmVyc2lvbiAtPiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgVV9jb252ZXJzaW9uIC0+IFwiMHVcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBPX2NvbnZlcnNpb24gLT4gXCIwb1wiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFhfY29udmVyc2lvbiAtPiBcIjB4XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgQl9jb252ZXJzaW9uIC0+IFwiMGJcIiBeIFNjYW5uaW5nLnRva2VuIGliIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCB0b2sgaW5cbiAgaWYgbCA9IDAgfHwgdG9rLlswXSA8PiAnKycgdGhlbiB0b2sgZWxzZSBTdHJpbmcuc3ViIHRvayAxIChsIC0gMSlcblxuXG4oKiBBbGwgdGhlIGZ1bmN0aW9ucyB0aGF0IGNvbnZlcnQgYSBzdHJpbmcgdG8gYSBudW1iZXIgcmFpc2UgdGhlIGV4Y2VwdGlvblxuICAgRmFpbHVyZSB3aGVuIHRoZSBjb252ZXJzaW9uIGlzIG5vdCBwb3NzaWJsZS5cbiAgIFRoaXMgZXhjZXB0aW9uIGlzIHRoZW4gdHJhcHBlZCBpbiBba3NjYW5mXS4gKilcbmxldCB0b2tlbl9pbnQgY29udiBpYiA9IGludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbmxldCB0b2tlbl9mbG9hdCBpYiA9IGZsb2F0X29mX3N0cmluZyAoU2Nhbm5pbmcudG9rZW4gaWIpXG5cbigqIFRvIHNjYW4gbmF0aXZlIGludHMsIGludDMyIGFuZCBpbnQ2NCBpbnRlZ2Vycy5cbiAgIFdlIGNhbm5vdCBhY2Nlc3MgdG8gY29udmVyc2lvbnMgdG8vZnJvbSBzdHJpbmdzIGZvciB0aG9zZSB0eXBlcyxcbiAgIE5hdGl2ZWludC5vZl9zdHJpbmcsIEludDMyLm9mX3N0cmluZywgYW5kIEludDY0Lm9mX3N0cmluZyxcbiAgIHNpbmNlIHRob3NlIG1vZHVsZXMgYXJlIG5vdCBhdmFpbGFibGUgdG8gW1NjYW5mXS5cbiAgIEhvd2V2ZXIsIHdlIGNhbiBiaW5kIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmcgcHJpbWl0aXZlcyB0aGF0IGFyZVxuICAgYXZhaWxhYmxlIGluIHRoZSBydW50aW1lLiAqKVxuZXh0ZXJuYWwgbmF0aXZlaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDMyX29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQ2NF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxuXG5sZXQgdG9rZW5fbmF0aXZlaW50IGNvbnYgaWIgPSBuYXRpdmVpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDMyIGNvbnYgaWIgPSBpbnQzMl9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50NjQgY29udiBpYiA9IGludDY0X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxuKCogU2Nhbm5pbmcgbnVtYmVycy4gKilcblxuKCogRGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzdXBwb3NlIHRoYXQgb25lIGNoYXJhY3RlciBoYXMgYmVlbiBjaGVja2VkIGFuZFxuICAgaXMgYXZhaWxhYmxlLCBzaW5jZSB0aGV5IHJldHVybiBhdCBlbmQgb2YgZmlsZSB3aXRoIHRoZSBjdXJyZW50bHkgZm91bmRcbiAgIHRva2VuIHNlbGVjdGVkLlxuXG4gICBQdXQgaXQgaW4gYW5vdGhlciB3YXksIHRoZSBkaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHNjYW4gZm9yIGEgcG9zc2libHlcbiAgIGVtcHR5IHNlcXVlbmNlIG9mIGRpZ2l0cywgKGhlbmNlLCBhIHN1Y2Nlc3NmdWwgc2Nhbm5pbmcgZnJvbSBvbmUgb2YgdGhvc2VcbiAgIGZ1bmN0aW9ucyBkb2VzIG5vdCBpbXBseSB0aGF0IHRoZSB0b2tlbiBpcyBhIHdlbGwtZm9ybWVkIG51bWJlcjogdG8gZ2V0IGFcbiAgIHRydWUgbnVtYmVyLCBpdCBpcyBtYW5kYXRvcnkgdG8gY2hlY2sgdGhhdCBhdCBsZWFzdCBvbmUgdmFsaWQgZGlnaXQgaXNcbiAgIGF2YWlsYWJsZSBiZWZvcmUgY2FsbGluZyBvbmUgb2YgdGhlIGRpZ2l0IHNjYW5uaW5nIGZ1bmN0aW9ucykuICopXG5cbigqIFRoZSBkZWNpbWFsIGNhc2UgaXMgdHJlYXRlZCBlc3BlY2lhbGx5IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuICopXG5sZXQgcmVjIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgJ18nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXMgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGVjaW1hbCBkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgZGVjaW1hbCBkaWdpdFwiIGMpXG5cblxuKCogVG8gc2NhbiBudW1iZXJzIGZyb20gb3RoZXIgYmFzZXMsIHdlIHVzZSBhIHByZWRpY2F0ZSBhcmd1bWVudCB0b1xuICAgc2NhbiBkaWdpdHMuICopXG5sZXQgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9kaWdpdHMgd2lkdGggaWIgPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8IGMgd2hlbiBkaWdpdHAgYyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgJ18nIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8IF8gLT4gd2lkdGggaW5cbiAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9kaWdpdF9wbHVzIGJhc2lzIGRpZ2l0cCB3aWR0aCBpYiA9XG4gICgqIEVuc3VyZSB3ZSBoYXZlIGdvdCBlbm91Z2ggd2lkdGggbGVmdCxcbiAgICAgYW5kIHJlYWQgYXQgbGVhc3Qgb25lIGRpZ2l0LiAqKVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGRpZ2l0cCBjIHRoZW5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliXG4gIGVsc2VcbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIHZhbGlkICVzIGRpZ2l0XCIgYyBiYXNpcylcblxuXG5sZXQgaXNfYmluYXJ5X2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzEnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fYmluYXJ5X2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImJpbmFyeVwiIGlzX2JpbmFyeV9kaWdpdFxuXG5sZXQgaXNfb2N0YWxfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnNycgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9vY3RhbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJvY3RhbFwiIGlzX29jdGFsX2RpZ2l0XG5cbmxldCBpc19oZXhhX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9oZXhhZGVjaW1hbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJoZXhhZGVjaW1hbFwiIGlzX2hleGFfZGlnaXRcblxuKCogU2NhbiBhIGRlY2ltYWwgaW50ZWdlci4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50ID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXNcblxubGV0IHNjYW5fc2lnbiB3aWR0aCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJysnIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8ICctJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW4gYW4gdW5zaWduZWQgaW50ZWdlciB0aGF0IGNvdWxkIGJlIGdpdmVuIGluIGFueSAoY29tbW9uKSBiYXNpcy5cbiAgIElmIGRpZ2l0cyBhcmUgcHJlZml4ZWQgYnkgb25lIG9mIDB4LCAwWCwgMG8sIG9yIDBiLCB0aGUgbnVtYmVyIGlzXG4gICBhc3N1bWVkIHRvIGJlIHdyaXR0ZW4gcmVzcGVjdGl2ZWx5IGluIGhleGFkZWNpbWFsLCBoZXhhZGVjaW1hbCxcbiAgIG9jdGFsLCBvciBiaW5hcnkuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgYmVnaW4gbWF0Y2ggYyB3aXRoXG4gICAgfCAneCcgfCAnWCcgLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdvJyAtPiBzY2FuX29jdGFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ2InIC0+IHNjYW5fYmluYXJ5X2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgXyAtPiBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBlbmRcbiAgfCBfIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9pbnRfY29udmVyc2lvbiBjb252IHdpZHRoIGliID1cbiAgbWF0Y2ggY29udiB3aXRoXG4gIHwgQl9jb252ZXJzaW9uIC0+IHNjYW5fYmluYXJ5X2ludCB3aWR0aCBpYlxuICB8IERfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgSV9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliXG4gIHwgT19jb252ZXJzaW9uIC0+IHNjYW5fb2N0YWxfaW50IHdpZHRoIGliXG4gIHwgVV9jb252ZXJzaW9uIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBYX2NvbnZlcnNpb24gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FubmluZyBmbG9hdGluZyBwb2ludCBudW1iZXJzLiAqKVxuXG4oKiBGcmFjdGlvbmFsIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIEV4cCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJ2UnIHwgJ0UnIGFzIGMgLT5cbiAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIFNjYW4gdGhlIGludGVnZXIgcGFydCBvZiBhIGZsb2F0aW5nIHBvaW50IG51bWJlciwgKG5vdCB1c2luZyB0aGVcbiAgIE9DYW1sIGxleGljYWwgY29udmVudGlvbiBzaW5jZSB0aGUgaW50ZWdlciBwYXJ0IGNhbiBiZSBlbXB0eSk6XG4gICBhbiBvcHRpb25hbCBzaWduLCBmb2xsb3dlZCBieSBhIHBvc3NpYmx5IGVtcHR5IHNlcXVlbmNlIG9mIGRlY2ltYWxcbiAgIGRpZ2l0cyAoZS5nLiAtLjEpLiAqKVxubGV0IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG5cblxuKCpcbiAgIEZvciB0aGUgdGltZSBiZWluZyB3ZSBoYXZlIChhcyBmb3VuZCBpbiBzY2FuZi5tbGkpOlxuICAgdGhlIGZpZWxkIHdpZHRoIGlzIGNvbXBvc2VkIG9mIGFuIG9wdGlvbmFsIGludGVnZXIgbGl0ZXJhbFxuICAgaW5kaWNhdGluZyB0aGUgbWF4aW1hbCB3aWR0aCBvZiB0aGUgdG9rZW4gdG8gcmVhZC5cbiAgIFVuZm9ydHVuYXRlbHksIHRoZSB0eXBlLWNoZWNrZXIgbGV0IHRoZSB1c2VyIHdyaXRlIGFuIG9wdGlvbmFsIHByZWNpc2lvbixcbiAgIHNpbmNlIHRoaXMgaXMgdmFsaWQgZm9yIHByaW50ZiBmb3JtYXQgc3RyaW5ncy5cblxuICAgVGh1cywgdGhlIG5leHQgc3RlcCBmb3IgU2NhbmYgaXMgdG8gc3VwcG9ydCBhIGZ1bGwgd2lkdGggYW5kIHByZWNpc2lvblxuICAgaW5kaWNhdGlvbiwgbW9yZSBvciBsZXNzIHNpbWlsYXIgdG8gdGhlIG9uZSBmb3IgcHJpbnRmLCBwb3NzaWJseSBleHRlbmRlZFxuICAgdG8gdGhlIHNwZWNpZmljYXRpb24gb2YgYSBbbWF4LCBtaW5dIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWRcbiAgIGZvciBzdHJpbmdzLiBTb21ldGhpbmcgbGlrZSB0aGUgZm9sbG93aW5nIHNwZWMgZm9yIHNjYW5mLm1saTpcblxuICAgVGhlIG9wdGlvbmFsIFt3aWR0aF0gaXMgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsXG4gICB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC4gRm9yIGluc3RhbmNlLCBbJTZkXSByZWFkcyBhbiBpbnRlZ2VyLFxuICAgaGF2aW5nIGF0IG1vc3QgNiBjaGFyYWN0ZXJzLlxuXG4gICBUaGUgb3B0aW9uYWwgW3ByZWNpc2lvbl0gaXMgYSBkb3QgWy5dIGZvbGxvd2VkIGJ5IGFuIGludGVnZXI6XG5cbiAgIC0gaW4gdGhlIGZsb2F0aW5nIHBvaW50IG51bWJlciBjb252ZXJzaW9ucyAoWyVmXSwgWyVlXSwgWyVnXSwgWyVGXSwgWyVFXSxcbiAgIGFuZCBbJUZdIGNvbnZlcnNpb25zLCB0aGUgW3ByZWNpc2lvbl0gaW5kaWNhdGVzIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuICAgZGlnaXRzIHRoYXQgbWF5IGZvbGxvdyB0aGUgZGVjaW1hbCBwb2ludC4gRm9yIGluc3RhbmNlLCBbJS40Zl0gcmVhZHMgYVxuICAgW2Zsb2F0XSB3aXRoIGF0IG1vc3QgNCBmcmFjdGlvbmFsIGRpZ2l0cyxcblxuICAgLSBpbiB0aGUgc3RyaW5nIGNvbnZlcnNpb25zIChbJXNdLCBbJVNdLCBbJVxcWyByYW5nZSBcXF1dKSwgYW5kIGluIHRoZVxuICAgaW50ZWdlciBudW1iZXIgY29udmVyc2lvbnMgKFslaV0sIFslZF0sIFsldV0sIFsleF0sIFslb10sIGFuZCB0aGVpclxuICAgW2ludDMyXSwgW2ludDY0XSwgYW5kIFtuYXRpdmVfaW50XSBjb3JyZXNwb25kZW50KSwgdGhlIFtwcmVjaXNpb25dXG4gICBpbmRpY2F0ZXMgdGhlIHJlcXVpcmVkIG1pbmltdW0gd2lkdGggb2YgdGhlIHRva2VuIHJlYWQsXG5cbiAgIC0gb24gYWxsIG90aGVyIGNvbnZlcnNpb25zLCB0aGUgd2lkdGggYW5kIHByZWNpc2lvbiBzcGVjaWZ5IHRoZSBbbWF4LCBtaW5dXG4gICByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLlxuKilcbmxldCBzY2FuX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIpIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cbiAgfCBfIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cblxuXG5sZXQgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgZXJyb3Igc3RyID1cbiAgbGV0IGxvd2VyY2FzZSBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICdBJyAuLiAnWicgLT5cbiAgICAgIGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICsgaW50X29mX2NoYXIgJ2EnKVxuICAgIHwgXyAtPiBjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGggPSByZWYgd2lkdGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGxvd2VyY2FzZSBjIDw+IGxvd2VyY2FzZSBzdHIuW2ldIHRoZW4gZXJyb3IgKCk7XG4gICAgaWYgIXdpZHRoID0gMCB0aGVuIGVycm9yICgpO1xuICAgIHdpZHRoIDo9IFNjYW5uaW5nLnN0b3JlX2NoYXIgIXdpZHRoIGliIGM7XG4gIGRvbmU7XG4gICF3aWR0aFxuXG5cbmxldCBzY2FuX2hleF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBsZXQgd2lkdGggPSBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwieFwiIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgICAgKVxuICAgICAgICAgIHwgXyAtPiB3aWR0aCBpblxuICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgICB8IF8gLT4gd2lkdGhcbiAgKVxuICB8ICduJyB8ICdOJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcImFuXCJcbiAgfCAnaScgfCAnSScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJuZmluaXR5XCJcbiAgfCBfIC0+IGJhZF9oZXhfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgKCogVGhlIGVmZmVjdGl2ZSB3aWR0aCBhdmFpbGFibGUgZm9yIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgaXNcbiAgICAgICB0aGUgbWluaW11bSBvZiBkZWNsYXJlZCBwcmVjaXNpb24gYW5kIHdpZHRoIGxlZnQuICopXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAoKiBBZnRlciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHdpdGggW3ByZWNpc2lvbl0gcHJvdmlzaW9uYWwgd2lkdGgsXG4gICAgICAgW3dpZHRoX3ByZWNpc2lvbl0gaXMgbGVmdC4gKilcbiAgICBsZXQgd2lkdGhfcHJlY2lzaW9uID0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliIGluXG4gICAgKCogSGVuY2UsIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgdG9vayBleGFjdGx5XG4gICAgICAgW3ByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbl0gY2hhcnMuICopXG4gICAgbGV0IGZyYWNfd2lkdGggPSBwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb24gaW5cbiAgICAoKiBBbmQgbmV3IHByb3Zpc2lvbmFsIHdpZHRoIGlzIFt3aWR0aCAtIHdpZHRoX3ByZWNpc2lvbi4gKilcbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIGZyYWNfd2lkdGggaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCAnZScgfCAnRScgLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICB8ICd4JyB8ICdYJyBhcyBjIC0+IChcbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgKVxuICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gYmFkX2Zsb2F0ICgpIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICB8IF8gLT4gd2lkdGhcbiAgICApXG4gICAgfCBfIC0+XG4gICAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbiAgKVxuICB8ICcxJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4oKiBTcGVjaWFsIGNhc2Ugb2YgbmFuIGFuZCBpbmZpbml0eTpcbiAgfCAnaScgLT5cbiAgfCAnbicgLT5cbiopXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG4oKiBTY2FuIGEgcmVndWxhciBzdHJpbmc6XG4gICBzdG9wcyB3aGVuIGVuY291bnRlcmluZyBhIHNwYWNlLCBpZiBubyBzY2FubmluZyBpbmRpY2F0aW9uIGhhcyBiZWVuIGdpdmVuO1xuICAgb3RoZXJ3aXNlLCBzdG9wcyB3aGVuIGVuY291bnRlcmluZyB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2Nhbm5pbmdcbiAgIGluZGljYXRpb24gW3N0cF0uXG4gICBJdCBhbHNvIHN0b3BzIGF0IGVuZCBvZiBmaWxlIG9yIHdoZW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaGFzXG4gICBiZWVuIHJlYWQuICopXG5sZXQgc2Nhbl9zdHJpbmcgc3RwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBsb29wIHdpZHRoID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBtYXRjaCBzdHAgd2l0aFxuICAgICAgfCBTb21lIGMnIHdoZW4gYyA9IGMnIC0+IFNjYW5uaW5nLnNraXBfY2hhciB3aWR0aCBpYlxuICAgICAgfCBTb21lIF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpblxuICBsb29wIHdpZHRoXG5cblxuKCogU2NhbiBhIGNoYXI6IHBlZWsgc3RyaWN0bHkgb25lIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQsIHdoYXRzb2V2ZXIuICopXG5sZXQgc2Nhbl9jaGFyIHdpZHRoIGliID1cbiAgKCogVGhlIGNhc2Ugd2lkdGggPSAwIGNvdWxkIG5vdCBoYXBwZW4gaGVyZSwgc2luY2UgaXQgaXMgdGVzdGVkIGJlZm9yZVxuICAgICBjYWxsaW5nIHNjYW5fY2hhciwgaW4gdGhlIG1haW4gc2Nhbm5pbmcgZnVuY3Rpb24uXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImEgY2hhcmFjdGVyXCIgZWxzZSAqKVxuICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYilcblxuXG5sZXQgY2hhcl9mb3JfYmFja3NsYXNoID0gZnVuY3Rpb25cbiAgfCAnbicgLT4gJ1xcMDEwJ1xuICB8ICdyJyAtPiAnXFwwMTMnXG4gIHwgJ2InIC0+ICdcXDAwOCdcbiAgfCAndCcgLT4gJ1xcMDA5J1xuICB8IGMgLT4gY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9IGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCdcblxubGV0IGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxMDAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzAgK1xuICAgICAxMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICAgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICBcImJhZCBjaGFyYWN0ZXIgZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlYyVjXCIgYzAgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBoZXhhZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID1cbiAgbGV0IGQgPSBpbnRfb2ZfY2hhciBjIGluXG4gICgqIENvdWxkIGFsc28gYmU6XG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnOScgdGhlbiBkIC0gaW50X29mX2NoYXIgJzAnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdGJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdBJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnZicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnYScgZWxzZSBhc3NlcnQgZmFsc2VcbiAgKilcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnYScgdGhlblxuICAgIGQgLSA4NyAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnYScgKikgZWxzZVxuICBpZiBkID49IGludF9vZl9jaGFyICdBJyB0aGVuXG4gICAgZCAtIDU1ICAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKikgZWxzZVxuICAgIGQgLSBpbnRfb2ZfY2hhciAnMCdcblxuXG5sZXQgY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxNiAqIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZiBcImJhZCBjaGFyYWN0ZXIgaGV4YWRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWNcIiBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogQ2FsbGVkIGluIHBhcnRpY3VsYXIgd2hlbiBlbmNvdW50ZXJpbmcgJ1xcXFwnIGFzIHN0YXJ0ZXIgb2YgYSBjaGFyLlxuICAgU3RvcHMgYmVmb3JlIHRoZSBjb3JyZXNwb25kaW5nICdcXCcnLiAqKVxubGV0IGNoZWNrX25leHRfY2hhciBtZXNzYWdlIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlIGVsc2VcbiAgY1xuXG5cbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgPSBjaGVja19uZXh0X2NoYXIgXCJhIENoYXJcIlxubGV0IGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBTdHJpbmdcIlxuXG5sZXQgc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYiA9XG4gIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gIHwgJ1xcXFwnIHwgJ1xcJycgfCAnXFxcIicgfCAnbicgfCAndCcgfCAnYicgfCAncicgYXMgYyAtPlxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKGNoYXJfZm9yX2JhY2tzbGFzaCBjKVxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMCA9IGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIpXG4gIHwgJ3gnIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyKVxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXRfZXNjYXBlIGNcblxuXG4oKiBTY2FuIGEgY2hhcmFjdGVyIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX2NoYXIgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gZmluZF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGNcblxuICBhbmQgZmluZF9jaGFyIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXFwnIC0+XG4gICAgICBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKSBpYilcbiAgICB8IGMgLT5cbiAgICAgIGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgYyBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgZGVsaW1pdGVkIHN0cmluZyAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxcIicgY1xuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgJ1xcXFwnIC0+IHNjYW5fYmFja3NsYXNoIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIHNjYW5fYmFja3NsYXNoIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxyJyAtPiBza2lwX25ld2xpbmUgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIpXG5cbiAgYW5kIHNraXBfbmV3bGluZSB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgJ1xccicpXG5cbiAgYW5kIHNraXBfc3BhY2VzIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnICcgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3Agd2lkdGggaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGJvb2xlYW4gKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2Jvb2wgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGxldCBtID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICd0JyAtPiA0XG4gICAgfCAnZicgLT4gNVxuICAgIHwgYyAtPlxuICAgICAgYmFkX2lucHV0XG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcInRoZSBjaGFyYWN0ZXIgJUMgY2Fubm90IHN0YXJ0IGEgYm9vbGVhblwiIGMpIGluXG4gIHNjYW5fc3RyaW5nIE5vbmUgbSBpYlxuXG5cbigqIFNjYW4gYSBzdHJpbmcgY29udGFpbmluZyBlbGVtZW50cyBpbiBjaGFyX3NldCBhbmQgdGVybWluYXRlZCBieSBzY2FuX2luZGljXG4gICBpZiBwcm92aWRlZC4gKilcbmxldCBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IHNjYW5faW5kaWMgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fY2hhcnMgaSBzdHAgPVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgaSA+IDAgJiYgbm90IChTY2FubmluZy5lb2YgaWIpICYmXG4gICAgICAgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyAmJlxuICAgICAgIGludF9vZl9jaGFyIGMgPD4gc3RwIHRoZW5cbiAgICAgIGxldCBfID0gU2Nhbm5pbmcuc3RvcmVfY2hhciBtYXhfaW50IGliIGMgaW5cbiAgICAgIHNjYW5fY2hhcnMgKGkgLSAxKSBzdHAgaW5cbiAgbWF0Y2ggc2Nhbl9pbmRpYyB3aXRoXG4gIHwgTm9uZSAtPiBzY2FuX2NoYXJzIHdpZHRoICgtMSk7XG4gIHwgU29tZSBjIC0+XG4gICAgc2Nhbl9jaGFycyB3aWR0aCAoaW50X29mX2NoYXIgYyk7XG4gICAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW5cbiAgICAgIGxldCBjaSA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgICAgaWYgYyA9IGNpXG4gICAgICB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gICAgICBlbHNlIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cblxuKCogVGhlIGdsb2JhbCBlcnJvciByZXBvcnQgZnVuY3Rpb24gZm9yIFtTY2FuZl0uICopXG5sZXQgc2NhbmZfYmFkX2lucHV0IGliID0gZnVuY3Rpb25cbiAgfCBTY2FuX2ZhaWx1cmUgcyB8IEZhaWx1cmUgcyAtPlxuICAgIGxldCBpID0gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYiBpblxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJzY2FuZjogYmFkIGlucHV0IGF0IGNoYXIgbnVtYmVyICVpOiAlc1wiIGkgcylcbiAgfCB4IC0+IHJhaXNlIHhcblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgYSBjb3VudGVyIGZyb20gYW4gaW5wdXQgYnVmZmVyLiAqKVxubGV0IGdldF9jb3VudGVyIGliIGNvdW50ZXIgPVxuICBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgLT4gU2Nhbm5pbmcubGluZV9jb3VudCBpYlxuICB8IENoYXJfY291bnRlciAtPiBTY2FubmluZy5jaGFyX2NvdW50IGliXG4gIHwgVG9rZW5fY291bnRlciAtPiBTY2FubmluZy50b2tlbl9jb3VudCBpYlxuXG5cbigqIENvbXB1dGUgdGhlIHdpZHRoIG9mIGEgcGFkZGluZyBvcHRpb24gKHNlZSBcIiU0MntcIiBhbmQgXCIlMTIzKFwiKS4gKilcbmxldCB3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IG1heF9pbnRcbiAgfCBTb21lIHdpZHRoIC0+IHdpZHRoXG5cblxubGV0IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nID1cbiAgaWYgZm10aW5nID0gRXNjYXBlZF9wZXJjZW50IHRoZW4gJyUnLCBcIlwiIGVsc2VcbiAgICBsZXQgc3RyID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyBpblxuICAgIGxldCBzdHAgPSBzdHIuWzFdIGluXG4gICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciAyIChTdHJpbmcubGVuZ3RoIHN0ciAtIDIpIGluXG4gICAgc3RwLCBzdWJfc3RyXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFJlYWRlciBtYW5hZ2VtZW50ICopXG5cbigqIEEgY2FsbCB0byB0YWtlX2Zvcm1hdF9yZWFkZXJzIG9uIGEgZm9ybWF0IGlzIGV2YWx1YXRlZCBpbnRvIGZ1bmN0aW9uc1xuICAgdGFraW5nIHJlYWRlcnMgYXMgYXJndW1lbnRzIGFuZCBhZ2dyZWdhdGUgdGhlbSBpbnRvIGFuIGhldGVyb2dlbmVvdXMgbGlzdCAqKVxuKCogV2hlbiBhbGwgcmVhZGVycyBhcmUgdGFrZW4sIGZpbmFsbHkgcGFzcyB0aGUgbGlzdCBvZiB0aGUgcmVhZGVycyB0byB0aGVcbiAgIGNvbnRpbnVhdGlvbiBrLiAqKVxubGV0IHJlYyB0YWtlX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgZCA9XG5mdW4gayBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdFxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfc3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQzMiAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IE5hdGl2ZWludCAoXywgXywgXywgcmVzdCkgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50NjQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbG9hdCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEJvb2wgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEN1c3RvbSAoXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgICAgLT5cbiAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKSByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgICAgICAgLT4gdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIGsgaWduIHJlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgICAgICAgIC0+IGsgTmlsXG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGZtdHR5IGNvbWluZyBmcm9tIGEgRm9ybWF0X3N1YnN0IFwiJSguLi4lKVwiLiAqKVxuYW5kIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgZm10dHkgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFJlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGlnbm9yZWQgcGFyYW1ldGVyLiAqKVxuYW5kIHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBpZ25vcmVkIC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10XG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgZm10dHkgZm10XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgc2Nhbm5pbmcgKilcblxuKCogTWFrZSBhIGdlbmVyaWMgc2Nhbm5pbmcgZnVuY3Rpb24uICopXG4oKiBTY2FuIGEgc3RyZWFtIGFjY29yZGluZyB0byBhIGZvcm1hdCBhbmQgcmVhZGVycyBvYnRhaW5lZCBieVxuICAgdGFrZV9mb3JtYXRfcmVhZGVycywgYW5kIGFnZ3JlZ2F0ZSBzY2FubmVkIHZhbHVlcyBpbnRvIGFuXG4gICBoZXRlcm9nZW5lb3VzIGxpc3QuICopXG4oKiBSZXR1cm4gdGhlIGhldGVyb2dlbmVvdXMgbGlzdCBvZiBzY2FubmVkIHZhbHVlcy4gKilcbmxldCByZWMgbWFrZV9zY2FuZiA6IHR5cGUgYSBjIGQgZSBmLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKGEsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSBzdHApIHdpZHRoIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICd7Jykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAnWycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyBOb25lIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcblxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50IGMpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDMyIGMpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9uYXRpdmVpbnQgYylcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50NjQgYylcbiAgfCBGbG9hdCAoKF8sIEZsb2F0X0YpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fY2FtbF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HKSksXG4gICAgICAgICAgIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2ggfCBGbG9hdF9IKSksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9oZXhfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gXyBfIGliID0gc2Nhbl9ib29sIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9ib29sXG4gIHwgQWxwaGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlYVxcXCJcIlxuICB8IFRoZXRhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJXRcXFwiXCJcbiAgfCBDdXN0b20gXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlP1xcXCIgKGN1c3RvbSBjb252ZXJ0ZXIpXCJcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBiZWdpbiBtYXRjaCByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSAtPlxuICAgICAgICBsZXQgeCA9IHJlYWRlciBpYiBpblxuICAgICAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdF9yZXN0IHJlYWRlcnNfcmVzdClcbiAgICB8IE5pbCAtPlxuICAgICAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBtaXNzaW5nIHJlYWRlclwiXG4gICAgZW5kXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIGlmIFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gICAgZWxzZSBiYWRfaW5wdXQgXCJlbmQgb2YgaW5wdXQgbm90IGZvdW5kXCJcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIHN0cjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgY2hyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgcyBmbXR0eVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChmbXQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10LCBmbXQnID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCcgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgICgqIFRPRE86IGZpbmQgYSB3YXkgdG8gYXZvaWQgcmVwYXJzaW5nIHR3aWNlICopXG5cbiAgICAgICAgKCogVE9ETzogdGhlc2UgdHlwZS1jaGVja3MgYmVsb3cgKmNhbiogZmFpbCBiZWNhdXNlIG9mIHR5cGVcbiAgICAgICAgICAgYW1iaWd1aXR5IGluIHByZXNlbmNlIG9mIGlnbm9yZWQtcmVhZGVyczogXCIlX3IlZFwiIGFuZCBcIiVkJV9yXCJcbiAgICAgICAgICAgYXJlIHR5cGVkIGluIHRoZSBzYW1lIHdheS5cblxuICAgICAgICAgICAjIFNjYW5mLnNzY2FuZiBcIlxcXCIlX3IlZFxcXCIzXCIgXCIlKCVkJV9yJSlcIiBpZ25vcmVcbiAgICAgICAgICAgICAoZnVuIGZtdCBuIC0+IHN0cmluZ19vZl9mb3JtYXQgZm10LCBuKVxuICAgICAgICAgICBFeGNlcHRpb246IENhbWxpbnRlcm5hbEZvcm1hdC5UeXBlX21pc21hdGNoLlxuXG4gICAgICAgICAgIFdlIHNob3VsZCBwcm9wZXJseSBjYXRjaCB0aGlzIGV4Y2VwdGlvbi5cbiAgICAgICAgKilcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgZm10dHkpLFxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQnIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChGb3JtYXQgKGZtdCwgcyksXG4gICAgICAgICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IChTb21lIHN0cCkgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBOb25lIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBsZXQgY291bnQgPSBnZXRfY291bnRlciBpYiBjb3VudGVyIGluXG4gICAgQ29ucyAoY291bnQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQpO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAneyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICdbJztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICBiZWdpbiBtYXRjaCBtYWtlX3NjYW5mIGliIGZtdCcgcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChfLCBhcmdfcmVzdCkgLT4gYXJnX3Jlc3RcbiAgICB8IE5pbCAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBOaWxcblxuKCogQ2FzZSBhbmFseXNpcyBvbiBwYWRkaW5nIGFuZCBwcmVjaXNpb24uICopXG4oKiBSZWplY3QgZm9ybWF0cyBjb250YWluaW5nIFwiJSpcIiBvciBcIiUuKlwiLiAqKVxuKCogUGFzcyBwYWRkaW5nIGFuZCBwcmVjaXNpb24gdG8gdGhlIGdlbmVyaWMgc2Nhbm5lciBgc2NhbicuICopXG5hbmQgcGFkX3ByZWNfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZiB4IHkgeiB0IC5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+ICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPlxuICAgICAgKGludCAtPiBpbnQgLT4gU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB0KSAtPlxuICAgICAgKFNjYW5uaW5nLmluX2NoYW5uZWwgLT4geikgLT5cbiAgICAgICh4LCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyBwYWQgcHJlYyBzY2FuIHRva2VuIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKExlZnQsIF8pLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUtXFxcIlwiXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgXyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBBcmdfcGFkZGluZyBfLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgKCogRGVmaW5pbmcgW3NjYW5mXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtzY2FuZl0gKilcblxudHlwZSAnYSBrc2NhbmZfcmVzdWx0ID0gQXJncyBvZiAnYSB8IEV4YyBvZiBleG5cblxubGV0IGtzY2FuZiBpYiBlZiAoRm9ybWF0IChmbXQsIHN0cikpID1cbiAgbGV0IHJlYyBhcHBseSA6IHR5cGUgYSBiIC4gYSAtPiAoYSwgYikgaGV0ZXJfbGlzdCAtPiBiID1cbiAgICBmdW4gZiBhcmdzIC0+IG1hdGNoIGFyZ3Mgd2l0aFxuICAgIHwgQ29ucyAoeCwgcikgLT4gYXBwbHkgKGYgeCkgclxuICAgIHwgTmlsIC0+IGZcbiAgaW5cbiAgbGV0IGsgcmVhZGVycyBmID1cbiAgICBTY2FubmluZy5yZXNldF90b2tlbiBpYjtcbiAgICBtYXRjaCB0cnkgQXJncyAobWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycykgd2l0aFxuICAgICAgfCAoU2Nhbl9mYWlsdXJlIF8gfCBGYWlsdXJlIF8gfCBFbmRfb2ZfZmlsZSkgYXMgZXhjIC0+IEV4YyBleGNcbiAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgKG1zZyBeIFwiIGluIGZvcm1hdCBcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzdHIgXiBcIlxcXCJcIilcbiAgICB3aXRoXG4gICAgICB8IEFyZ3MgYXJncyAtPiBhcHBseSBmIGFyZ3NcbiAgICAgIHwgRXhjIGV4YyAtPiBlZiBpYiBleGNcbiAgaW5cbiAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKVxuXG5sZXQga2JzY2FuZiA9IGtzY2FuZlxubGV0IGJzY2FuZiBpYiBmbXQgPSBrYnNjYW5mIGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IGtzc2NhbmYgcyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBlZiBmbXRcbmxldCBzc2NhbmYgcyBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBzY2FuZiBmbXQgPSBrc2NhbmYgU2Nhbm5pbmcuc3RkaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG4oKioqKVxuXG4oKiBTY2FubmluZyBmb3JtYXQgc3RyaW5ncy4gKilcbmxldCBic2NhbmZfZm9ybWF0IDpcbiAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIGliIGZvcm1hdCBmIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nIG1heF9pbnQgaWIgaW5cbiAgICBsZXQgc3RyID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCcgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciBmb3JtYXRcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZyBpblxuICAgIGYgZm10J1xuXG5cbmxldCBzc2NhbmZfZm9ybWF0IDpcbiAgc3RyaW5nIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gcyBmb3JtYXQgZiAtPiBic2NhbmZfZm9ybWF0IChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBmb3JtYXQgZlxuXG5cbmxldCBmb3JtYXRfZnJvbV9zdHJpbmcgcyBmbXQgPVxuICBzc2NhbmZfZm9ybWF0IChcIlxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHMgXiBcIlxcXCJcIikgZm10IChmdW4geCAtPiB4KVxuXG5cbmxldCB1bmVzY2FwZWQgcyA9XG4gIHNzY2FuZiAoXCJcXFwiXCIgXiBzIF4gXCJcXFwiXCIpIFwiJVMlIVwiIChmdW4geCAtPiB4KVxuXG5cbigqIERlcHJlY2F0ZWQgKilcbmxldCBrZnNjYW5mIGljIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBlZiBmbXRcbmxldCBmc2NhbmYgaWMgZm10ID0ga3NjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgc2NhbmZfYmFkX2lucHV0IGZtdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBSZWdpc3RlcmluZyBPQ2FtbCB2YWx1ZXMgd2l0aCB0aGUgQyBydW50aW1lIGZvciBsYXRlciBjYWxsYmFja3MgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gT2JqLnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgcmVnaXN0ZXIgbmFtZSB2ID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSAoT2JqLnJlcHIgdilcblxubGV0IHJlZ2lzdGVyX2V4Y2VwdGlvbiBuYW1lIChleG4gOiBleG4pID1cbiAgbGV0IGV4biA9IE9iai5yZXByIGV4biBpblxuICBsZXQgc2xvdCA9IGlmIE9iai50YWcgZXhuID0gT2JqLm9iamVjdF90YWcgdGhlbiBleG4gZWxzZSBPYmouZmllbGQgZXhuIDAgaW5cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSBzbG90XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICBKZXJvbWUgVm91aWxsb24sIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gT2JqXG5cbigqKioqIE9iamVjdCByZXByZXNlbnRhdGlvbiAqKioqKVxuXG5leHRlcm5hbCBzZXRfaWQ6ICdhIC0+ICdhID0gXCJjYW1sX3NldF9vb19pZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIE9iamVjdCBjb3B5ICoqKiopXG5cbmxldCBjb3B5IG8gPVxuICBsZXQgbyA9IChPYmoub2JqIChPYmouZHVwIChPYmoucmVwciBvKSkpIGluXG4gIHNldF9pZCBvXG5cbigqKioqIENvbXByZXNzaW9uIG9wdGlvbnMgKioqKilcbigqIFBhcmFtZXRlcnMgKilcbnR5cGUgcGFyYW1zID0ge1xuICAgIG11dGFibGUgY29tcGFjdF90YWJsZSA6IGJvb2w7XG4gICAgbXV0YWJsZSBjb3B5X3BhcmVudCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjbGVhbl93aGVuX2NvcHlpbmcgOiBib29sO1xuICAgIG11dGFibGUgcmV0cnlfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBidWNrZXRfc21hbGxfc2l6ZSA6IGludFxuICB9XG5cbmxldCBwYXJhbXMgPSB7XG4gIGNvbXBhY3RfdGFibGUgPSB0cnVlO1xuICBjb3B5X3BhcmVudCA9IHRydWU7XG4gIGNsZWFuX3doZW5fY29weWluZyA9IHRydWU7XG4gIHJldHJ5X2NvdW50ID0gMztcbiAgYnVja2V0X3NtYWxsX3NpemUgPSAxNlxufVxuXG4oKioqKiBQYXJhbWV0ZXJzICoqKiopXG5cbmxldCBpbml0aWFsX29iamVjdF9zaXplID0gMlxuXG4oKioqKiBJdGVtcyAqKioqKVxuXG50eXBlIGl0ZW0gPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbmxldCBkdW1teV9pdGVtID0gKG1hZ2ljICgpIDogaXRlbSlcblxuKCoqKiogVHlwZXMgKioqKilcblxudHlwZSB0YWdcbnR5cGUgbGFiZWwgPSBpbnRcbnR5cGUgY2xvc3VyZSA9IGl0ZW1cbnR5cGUgdCA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxudHlwZSBvYmogPSB0IGFycmF5XG5leHRlcm5hbCByZXQgOiAob2JqIC0+ICdhKSAtPiBjbG9zdXJlID0gXCIlaWRlbnRpdHlcIlxuXG4oKioqKiBMYWJlbHMgKioqKilcblxubGV0IHB1YmxpY19tZXRob2RfbGFiZWwgcyA6IHRhZyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9IDIyMyAqICFhY2N1ICsgQ2hhci5jb2RlIHMuW2ldXG4gIGRvbmU7XG4gICgqIHJlZHVjZSB0byAzMSBiaXRzICopXG4gIGFjY3UgOj0gIWFjY3UgbGFuZCAoMSBsc2wgMzEgLSAxKTtcbiAgKCogbWFrZSBpdCBzaWduZWQgZm9yIDY0IGJpdHMgYXJjaGl0ZWN0dXJlcyAqKVxuICBsZXQgdGFnID0gaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3UgaW5cbiAgKCogUHJpbnRmLmVwcmludGYgXCIlcyA9ICVkXFxuXCIgcyB0YWc7IGZsdXNoIHN0ZGVycjsgKilcbiAgbWFnaWMgdGFnXG5cbigqKioqIFNwYXJzZSBhcnJheSAqKioqKVxuXG5tb2R1bGUgVmFycyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgdmFycyA9IGludCBWYXJzLnRcblxubW9kdWxlIE1ldGhzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBtZXRocyA9IGxhYmVsIE1ldGhzLnRcbm1vZHVsZSBMYWJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IGxhYmVsIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIGxhYnMgPSBib29sIExhYnMudFxuXG4oKiBUaGUgY29tcGlsZXIgYXNzdW1lcyB0aGF0IHRoZSBmaXJzdCBmaWVsZCBvZiB0aGlzIHN0cnVjdHVyZSBpcyBbc2l6ZV0uICopXG50eXBlIHRhYmxlID1cbiB7IG11dGFibGUgc2l6ZTogaW50O1xuICAgbXV0YWJsZSBtZXRob2RzOiBjbG9zdXJlIGFycmF5O1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X25hbWU6IG1ldGhzO1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X2xhYmVsOiBsYWJzO1xuICAgbXV0YWJsZSBwcmV2aW91c19zdGF0ZXM6XG4gICAgIChtZXRocyAqIGxhYnMgKiAobGFiZWwgKiBpdGVtKSBsaXN0ICogdmFycyAqXG4gICAgICBsYWJlbCBsaXN0ICogc3RyaW5nIGxpc3QpIGxpc3Q7XG4gICBtdXRhYmxlIGhpZGRlbl9tZXRoczogKGxhYmVsICogaXRlbSkgbGlzdDtcbiAgIG11dGFibGUgdmFyczogdmFycztcbiAgIG11dGFibGUgaW5pdGlhbGl6ZXJzOiAob2JqIC0+IHVuaXQpIGxpc3QgfVxuXG5sZXQgZHVtbXlfdGFibGUgPVxuICB7IG1ldGhvZHMgPSBbfCBkdW1teV9pdGVtIHxdO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSAwIH1cblxubGV0IHRhYmxlX2NvdW50ID0gcmVmIDBcblxuKCogZHVtbXlfbWV0IHNob3VsZCBiZSBhIHBvaW50ZXIsIHNvIHVzZSBhbiBhdG9tICopXG5sZXQgZHVtbXlfbWV0IDogaXRlbSA9IG9iaiAoT2JqLm5ld19ibG9jayAwIDApXG4oKiBpZiBkZWJ1Z2dpbmcgaXMgbmVlZGVkLCB0aGlzIGNvdWxkIGJlIGEgZ29vZCBpZGVhOiAqKVxuKCogbGV0IGR1bW15X21ldCAoKSA9IGZhaWx3aXRoIFwiVW5kZWZpbmVkIG1ldGhvZFwiICopXG5cbmxldCByZWMgZml0X3NpemUgbiA9XG4gIGlmIG4gPD0gMiB0aGVuIG4gZWxzZVxuICBmaXRfc2l6ZSAoKG4rMSkvMikgKiAyXG5cbmxldCBuZXdfdGFibGUgcHViX2xhYmVscyA9XG4gIGluY3IgdGFibGVfY291bnQ7XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggcHViX2xhYmVscyBpblxuICBsZXQgbWV0aG9kcyA9IEFycmF5Lm1ha2UgKGxlbioyKzIpIGR1bW15X21ldCBpblxuICBtZXRob2RzLigwKSA8LSBtYWdpYyBsZW47XG4gIG1ldGhvZHMuKDEpIDwtIG1hZ2ljIChmaXRfc2l6ZSBsZW4gKiBTeXMud29yZF9zaXplIC8gOCAtIDEpO1xuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkbyBtZXRob2RzLihpKjIrMykgPC0gbWFnaWMgcHViX2xhYmVscy4oaSkgZG9uZTtcbiAgeyBtZXRob2RzID0gbWV0aG9kcztcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gaW5pdGlhbF9vYmplY3Rfc2l6ZSB9XG5cbmxldCByZXNpemUgYXJyYXkgbmV3X3NpemUgPVxuICBsZXQgb2xkX3NpemUgPSBBcnJheS5sZW5ndGggYXJyYXkubWV0aG9kcyBpblxuICBpZiBuZXdfc2l6ZSA+IG9sZF9zaXplIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3X2J1Y2sgPSBBcnJheS5tYWtlIG5ld19zaXplIGR1bW15X21ldCBpblxuICAgIEFycmF5LmJsaXQgYXJyYXkubWV0aG9kcyAwIG5ld19idWNrIDAgb2xkX3NpemU7XG4gICAgYXJyYXkubWV0aG9kcyA8LSBuZXdfYnVja1xuIGVuZFxuXG5sZXQgcHV0IGFycmF5IGxhYmVsIGVsZW1lbnQgPVxuICByZXNpemUgYXJyYXkgKGxhYmVsICsgMSk7XG4gIGFycmF5Lm1ldGhvZHMuKGxhYmVsKSA8LSBlbGVtZW50XG5cbigqKioqIENsYXNzZXMgKioqKilcblxubGV0IG1ldGhvZF9jb3VudCA9IHJlZiAwXG5sZXQgaW5zdF92YXJfY291bnQgPSByZWYgMFxuXG4oKiB0eXBlIHQgKilcbnR5cGUgbWV0aCA9IGl0ZW1cblxubGV0IG5ld19tZXRob2QgdGFibGUgPVxuICBsZXQgaW5kZXggPSBBcnJheS5sZW5ndGggdGFibGUubWV0aG9kcyBpblxuICByZXNpemUgdGFibGUgKGluZGV4ICsgMSk7XG4gIGluZGV4XG5cbmxldCBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG5hbWUgPVxuICB0cnlcbiAgICBNZXRocy5maW5kIG5hbWUgdGFibGUubWV0aG9kc19ieV9uYW1lXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGxhYmVsID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBNZXRocy5hZGQgbmFtZSBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWJlbCB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWw7XG4gICAgbGFiZWxcblxubGV0IGdldF9tZXRob2RfbGFiZWxzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBuYW1lc1xuXG5sZXQgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBlbGVtZW50ID1cbiAgaW5jciBtZXRob2RfY291bnQ7XG4gIGlmIExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHRoZW5cbiAgICBwdXQgdGFibGUgbGFiZWwgZWxlbWVudFxuICBlbHNlXG4gICAgdGFibGUuaGlkZGVuX21ldGhzIDwtIChsYWJlbCwgZWxlbWVudCkgOjogdGFibGUuaGlkZGVuX21ldGhzXG5cbmxldCBnZXRfbWV0aG9kIHRhYmxlIGxhYmVsID1cbiAgdHJ5IExpc3QuYXNzb2MgbGFiZWwgdGFibGUuaGlkZGVuX21ldGhzXG4gIHdpdGggTm90X2ZvdW5kIC0+IHRhYmxlLm1ldGhvZHMuKGxhYmVsKVxuXG5sZXQgdG9fbGlzdCBhcnIgPVxuICBpZiBhcnIgPT0gbWFnaWMgMCB0aGVuIFtdIGVsc2UgQXJyYXkudG9fbGlzdCBhcnJcblxubGV0IG5hcnJvdyB0YWJsZSB2YXJzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgPVxuICBsZXQgdmFycyA9IHRvX2xpc3QgdmFyc1xuICBhbmQgdmlydF9tZXRocyA9IHRvX2xpc3QgdmlydF9tZXRoc1xuICBhbmQgY29uY3JfbWV0aHMgPSB0b19saXN0IGNvbmNyX21ldGhzIGluXG4gIGxldCB2aXJ0X21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSB2aXJ0X21ldGhzIGluXG4gIGxldCBjb25jcl9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgY29uY3JfbWV0aHMgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtXG4gICAgICh0YWJsZS5tZXRob2RzX2J5X25hbWUsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwsIHRhYmxlLmhpZGRlbl9tZXRocyxcbiAgICAgIHRhYmxlLnZhcnMsIHZpcnRfbWV0aF9sYWJzLCB2YXJzKVxuICAgICA6OiB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICBWYXJzLmZvbGRcbiAgICAgIChmdW4gbGFiIGluZm8gdHZhcnMgLT5cbiAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZhcnMgdGhlbiBWYXJzLmFkZCBsYWIgaW5mbyB0dmFycyBlbHNlIHR2YXJzKVxuICAgICAgdGFibGUudmFycyBWYXJzLmVtcHR5O1xuICBsZXQgYnlfbmFtZSA9IHJlZiBNZXRocy5lbXB0eSBpblxuICBsZXQgYnlfbGFiZWwgPSByZWYgTGFicy5lbXB0eSBpblxuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj1cbiAgICAgICAgICBMYWJzLmFkZCBsYWJlbFxuICAgICAgICAgICAgKHRyeSBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB3aXRoIE5vdF9mb3VuZCAtPiB0cnVlKVxuICAgICAgICAgICAgIWJ5X2xhYmVsKVxuICAgIGNvbmNyX21ldGhzIGNvbmNyX21ldGhfbGFicztcbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9IExhYnMuYWRkIGxhYmVsIGZhbHNlICFieV9sYWJlbClcbiAgICB2aXJ0X21ldGhzIHZpcnRfbWV0aF9sYWJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gIWJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gIWJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhfbGFicyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBbXVxuXG5sZXQgd2lkZW4gdGFibGUgPVxuICBsZXQgKGJ5X25hbWUsIGJ5X2xhYmVsLCBzYXZlZF9oaWRkZW5fbWV0aHMsIHNhdmVkX3ZhcnMsIHZpcnRfbWV0aHMsIHZhcnMpID1cbiAgICBMaXN0LmhkIHRhYmxlLnByZXZpb3VzX3N0YXRlc1xuICBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC0gTGlzdC50bCB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAoZnVuIHMgdiAtPiBWYXJzLmFkZCB2IChWYXJzLmZpbmQgdiB0YWJsZS52YXJzKSBzKVxuICAgICAgIHNhdmVkX3ZhcnMgdmFycztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIGJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aHMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgc2F2ZWRfaGlkZGVuX21ldGhzXG5cbmxldCBuZXdfc2xvdCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IHRhYmxlLnNpemUgaW5cbiAgdGFibGUuc2l6ZSA8LSBpbmRleCArIDE7XG4gIGluZGV4XG5cbmxldCBuZXdfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGluZGV4ID0gbmV3X3Nsb3QgdGFibGUgaW5cbiAgICBpZiBuYW1lIDw+IFwiXCIgdGhlbiB0YWJsZS52YXJzIDwtIFZhcnMuYWRkIG5hbWUgaW5kZXggdGFibGUudmFycztcbiAgICBpbmRleFxuXG5sZXQgdG9fYXJyYXkgYXJyID1cbiAgaWYgYXJyID0gT2JqLm1hZ2ljIDAgdGhlbiBbfHxdIGVsc2UgYXJyXG5cbmxldCBuZXdfbWV0aG9kc192YXJpYWJsZXMgdGFibGUgbWV0aHMgdmFscyA9XG4gIGxldCBtZXRocyA9IHRvX2FycmF5IG1ldGhzIGluXG4gIGxldCBubWV0aHMgPSBBcnJheS5sZW5ndGggbWV0aHMgYW5kIG52YWxzID0gQXJyYXkubGVuZ3RoIHZhbHMgaW5cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgKG5tZXRocyArIG52YWxzKSAwIGluXG4gIGZvciBpID0gMCB0byBubWV0aHMgLSAxIGRvXG4gICAgcmVzLihpKSA8LSBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG1ldGhzLihpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbnZhbHMgLSAxIGRvXG4gICAgcmVzLihpK25tZXRocykgPC0gbmV3X3ZhcmlhYmxlIHRhYmxlIHZhbHMuKGkpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgZ2V0X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFycyB3aXRoIE5vdF9mb3VuZCAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGdldF92YXJpYWJsZXMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF92YXJpYWJsZSB0YWJsZSkgbmFtZXNcblxubGV0IGFkZF9pbml0aWFsaXplciB0YWJsZSBmID1cbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIGY6OnRhYmxlLmluaXRpYWxpemVyc1xuXG4oKlxubW9kdWxlIEtleXMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gdGFnIGFycmF5IGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG5sZXQga2V5X21hcCA9IHJlZiBLZXlzLmVtcHR5XG5sZXQgZ2V0X2tleSB0YWdzIDogaXRlbSA9XG4gIHRyeSBtYWdpYyAoS2V5cy5maW5kIHRhZ3MgIWtleV9tYXAgOiB0YWcgYXJyYXkpXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAga2V5X21hcCA6PSBLZXlzLmFkZCB0YWdzIHRhZ3MgIWtleV9tYXA7XG4gICAgbWFnaWMgdGFnc1xuKilcblxubGV0IGNyZWF0ZV90YWJsZSBwdWJsaWNfbWV0aG9kcyA9XG4gIGlmIHB1YmxpY19tZXRob2RzID09IG1hZ2ljIDAgdGhlbiBuZXdfdGFibGUgW3x8XSBlbHNlXG4gICgqIFtwdWJsaWNfbWV0aG9kc10gbXVzdCBiZSBpbiBhc2NlbmRpbmcgb3JkZXIgZm9yIGJ5dGVjb2RlICopXG4gIGxldCB0YWdzID0gQXJyYXkubWFwIHB1YmxpY19tZXRob2RfbGFiZWwgcHVibGljX21ldGhvZHMgaW5cbiAgbGV0IHRhYmxlID0gbmV3X3RhYmxlIHRhZ3MgaW5cbiAgQXJyYXkuaXRlcmlcbiAgICAoZnVuIGkgbWV0IC0+XG4gICAgICBsZXQgbGFiID0gaSoyKzIgaW5cbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSAgPC0gTWV0aHMuYWRkIG1ldCBsYWIgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWIgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsKVxuICAgIHB1YmxpY19tZXRob2RzO1xuICB0YWJsZVxuXG5sZXQgaW5pdF9jbGFzcyB0YWJsZSA9XG4gIGluc3RfdmFyX2NvdW50IDo9ICFpbnN0X3Zhcl9jb3VudCArIHRhYmxlLnNpemUgLSAxO1xuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gTGlzdC5yZXYgdGFibGUuaW5pdGlhbGl6ZXJzO1xuICByZXNpemUgdGFibGUgKDMgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZSlcblxubGV0IGluaGVyaXRzIGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgKF8sIHN1cGVyLCBfLCBlbnYpIHRvcCA9XG4gIG5hcnJvdyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzO1xuICBsZXQgaW5pdCA9XG4gICAgaWYgdG9wIHRoZW4gc3VwZXIgY2xhIGVudiBlbHNlIE9iai5yZXByIChzdXBlciBjbGEpIGluXG4gIHdpZGVuIGNsYTtcbiAgQXJyYXkuY29uY2F0XG4gICAgW1t8IHJlcHIgaW5pdCB8XTtcbiAgICAgbWFnaWMgKEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIGNsYSkgKHRvX2FycmF5IHZhbHMpIDogaW50IGFycmF5KTtcbiAgICAgQXJyYXkubWFwXG4gICAgICAgKGZ1biBubSAtPiByZXByIChnZXRfbWV0aG9kIGNsYSAoZ2V0X21ldGhvZF9sYWJlbCBjbGEgbm0pIDogY2xvc3VyZSkpXG4gICAgICAgKHRvX2FycmF5IGNvbmNyX21ldGhzKSBdXG5cbmxldCBtYWtlX2NsYXNzIHB1Yl9tZXRocyBjbGFzc19pbml0ID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIChlbnZfaW5pdCAoT2JqLnJlcHIgMCksIGNsYXNzX2luaXQsIGVudl9pbml0LCBPYmoucmVwciAwKVxuXG50eXBlIGluaXRfdGFibGUgPSB7IG11dGFibGUgZW52X2luaXQ6IHQ7IG11dGFibGUgY2xhc3NfaW5pdDogdGFibGUgLT4gdCB9XG5cbmxldCBtYWtlX2NsYXNzX3N0b3JlIHB1Yl9tZXRocyBjbGFzc19pbml0IGluaXRfdGFibGUgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgaW5pdF90YWJsZS5jbGFzc19pbml0IDwtIGNsYXNzX2luaXQ7XG4gIGluaXRfdGFibGUuZW52X2luaXQgPC0gZW52X2luaXRcblxubGV0IGR1bW15X2NsYXNzIGxvYyA9XG4gIGxldCB1bmRlZiA9IGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpIGluXG4gIChPYmoubWFnaWMgdW5kZWYsIHVuZGVmLCB1bmRlZiwgT2JqLnJlcHIgMClcblxuKCoqKiogT2JqZWN0cyAqKioqKVxuXG5sZXQgY3JlYXRlX29iamVjdCB0YWJsZSA9XG4gICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gIE9iai5vYmogKHNldF9pZCBvYmopXG5cbmxldCBjcmVhdGVfb2JqZWN0X29wdCBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICAgIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICAgIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICAgIE9iai5vYmogKHNldF9pZCBvYmopXG4gIGVuZFxuXG5sZXQgcmVjIGl0ZXJfZiBvYmogPVxuICBmdW5jdGlvblxuICAgIFtdICAgLT4gKClcbiAgfCBmOjpsIC0+IGYgb2JqOyBpdGVyX2Ygb2JqIGxcblxubGV0IHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlID1cbiAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gIGlmIGluaXRzIDw+IFtdIHRoZW5cbiAgICBpdGVyX2Ygb2JqIGluaXRzXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzX29wdCBvYmpfMCBvYmogdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmogZWxzZSBiZWdpblxuICAgIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICAgIGlmIGluaXRzIDw+IFtdIHRoZW4gaXRlcl9mIG9iaiBpbml0cztcbiAgICBvYmpcbiAgZW5kXG5cbmxldCBjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGl6ZXJzIG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgIGxldCBvYmogPSBjcmVhdGVfb2JqZWN0IHRhYmxlIGluXG4gICAgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGU7XG4gICAgb2JqXG4gIGVuZFxuXG4oKiBFcXVpdmFsZW50IHByaW1pdGl2ZSBiZWxvd1xubGV0IHNlbmRzZWxmIG9iaiBsYWIgPVxuICAobWFnaWMgb2JqIDogKG9iaiAtPiB0KSBhcnJheSBhcnJheSkuKDApLihsYWIpIG9ialxuKilcbmV4dGVybmFsIHNlbmQgOiBvYmogLT4gdGFnIC0+ICdhID0gXCIlc2VuZFwiXG5leHRlcm5hbCBzZW5kY2FjaGUgOiBvYmogLT4gdGFnIC0+IHQgLT4gaW50IC0+ICdhID0gXCIlc2VuZGNhY2hlXCJcbmV4dGVybmFsIHNlbmRzZWxmIDogb2JqIC0+IGxhYmVsIC0+ICdhID0gXCIlc2VuZHNlbGZcIlxuZXh0ZXJuYWwgZ2V0X3B1YmxpY19tZXRob2QgOiBvYmogLT4gdGFnIC0+IGNsb3N1cmVcbiAgICA9IFwiY2FtbF9nZXRfcHVibGljX21ldGhvZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIHRhYmxlIGNvbGxlY3Rpb24gYWNjZXNzICoqKiopXG5cbnR5cGUgdGFibGVzID1cbiAgfCBFbXB0eVxuICB8IENvbnMgb2Yge2tleSA6IGNsb3N1cmU7IG11dGFibGUgZGF0YTogdGFibGVzOyBtdXRhYmxlIG5leHQ6IHRhYmxlc31cblxubGV0IHNldF9kYXRhIHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YSA8LSB2XG5sZXQgc2V0X25leHQgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0IDwtIHZcbmxldCBnZXRfa2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMua2V5XG5sZXQgZ2V0X2RhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhXG5sZXQgZ2V0X25leHQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0XG5cbmxldCBidWlsZF9wYXRoIG4ga2V5cyB0YWJsZXMgPVxuICBsZXQgcmVzID0gQ29ucyB7a2V5ID0gT2JqLm1hZ2ljIDA7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICBsZXQgciA9IHJlZiByZXMgaW5cbiAgZm9yIGkgPSAwIHRvIG4gZG9cbiAgICByIDo9IENvbnMge2tleSA9IGtleXMuKGkpOyBkYXRhID0gIXI7IG5leHQgPSBFbXB0eX1cbiAgZG9uZTtcbiAgc2V0X2RhdGEgdGFibGVzICFyO1xuICByZXNcblxubGV0IHJlYyBsb29rdXBfa2V5cyBpIGtleXMgdGFibGVzID1cbiAgaWYgaSA8IDAgdGhlbiB0YWJsZXMgZWxzZVxuICBsZXQga2V5ID0ga2V5cy4oaSkgaW5cbiAgbGV0IHJlYyBsb29rdXBfa2V5ICh0YWJsZXM6dGFibGVzKSA9XG4gICAgaWYgZ2V0X2tleSB0YWJsZXMgPT0ga2V5IHRoZW5cbiAgICAgIG1hdGNoIGdldF9kYXRhIHRhYmxlcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBDb25zIF8gYXMgdGFibGVzX2RhdGEgLT5cbiAgICAgICAgICBsb29rdXBfa2V5cyAoaS0xKSBrZXlzIHRhYmxlc19kYXRhXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZ2V0X25leHQgdGFibGVzIHdpdGhcbiAgICAgIHwgQ29ucyBfIGFzIG5leHQgLT4gbG9va3VwX2tleSBuZXh0XG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgbGV0IG5leHQgOiB0YWJsZXMgPSBDb25zIHtrZXk7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICAgICAgICAgIHNldF9uZXh0IHRhYmxlcyBuZXh0O1xuICAgICAgICAgIGJ1aWxkX3BhdGggKGktMSkga2V5cyBuZXh0XG4gIGluXG4gIGxvb2t1cF9rZXkgdGFibGVzXG5cbmxldCBsb29rdXBfdGFibGVzIHJvb3Qga2V5cyA9XG4gIG1hdGNoIGdldF9kYXRhIHJvb3Qgd2l0aFxuICB8IENvbnMgXyBhcyByb290X2RhdGEgLT5cbiAgICBsb29rdXBfa2V5cyAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RfZGF0YVxuICB8IEVtcHR5IC0+XG4gICAgYnVpbGRfcGF0aCAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RcblxuKCoqKiogYnVpbHRpbiBtZXRob2RzICoqKiopXG5cbmxldCBnZXRfY29uc3QgeCA9IHJldCAoZnVuIF9vYmogLT4geClcbmxldCBnZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiAtPiBBcnJheS51bnNhZmVfZ2V0IG9iaiBuKVxubGV0IGdldF9lbnYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbilcbmxldCBnZXRfbWV0aCBuICA9IHJldCAoZnVuIG9iaiAtPiBzZW5kc2VsZiBvYmogbilcbmxldCBzZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiB4IC0+IEFycmF5LnVuc2FmZV9zZXQgb2JqIG4geClcbmxldCBhcHBfY29uc3QgZiB4ID0gcmV0IChmdW4gX29iaiAtPiBmIHgpXG5sZXQgYXBwX3ZhciBmIG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfZW52IGYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX21ldGggZiBuICA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX2NvbnN0X2NvbnN0IGYgeCB5ID0gcmV0IChmdW4gX29iaiAtPiBmIHggeSlcbmxldCBhcHBfY29uc3RfdmFyIGYgeCBuICAgPSByZXQgKGZ1biBvYmogLT4gZiB4IChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfY29uc3RfbWV0aCBmIHggbiA9IHJldCAoZnVuIG9iaiAtPiBmIHggKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfdmFyX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIHgpXG5sZXQgYXBwX21ldGhfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pIHgpXG5sZXQgYXBwX2NvbnN0X2VudiBmIHggZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiB4IChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfZW52X2NvbnN0IGYgZSBuIHggPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSB4KVxubGV0IG1ldGhfYXBwX2NvbnN0IG4geCA9IHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIHgpXG5sZXQgbWV0aF9hcHBfdmFyIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChBcnJheS51bnNhZmVfZ2V0IG9iaiBtKSlcbmxldCBtZXRoX2FwcF9lbnYgbiBlIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG0pKVxubGV0IG1ldGhfYXBwX21ldGggbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKHNlbmRzZWxmIG9iaiBtKSlcbmxldCBzZW5kX2NvbnN0IG0geCBjID1cbiAgcmV0IChmdW4gb2JqIC0+IHNlbmRjYWNoZSB4IG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF92YXIgbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgOiBvYmopIG1cbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfZW52IG0gZSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGVcbiAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXRcbiAgICAgICAgICAgICAgICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIDogb2JqKVxuICAgICAgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX21ldGggbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKHNlbmRzZWxmIG9iaiBuKSBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IG5ld19jYWNoZSB0YWJsZSA9XG4gIGxldCBuID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICBsZXQgbiA9XG4gICAgaWYgbiBtb2QgMiA9IDAgfHwgbiA+IDIgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZVxuICAgIHRoZW4gbiBlbHNlIG5ld19tZXRob2QgdGFibGVcbiAgaW5cbiAgdGFibGUubWV0aG9kcy4obikgPC0gT2JqLm1hZ2ljIDA7XG4gIG5cblxudHlwZSBpbXBsID1cbiAgICBHZXRDb25zdFxuICB8IEdldFZhclxuICB8IEdldEVudlxuICB8IEdldE1ldGhcbiAgfCBTZXRWYXJcbiAgfCBBcHBDb25zdFxuICB8IEFwcFZhclxuICB8IEFwcEVudlxuICB8IEFwcE1ldGhcbiAgfCBBcHBDb25zdENvbnN0XG4gIHwgQXBwQ29uc3RWYXJcbiAgfCBBcHBDb25zdEVudlxuICB8IEFwcENvbnN0TWV0aFxuICB8IEFwcFZhckNvbnN0XG4gIHwgQXBwRW52Q29uc3RcbiAgfCBBcHBNZXRoQ29uc3RcbiAgfCBNZXRoQXBwQ29uc3RcbiAgfCBNZXRoQXBwVmFyXG4gIHwgTWV0aEFwcEVudlxuICB8IE1ldGhBcHBNZXRoXG4gIHwgU2VuZENvbnN0XG4gIHwgU2VuZFZhclxuICB8IFNlbmRFbnZcbiAgfCBTZW5kTWV0aFxuICB8IENsb3N1cmUgb2YgY2xvc3VyZVxuXG5sZXQgbWV0aG9kX2ltcGwgdGFibGUgaSBhcnIgPVxuICBsZXQgbmV4dCAoKSA9IGluY3IgaTsgbWFnaWMgYXJyLighaSkgaW5cbiAgbWF0Y2ggbmV4dCgpIHdpdGhcbiAgICBHZXRDb25zdCAtPiBsZXQgeCA6IHQgPSBuZXh0KCkgaW4gZ2V0X2NvbnN0IHhcbiAgfCBHZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfdmFyIG5cbiAgfCBHZXRFbnYgICAtPiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfZW52IGUgblxuICB8IEdldE1ldGggIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF9tZXRoIG5cbiAgfCBTZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBzZXRfdmFyIG5cbiAgfCBBcHBDb25zdCAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBhcHBfY29uc3QgZiB4XG4gIHwgQXBwVmFyICAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF92YXIgZiBuXG4gIHwgQXBwRW52ICAgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluICBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2VudiBmIGUgblxuICB8IEFwcE1ldGggIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfbWV0aCBmIG5cbiAgfCBBcHBDb25zdENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgeSA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2NvbnN0IGYgeCB5XG4gIHwgQXBwQ29uc3RWYXIgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfdmFyIGYgeCBuXG4gIHwgQXBwQ29uc3RFbnYgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2VudiBmIHggZSBuXG4gIHwgQXBwQ29uc3RNZXRoIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X21ldGggZiB4IG5cbiAgfCBBcHBWYXJDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF92YXJfY29uc3QgZiBuIHhcbiAgfCBBcHBFbnZDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52X2NvbnN0IGYgZSBuIHhcbiAgfCBBcHBNZXRoQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfbWV0aF9jb25zdCBmIG4geFxuICB8IE1ldGhBcHBDb25zdCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbWV0aF9hcHBfY29uc3QgbiB4XG4gIHwgTWV0aEFwcFZhciAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfdmFyIG4gbVxuICB8IE1ldGhBcHBFbnYgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluXG4gICAgICBtZXRoX2FwcF9lbnYgbiBlIG1cbiAgfCBNZXRoQXBwTWV0aCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfbWV0aCBuIG1cbiAgfCBTZW5kQ29uc3QgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIHNlbmRfY29uc3QgbSB4IChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZFZhciAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfdmFyIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRFbnYgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBzZW5kX2VudiBtIGUgbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRNZXRoIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF9tZXRoIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IENsb3N1cmUgXyBhcyBjbG8gLT4gbWFnaWMgY2xvXG5cbmxldCBzZXRfbWV0aG9kcyB0YWJsZSBtZXRob2RzID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBtZXRob2RzIGluIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gZG9cbiAgICBsZXQgbGFiZWwgPSBtZXRob2RzLighaSkgaW4gbGV0IGNsbyA9IG1ldGhvZF9pbXBsIHRhYmxlIGkgbWV0aG9kcyBpblxuICAgIHNldF9tZXRob2QgdGFibGUgbGFiZWwgY2xvO1xuICAgIGluY3IgaVxuICBkb25lXG5cbigqKioqIFN0YXRpc3RpY3MgKioqKilcblxudHlwZSBzdGF0cyA9XG4gIHsgY2xhc3NlczogaW50OyBtZXRob2RzOiBpbnQ7IGluc3RfdmFyczogaW50OyB9XG5cbmxldCBzdGF0cyAoKSA9XG4gIHsgY2xhc3NlcyA9ICF0YWJsZV9jb3VudDtcbiAgICBtZXRob2RzID0gIW1ldGhvZF9jb3VudDsgaW5zdF92YXJzID0gIWluc3RfdmFyX2NvdW50OyB9XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdG9rZW4gPVxuICAgIEt3ZCBvZiBzdHJpbmdcbiAgfCBJZGVudCBvZiBzdHJpbmdcbiAgfCBJbnQgb2YgaW50XG4gIHwgRmxvYXQgb2YgZmxvYXRcbiAgfCBTdHJpbmcgb2Ygc3RyaW5nXG4gIHwgQ2hhciBvZiBjaGFyXG5cbigqIFRoZSBzdHJpbmcgYnVmZmVyaW5nIG1hY2hpbmVyeSAqKVxuXG5sZXQgaW5pdGlhbF9idWZmZXIgPSBCeXRlcy5jcmVhdGUgMzJcblxubGV0IGJ1ZmZlciA9IHJlZiBpbml0aWFsX2J1ZmZlclxubGV0IGJ1ZnBvcyA9IHJlZiAwXG5cbmxldCByZXNldF9idWZmZXIgKCkgPSBidWZmZXIgOj0gaW5pdGlhbF9idWZmZXI7IGJ1ZnBvcyA6PSAwXG5cbmxldCBzdG9yZSBjID1cbiAgaWYgIWJ1ZnBvcyA+PSBCeXRlcy5sZW5ndGggIWJ1ZmZlciB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAoMiAqICFidWZwb3MpIGluXG4gICAgQnl0ZXMuYmxpdCAhYnVmZmVyIDAgbmV3YnVmZmVyIDAgIWJ1ZnBvcztcbiAgICBidWZmZXIgOj0gbmV3YnVmZmVyXG4gIGVuZDtcbiAgQnl0ZXMuc2V0ICFidWZmZXIgIWJ1ZnBvcyBjO1xuICBpbmNyIGJ1ZnBvc1xuXG5sZXQgZ2V0X3N0cmluZyAoKSA9XG4gIGxldCBzID0gQnl0ZXMuc3ViX3N0cmluZyAhYnVmZmVyIDAgIWJ1ZnBvcyBpbiBidWZmZXIgOj0gaW5pdGlhbF9idWZmZXI7IHNcblxuKCogVGhlIGxleGVyICopXG5cbmxldCBtYWtlX2xleGVyIGtleXdvcmRzID1cbiAgbGV0IGt3ZF90YWJsZSA9IEhhc2h0YmwuY3JlYXRlIDE3IGluXG4gIExpc3QuaXRlciAoZnVuIHMgLT4gSGFzaHRibC5hZGQga3dkX3RhYmxlIHMgKEt3ZCBzKSkga2V5d29yZHM7XG4gIGxldCBpZGVudF9vcl9rZXl3b3JkIGlkID1cbiAgICB0cnkgSGFzaHRibC5maW5kIGt3ZF90YWJsZSBpZCB3aXRoXG4gICAgICBOb3RfZm91bmQgLT4gSWRlbnQgaWRcbiAgYW5kIGtleXdvcmRfb3JfZXJyb3IgYyA9XG4gICAgbGV0IHMgPSBTdHJpbmcubWFrZSAxIGMgaW5cbiAgICB0cnkgSGFzaHRibC5maW5kIGt3ZF90YWJsZSBzIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RyZWFtLkVycm9yIChcIklsbGVnYWwgY2hhcmFjdGVyIFwiIF4gcykpXG4gIGluXG4gIGxldCByZWMgbmV4dF90b2tlbiAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnICcgfCAnXFwwMTAnIHwgJ1xcMDEzJyB8ICdcXDAwOScgfCAnXFwwMjYnIHwgJ1xcMDEyJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBuZXh0X3Rva2VuIHN0cm1fX1xuICAgIHwgU29tZSAoJ0EnLi4nWicgfCAnYScuLid6JyB8ICdfJyB8ICdcXDE5MicuLidcXDI1NScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IGlkZW50IHNcbiAgICB8IFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8ICc+JyB8XG4gICAgICAgICAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IGlkZW50MiBzXG4gICAgfCBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IFNvbWUgJ1xcJycgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgYyA9XG4gICAgICAgICAgdHJ5IGNoYXIgc3RybV9fIHdpdGhcbiAgICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICBTb21lICdcXCcnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoQ2hhciBjKVxuICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgJ1xcXCInIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBTb21lIChTdHJpbmcgKHN0cmluZyBzKSlcbiAgICB8IFNvbWUgJy0nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbmVnX251bWJlciBzdHJtX19cbiAgICB8IFNvbWUgJygnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgYylcbiAgICB8IF8gLT4gTm9uZVxuICBhbmQgaWRlbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZVxuICAgICAgICAoJ0EnLi4nWicgfCAnYScuLid6JyB8ICdcXDE5MicuLidcXDI1NScgfCAnMCcuLic5JyB8ICdfJyB8ICdcXCcnIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIGlkZW50MiAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnIScgfCAnJScgfCAnJicgfCAnJCcgfCAnIycgfCAnKycgfCAnLScgfCAnLycgfCAnOicgfCAnPCcgfCAnPScgfFxuICAgICAgICAgJz4nIHwgJz8nIHwgJ0AnIHwgJ1xcXFwnIHwgJ34nIHwgJ14nIHwgJ3wnIHwgJyonIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IF8gLT4gU29tZSAoaWRlbnRfb3Jfa2V5d29yZCAoZ2V0X3N0cmluZyAoKSkpXG4gIGFuZCBuZWdfbnVtYmVyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBfIC0+IGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgJy0nOyBpZGVudDIgc1xuICBhbmQgbnVtYmVyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IFNvbWUgJy4nIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJy4nOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEludCAoaW50X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgZGVjaW1hbF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZGVjaW1hbF9wYXJ0IHNcbiAgICB8IFNvbWUgKCdlJyB8ICdFJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnRSc7IGV4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBleHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcrJyB8ICctJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGVuZF9leHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gZW5kX2V4cG9uZW50X3BhcnQgc3RybV9fXG4gIGFuZCBlbmRfZXhwb25lbnRfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGVuZF9leHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoRmxvYXQgKGZsb2F0X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgc3RyaW5nIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ1xcXCInIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgZ2V0X3N0cmluZyAoKVxuICAgIHwgU29tZSAnXFxcXCcgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgYyA9XG4gICAgICAgICAgdHJ5IGVzY2FwZSBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgc3RyaW5nIHNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIGNoYXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcXCcgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBiZWdpbiB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIGVzY2FwZSAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICduJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXG4nXG4gICAgfCBTb21lICdyJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXHInXG4gICAgfCBTb21lICd0JyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXHQnXG4gICAgfCBTb21lICgnMCcuLic5JyBhcyBjMSkgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMyKSAtPlxuICAgICAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzMpIC0+XG4gICAgICAgICAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICAgICAgICAgIENoYXIuY2hyXG4gICAgICAgICAgICAgICAgICAoKENoYXIuY29kZSBjMSAtIDQ4KSAqIDEwMCArIChDaGFyLmNvZGUgYzIgLSA0OCkgKiAxMCArXG4gICAgICAgICAgICAgICAgICAgICAoQ2hhci5jb2RlIGMzIC0gNDgpKVxuICAgICAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBjb21tZW50IHM7IG5leHRfdG9rZW4gc1xuICAgIHwgXyAtPiBTb21lIChrZXl3b3JkX29yX2Vycm9yICcoJylcbiAgYW5kIGNvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9uZXN0ZWRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfZW5kX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfbmVzdGVkX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBjb21tZW50IHM7IGNvbW1lbnQgc1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX2VuZF9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyknIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgKClcbiAgICB8IFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfZW5kX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBpblxuICBmdW4gaW5wdXQgLT4gU3RyZWFtLmZyb20gKGZ1biBfY291bnQgLT4gbmV4dF90b2tlbiBpbnB1dClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9IHNpZ1xuICBpbmNsdWRlIEhhc2h0YmwuU2VlZGVkU1xuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICBpbmNsdWRlIEhhc2h0YmwuU1xuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIEdlbkhhc2hUYWJsZSA9IHN0cnVjdFxuXG4gIHR5cGUgZXF1YWwgPVxuICB8IEVUcnVlIHwgRUZhbHNlXG4gIHwgRURlYWQgKCoqIHRoZSBnYXJiYWdlIGNvbGxlY3RvciByZWNsYWltZWQgdGhlIGRhdGEgKilcblxuICBtb2R1bGUgTWFrZVNlZWRlZChIOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlICdhIGNvbnRhaW5lclxuICAgIHZhbCBjcmVhdGU6IHQgLT4gJ2EgLT4gJ2EgY29udGFpbmVyXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogJ2EgY29udGFpbmVyIC0+IHQgLT4gZXF1YWxcbiAgICB2YWwgZ2V0X2RhdGE6ICdhIGNvbnRhaW5lciAtPiAnYSBvcHRpb25cbiAgICB2YWwgZ2V0X2tleTogJ2EgY29udGFpbmVyIC0+IHQgb3B0aW9uXG4gICAgdmFsIHNldF9rZXlfZGF0YTogJ2EgY29udGFpbmVyIC0+IHQgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBjaGVja19rZXk6ICdhIGNvbnRhaW5lciAtPiBib29sXG4gIGVuZCkgOiBTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnRcbiAgPSBzdHJ1Y3RcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgICAgIG11dGFibGUgZGF0YTogJ2EgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgICAgIG11dGFibGUgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgICAgIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIGluaXRpYWwgYXJyYXkgc2l6ZSAqKVxuICAgICAgfVxuXG4gICAgYW5kICdhIGJ1Y2tldGxpc3QgPVxuICAgIHwgRW1wdHlcbiAgICB8IENvbnMgb2YgaW50ICgqIGhhc2ggb2YgdGhlIGtleSAqKSAqICdhIEguY29udGFpbmVyICogJ2EgYnVja2V0bGlzdFxuXG4gICAgKCoqIHRoZSBoYXNoIG9mIHRoZSBrZXkgaXMga2VwdCBpbiBvcmRlciB0byB0ZXN0IHRoZSBlcXVhbGl0eSBvZiB0aGUgaGFzaFxuICAgICAgYmVmb3JlIHRoZSBrZXkuIFNhbWUgcmVhc29uIGFzIGZvciBXZWFrLk1ha2UgKilcblxuICAgIHR5cGUga2V5ID0gSC50XG5cbiAgICBsZXQgcmVjIHBvd2VyXzJfYWJvdmUgeCBuID1cbiAgICAgIGlmIHggPj0gbiB0aGVuIHhcbiAgICAgIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgICAgIGVsc2UgcG93ZXJfMl9hYm92ZSAoeCAqIDIpIG5cblxuICAgIGxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbiAgICBsZXQgY3JlYXRlID8ocmFuZG9tID0gKEhhc2h0YmwuaXNfcmFuZG9taXplZCAoKSkpIGluaXRpYWxfc2l6ZSA9XG4gICAgICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgaW5pdGlhbF9zaXplIGluXG4gICAgICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICAgICAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG4gICAgbGV0IGNsZWFyIGggPVxuICAgICAgaC5zaXplIDwtIDA7XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgZG9uZVxuXG4gICAgbGV0IHJlc2V0IGggPVxuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGlmIGxlbiA9IGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICAgICAgY2xlYXIgaFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBoLnNpemUgPC0gMDtcbiAgICAgICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgaC5pbml0aWFsX3NpemUgRW1wdHlcbiAgICAgIGVuZFxuXG4gICAgbGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5jb3B5IGguZGF0YSB9XG5cbiAgICBsZXQga2V5X2luZGV4IGggaGtleSA9XG4gICAgICBoa2V5IGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGNsZWFuIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBub3QgKEguY2hlY2tfa2V5IGMpIC0+XG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgIHwgQ29ucyhoa2V5LCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgQ29ucyhoa2V5LCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgICgqKiByZXNpemUgaXMgdGhlIG9ubHkgZnVuY3Rpb24gdG8gZG8gdGhlIGFjdHVhbCBjbGVhbmluZyBvZiBkZWFkIGtleXNcbiAgICAgICAgKHJlbW92ZSBkb2VzIGl0IGp1c3QgYmVjYXVzZSBpdCBjb3VsZCkuXG5cbiAgICAgICAgVGhlIGdvYWwgaXMgdG86XG5cbiAgICAgICAgLSBub3QgcmVzaXplIGluZmluaXRlbHkgd2hlbiB0aGUgYWN0dWFsIG51bWJlciBvZiBhbGl2ZSBrZXlzIGlzXG4gICAgICAgIGJvdW5kZWQgYnV0IGtleXMgYXJlIGNvbnRpbnVvdXNseSBhZGRlZC4gVGhhdCB3b3VsZCBoYXBwZW4gaWZcbiAgICAgICAgdGhpcyBmdW5jdGlvbiBhbHdheXMgcmVzaXplLlxuICAgICAgICAtIG5vdCBjYWxsIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgZWFjaCBhZGRpdGlvbiwgdGhhdCB3b3VsZCBoYXBwZW4gaWYgdGhpc1xuICAgICAgICBmdW5jdGlvbiBkb24ndCByZXNpemUgZXZlbiB3aGVuIG9ubHkgb25lIGtleSBpcyBkZWFkLlxuXG4gICAgICAgIFNvIHRoZSBhbGdvcml0aG06XG4gICAgICAgIC0gY2xlYW4gdGhlIGtleXMgYmVmb3JlIHJlc2l6aW5nXG4gICAgICAgIC0gaWYgdGhlIG51bWJlciBvZiByZW1haW5pbmcga2V5cyBpcyBsZXNzIHRoYW4gaGFsZiB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgICAgYXJyYXksIGRvbid0IHJlc2l6ZS5cbiAgICAgICAgLSBpZiBpdCBpcyBtb3JlLCByZXNpemUuXG5cbiAgICAgICAgVGhlIHNlY29uZCBwcm9ibGVtIHJlbWFpbnMgaWYgdGhlIHRhYmxlIHJlYWNoZXMgeyFTeXMubWF4X2FycmF5X2xlbmd0aH0uXG5cbiAgICAqKVxuICAgIGxldCByZXNpemUgaCA9XG4gICAgICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICAgICAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gICAgICBjbGVhbiBoO1xuICAgICAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCAmJiBoLnNpemUgPj0gb3NpemUgbHNyIDEgdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgKCogc28gdGhhdCBrZXlfaW5kZXggc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgICAgICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgICAgICB8IENvbnMoaGtleSwgZGF0YSwgcmVzdCkgLT5cbiAgICAgICAgICAgICAgaW5zZXJ0X2J1Y2tldCByZXN0OyAoKiBwcmVzZXJ2ZSBvcmlnaW5hbCBvcmRlciBvZiBlbGVtZW50cyAqKVxuICAgICAgICAgICAgICBsZXQgbmlkeCA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgICAgICAgICAgbmRhdGEuKG5pZHgpIDwtIENvbnMoaGtleSwgZGF0YSwgbmRhdGEuKG5pZHgpKSBpblxuICAgICAgICBmb3IgaSA9IDAgdG8gb3NpemUgLSAxIGRvXG4gICAgICAgICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgICAgICAgZG9uZVxuICAgICAgZW5kXG5cbiAgICBsZXQgYWRkIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25zKGhrZXksIGNvbnRhaW5lciwgaC5kYXRhLihpKSkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZW1vdmVfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gaC5zaXplIDwtIGguc2l6ZSAtIDE7IG5leHRcbiAgICAgICAgICAgIHwgRUZhbHNlIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dClcbiAgICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgICAoKiBUaGUgZGVhZCBrZXkgaXMgYXV0b21hdGljYWxseSByZW1vdmVkLiBJdCBpcyBhY2NlcHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGZvciB0aGlzIGZ1bmN0aW9uIHNpbmNlIGl0IGFscmVhZHkgcmVtb3ZlcyBhIGJpbmRpbmcgKilcbiAgICAgICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgICAgICByZW1vdmVfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoaGssYyxuZXh0KSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gcmVtb3ZlX2J1Y2tldCBoLmRhdGEuKGkpXG5cbiAgICAoKiogeyFmaW5kfSBkb24ndCByZW1vdmUgZGVhZCBrZXlzIGJlY2F1c2UgaXQgd291bGQgYmUgc3VycHJpc2luZyBmb3JcbiAgICAgICAgdGhlIHVzZXIgdGhhdCBhIHJlYWQtb25seSBmdW5jdGlvbiBtdXRhdGVzIHRoZSBzdGF0ZSAoZWcuIGNvbmN1cnJlbnRcbiAgICAgICAgYWNjZXNzKS4gU2FtZSBmb3IgeyFpdGVyfSwgeyFmb2xkfSwgeyFtZW19LlxuICAgICopXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWMga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IFtdXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGQ6OmZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IEguc2V0X2tleV9kYXRhIGMga2V5IGluZm9cbiAgICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhfLF8sbmV4dCkgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICB0cnlcbiAgICAgICAgcmVwbGFjZV9idWNrZXQgbFxuICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29ucyhoa2V5LCBjb250YWluZXIsIGwpO1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoayA9IGhrZXkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IHRydWVcbiAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IG1lbV9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF9oaywgX2MsIHJlc3QpIC0+IG1lbV9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cbiAgICBsZXQgaXRlciBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICAoKVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiAoKVxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPiBmIGsgZFxuICAgICAgICAgICAgZW5kOyBkb19idWNrZXQgcmVzdCBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICBsZXQgZm9sZCBmIGggaW5pdCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgICAgICBtYXRjaCBiIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICAgYWNjdVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIGxldCBhY2N1ID0gYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gYWNjdVxuICAgICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkIGFjY3VcbiAgICAgICAgICAgIGVuZCBpblxuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3QgYWNjdSAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBsZXQgYWNjdSA9IHJlZiBpbml0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgICBkb25lO1xuICAgICAgIWFjY3VcblxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgZiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+XG4gICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT5cbiAgICAgICAgICAgICAgICBtYXRjaCBmIGsgZCB3aXRoXG4gICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgICAgICAgICAgfCBTb21lIG5ld19kIC0+XG4gICAgICAgICAgICAgICAgICAgIEguc2V0X2tleV9kYXRhIGMgayBuZXdfZDtcbiAgICAgICAgICAgICAgICAgICAgQ29ucyhoaywgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICBsZXQgbGVuZ3RoIGggPSBoLnNpemVcblxuICAgIGxldCByZWMgYnVja2V0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSByZXN0XG5cbiAgICBsZXQgc3RhdHMgaCA9XG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBILmNoZWNrX2tleSBjIC0+XG4gICAgICAgICAgYnVja2V0X2xlbmd0aF9hbGl2ZSAoYWNjdSArIDEpIHJlc3RcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgcmVzdFxuXG4gICAgbGV0IHN0YXRzX2FsaXZlIGggPVxuICAgICAgbGV0IHNpemUgPSByZWYgMCBpblxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBtYXggbSAoYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIpKSAwIGguZGF0YSBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYiBpblxuICAgICAgICAgICBzaXplIDo9ICFzaXplICsgbDtcbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSAhc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCB0b19zZXEgdGJsID1cbiAgICAgICgqIGNhcHR1cmUgY3VycmVudCBhcnJheSwgc28gdGhhdCBldmVuIGlmIHRoZSB0YWJsZSBpcyByZXNpemVkIHdlXG4gICAgICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICAgICAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgICAgICgqIHN0YXRlOiBpbmRleCAqIG5leHQgYnVja2V0IHRvIHRyYXZlcnNlICopXG4gICAgICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0YmxfZGF0YVxuICAgICAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgICAgICB8IENvbnMgKF8sIGMsIG5leHQpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhdXggaSBuZXh0ICgpXG4gICAgICAgICAgICAgIHwgU29tZSBrZXksIFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgICAgU2VxLkNvbnMgKChrZXksIGRhdGEpLCBhdXggaSBuZXh0KVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgYXV4IDAgRW1wdHlcblxuICAgIGxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgbSA9IFNlcS5tYXAgc25kICh0b19zZXEgbSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgZW5kXG5lbmRcblxubW9kdWxlIE9iakVwaCA9IE9iai5FcGhlbWVyb25cblxubGV0IF9vYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4geFxuICB8IFNvbWUgdiAtPiBTb21lIChPYmoub2JqIHYpXG5cbigqKiBUaGUgcHJldmlvdXMgZnVuY3Rpb24gaXMgdHlwZWQgc28gdGhpcyBvbmUgaXMgYWxzbyBjb3JyZWN0ICopXG5sZXQgb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPiBPYmoubWFnaWMgeFxuXG5cbm1vZHVsZSBLMSA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgMVxuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChrOidrKSA6IHVuaXQgPSBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKHQyOignaywnZCkgdCk6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnRcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggPSBILmhhc2hcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICAoKiB7IWdldF9rZXlfY29weX0gaXMgbm90IHVzZWQgYmVjYXVzZSB0aGUgZXF1YWxpdHkgb2YgdGhlIHVzZXIgY2FuIGJlXG4gICAgICAgICAgICB0aGUgcGh5c2ljYWwgZXF1YWxpdHkgKilcbiAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgaycgLT5cbiAgICAgICAgICAgIGlmIEguZXF1YWwgayBrJyB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSA9IGdldF9rZXlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgPSBjaGVja19rZXlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgSzIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2sxLCAnazIsICdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrMSwnazIsJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDJcblxuICBsZXQgZ2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXkxX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2sxKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBnZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAxKVxuICBsZXQgZ2V0X2tleTJfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMSlcbiAgbGV0IHNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSAoazonazIpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAxIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDFcbiAgbGV0IGNoZWNrX2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAxXG5cblxuICBsZXQgYmxpdF9rZXkxICh0MTooJ2sxLF8sXykgdCkgKHQyOignazEsXyxfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuICBsZXQgYmxpdF9rZXkyICh0MTooXywnazIsXykgdCkgKHQyOihfLCdrMixfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAxIHQyIDEgMVxuICBsZXQgYmxpdF9rZXkxMiAodDE6KCdrMSwnazIsXykgdCkgKHQyOignazEsJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAyXG5cbiAgbGV0IGdldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgKGQ6J2QpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLF8sJ2QpIHQpICh0MjooXyxfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWRcbiAgICAgIChIMTpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpXG4gICAgICAoSDI6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChIMS50LEgyLnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgxLnQgKiBIMi50XG4gICAgICBsZXQgY3JlYXRlIChrMSxrMikgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCAoazEsazIpID1cbiAgICAgICAgSDEuaGFzaCBzZWVkIGsxICsgSDIuaGFzaCBzZWVkIGsyICogNjU1OTlcbiAgICAgIGxldCBlcXVhbCBjIChrMSxrMikgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+XG4gICAgICAgICAgICBpZiBIMS5lcXVhbCBrMSBrMScgJiYgSDIuZXF1YWwgazIgazInXG4gICAgICAgICAgICB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT4gU29tZSAoazEnLCBrMicpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgKGsxLGsyKSBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9IGNoZWNrX2tleTEgYyAmJiBjaGVja19rZXkyIGNcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDE6IEhhc2h0YmwuSGFzaGVkVHlwZSkoSDI6IEhhc2h0YmwuSGFzaGVkVHlwZSk6XG4gICAgKFMgd2l0aCB0eXBlIGtleSA9IEgxLnQgKiBIMi50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZFxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDEudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgxLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMS5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDIudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgyLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMi5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLbiA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSBuIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSBuXG4gIGxldCBsZW5ndGggKGs6KCdrLCdkKSB0KSA6IGludCA9IE9iakVwaC5sZW5ndGgga1xuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgbilcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCBuKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgKGs6J2spIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCBuIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgblxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgblxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAobzE6aW50KSAodDI6KCdrLCdkKSB0KSAobzI6aW50KSAobDppbnQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIG8xIHQyIG8yIGxcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLCdkKSB0KSAodDI6KF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50IGFycmF5XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlIChBcnJheS5sZW5ndGggaykgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoIHNlZWQgayA9XG4gICAgICAgIGxldCBoID0gcmVmIDAgaW5cbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIGggOj0gSC5oYXNoIHNlZWQgay4oaSkgKiA2NTU5OSArICFoO1xuICAgICAgICBkb25lO1xuICAgICAgICAhaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgIGxldCBsZW4gID0gQXJyYXkubGVuZ3RoIGsgaW5cbiAgICAgICAgbGV0IGxlbicgPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gIT0gbGVuJyB0aGVuIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCByZWMgZXF1YWxfYXJyYXkgayBjIGkgPVxuICAgICAgICAgICAgaWYgaSA8IDAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrLihpKSBraVxuICAgICAgICAgICAgICAgICAgdGhlbiBlcXVhbF9hcnJheSBrIGMgKGktMSlcbiAgICAgICAgICAgICAgICAgIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICAgIGluXG4gICAgICAgICAgZXF1YWxfYXJyYXkgayBjIChsZW4tMSlcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbGV0IGxlbiA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiA9IDAgdGhlbiBTb21lIFt8fF1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyAwIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSBrMCAtPlxuICAgICAgICAgICAgICBsZXQgcmVjIGZpbGwgYSBpID1cbiAgICAgICAgICAgICAgICBpZiBpIDwgMSB0aGVuIFNvbWUgYVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgICAgICBhLihpKSA8LSBraTtcbiAgICAgICAgICAgICAgICAgICAgICBmaWxsIGEgKGktMSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbGV0IGEgPSBBcnJheS5tYWtlIGxlbiBrMCBpblxuICAgICAgICAgICAgICBmaWxsIGEgKGxlbi0xKVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9XG4gICAgICAgIGxldCByZWMgY2hlY2sgYyBpID1cbiAgICAgICAgICBpIDwgMCB8fCAoY2hlY2tfa2V5IGMgaSAmJiBjaGVjayBjIChpLTEpKSBpblxuICAgICAgICBjaGVjayBjIChsZW5ndGggYyAtIDEpXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQgYXJyYXkpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgTWFyayBTaGlud2VsbCBhbmQgTGVvIFdoaXRlLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE1LS0yMDE2IEphbmUgU3RyZWV0IEdyb3VwIExMQyAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIHNwYWNldGltZV9lbmFibGVkIDogdW5pdCAtPiBib29sXG4gID0gXCJjYW1sX3NwYWNldGltZV9lbmFibGVkXCIgW0BAbm9hbGxvY11cblxubGV0IGVuYWJsZWQgPSBzcGFjZXRpbWVfZW5hYmxlZCAoKVxuXG5sZXQgaWZfc3BhY2V0aW1lX2VuYWJsZWQgZiA9XG4gIGlmIGVuYWJsZWQgdGhlbiBmICgpIGVsc2UgKClcblxubW9kdWxlIFNlcmllcyA9IHN0cnVjdFxuICB0eXBlIHQgPSB7XG4gICAgY2hhbm5lbCA6IG91dF9jaGFubmVsO1xuICAgIG11dGFibGUgY2xvc2VkIDogYm9vbDtcbiAgfVxuXG4gIGV4dGVybmFsIHdyaXRlX21hZ2ljX251bWJlciA6IG91dF9jaGFubmVsIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgICAgXCJjYW1sX3NwYWNldGltZV93cml0ZV9tYWdpY19udW1iZXJcIlxuXG4gIGV4dGVybmFsIHJlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSA6IG91dF9jaGFubmVsIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWVcIlxuXG4gIGxldCBjcmVhdGUgfnBhdGggPVxuICAgIGlmIHNwYWNldGltZV9lbmFibGVkICgpIHRoZW4gYmVnaW5cbiAgICAgIGxldCBjaGFubmVsID0gb3Blbl9vdXQgcGF0aCBpblxuICAgICAgcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIGNoYW5uZWw7XG4gICAgICBsZXQgdCA9XG4gICAgICAgIHsgY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgICAgY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIGluXG4gICAgICB3cml0ZV9tYWdpY19udW1iZXIgdC5jaGFubmVsO1xuICAgICAgdFxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICB7IGNoYW5uZWwgPSBzdGRvdXQ7ICAoKiBhcmJpdHJhcnkgdmFsdWUgKilcbiAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICBlbmRcblxuICBleHRlcm5hbCBzYXZlX2V2ZW50IDogP3RpbWU6ZmxvYXQgLT4gb3V0X2NoYW5uZWwgLT4gZXZlbnRfbmFtZTpzdHJpbmcgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3NhdmVfZXZlbnRcIlxuXG4gIGxldCBzYXZlX2V2ZW50ID90aW1lIHQgfmV2ZW50X25hbWUgPVxuICAgIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICAgIHNhdmVfZXZlbnQgP3RpbWUgdC5jaGFubmVsIH5ldmVudF9uYW1lKVxuXG4gIGV4dGVybmFsIHNhdmVfdHJpZSA6ID90aW1lOmZsb2F0IC0+IG91dF9jaGFubmVsIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgICAgXCJjYW1sX3NwYWNldGltZV9zYXZlX3RyaWVcIlxuXG4gIGxldCBzYXZlX2FuZF9jbG9zZSA/dGltZSB0ID1cbiAgICBpZl9zcGFjZXRpbWVfZW5hYmxlZCAoZnVuICgpIC0+XG4gICAgICBpZiB0LmNsb3NlZCB0aGVuIGZhaWx3aXRoIFwiU2VyaWVzIGlzIGNsb3NlZFwiO1xuICAgICAgc2F2ZV90cmllID90aW1lIHQuY2hhbm5lbDtcbiAgICAgIGNsb3NlX291dCB0LmNoYW5uZWw7XG4gICAgICB0LmNsb3NlZCA8LSB0cnVlKVxuZW5kXG5cbm1vZHVsZSBTbmFwc2hvdCA9IHN0cnVjdFxuICBleHRlcm5hbCB0YWtlIDogP3RpbWU6ZmxvYXQgLT4gb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3Rha2Vfc25hcHNob3RcIlxuXG4gIGxldCB0YWtlID90aW1lIHsgU2VyaWVzLmNsb3NlZDsgY2hhbm5lbCB9ID1cbiAgICBpZl9zcGFjZXRpbWVfZW5hYmxlZCAoZnVuICgpIC0+XG4gICAgICBpZiBjbG9zZWQgdGhlbiBmYWlsd2l0aCBcIlNlcmllcyBpcyBjbG9zZWRcIjtcbiAgICAgIEdjLm1pbm9yICgpO1xuICAgICAgdGFrZSA/dGltZSBjaGFubmVsKVxuZW5kXG5cbmV4dGVybmFsIHNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHMgOiBldmVudF9uYW1lOnN0cmluZyAtPiB1bml0XG4gID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgXCJjYW1sX3NwYWNldGltZV9zYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzXCJcblxubGV0IHNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHMgfmV2ZW50X25hbWUgPVxuICBpZl9zcGFjZXRpbWVfZW5hYmxlZCAoZnVuICgpIC0+XG4gICAgc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyB+ZXZlbnRfbmFtZSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBNYW51ZWwgU2VycmFubyBldCBYYXZpZXIgTGVyb3ksIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDAgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtCaWdhcnJheV06IGxhcmdlLCBtdWx0aS1kaW1lbnNpb25hbCwgbnVtZXJpY2FsIGFycmF5cyAqKVxuXG4oKiBUaGVzZSB0eXBlcyBpbiBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB0YWJsZXMgaW5cbiAgIC4uL3R5cGluZy90eXBlb3B0Lm1sICopXG5cbnR5cGUgZmxvYXQzMl9lbHQgPSBGbG9hdDMyX2VsdFxudHlwZSBmbG9hdDY0X2VsdCA9IEZsb2F0NjRfZWx0XG50eXBlIGludDhfc2lnbmVkX2VsdCA9IEludDhfc2lnbmVkX2VsdFxudHlwZSBpbnQ4X3Vuc2lnbmVkX2VsdCA9IEludDhfdW5zaWduZWRfZWx0XG50eXBlIGludDE2X3NpZ25lZF9lbHQgPSBJbnQxNl9zaWduZWRfZWx0XG50eXBlIGludDE2X3Vuc2lnbmVkX2VsdCA9IEludDE2X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQzMl9lbHQgPSBJbnQzMl9lbHRcbnR5cGUgaW50NjRfZWx0ID0gSW50NjRfZWx0XG50eXBlIGludF9lbHQgPSBJbnRfZWx0XG50eXBlIG5hdGl2ZWludF9lbHQgPSBOYXRpdmVpbnRfZWx0XG50eXBlIGNvbXBsZXgzMl9lbHQgPSBDb21wbGV4MzJfZWx0XG50eXBlIGNvbXBsZXg2NF9lbHQgPSBDb21wbGV4NjRfZWx0XG5cbnR5cGUgKCdhLCAnYikga2luZCA9XG4gICAgRmxvYXQzMiA6IChmbG9hdCwgZmxvYXQzMl9lbHQpIGtpbmRcbiAgfCBGbG9hdDY0IDogKGZsb2F0LCBmbG9hdDY0X2VsdCkga2luZFxuICB8IEludDhfc2lnbmVkIDogKGludCwgaW50OF9zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50OF91bnNpZ25lZCA6IChpbnQsIGludDhfdW5zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MTZfc2lnbmVkIDogKGludCwgaW50MTZfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3Vuc2lnbmVkIDogKGludCwgaW50MTZfdW5zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MzIgOiAoaW50MzIsIGludDMyX2VsdCkga2luZFxuICB8IEludDY0IDogKGludDY0LCBpbnQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQgOiAoaW50LCBpbnRfZWx0KSBraW5kXG4gIHwgTmF0aXZlaW50IDogKG5hdGl2ZWludCwgbmF0aXZlaW50X2VsdCkga2luZFxuICB8IENvbXBsZXgzMiA6IChDb21wbGV4LnQsIGNvbXBsZXgzMl9lbHQpIGtpbmRcbiAgfCBDb21wbGV4NjQgOiAoQ29tcGxleC50LCBjb21wbGV4NjRfZWx0KSBraW5kXG4gIHwgQ2hhciA6IChjaGFyLCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuXG50eXBlIGNfbGF5b3V0ID0gQ19sYXlvdXRfdHlwXG50eXBlIGZvcnRyYW5fbGF5b3V0ID0gRm9ydHJhbl9sYXlvdXRfdHlwICgqKilcblxudHlwZSAnYSBsYXlvdXQgPVxuICAgIENfbGF5b3V0OiBjX2xheW91dCBsYXlvdXRcbiAgfCBGb3J0cmFuX2xheW91dDogZm9ydHJhbl9sYXlvdXQgbGF5b3V0XG5cbigqIEtlZXAgdGhvc2UgY29uc3RhbnRzIGluIHN5bmMgd2l0aCB0aGUgY2FtbF9iYV9raW5kIGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBmbG9hdDMyID0gRmxvYXQzMlxubGV0IGZsb2F0NjQgPSBGbG9hdDY0XG5sZXQgaW50OF9zaWduZWQgPSBJbnQ4X3NpZ25lZFxubGV0IGludDhfdW5zaWduZWQgPSBJbnQ4X3Vuc2lnbmVkXG5sZXQgaW50MTZfc2lnbmVkID0gSW50MTZfc2lnbmVkXG5sZXQgaW50MTZfdW5zaWduZWQgPSBJbnQxNl91bnNpZ25lZFxubGV0IGludDMyID0gSW50MzJcbmxldCBpbnQ2NCA9IEludDY0XG5sZXQgaW50ID0gSW50XG5sZXQgbmF0aXZlaW50ID0gTmF0aXZlaW50XG5sZXQgY29tcGxleDMyID0gQ29tcGxleDMyXG5sZXQgY29tcGxleDY0ID0gQ29tcGxleDY0XG5sZXQgY2hhciA9IENoYXJcblxubGV0IGtpbmRfc2l6ZV9pbl9ieXRlcyA6IHR5cGUgYSBiLiAoYSwgYikga2luZCAtPiBpbnQgPSBmdW5jdGlvblxuICB8IEZsb2F0MzIgLT4gNFxuICB8IEZsb2F0NjQgLT4gOFxuICB8IEludDhfc2lnbmVkIC0+IDFcbiAgfCBJbnQ4X3Vuc2lnbmVkIC0+IDFcbiAgfCBJbnQxNl9zaWduZWQgLT4gMlxuICB8IEludDE2X3Vuc2lnbmVkIC0+IDJcbiAgfCBJbnQzMiAtPiA0XG4gIHwgSW50NjQgLT4gOFxuICB8IEludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IE5hdGl2ZWludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IENvbXBsZXgzMiAtPiA4XG4gIHwgQ29tcGxleDY0IC0+IDE2XG4gIHwgQ2hhciAtPiAxXG5cbigqIEtlZXAgdGhvc2UgY29uc3RhbnRzIGluIHN5bmMgd2l0aCB0aGUgY2FtbF9iYV9sYXlvdXQgZW51bWVyYXRpb25cbiAgIGluIGJpZ2FycmF5LmggKilcblxubGV0IGNfbGF5b3V0ID0gQ19sYXlvdXRcbmxldCBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0XG5cbm1vZHVsZSBHZW5hcnJheSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0XG4gIGV4dGVybmFsIGNyZWF0ZTogKCdhLCAnYikga2luZCAtPiAnYyBsYXlvdXQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgID0gXCJjYW1sX2JhX2NyZWF0ZVwiXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhXG4gICAgID0gXCJjYW1sX2JhX2dldF9nZW5lcmljXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgYXJyYXkgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9zZXRfZ2VuZXJpY1wiXG4gIGV4dGVybmFsIG51bV9kaW1zOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcImNhbWxfYmFfbnVtX2RpbXNcIlxuICBleHRlcm5hbCBudGhfZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX2JhX2RpbVwiXG4gIGxldCBkaW1zIGEgPVxuICAgIGxldCBuID0gbnVtX2RpbXMgYSBpblxuICAgIGxldCBkID0gQXJyYXkubWFrZSBuIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbi0xIGRvIGQuKGkpIDwtIG50aF9kaW0gYSBpIGRvbmU7XG4gICAgZFxuXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoQXJyYXkuZm9sZF9sZWZ0ICggKiApIDEgKGRpbXMgYXJyKSlcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc2xpY2VfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgc2xpY2VfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5lbmRcblxubW9kdWxlIEFycmF5MCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8fF1cbiAgbGV0IGdldCBhcnIgPSBHZW5hcnJheS5nZXQgYXJyIFt8fF1cbiAgbGV0IHNldCBhcnIgPSBHZW5hcnJheS5zZXQgYXJyIFt8fF1cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPSBraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKVxuXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5cbiAgbGV0IG9mX3ZhbHVlIGtpbmQgbGF5b3V0IHYgPVxuICAgIGxldCBhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGluXG4gICAgc2V0IGEgdjtcbiAgICBhXG5lbmRcblxubW9kdWxlIEFycmF5MSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbXxdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMVwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8xXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzFcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8xXCJcbiAgZXh0ZXJuYWwgZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltIGFycilcblxuICBleHRlcm5hbCBzdWI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgJ2MpIHQgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlICh0eXBlIHQpIChhIDogKF8sIF8sIHQpIEdlbmFycmF5LnQpIG4gPVxuICAgIG1hdGNoIGxheW91dCBhIHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF0gOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCAoQXJyYXkubGVuZ3RoIGRhdGEpIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZGF0YSAtIDEgZG8gdW5zYWZlX3NldCBiYSAoaSArIG9mcykgZGF0YS4oaSkgZG9uZTtcbiAgICBiYVxuZW5kXG5cbm1vZHVsZSBBcnJheTIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMlwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8yXCJcbiAgZXh0ZXJuYWwgZGltMTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGRpbTI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzJcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlX2xlZnQgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodCBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBkaW0xIC0gMSBkb1xuICAgICAgbGV0IHJvdyA9IGRhdGEuKGkpIGluXG4gICAgICBpZiBBcnJheS5sZW5ndGggcm93IDw+IGRpbTIgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5Mi5vZl9hcnJheTogbm9uLXJlY3Rhbmd1bGFyIGRhdGFcIik7XG4gICAgICBmb3IgaiA9IDAgdG8gZGltMiAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIHJvdy4oailcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MyA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltMTsgZGltMjsgZGltM3xdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8zXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV9zZXRfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhXG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzNcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzNcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGRpbTM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzNcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpICogKGRpbTMgYXJyKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDpcbiAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9yaWdodF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG47IG18XVxuICBsZXQgc2xpY2VfbGVmdF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XVxuICBsZXQgc2xpY2VfcmlnaHRfMiBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgZGltMyA9IGlmIGRpbTIgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICBsZXQgY29sID0gcm93LihqKSBpblxuICAgICAgICBpZiBBcnJheS5sZW5ndGggY29sIDw+IGRpbTMgdGhlblxuICAgICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgICAgZm9yIGsgPSAwIHRvIGRpbTMgLSAxIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIChrICsgb2ZzKSBjb2wuKGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkwOiAoJ2EsICdiLCAnYykgQXJyYXkwLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkxOiAoJ2EsICdiLCAnYykgQXJyYXkxLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkyOiAoJ2EsICdiLCAnYykgQXJyYXkyLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkzOiAoJ2EsICdiLCAnYykgQXJyYXkzLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxubGV0IGFycmF5MF9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDAgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTBfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5MV9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDEgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTFfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5Ml9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDIgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTJfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5M19vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDMgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTNfb2ZfZ2VuYXJyYXlcIlxuXG5leHRlcm5hbCByZXNoYXBlOlxuICAgKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiY2FtbF9iYV9yZXNoYXBlXCJcbmxldCByZXNoYXBlXzAgYSA9IHJlc2hhcGUgYSBbfHxdXG5sZXQgcmVzaGFwZV8xIGEgZGltMSA9IHJlc2hhcGUgYSBbfGRpbTF8XVxubGV0IHJlc2hhcGVfMiBhIGRpbTEgZGltMiA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMnxdXG5sZXQgcmVzaGFwZV8zIGEgZGltMSBkaW0yIGRpbTMgPSByZXNoYXBlIGEgW3xkaW0xO2RpbTI7ZGltM3xdXG5cbigqIEZvcmNlIGNhbWxfYmFfZ2V0X3sxLDIsMyxOfSB0byBiZSBsaW5rZWQgaW4sIHNpbmNlIHdlIGRvbid0IHJlZmVyXG4gICB0byB0aG9zZSBwcmltaXRpdmVzIGRpcmVjdGx5IGluIHRoaXMgZmlsZSAqKVxuXG5sZXQgXyA9XG4gIGxldCBfID0gR2VuYXJyYXkuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkxLmdldCBpblxuICBsZXQgXyA9IEFycmF5Mi5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTMuZ2V0IGluXG4gICgpXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTMyXCJdXG5leHRlcm5hbCBnZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzFcIlxuZXh0ZXJuYWwgZ2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8yXCJcbmV4dGVybmFsIGdldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfM1wiXG5leHRlcm5hbCBzZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzFcIlxuZXh0ZXJuYWwgc2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8yXCJcbmV4dGVybmFsIHNldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfM1wiXG4iLG51bGwsIm9wZW4gSnNfb2Zfb2NhbWxcbm9wZW4gSnNfb2Zfb2NhbWxfdHl4bWwuVHl4bWxfanNcbm9wZW4gUmVhY3Rcbm9wZW4gUmVhY3RpdmVEYXRhXG5cbigqIEFQUCBMT0dJQyAqKVxuXG5tb2R1bGUgSWRzID0gc3RydWN0XG4gIGxldCBsaWVzSW5wdXQgPSBcImxpZXNJbnB1dFwiXG4gIGxldCBsaWVDb2RlSW5wdXQgPSBcImxpZUNvZGVJbnB1dFwiXG4gIGxldCB0cnV0aHNJbnB1dCA9IFwidHJ1dGhzSW5wdXRcIlxuZW5kXG5cbmxldCBlbmNvZGUgPSBCYXNlNjQuZW5jb2RlX3N0cmluZyB+YWxwaGFiZXQ6QmFzZTY0LnVyaV9zYWZlX2FscGhhYmV0XG5sZXQgZGVjb2RlID0gQmFzZTY0LmRlY29kZV9leG4gfmFscGhhYmV0OkJhc2U2NC51cmlfc2FmZV9hbHBoYWJldFxuXG5sZXQgdGV4dF90b19lbmNvZGVfcywgc2V0X3RleHRfdG9fZW5jb2RlID0gUy5jcmVhdGUgXCJcIlxubGV0IGVuY29kZWRfdGV4dF9zID0gUy5tYXAgZW5jb2RlIHRleHRfdG9fZW5jb2RlX3NcbmxldCB3aWx0eV9zLCBzZXRfd2lsdHkgPSBTLmNyZWF0ZSAoT2sgTm9uZSlcblxubGV0IHZhbHVlX29mX2lucHV0IH5pZCA9XG4gIGxldCBpbnB1dF9vcHQgPSBEb21faHRtbC5nZXRFbGVtZW50QnlJZF9leG4gaWQgfD4gRG9tX2h0bWwuQ29lcmNlVG8uaW5wdXQgaW5cbiAgbGV0IHZhbHVlX29wdCA9IEpzLk9wdC5tYXAgaW5wdXRfb3B0IChmdW4gaW5wdXQgLT4gSnMudG9fc3RyaW5nIChpbnB1dCMjLnZhbHVlKSkgaW5cbiAgSnMuT3B0LmdldCB2YWx1ZV9vcHQgKGZ1biAoKSAtPiBcIlwiKVxuXG5sZXQgc2V0X3ZhbHVlX29mX2lucHV0IH5pZCB2ID1cbiAgbGV0IGlucHV0X29wdCA9IERvbV9odG1sLmdldEVsZW1lbnRCeUlkX2V4biBpZCB8PiBEb21faHRtbC5Db2VyY2VUby5pbnB1dCBpblxuICBKcy5PcHQuaXRlciBpbnB1dF9vcHQgKGZ1biBpbnB1dCAtPlxuICAgIGlucHV0IyMudmFsdWUgOj0gSnMuc3RyaW5nIHZcbiAgKVxuXG5sZXQgdmFsdWVfb2ZfdGV4dGFyZWEgfmlkID1cbiAgbGV0IGlucHV0X29wdCA9IERvbV9odG1sLmdldEVsZW1lbnRCeUlkX2V4biBpZCB8PiBEb21faHRtbC5Db2VyY2VUby50ZXh0YXJlYSBpblxuICBsZXQgdmFsdWVfb3B0ID0gSnMuT3B0Lm1hcCBpbnB1dF9vcHQgKGZ1biBpbnB1dCAtPiBKcy50b19zdHJpbmcgKGlucHV0IyMudmFsdWUpKSBpblxuICBKcy5PcHQuZ2V0IHZhbHVlX29wdCAoZnVuICgpIC0+IGZhaWx3aXRoIGlkKVxuXG5sZXQgc2V0X3ZhbHVlX29mX3RleHRhcmVhIH5pZCB2ID1cbiAgbGV0IGlucHV0X29wdCA9IERvbV9odG1sLmdldEVsZW1lbnRCeUlkX2V4biBpZCB8PiBEb21faHRtbC5Db2VyY2VUby50ZXh0YXJlYSBpblxuICBKcy5PcHQuaXRlciBpbnB1dF9vcHQgKGZ1biBpbnB1dCAtPlxuICAgIGlucHV0IyMudmFsdWUgOj0gSnMuc3RyaW5nIHZcbiAgKVxuXG5sZXQgZW5jb2RlX3RleHRfaGFuZGxlciBfID1cbiAgc2V0X3RleHRfdG9fZW5jb2RlICh2YWx1ZV9vZl90ZXh0YXJlYSB+aWQ6SWRzLmxpZXNJbnB1dCk7XG4gIGZhbHNlXG5cbmxldCByZWMgcGljayA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFpbHdpdGggXCJwaWNrXCJcbiAgfCB4Ojp4cyAtPiBmdW5jdGlvblxuICAgIHwgMCAtPiAoeCwgeHMpXG4gICAgfCBuIC0+XG4gICAgICBsZXQgKHksIHlzKSA9IHBpY2sgeHMgKG4tMSkgaW5cbiAgICAgICh5LCB4Ojp5cylcblxubGV0IHdpbHR5X2hhbmRsZXIgXyA9XG4gIGxldCBsaWVzID1cbiAgICB2YWx1ZV9vZl9pbnB1dCB+aWQ6SWRzLmxpZUNvZGVJbnB1dFxuICAgIHw+IGRlY29kZVxuICAgIHw+IFN0cmluZy5zcGxpdF9vbl9jaGFyICdcXG4nXG4gIGluXG4gIGxldCB0cnV0aHMgPVxuICAgIHZhbHVlX29mX3RleHRhcmVhIH5pZDpJZHMudHJ1dGhzSW5wdXRcbiAgICB8PiBTdHJpbmcuc3BsaXRfb25fY2hhciAnXFxuJ1xuICBpblxuICBsZXQgbnVtX2xpZXMsIG51bV90cnV0aHMgPSBMaXN0Lmxlbmd0aCBsaWVzLCBMaXN0Lmxlbmd0aCB0cnV0aHMgaW5cbiAgaWYgbGllcyA9IFtcIlwiXSB8fCB0cnV0aHMgPSBbXCJcIl0gdGhlbiAoXG4gICAgc2V0X3dpbHR5IChFcnJvciBcIllvdSBtdXN0IGlucHV0IGF0IGxlYXN0IG9uZSB0cnV0aCBhbmQgYXQgbGVhc3Qgb25lIGxpZS5cIik7XG4gICkgZWxzZSAoXG4gICAgbGV0IGkgPSBSYW5kb20uaW50IChudW1fbGllcyArIG51bV90cnV0aHMpIGluXG4gICAgaWYgaSA8IG51bV9saWVzIHRoZW4gKFxuICAgICAgbGV0IChsaWUsIHJlbWFpbmluZ19saWVzKSA9IHBpY2sgbGllcyBpIGluXG4gICAgICBzZXRfd2lsdHkgKE9rIChTb21lIChmYWxzZSwgbGllKSkpO1xuICAgICAgbGV0IG5ld19saWVfY29kZSA9XG4gICAgICAgIHJlbWFpbmluZ19saWVzXG4gICAgICAgIHw+IFN0cmluZy5jb25jYXQgXCJcXG5cIlxuICAgICAgICB8PiBlbmNvZGVcbiAgICAgIGluXG4gICAgICBzZXRfdmFsdWVfb2ZfaW5wdXQgfmlkOklkcy5saWVDb2RlSW5wdXQgbmV3X2xpZV9jb2RlXG4gICAgKSBlbHNlIChcbiAgICAgIGxldCAodHJ1dGgsIHJlbWFpbmluZ190cnV0aHMpID0gcGljayB0cnV0aHMgKGkgLSBudW1fbGllcykgaW5cbiAgICAgIHNldF93aWx0eSAoT2sgKFNvbWUgKHRydWUsIHRydXRoKSkpO1xuICAgICAgc2V0X3ZhbHVlX29mX3RleHRhcmVhIH5pZDpJZHMudHJ1dGhzSW5wdXQgKFN0cmluZy5jb25jYXQgXCJcXG5cIiByZW1haW5pbmdfdHJ1dGhzKVxuICAgICk7XG4gICk7XG4gIGZhbHNlXG4gIFxuXG4oKiBDT05URU5UICopXG5cbmxldCBzZW5kX2xpZXNfYXBwID1cbiAgbGV0IG9wZW4gSHRtbCBpblxuICBkaXYgfmE6W2FfY2xhc3MgW1wibXktM1wiXV0gW1xuICAgIGxhYmVsXG4gICAgICB+YTpbYV9sYWJlbF9mb3IgSWRzLmxpZXNJbnB1dF1cbiAgICAgIFt0eHQgXCJMaWUocykgdG8gc2VuZCwgbmV3bGluZS1zZXBhcmF0ZWQ6XCJdO1xuICAgIGRpdiB+YTpbYV9jbGFzcyBbXCJpbnB1dC1ncm91cFwiXV0gW1xuICAgICAgdGV4dGFyZWEgfmE6W1xuICAgICAgICBhX2lkIElkcy5saWVzSW5wdXQ7XG4gICAgICAgIGFfY2xhc3MgW1wiZm9ybS1jb250cm9sXCJdO1xuICAgICAgICBhX3Jvd3MgMztcbiAgICAgIF0gKHR4dCBcIlwiKTtcbiAgICAgIGRpdiB+YTpbYV9jbGFzcyBbXCJpbnB1dC1ncm91cC1hcHBlbmRcIl1dIFtcbiAgICAgICAgYnV0dG9uIH5hOltcbiAgICAgICAgICBhX2NsYXNzIFtcImJ0blwiOyBcImJ0bi1wcmltYXJ5XCJdO1xuICAgICAgICAgIGFfYnV0dG9uX3R5cGUgYEJ1dHRvbjtcbiAgICAgICAgICBhX29uY2xpY2sgZW5jb2RlX3RleHRfaGFuZGxlcjtcbiAgICAgICAgXSBbXG4gICAgICAgICAgdHh0IFwiRW5jb2RlXCJcbiAgICAgICAgXVxuICAgICAgXVxuICAgIF07XG4gICAgZGl2IFtcbiAgICAgIHR4dCBcIkxpZSBjb2RlIHRvIHNlbmQ6IChjbGljayB0byBzZWxlY3QgYWxsKVwiO1xuICAgIF07XG4gICAgZGl2IH5hOltcbiAgICAgIGFfY2xhc3MgW1widXNlci1zZWxlY3QtYWxsXCI7IFwiYmctbGlnaHRcIjsgXCJyb3VuZGVkXCI7IFwicC0zXCI7IFwib3ZlcmZsb3ctYXV0b1wiXTtcbiAgICBdIFtcbiAgICAgIFIuSHRtbC50eHQgZW5jb2RlZF90ZXh0X3NcbiAgICBdO1xuICBdXG5cbmxldCB3aWx0eV9hcHAgPVxuICBsZXQgb3BlbiBIdG1sIGluXG4gIGRpdiB+YTpbYV9jbGFzcyBbXCJteS0zXCJdXSBbXG4gICAgbGFiZWxcbiAgICAgIH5hOlthX2xhYmVsX2ZvciBJZHMudHJ1dGhzSW5wdXRdXG4gICAgICBbdHh0IFwiVHJ1dGgocykgYWJvdXQgeW91cnNlbGYsIG5ld2xpbmUtc2VwYXJhdGVkOlwiXTtcbiAgICB0ZXh0YXJlYSB+YTpbXG4gICAgICBhX2lkIElkcy50cnV0aHNJbnB1dDtcbiAgICAgIGFfY2xhc3MgW1wiZm9ybS1jb250cm9sXCJdO1xuICAgICAgYV9yb3dzIDM7XG4gICAgXSAodHh0IFwiXCIpO1xuICAgIGxhYmVsXG4gICAgICB+YTpbYV9sYWJlbF9mb3IgSWRzLmxpZUNvZGVJbnB1dF1cbiAgICAgIFt0eHQgXCJMaWUgY29kZSB5b3UgcmVjZWl2ZWQ6XCJdO1xuICAgIGlucHV0IH5hOltcbiAgICAgIGFfaWQgSWRzLmxpZUNvZGVJbnB1dDtcbiAgICAgIGFfY2xhc3MgW1wiZm9ybS1jb250cm9sXCJdO1xuICAgIF0gKCk7XG4gICAgZGl2IH5hOltcbiAgICAgIGFfY2xhc3MgW1wibS0zXCI7IFwidGV4dC1jZW50ZXJcIl07XG4gICAgXSBbXG4gICAgICBidXR0b24gfmE6W1xuICAgICAgICBhX2NsYXNzIFtcImJ0blwiOyBcImJ0bi1wcmltYXJ5XCJdO1xuICAgICAgICBhX2J1dHRvbl90eXBlIGBCdXR0b247XG4gICAgICAgIGFfb25jbGljayB3aWx0eV9oYW5kbGVyO1xuICAgICAgXSBbXG4gICAgICAgIHR4dCBcIldvdWxkIEkgTGllIHRvIFlvdT9cIlxuICAgICAgXTtcbiAgICBdO1xuICAgIFIuSHRtbC5kaXYgfmE6W1xuICAgICAgYV9jbGFzcyBbXCJiZy1saWdodFwiOyBcInJvdW5kZWRcIjsgXCJwLTNcIl07XG4gICAgXSAoXG4gICAgICBTLm1hcCAoZnVuY3Rpb24gXG4gICAgICAgIHwgRXJyb3IgbXNnIC0+IFtcbiAgICAgICAgICAgIHNwYW4gfmE6W1xuICAgICAgICAgICAgICBhX2NsYXNzIFtcInRleHQtZGFuZ2VyXCJdXG4gICAgICAgICAgICBdIFtcbiAgICAgICAgICAgICAgdHh0IChcIkVycm9yOiBcIiBeIG1zZylcbiAgICAgICAgICAgIF1cbiAgICAgICAgICBdXG4gICAgICAgIHwgT2sgTm9uZSAtPiBbXVxuICAgICAgICB8IE9rIChTb21lIChpc190cnV0aCwgc3RtdCkpIC0+IFtcbiAgICAgICAgICAgIHR4dCAoaWYgaXNfdHJ1dGggdGhlbiBcIlRydXRoOlwiIGVsc2UgXCJMaWU6XCIpO1xuICAgICAgICAgICAgYnIgKCk7XG4gICAgICAgICAgICB0eHQgc3RtdFxuICAgICAgICAgIF1cbiAgICAgICAgKSB3aWx0eV9zXG4gICAgICB8PiBSTGlzdC5mcm9tX3NpZ25hbFxuICAgIClcbiAgXVxuXG5sZXQgYXBwID1cbiAgbGV0IG9wZW4gSHRtbCBpblxuICBmb3JtIFtcbiAgICBzZW5kX2xpZXNfYXBwO1xuICAgIGhyICgpO1xuICAgIHdpbHR5X2FwcDtcbiAgXVxuICAgIFxuXG5sZXQgKCkgPVxuICBSYW5kb20uc2VsZl9pbml0ICgpO1xuICBsZXQgYXBwX2NvbnRhaW5lciA9IERvbV9odG1sLmdldEVsZW1lbnRCeUlkX2V4biBcImFwcFwiIGluXG4gIERvbS5hcHBlbmRDaGlsZCBhcHBfY29udGFpbmVyIChUb19kb20ub2ZfZWxlbWVudCBhcHApO1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFbnN1cmUgdGhhdCBbYXRfZXhpdF0gZnVuY3Rpb25zIGFyZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBwcm9ncmFtICopXG5cbmxldCBfID0gZG9fYXRfZXhpdCgpXG4iXX0=
//]]>
</script></body></html>